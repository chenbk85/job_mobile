// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gameLogic.proto

#ifndef PROTOBUF_gameLogic_2eproto__INCLUDED
#define PROTOBUF_gameLogic_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_gameLogic_2eproto();
void protobuf_AssignDesc_gameLogic_2eproto();
void protobuf_ShutdownFile_gameLogic_2eproto();

class GameUserInfo;
class GameRoomInfo;
class GameInfo;
class MemberInfo;
class s_req_game_test_packet;
class s_req_send_cmd;
class s_req_join_room;
class s_req_send_start;
class s_req_send_select_card;
class s_req_betting;
class s_req_ping;
class s_req_entry;
class s_req_continue;
class s_req_ruleset;
class s_req_jokboset;
class s_req_ack;
class s_req_choiceremovecard;
class s_req_purge;
class s_req_exitque;
class s_req_soundtype;
class s_req_abuse;
class s_req_observe;
class GLReqGameProtocol;
class s_ans_game_test_packet;
class s_ans_join_room;
class s_ans_deal_card;
class s_ans_deal_cards;
class s_ans_send_ante;
class s_ans_select_card;
class s_ans_opencard;
class s_ans_boss;
class s_ans_deal_hiddencard;
class s_ans_betting;
class s_ans_pong;
class s_ans_entry;
class s_betting_msg;
class s_finished;
class s_jackpotmoneyntf;
class s_ans_continue;
class s_ans_ruleset;
class s_ans_start;
class s_carddata;
class s_entryreject;
class s_nostart;
class s_newgame;
class s_ans_purge;
class s_purgeinfo;
class s_systemmsg;
class s_exitntf;
class s_refillmoneyntf;
class s_bonus;
class s_userjoinerr;
class s_userdisconnect;
class s_soundtypeans;
class s_userjoinans;
class s_startreq;
class s_ans_abuse;
class s_continue_msg;
class s_ans_observe;
class s_observercnt;
class GLAnsGameProtocol;
class PKCards;
class PKMoney;
class UserMoney;
class PKCWinLose;
class PKUserInfo;
class PKOneCard;
class PKVecMoney;
class PKWinLoseInfo;
class PKVecUSN;
class PKWAITINGUSERDATA;
class CRefill;
class PKItemList;
class PKItem;
class PKRCUserData;
class PKOption;
class PKRCUser;
class PKBettingMsg;
class PKBettingMsgTable;
class PKMoneyTable;
class PKCardTable;
class PKUITable;
class PKRCRoomData;
class PKSPUserBaseInfo;
class PKMsgCS_Entry;
class PKMsgCS_Observe;
class PKMsgCS_Start;
class PKMsgCS_SelectedCardReq;
class PKMsgCS_BettingReq;
class PKMsgCS_ChoiceRemoveCard;
class PKMsgCS_Purge;
class PKMsgCS_Abuse;
class PKMsgCS_AskPurgeVote;
class PKMsgCS_AnswerPurgeVote;
class PKMsgCS_WaitingUserTicketReq;
class PKMsgCS_UpdateWaitingUserInfoReq;
class PKMsgCS_SoundType;
class PKMsgCS_ExitQue;
class PKMsgCS_Continue;
class PKMsgCS_RuleSet;
class PKMsgCS_GameMasterCall;
class PKMsgCS_FieldReserved;
class PKMsgCS_JokboSet;
class PKMsgCS_TestKeySetting;
class PKMsgCS_CheckNotice;
class PKMsgCS_Ack;
class PKMsgCS_Ping;
class PKMsgSC_UserJoinAns;
class PKMsgSC_UserJoinErr;
class PKMsgSC_UserDisconnect;
class PKMsgSC_CardData;
class PKMsgSC_EntryAns;
class PKMsgSC_EntryReject;
class PKMsgSC_ObserveAns;
class PKMsgSC_StartReq;
class PKMsgSC_StartAns;
class PKMsgSC_NoStart;
class PKMsgSC_DealCards;
class PKMsgSC_SelectedCardAns;
class PKMsgSC_DealOpenCard;
class PKMsgSC_DealCard;
class PKMsgSC_Boss;
class PKMsgSC_Betting;
class PKMsgSC_BettingAns;
class PKMsgSC_BettingAnsMsg;
class PKMsgSC_DealHiddenCard;
class PKMsgSC_AnteMoney;
class PKMsgSC_RuleQuaterHalf;
class PKMsgSC_Finished;
class PKMsgSC_NewGame;
class PKMsgSC_ContinueAns;
class PKMsgSC_Continue;
class PKMsgSC_SystemMsg;
class PKMsgSC_PurgeAns;
class PKMsgSC_PurgeInfo;
class PKMsgSC_SetPurgeMoney;
class PKMsgSC_AssaItemNotify;
class PKMsgSC_ThankYouItemNotify;
class PKMsgSC_MadeItemNotify;
class PKMsgSC_ExtMoneyNotify;
class PKMsgSC_GameEndSystemMsg;
class PKMsgSC_ChangeAvatarNotify;
class PKMsgSC_AbuseAns;
class PKMsgSC_SoundTypeAns;
class PKMsgSC_FMoney;
class PKMsgSC_ItemNotify;
class PKMsgSC_DisconnectMoneyNotify;
class PKMsgSC_ExitNtf;
class PKMsgSC_RematchOKAns;
class PKMsgSC_RuleNotify;
class PKMsgSC_AllowEntryWaitingUser;
class PKMsgSC_AllWaitingUserDataNtf;
class PKMsgSC_UserDataChangeNtf;
class PKMsgSC_RefillMoneyNtf;
class PKMsgSC_JackpotMoneyNtf;
class PKMsgSC_GuardianAngelMoney;
class PKMsgSC_GameMasterCallNtf;
class PKMsgSC_ObserverCnt;
class PKMsgSC_Bonus;
class PKMsgSC_PoliceNotify;

enum GLReqGameProtocol_Type {
  GLReqGameProtocol_Type_NONE = 1,
  GLReqGameProtocol_Type_req_game_test_packet = 2,
  GLReqGameProtocol_Type_req_send_cmd = 3,
  GLReqGameProtocol_Type_req_join_room = 4,
  GLReqGameProtocol_Type_req_send_start = 5,
  GLReqGameProtocol_Type_req_send_select_card = 6,
  GLReqGameProtocol_Type_req_betting = 7,
  GLReqGameProtocol_Type_req_ping = 8,
  GLReqGameProtocol_Type_req_entry = 9,
  GLReqGameProtocol_Type_req_continue = 10,
  GLReqGameProtocol_Type_req_ruleset = 11,
  GLReqGameProtocol_Type_req_jokboset = 12,
  GLReqGameProtocol_Type_req_ack = 13,
  GLReqGameProtocol_Type_req_choiceremovecard = 14,
  GLReqGameProtocol_Type_req_purge = 15,
  GLReqGameProtocol_Type_req_exitque = 16,
  GLReqGameProtocol_Type_req_soundtype = 17,
  GLReqGameProtocol_Type_req_abuse = 18,
  GLReqGameProtocol_Type_req_observe = 19
};
bool GLReqGameProtocol_Type_IsValid(int value);
const GLReqGameProtocol_Type GLReqGameProtocol_Type_Type_MIN = GLReqGameProtocol_Type_NONE;
const GLReqGameProtocol_Type GLReqGameProtocol_Type_Type_MAX = GLReqGameProtocol_Type_req_observe;
const int GLReqGameProtocol_Type_Type_ARRAYSIZE = GLReqGameProtocol_Type_Type_MAX + 1;

enum GLAnsGameProtocol_Type {
  GLAnsGameProtocol_Type_NONE = 1,
  GLAnsGameProtocol_Type_ans_game_test_packet = 2,
  GLAnsGameProtocol_Type_ans_join_room = 3,
  GLAnsGameProtocol_Type_ans_deal_card = 4,
  GLAnsGameProtocol_Type_ans_send_ante = 5,
  GLAnsGameProtocol_Type_ans_select_card = 6,
  GLAnsGameProtocol_Type_ans_opencard = 7,
  GLAnsGameProtocol_Type_ans_boss = 8,
  GLAnsGameProtocol_Type_ans_deal_hiddencard = 9,
  GLAnsGameProtocol_Type_ans_betting = 10,
  GLAnsGameProtocol_Type_ans_pong = 11,
  GLAnsGameProtocol_Type_ans_entry = 12,
  GLAnsGameProtocol_Type_ans_deal_cards = 13,
  GLAnsGameProtocol_Type_betting_msg = 14,
  GLAnsGameProtocol_Type_finished = 15,
  GLAnsGameProtocol_Type_jackpotmoneyntf = 16,
  GLAnsGameProtocol_Type_ans_continue = 17,
  GLAnsGameProtocol_Type_ans_ruleset = 18,
  GLAnsGameProtocol_Type_ans_start = 19,
  GLAnsGameProtocol_Type_carddata = 20,
  GLAnsGameProtocol_Type_entryreject = 21,
  GLAnsGameProtocol_Type_nostart = 22,
  GLAnsGameProtocol_Type_newgame = 23,
  GLAnsGameProtocol_Type_ans_purge = 24,
  GLAnsGameProtocol_Type_purgeinfo = 25,
  GLAnsGameProtocol_Type_exitntf = 26,
  GLAnsGameProtocol_Type_refillmoneyntf = 27,
  GLAnsGameProtocol_Type_bonus = 28,
  GLAnsGameProtocol_Type_systemmsg = 29,
  GLAnsGameProtocol_Type_userjoinerr = 30,
  GLAnsGameProtocol_Type_userdisconnect = 31,
  GLAnsGameProtocol_Type_soundtypeans = 32,
  GLAnsGameProtocol_Type_userjoinans = 33,
  GLAnsGameProtocol_Type_startreq = 34,
  GLAnsGameProtocol_Type_ans_abuse = 35,
  GLAnsGameProtocol_Type_continue_msg = 36,
  GLAnsGameProtocol_Type_ans_observe = 37,
  GLAnsGameProtocol_Type_observercnt = 38
};
bool GLAnsGameProtocol_Type_IsValid(int value);
const GLAnsGameProtocol_Type GLAnsGameProtocol_Type_Type_MIN = GLAnsGameProtocol_Type_NONE;
const GLAnsGameProtocol_Type GLAnsGameProtocol_Type_Type_MAX = GLAnsGameProtocol_Type_observercnt;
const int GLAnsGameProtocol_Type_Type_ARRAYSIZE = GLAnsGameProtocol_Type_Type_MAX + 1;

enum PKCards_state {
  PKCards_state_CARDTYPE_NORMAL = 0,
  PKCards_state_CARDTYPE_HIDDEN = 1,
  PKCards_state_CARDTYPE_SAME = 2
};
bool PKCards_state_IsValid(int value);
const PKCards_state PKCards_state_state_MIN = PKCards_state_CARDTYPE_NORMAL;
const PKCards_state PKCards_state_state_MAX = PKCards_state_CARDTYPE_SAME;
const int PKCards_state_state_ARRAYSIZE = PKCards_state_state_MAX + 1;

enum ITEM {
  ITEM_PAYBOOK = 1075,
  ITEM_MINICASHBOX = 1049,
  ITEM_FIRSTGOLD = 1904,
  ITEM_FIRSTCLUB = 1901,
  ITEM_FIRSTDREAM = 1905,
  ITEM_FIRSTLOVE = 1906,
  ITEM_FIRSTMINI = 1903,
  ITEM_MINICASHBOX_PRACTICE = 1080,
  ITEM_MINICASHBOX_DISCOUNT = 1081,
  ITEM_INFINITYSPEED = 1030,
  ITEM_GAMEHELPER = 1063,
  ITEM_GAMEHELPER_PLUS = 1064
};
bool ITEM_IsValid(int value);
const ITEM ITEM_MIN = ITEM_INFINITYSPEED;
const ITEM ITEM_MAX = ITEM_FIRSTLOVE;
const int ITEM_ARRAYSIZE = ITEM_MAX + 1;

enum BETTING_RULE {
  BETTING_FREE = 0,
  BETTING_AUTO = 1,
  BETTING_AUTO_ADD = 2,
  BETTING_492 = 3
};
bool BETTING_RULE_IsValid(int value);
const BETTING_RULE BETTING_RULE_MIN = BETTING_FREE;
const BETTING_RULE BETTING_RULE_MAX = BETTING_492;
const int BETTING_RULE_ARRAYSIZE = BETTING_RULE_MAX + 1;

enum ADD_RULE {
  ADD_FREE = 0,
  ADD_QUATER_1 = 1,
  ADD_QUATERHALF_11 = 2,
  ADD_QUATERHALF_12 = 3
};
bool ADD_RULE_IsValid(int value);
const ADD_RULE ADD_RULE_MIN = ADD_FREE;
const ADD_RULE ADD_RULE_MAX = ADD_QUATERHALF_12;
const int ADD_RULE_ARRAYSIZE = ADD_RULE_MAX + 1;

enum FIRST_RULE {
  FIRST_FREE = 0,
  FIRST_591 = 1,
  FIRST_491_1QUARTER = 2,
  FIRST_491_1HALF = 3,
  FIRST_491_2HALF = 4,
  FIRST_592 = 5,
  FIRST_592_SPEED = 6
};
bool FIRST_RULE_IsValid(int value);
const FIRST_RULE FIRST_RULE_MIN = FIRST_FREE;
const FIRST_RULE FIRST_RULE_MAX = FIRST_592_SPEED;
const int FIRST_RULE_ARRAYSIZE = FIRST_RULE_MAX + 1;

enum SECOND_RULE {
  SECOND_FREE = 0,
  SECOND_NODIE = 1
};
bool SECOND_RULE_IsValid(int value);
const SECOND_RULE SECOND_RULE_MIN = SECOND_FREE;
const SECOND_RULE SECOND_RULE_MAX = SECOND_NODIE;
const int SECOND_RULE_ARRAYSIZE = SECOND_RULE_MAX + 1;

enum GAMETYPE {
  GAMETYPE_NORMAL = 0,
  GAMETYPE_USERDEAL = 1,
  GAMETYPE_POKERBET = 2
};
bool GAMETYPE_IsValid(int value);
const GAMETYPE GAMETYPE_MIN = GAMETYPE_NORMAL;
const GAMETYPE GAMETYPE_MAX = GAMETYPE_POKERBET;
const int GAMETYPE_ARRAYSIZE = GAMETYPE_MAX + 1;

enum USER_STATE {
  USERSTATE_NONE = -1,
  USERSTATE_READY = 0,
  USERSTATE_WAITING = 1,
  USERSTATE_49WAITING = 2,
  USERSTATE_SELECTBEGIN = 3,
  USERSTATE_SELECTEND = 4,
  USERSTATE_PLAYING = 5,
  USERSTATE_DIE = 6,
  USERSTATE_SELECTCONTINUE = 7
};
bool USER_STATE_IsValid(int value);
const USER_STATE USER_STATE_MIN = USERSTATE_NONE;
const USER_STATE USER_STATE_MAX = USERSTATE_SELECTCONTINUE;
const int USER_STATE_ARRAYSIZE = USER_STATE_MAX + 1;

enum GAMESTATE {
  GAMESTATE_INVALID = -1,
  GAMESTATE_READY = 0,
  GAMESTATE_START = 1,
  GAMESTATE_SELECT = 2,
  GAMESTATE_PLAY = 3,
  GAMESTATE_RESULT = 4,
  GAMESTATE_SAVE = 5,
  GAMESTATE_DEAD = 6
};
bool GAMESTATE_IsValid(int value);
const GAMESTATE GAMESTATE_MIN = GAMESTATE_INVALID;
const GAMESTATE GAMESTATE_MAX = GAMESTATE_DEAD;
const int GAMESTATE_ARRAYSIZE = GAMESTATE_MAX + 1;

enum SYSMSG_TYPE {
  SYSMSG_MONEYDEFICIT = 10,
  SYSMSG_MONEYOVER = 11,
  SYSMSG_PRIZEMONEY = 12,
  SYSMSG_PURGE_RESERVED = 100,
  SYSMSG_PURGE_CANCEL = 101,
  SYSMSG_PURGE = 102,
  SYSMSG_WINER = 200,
  SYSMSG_DEALER = 201,
  SYSMSG_MONEYLOSER = 202,
  SYSMSG_MONEYADD = 203,
  SYSMSG_GIVEMONEY = 204,
  SYSMSG_GAMESTART = 205,
  SYSMSG_CARDSELECT = 206,
  SYSMSG_ENTRY = 207,
  SYSMSG_OBSERVE = 208,
  SYSMSG_EXIT = 209,
  SYSMSG_BOSS = 210,
  SYSMSG_NOSTART = 211,
  SYSMSG_DBFAIL = 212,
  SYSMSG_POWER = 213,
  SYSMSG_MISSION = 214,
  SYSMSG_GAMELIMIT = 215,
  SYSMSG_MONEYWINADD = 216,
  SYSMSG_TWOOWNER_NOMONEY = 217,
  SYSMSG_LCS_KICKOUT_USER = 218,
  SYSMSG_GAMEEND = 219,
  SYSMSG_STRANGENESS = 220,
  SYSMSG_AUTOBET = 221,
  SYSMSG_TEST = 1000
};
bool SYSMSG_TYPE_IsValid(int value);
const SYSMSG_TYPE SYSMSG_TYPE_MIN = SYSMSG_MONEYDEFICIT;
const SYSMSG_TYPE SYSMSG_TYPE_MAX = SYSMSG_TEST;
const int SYSMSG_TYPE_ARRAYSIZE = SYSMSG_TYPE_MAX + 1;

enum BET_STATE {
  BETSTATE_NONE = 0,
  BETSTATE_CALL = 1,
  BETSTATE_BBING = 2,
  BETSTATE_CHECK = 3,
  BETSTATE_DOUBLE = 4,
  BETSTATE_QUARTER = 5,
  BETSTATE_HALF = 6,
  BETSTATE_FULL = 7,
  BETSTATE_DIE = 8,
  BETSTATE_LIVE = 9,
  BETSTATE_ALLIN = 10,
  BETSTATE_REST = 11,
  BETSTATE_RECEIVE = 12,
  BETSTATE_SAMEPOINT = 13,
  BETSTATE_TENPOINT = 14,
  BETSTATE_TWENTYPOINT = 15,
  BETSTATE_FIFTYPOINT = 16,
  BETSTATE_NINETYPOINT = 17,
  BETSTATE_CUT = 18,
  BETSTATE_PASS = 19,
  BETSTATE_LIVE_CUT = 20,
  BETSTATE_LIVE_PASS = 21,
  BETSTATE_LINE = 22,
  BETSTATE_DEAL = 23
};
bool BET_STATE_IsValid(int value);
const BET_STATE BET_STATE_MIN = BETSTATE_NONE;
const BET_STATE BET_STATE_MAX = BETSTATE_DEAL;
const int BET_STATE_ARRAYSIZE = BET_STATE_MAX + 1;

enum BET_TYPE {
  BET_TYPE_NONE = 0,
  BET_TYPE_CALL = 1,
  BET_TYPE_CHECK = 2,
  BET_TYPE_CHECK_ONLY = 3,
  BET_TYPE_BBING = 4,
  BET_TYPE_BET = 5,
  BET_TYPE_DIE = 6,
  BET_TYPE_LIVE = 7,
  BET_TYPE_REST_ONLY = 8,
  BET_TYPE_REST = 9,
  BET_TYPE_REST_HIGH = 10,
  BET_TYPE_RECEIVE = 11,
  BET_TYPE_SAMEPOINT = 12,
  BET_TYPE_SAMEPOINT_HIGH = 13,
  BET_TYPE_CHANGE = 14,
  BET_TYPE_LIVE_CHANGE = 15,
  BET_TYPE_LINE = 16,
  BET_TYPE_LINE_TIME = 17,
  BET_TYPE_LINEDEAL = 18,
  BET_TYPE_LINEEND = 19,
  BET_TYPE_AUTO = 20
};
bool BET_TYPE_IsValid(int value);
const BET_TYPE BET_TYPE_MIN = BET_TYPE_NONE;
const BET_TYPE BET_TYPE_MAX = BET_TYPE_AUTO;
const int BET_TYPE_ARRAYSIZE = BET_TYPE_MAX + 1;

enum BET_TURN {
  BET_TURN_NONE = 0,
  BET_TURN_LIVE_1 = 1,
  BET_TURN_LIVE_2 = 2,
  BET_TURN_REST_1 = 3,
  BET_TURN_REST_2 = 4,
  BET_TURN_REST_3 = 5,
  BET_TURN_REMATCH_REST_1 = 11,
  BET_TURN_REMATCH_REST_2 = 12,
  BET_TURN_REMATCH_REST_3 = 13,
  BET_TURN_LINE = 21,
  BET_TURN_BET_1_1 = 101,
  BET_TURN_BET_2_1 = 102,
  BET_TURN_BET_2_2 = 103,
  BET_TURN_BET_2_3 = 104
};
bool BET_TURN_IsValid(int value);
const BET_TURN BET_TURN_MIN = BET_TURN_NONE;
const BET_TURN BET_TURN_MAX = BET_TURN_BET_2_3;
const int BET_TURN_ARRAYSIZE = BET_TURN_MAX + 1;

enum _EXIT {
  EXIT_INVALID = 0,
  EXIT_OBSERVE = 1,
  EXIT_EXIT = 2
};
bool _EXIT_IsValid(int value);
const _EXIT _EXIT_MIN = EXIT_INVALID;
const _EXIT _EXIT_MAX = EXIT_EXIT;
const int _EXIT_ARRAYSIZE = _EXIT_MAX + 1;

enum MSG_ERRORCODE {
  ERR_SUCCESS = 0,
  ERR_NOACCESS = 1,
  ERR_INVALIDTARGET = 2,
  ERR_INVALIDPWD = 3,
  ERR_NOSEAT = 4,
  ERR_ALREADY = 5,
  ERR_INVALIDSVCID = 6,
  ERR_SYSTEM = 7,
  ERR_MISMATCHVERSION = 8,
  ERR_FAULTSTATE = 9,
  ERR_NOTNOWTURN = 10,
  ERR_DONOTPLAYER = 11,
  ERR_VERIFYPLAYER = 12,
  ERR_FIRSTUSER = 13,
  ERR_REALNAME = 14,
  ERR_CHECKNOTICE_0 = 15,
  ERR_CHECKNOTICE_1 = 16
};
bool MSG_ERRORCODE_IsValid(int value);
const MSG_ERRORCODE MSG_ERRORCODE_MIN = ERR_SUCCESS;
const MSG_ERRORCODE MSG_ERRORCODE_MAX = ERR_CHECKNOTICE_1;
const int MSG_ERRORCODE_ARRAYSIZE = MSG_ERRORCODE_MAX + 1;

enum ENTRY_ERRORCODE {
  ENTRY_NOMONEY = 0,
  ENTRY_NOMONEY_OBSERVE = 1,
  ENTRY_SPACE = 2,
  ENTRY_IP = 3,
  ENTRY_VERSION = 4,
  ENTRY_BLACKLIST = 5,
  ENTRY_GAMELIMIT = 6,
  ENTRY_POWERCHANNEL = 7,
  ENTRY_LOCALJACKPOT_NOMONEY = 8,
  ENTRY_NEEDTICKET = 9,
  ENTRY_GRADE = 10,
  ENTRY_OVERMONEY = 11,
  ENTRY_TWOOWNER_NOMONEY = 12
};
bool ENTRY_ERRORCODE_IsValid(int value);
const ENTRY_ERRORCODE ENTRY_ERRORCODE_MIN = ENTRY_NOMONEY;
const ENTRY_ERRORCODE ENTRY_ERRORCODE_MAX = ENTRY_TWOOWNER_NOMONEY;
const int ENTRY_ERRORCODE_ARRAYSIZE = ENTRY_ERRORCODE_MAX + 1;

enum RankPrecedence {
  RANK_NONE = -1,
  RANK_NOMADE = 0,
  RANK_MADE = 1,
  RANK_NINE_FOUR = 2,
  RANK_FOOL_NINE_FOUR = 3,
  RANK_THREE_SEVEN = 4,
  RANK_FOUR_SEVEN = 5,
  RANK_ZERO = 6,
  RANK_ONE = 7,
  RANK_TWO = 8,
  RANK_THREE = 9,
  RANK_FOUR = 10,
  RANK_FIVE = 11,
  RANK_SIX = 12,
  RANK_SEVEN = 13,
  RANK_EIGHT = 14,
  RANK_NINE = 15,
  RANK_FOUR_SIX = 16,
  RANK_TEN_FOUR = 17,
  RANK_TEN_ONE = 18,
  RANK_ONE_NINE = 19,
  RANK_ONE_FOUR = 20,
  RANK_ONE_TWO = 21,
  RANK_1DDANG = 22,
  RANK_2DDANG = 23,
  RANK_3DDANG = 24,
  RANK_4DDANG = 25,
  RANK_5DDANG = 26,
  RANK_6DDANG = 27,
  RANK_7DDANG = 28,
  RANK_8DDANG = 29,
  RANK_9DDANG = 30,
  RANK_10DDANG = 31,
  RANK_13DDANG = 32,
  RANK_18DDANG = 33,
  RANK_38DDANG = 34,
  RANK_MAX = 35,
  RANK_73DDANGCATCH = 36,
  RANK_ASSA_JANGDDANG = 37,
  RANK_TOP = 0,
  RANK_ONEPAIR = 1,
  RANK_TWOPAIR = 2,
  RANK_THREEOFAKIND = 3,
  RANK_STRAIGHT = 4,
  RANK_BACKSTRAIGHT = 5,
  RANK_MOUNTAIN = 6,
  RANK_FLUSH = 7,
  RANK_FULLHOUSE = 8,
  RANK_FOUROFAKIND = 9,
  RANK_STRAIGHTFLUSH = 10,
  RANK_ROYALSTRAIGHTFLUSH = 11
};
bool RankPrecedence_IsValid(int value);
const RankPrecedence RankPrecedence_MIN = RANK_NONE;
const RankPrecedence RankPrecedence_MAX = RANK_ASSA_JANGDDANG;
const int RankPrecedence_ARRAYSIZE = RankPrecedence_MAX + 1;

enum Timer {
  TIMER_START = 1,
  TIMER_STARTPREV = 2,
  TIMER_DEALOPEN = 3,
  TIMER_BETTING = 4,
  TIMER_BETTINGTURN = 5,
  TIMER_BETTINGWANT = 6,
  TIMER_DEAL = 7,
  TIMER_SPEEDGAME = 8,
  TIMER_GAMEEND = 9,
  TIMER_NEWGAME = 10,
  TIMER_CONTINUE = 11,
  TIMER_REMATCH = 12,
  TIMER_AUTOBET = 13,
  TIMER_PURGE = 14,
  TIMER_CARDDEAL = 15,
  TIMER_FINISHUSER = 16,
  TIMER_ECHO_DEALS = 17,
  TIMER_ECHO_BET = 18,
  TIMER_ECHO_DEAL = 19,
  TIMER_ECHO_FINISH = 20
};
bool Timer_IsValid(int value);
const Timer Timer_MIN = TIMER_START;
const Timer Timer_MAX = TIMER_ECHO_FINISH;
const int Timer_ARRAYSIZE = Timer_MAX + 1;

// ===================================================================

class GameUserInfo : public ::google::protobuf::MessageLite {
 public:
  GameUserInfo();
  virtual ~GameUserInfo();
  
  GameUserInfo(const GameUserInfo& from);
  
  inline GameUserInfo& operator=(const GameUserInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GameUserInfo& default_instance();
  
  void Swap(GameUserInfo* other);
  
  // implements Message ----------------------------------------------
  
  GameUserInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GameUserInfo& from);
  void MergeFrom(const GameUserInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .GameInfo gameInfo = 1;
  inline bool has_gameinfo() const;
  inline void clear_gameinfo();
  static const int kGameInfoFieldNumber = 1;
  inline const ::GameInfo& gameinfo() const;
  inline ::GameInfo* mutable_gameinfo();
  inline ::GameInfo* release_gameinfo();
  
  // required .MemberInfo memberInfo = 2;
  inline bool has_memberinfo() const;
  inline void clear_memberinfo();
  static const int kMemberInfoFieldNumber = 2;
  inline const ::MemberInfo& memberinfo() const;
  inline ::MemberInfo* mutable_memberinfo();
  inline ::MemberInfo* release_memberinfo();
  
  // @@protoc_insertion_point(class_scope:GameUserInfo)
 private:
  inline void set_has_gameinfo();
  inline void clear_has_gameinfo();
  inline void set_has_memberinfo();
  inline void clear_has_memberinfo();
  
  ::GameInfo* gameinfo_;
  ::MemberInfo* memberinfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GameUserInfo* default_instance_;
};
// -------------------------------------------------------------------

class GameRoomInfo : public ::google::protobuf::MessageLite {
 public:
  GameRoomInfo();
  virtual ~GameRoomInfo();
  
  GameRoomInfo(const GameRoomInfo& from);
  
  inline GameRoomInfo& operator=(const GameRoomInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GameRoomInfo& default_instance();
  
  void Swap(GameRoomInfo* other);
  
  // implements Message ----------------------------------------------
  
  GameRoomInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GameRoomInfo& from);
  void MergeFrom(const GameRoomInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 roomID = 1;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIDFieldNumber = 1;
  inline ::google::protobuf::int32 roomid() const;
  inline void set_roomid(::google::protobuf::int32 value);
  
  // required int32 pointMoney = 2;
  inline bool has_pointmoney() const;
  inline void clear_pointmoney();
  static const int kPointMoneyFieldNumber = 2;
  inline ::google::protobuf::int32 pointmoney() const;
  inline void set_pointmoney(::google::protobuf::int32 value);
  
  // repeated .GameUserInfo gameUserInfo = 3;
  inline int gameuserinfo_size() const;
  inline void clear_gameuserinfo();
  static const int kGameUserInfoFieldNumber = 3;
  inline const ::GameUserInfo& gameuserinfo(int index) const;
  inline ::GameUserInfo* mutable_gameuserinfo(int index);
  inline ::GameUserInfo* add_gameuserinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::GameUserInfo >&
      gameuserinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::GameUserInfo >*
      mutable_gameuserinfo();
  
  // optional bool enablestart = 4;
  inline bool has_enablestart() const;
  inline void clear_enablestart();
  static const int kEnablestartFieldNumber = 4;
  inline bool enablestart() const;
  inline void set_enablestart(bool value);
  
  // @@protoc_insertion_point(class_scope:GameRoomInfo)
 private:
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_pointmoney();
  inline void clear_has_pointmoney();
  inline void set_has_enablestart();
  inline void clear_has_enablestart();
  
  ::google::protobuf::int32 roomid_;
  ::google::protobuf::int32 pointmoney_;
  ::google::protobuf::RepeatedPtrField< ::GameUserInfo > gameuserinfo_;
  bool enablestart_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GameRoomInfo* default_instance_;
};
// -------------------------------------------------------------------

class GameInfo : public ::google::protobuf::MessageLite {
 public:
  GameInfo();
  virtual ~GameInfo();
  
  GameInfo(const GameInfo& from);
  
  inline GameInfo& operator=(const GameInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GameInfo& default_instance();
  
  void Swap(GameInfo* other);
  
  // implements Message ----------------------------------------------
  
  GameInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GameInfo& from);
  void MergeFrom(const GameInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // required string level = 3;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 3;
  inline const ::std::string& level() const;
  inline void set_level(const ::std::string& value);
  inline void set_level(const char* value);
  inline void set_level(const char* value, size_t size);
  inline ::std::string* mutable_level();
  inline ::std::string* release_level();
  
  // required string money = 4;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 4;
  inline const ::std::string& money() const;
  inline void set_money(const ::std::string& value);
  inline void set_money(const char* value);
  inline void set_money(const char* value, size_t size);
  inline ::std::string* mutable_money();
  inline ::std::string* release_money();
  
  // required int32 winCnt = 5;
  inline bool has_wincnt() const;
  inline void clear_wincnt();
  static const int kWinCntFieldNumber = 5;
  inline ::google::protobuf::int32 wincnt() const;
  inline void set_wincnt(::google::protobuf::int32 value);
  
  // required int32 loseCnt = 6;
  inline bool has_losecnt() const;
  inline void clear_losecnt();
  static const int kLoseCntFieldNumber = 6;
  inline ::google::protobuf::int32 losecnt() const;
  inline void set_losecnt(::google::protobuf::int32 value);
  
  // required int32 allInCnt = 7;
  inline bool has_allincnt() const;
  inline void clear_allincnt();
  static const int kAllInCntFieldNumber = 7;
  inline ::google::protobuf::int32 allincnt() const;
  inline void set_allincnt(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:GameInfo)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_wincnt();
  inline void clear_has_wincnt();
  inline void set_has_losecnt();
  inline void clear_has_losecnt();
  inline void set_has_allincnt();
  inline void clear_has_allincnt();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  ::std::string* level_;
  ::std::string* money_;
  ::google::protobuf::int32 wincnt_;
  ::google::protobuf::int32 losecnt_;
  ::google::protobuf::int32 allincnt_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GameInfo* default_instance_;
};
// -------------------------------------------------------------------

class MemberInfo : public ::google::protobuf::MessageLite {
 public:
  MemberInfo();
  virtual ~MemberInfo();
  
  MemberInfo(const MemberInfo& from);
  
  inline MemberInfo& operator=(const MemberInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const MemberInfo& default_instance();
  
  void Swap(MemberInfo* other);
  
  // implements Message ----------------------------------------------
  
  MemberInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MemberInfo& from);
  void MergeFrom(const MemberInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required string avatarUrl = 2;
  inline bool has_avatarurl() const;
  inline void clear_avatarurl();
  static const int kAvatarUrlFieldNumber = 2;
  inline const ::std::string& avatarurl() const;
  inline void set_avatarurl(const ::std::string& value);
  inline void set_avatarurl(const char* value);
  inline void set_avatarurl(const char* value, size_t size);
  inline ::std::string* mutable_avatarurl();
  inline ::std::string* release_avatarurl();
  
  // required string nickName = 3;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNickNameFieldNumber = 3;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  
  // @@protoc_insertion_point(class_scope:MemberInfo)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_avatarurl();
  inline void clear_has_avatarurl();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  
  ::std::string* avatarurl_;
  ::std::string* nickname_;
  ::google::protobuf::int32 gameid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static MemberInfo* default_instance_;
};
// -------------------------------------------------------------------

class s_req_game_test_packet : public ::google::protobuf::MessageLite {
 public:
  s_req_game_test_packet();
  virtual ~s_req_game_test_packet();
  
  s_req_game_test_packet(const s_req_game_test_packet& from);
  
  inline s_req_game_test_packet& operator=(const s_req_game_test_packet& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_req_game_test_packet& default_instance();
  
  void Swap(s_req_game_test_packet* other);
  
  // implements Message ----------------------------------------------
  
  s_req_game_test_packet* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_req_game_test_packet& from);
  void MergeFrom(const s_req_game_test_packet& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 test_int = 2;
  inline bool has_test_int() const;
  inline void clear_test_int();
  static const int kTestIntFieldNumber = 2;
  inline ::google::protobuf::int32 test_int() const;
  inline void set_test_int(::google::protobuf::int32 value);
  
  // required string test_string = 3;
  inline bool has_test_string() const;
  inline void clear_test_string();
  static const int kTestStringFieldNumber = 3;
  inline const ::std::string& test_string() const;
  inline void set_test_string(const ::std::string& value);
  inline void set_test_string(const char* value);
  inline void set_test_string(const char* value, size_t size);
  inline ::std::string* mutable_test_string();
  inline ::std::string* release_test_string();
  
  // @@protoc_insertion_point(class_scope:s_req_game_test_packet)
 private:
  inline void set_has_test_int();
  inline void clear_has_test_int();
  inline void set_has_test_string();
  inline void clear_has_test_string();
  
  ::std::string* test_string_;
  ::google::protobuf::int32 test_int_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_req_game_test_packet* default_instance_;
};
// -------------------------------------------------------------------

class s_req_send_cmd : public ::google::protobuf::MessageLite {
 public:
  s_req_send_cmd();
  virtual ~s_req_send_cmd();
  
  s_req_send_cmd(const s_req_send_cmd& from);
  
  inline s_req_send_cmd& operator=(const s_req_send_cmd& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_req_send_cmd& default_instance();
  
  void Swap(s_req_send_cmd* other);
  
  // implements Message ----------------------------------------------
  
  s_req_send_cmd* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_req_send_cmd& from);
  void MergeFrom(const s_req_send_cmd& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 cmd_type = 2;
  inline bool has_cmd_type() const;
  inline void clear_cmd_type();
  static const int kCmdTypeFieldNumber = 2;
  inline ::google::protobuf::int32 cmd_type() const;
  inline void set_cmd_type(::google::protobuf::int32 value);
  
  // required string cmd = 3;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 3;
  inline const ::std::string& cmd() const;
  inline void set_cmd(const ::std::string& value);
  inline void set_cmd(const char* value);
  inline void set_cmd(const char* value, size_t size);
  inline ::std::string* mutable_cmd();
  inline ::std::string* release_cmd();
  
  // @@protoc_insertion_point(class_scope:s_req_send_cmd)
 private:
  inline void set_has_cmd_type();
  inline void clear_has_cmd_type();
  inline void set_has_cmd();
  inline void clear_has_cmd();
  
  ::std::string* cmd_;
  ::google::protobuf::int32 cmd_type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_req_send_cmd* default_instance_;
};
// -------------------------------------------------------------------

class s_req_join_room : public ::google::protobuf::MessageLite {
 public:
  s_req_join_room();
  virtual ~s_req_join_room();
  
  s_req_join_room(const s_req_join_room& from);
  
  inline s_req_join_room& operator=(const s_req_join_room& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_req_join_room& default_instance();
  
  void Swap(s_req_join_room* other);
  
  // implements Message ----------------------------------------------
  
  s_req_join_room* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_req_join_room& from);
  void MergeFrom(const s_req_join_room& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .GameInfo gameinfo = 1;
  inline bool has_gameinfo() const;
  inline void clear_gameinfo();
  static const int kGameinfoFieldNumber = 1;
  inline const ::GameInfo& gameinfo() const;
  inline ::GameInfo* mutable_gameinfo();
  inline ::GameInfo* release_gameinfo();
  
  // @@protoc_insertion_point(class_scope:s_req_join_room)
 private:
  inline void set_has_gameinfo();
  inline void clear_has_gameinfo();
  
  ::GameInfo* gameinfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_req_join_room* default_instance_;
};
// -------------------------------------------------------------------

class s_req_send_start : public ::google::protobuf::MessageLite {
 public:
  s_req_send_start();
  virtual ~s_req_send_start();
  
  s_req_send_start(const s_req_send_start& from);
  
  inline s_req_send_start& operator=(const s_req_send_start& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_req_send_start& default_instance();
  
  void Swap(s_req_send_start* other);
  
  // implements Message ----------------------------------------------
  
  s_req_send_start* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_req_send_start& from);
  void MergeFrom(const s_req_send_start& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameid = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameidFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:s_req_send_start)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  
  ::google::protobuf::int32 gameid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_req_send_start* default_instance_;
};
// -------------------------------------------------------------------

class s_req_send_select_card : public ::google::protobuf::MessageLite {
 public:
  s_req_send_select_card();
  virtual ~s_req_send_select_card();
  
  s_req_send_select_card(const s_req_send_select_card& from);
  
  inline s_req_send_select_card& operator=(const s_req_send_select_card& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_req_send_select_card& default_instance();
  
  void Swap(s_req_send_select_card* other);
  
  // implements Message ----------------------------------------------
  
  s_req_send_select_card* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_req_send_select_card& from);
  void MergeFrom(const s_req_send_select_card& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lCardIdx = 1;
  inline bool has_m_lcardidx() const;
  inline void clear_m_lcardidx();
  static const int kMLCardIdxFieldNumber = 1;
  inline ::google::protobuf::int32 m_lcardidx() const;
  inline void set_m_lcardidx(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:s_req_send_select_card)
 private:
  inline void set_has_m_lcardidx();
  inline void clear_has_m_lcardidx();
  
  ::google::protobuf::int32 m_lcardidx_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_req_send_select_card* default_instance_;
};
// -------------------------------------------------------------------

class s_req_betting : public ::google::protobuf::MessageLite {
 public:
  s_req_betting();
  virtual ~s_req_betting();
  
  s_req_betting(const s_req_betting& from);
  
  inline s_req_betting& operator=(const s_req_betting& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_req_betting& default_instance();
  
  void Swap(s_req_betting* other);
  
  // implements Message ----------------------------------------------
  
  s_req_betting* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_req_betting& from);
  void MergeFrom(const s_req_betting& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 gameid = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameidFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required sint32 m_lBetType = 2;
  inline bool has_m_lbettype() const;
  inline void clear_m_lbettype();
  static const int kMLBetTypeFieldNumber = 2;
  inline ::google::protobuf::int32 m_lbettype() const;
  inline void set_m_lbettype(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:s_req_betting)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_m_lbettype();
  inline void clear_has_m_lbettype();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 m_lbettype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_req_betting* default_instance_;
};
// -------------------------------------------------------------------

class s_req_ping : public ::google::protobuf::MessageLite {
 public:
  s_req_ping();
  virtual ~s_req_ping();
  
  s_req_ping(const s_req_ping& from);
  
  inline s_req_ping& operator=(const s_req_ping& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_req_ping& default_instance();
  
  void Swap(s_req_ping* other);
  
  // implements Message ----------------------------------------------
  
  s_req_ping* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_req_ping& from);
  void MergeFrom(const s_req_ping& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 usn = 1;
  inline bool has_usn() const;
  inline void clear_usn();
  static const int kUsnFieldNumber = 1;
  inline ::google::protobuf::int32 usn() const;
  inline void set_usn(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:s_req_ping)
 private:
  inline void set_has_usn();
  inline void clear_has_usn();
  
  ::google::protobuf::int32 usn_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_req_ping* default_instance_;
};
// -------------------------------------------------------------------

class s_req_entry : public ::google::protobuf::MessageLite {
 public:
  s_req_entry();
  virtual ~s_req_entry();
  
  s_req_entry(const s_req_entry& from);
  
  inline s_req_entry& operator=(const s_req_entry& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_req_entry& default_instance();
  
  void Swap(s_req_entry* other);
  
  // implements Message ----------------------------------------------
  
  s_req_entry* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_req_entry& from);
  void MergeFrom(const s_req_entry& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 m_nVersion = 1;
  inline bool has_m_nversion() const;
  inline void clear_m_nversion();
  static const int kMNVersionFieldNumber = 1;
  inline ::google::protobuf::int32 m_nversion() const;
  inline void set_m_nversion(::google::protobuf::int32 value);
  
  // optional sint32 m_bWelcomeSound = 2;
  inline bool has_m_bwelcomesound() const;
  inline void clear_m_bwelcomesound();
  static const int kMBWelcomeSoundFieldNumber = 2;
  inline ::google::protobuf::int32 m_bwelcomesound() const;
  inline void set_m_bwelcomesound(::google::protobuf::int32 value);
  
  // required sint32 m_lSoundType = 3;
  inline bool has_m_lsoundtype() const;
  inline void clear_m_lsoundtype();
  static const int kMLSoundTypeFieldNumber = 3;
  inline ::google::protobuf::int32 m_lsoundtype() const;
  inline void set_m_lsoundtype(::google::protobuf::int32 value);
  
  // required string m_sNickName = 4;
  inline bool has_m_snickname() const;
  inline void clear_m_snickname();
  static const int kMSNickNameFieldNumber = 4;
  inline const ::std::string& m_snickname() const;
  inline void set_m_snickname(const ::std::string& value);
  inline void set_m_snickname(const char* value);
  inline void set_m_snickname(const char* value, size_t size);
  inline ::std::string* mutable_m_snickname();
  inline ::std::string* release_m_snickname();
  
  // optional string m_sAvt = 5;
  inline bool has_m_savt() const;
  inline void clear_m_savt();
  static const int kMSAvtFieldNumber = 5;
  inline const ::std::string& m_savt() const;
  inline void set_m_savt(const ::std::string& value);
  inline void set_m_savt(const char* value);
  inline void set_m_savt(const char* value, size_t size);
  inline ::std::string* mutable_m_savt();
  inline ::std::string* release_m_savt();
  
  // required sint32 m_lCLevel = 6;
  inline bool has_m_lclevel() const;
  inline void clear_m_lclevel();
  static const int kMLCLevelFieldNumber = 6;
  inline ::google::protobuf::int32 m_lclevel() const;
  inline void set_m_lclevel(::google::protobuf::int32 value);
  
  // required sint32 m_lSex = 7;
  inline bool has_m_lsex() const;
  inline void clear_m_lsex();
  static const int kMLSexFieldNumber = 7;
  inline ::google::protobuf::int32 m_lsex() const;
  inline void set_m_lsex(::google::protobuf::int32 value);
  
  // required int32 gameid = 8;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameidFieldNumber = 8;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:s_req_entry)
 private:
  inline void set_has_m_nversion();
  inline void clear_has_m_nversion();
  inline void set_has_m_bwelcomesound();
  inline void clear_has_m_bwelcomesound();
  inline void set_has_m_lsoundtype();
  inline void clear_has_m_lsoundtype();
  inline void set_has_m_snickname();
  inline void clear_has_m_snickname();
  inline void set_has_m_savt();
  inline void clear_has_m_savt();
  inline void set_has_m_lclevel();
  inline void clear_has_m_lclevel();
  inline void set_has_m_lsex();
  inline void clear_has_m_lsex();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  
  ::google::protobuf::int32 m_nversion_;
  ::google::protobuf::int32 m_bwelcomesound_;
  ::std::string* m_snickname_;
  ::google::protobuf::int32 m_lsoundtype_;
  ::google::protobuf::int32 m_lclevel_;
  ::std::string* m_savt_;
  ::google::protobuf::int32 m_lsex_;
  ::google::protobuf::int32 gameid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_req_entry* default_instance_;
};
// -------------------------------------------------------------------

class s_req_continue : public ::google::protobuf::MessageLite {
 public:
  s_req_continue();
  virtual ~s_req_continue();
  
  s_req_continue(const s_req_continue& from);
  
  inline s_req_continue& operator=(const s_req_continue& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_req_continue& default_instance();
  
  void Swap(s_req_continue* other);
  
  // implements Message ----------------------------------------------
  
  s_req_continue* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_req_continue& from);
  void MergeFrom(const s_req_continue& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lExit = 1;
  inline bool has_m_lexit() const;
  inline void clear_m_lexit();
  static const int kMLExitFieldNumber = 1;
  inline ::google::protobuf::int32 m_lexit() const;
  inline void set_m_lexit(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:s_req_continue)
 private:
  inline void set_has_m_lexit();
  inline void clear_has_m_lexit();
  
  ::google::protobuf::int32 m_lexit_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_req_continue* default_instance_;
};
// -------------------------------------------------------------------

class s_req_ruleset : public ::google::protobuf::MessageLite {
 public:
  s_req_ruleset();
  virtual ~s_req_ruleset();
  
  s_req_ruleset(const s_req_ruleset& from);
  
  inline s_req_ruleset& operator=(const s_req_ruleset& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_req_ruleset& default_instance();
  
  void Swap(s_req_ruleset* other);
  
  // implements Message ----------------------------------------------
  
  s_req_ruleset* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_req_ruleset& from);
  void MergeFrom(const s_req_ruleset& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 m_nRuleIdx = 1;
  inline bool has_m_nruleidx() const;
  inline void clear_m_nruleidx();
  static const int kMNRuleIdxFieldNumber = 1;
  inline ::google::protobuf::int32 m_nruleidx() const;
  inline void set_m_nruleidx(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:s_req_ruleset)
 private:
  inline void set_has_m_nruleidx();
  inline void clear_has_m_nruleidx();
  
  ::google::protobuf::int32 m_nruleidx_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_req_ruleset* default_instance_;
};
// -------------------------------------------------------------------

class s_req_jokboset : public ::google::protobuf::MessageLite {
 public:
  s_req_jokboset();
  virtual ~s_req_jokboset();
  
  s_req_jokboset(const s_req_jokboset& from);
  
  inline s_req_jokboset& operator=(const s_req_jokboset& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_req_jokboset& default_instance();
  
  void Swap(s_req_jokboset* other);
  
  // implements Message ----------------------------------------------
  
  s_req_jokboset* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_req_jokboset& from);
  void MergeFrom(const s_req_jokboset& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lKey1 = 1;
  inline bool has_m_lkey1() const;
  inline void clear_m_lkey1();
  static const int kMLKey1FieldNumber = 1;
  inline ::google::protobuf::int32 m_lkey1() const;
  inline void set_m_lkey1(::google::protobuf::int32 value);
  
  // required sint32 m_lKey2 = 2;
  inline bool has_m_lkey2() const;
  inline void clear_m_lkey2();
  static const int kMLKey2FieldNumber = 2;
  inline ::google::protobuf::int32 m_lkey2() const;
  inline void set_m_lkey2(::google::protobuf::int32 value);
  
  // required sint32 m_lKey3 = 3;
  inline bool has_m_lkey3() const;
  inline void clear_m_lkey3();
  static const int kMLKey3FieldNumber = 3;
  inline ::google::protobuf::int32 m_lkey3() const;
  inline void set_m_lkey3(::google::protobuf::int32 value);
  
  // required sint32 m_lKey4 = 4;
  inline bool has_m_lkey4() const;
  inline void clear_m_lkey4();
  static const int kMLKey4FieldNumber = 4;
  inline ::google::protobuf::int32 m_lkey4() const;
  inline void set_m_lkey4(::google::protobuf::int32 value);
  
  // required sint32 m_lKey5 = 5;
  inline bool has_m_lkey5() const;
  inline void clear_m_lkey5();
  static const int kMLKey5FieldNumber = 5;
  inline ::google::protobuf::int32 m_lkey5() const;
  inline void set_m_lkey5(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:s_req_jokboset)
 private:
  inline void set_has_m_lkey1();
  inline void clear_has_m_lkey1();
  inline void set_has_m_lkey2();
  inline void clear_has_m_lkey2();
  inline void set_has_m_lkey3();
  inline void clear_has_m_lkey3();
  inline void set_has_m_lkey4();
  inline void clear_has_m_lkey4();
  inline void set_has_m_lkey5();
  inline void clear_has_m_lkey5();
  
  ::google::protobuf::int32 m_lkey1_;
  ::google::protobuf::int32 m_lkey2_;
  ::google::protobuf::int32 m_lkey3_;
  ::google::protobuf::int32 m_lkey4_;
  ::google::protobuf::int32 m_lkey5_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_req_jokboset* default_instance_;
};
// -------------------------------------------------------------------

class s_req_ack : public ::google::protobuf::MessageLite {
 public:
  s_req_ack();
  virtual ~s_req_ack();
  
  s_req_ack(const s_req_ack& from);
  
  inline s_req_ack& operator=(const s_req_ack& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_req_ack& default_instance();
  
  void Swap(s_req_ack* other);
  
  // implements Message ----------------------------------------------
  
  s_req_ack* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_req_ack& from);
  void MergeFrom(const s_req_ack& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 m_nTagID = 1;
  inline bool has_m_ntagid() const;
  inline void clear_m_ntagid();
  static const int kMNTagIDFieldNumber = 1;
  inline ::google::protobuf::int32 m_ntagid() const;
  inline void set_m_ntagid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:s_req_ack)
 private:
  inline void set_has_m_ntagid();
  inline void clear_has_m_ntagid();
  
  ::google::protobuf::int32 m_ntagid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_req_ack* default_instance_;
};
// -------------------------------------------------------------------

class s_req_choiceremovecard : public ::google::protobuf::MessageLite {
 public:
  s_req_choiceremovecard();
  virtual ~s_req_choiceremovecard();
  
  s_req_choiceremovecard(const s_req_choiceremovecard& from);
  
  inline s_req_choiceremovecard& operator=(const s_req_choiceremovecard& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_req_choiceremovecard& default_instance();
  
  void Swap(s_req_choiceremovecard* other);
  
  // implements Message ----------------------------------------------
  
  s_req_choiceremovecard* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_req_choiceremovecard& from);
  void MergeFrom(const s_req_choiceremovecard& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lUSN = 1;
  inline bool has_m_lusn() const;
  inline void clear_m_lusn();
  static const int kMLUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lusn() const;
  inline void set_m_lusn(::google::protobuf::int32 value);
  
  // required int32 m_nRemoveCardIndex = 2;
  inline bool has_m_nremovecardindex() const;
  inline void clear_m_nremovecardindex();
  static const int kMNRemoveCardIndexFieldNumber = 2;
  inline ::google::protobuf::int32 m_nremovecardindex() const;
  inline void set_m_nremovecardindex(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:s_req_choiceremovecard)
 private:
  inline void set_has_m_lusn();
  inline void clear_has_m_lusn();
  inline void set_has_m_nremovecardindex();
  inline void clear_has_m_nremovecardindex();
  
  ::google::protobuf::int32 m_lusn_;
  ::google::protobuf::int32 m_nremovecardindex_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_req_choiceremovecard* default_instance_;
};
// -------------------------------------------------------------------

class s_req_purge : public ::google::protobuf::MessageLite {
 public:
  s_req_purge();
  virtual ~s_req_purge();
  
  s_req_purge(const s_req_purge& from);
  
  inline s_req_purge& operator=(const s_req_purge& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_req_purge& default_instance();
  
  void Swap(s_req_purge* other);
  
  // implements Message ----------------------------------------------
  
  s_req_purge* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_req_purge& from);
  void MergeFrom(const s_req_purge& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lType = 1;
  inline bool has_m_ltype() const;
  inline void clear_m_ltype();
  static const int kMLTypeFieldNumber = 1;
  inline ::google::protobuf::int32 m_ltype() const;
  inline void set_m_ltype(::google::protobuf::int32 value);
  
  // required sint32 m_lPurgeUSN = 2;
  inline bool has_m_lpurgeusn() const;
  inline void clear_m_lpurgeusn();
  static const int kMLPurgeUSNFieldNumber = 2;
  inline ::google::protobuf::int32 m_lpurgeusn() const;
  inline void set_m_lpurgeusn(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:s_req_purge)
 private:
  inline void set_has_m_ltype();
  inline void clear_has_m_ltype();
  inline void set_has_m_lpurgeusn();
  inline void clear_has_m_lpurgeusn();
  
  ::google::protobuf::int32 m_ltype_;
  ::google::protobuf::int32 m_lpurgeusn_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_req_purge* default_instance_;
};
// -------------------------------------------------------------------

class s_req_exitque : public ::google::protobuf::MessageLite {
 public:
  s_req_exitque();
  virtual ~s_req_exitque();
  
  s_req_exitque(const s_req_exitque& from);
  
  inline s_req_exitque& operator=(const s_req_exitque& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_req_exitque& default_instance();
  
  void Swap(s_req_exitque* other);
  
  // implements Message ----------------------------------------------
  
  s_req_exitque* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_req_exitque& from);
  void MergeFrom(const s_req_exitque& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lExit = 1;
  inline bool has_m_lexit() const;
  inline void clear_m_lexit();
  static const int kMLExitFieldNumber = 1;
  inline ::google::protobuf::int32 m_lexit() const;
  inline void set_m_lexit(::google::protobuf::int32 value);
  
  // required sint32 m_bAction = 2;
  inline bool has_m_baction() const;
  inline void clear_m_baction();
  static const int kMBActionFieldNumber = 2;
  inline ::google::protobuf::int32 m_baction() const;
  inline void set_m_baction(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:s_req_exitque)
 private:
  inline void set_has_m_lexit();
  inline void clear_has_m_lexit();
  inline void set_has_m_baction();
  inline void clear_has_m_baction();
  
  ::google::protobuf::int32 m_lexit_;
  ::google::protobuf::int32 m_baction_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_req_exitque* default_instance_;
};
// -------------------------------------------------------------------

class s_req_soundtype : public ::google::protobuf::MessageLite {
 public:
  s_req_soundtype();
  virtual ~s_req_soundtype();
  
  s_req_soundtype(const s_req_soundtype& from);
  
  inline s_req_soundtype& operator=(const s_req_soundtype& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_req_soundtype& default_instance();
  
  void Swap(s_req_soundtype* other);
  
  // implements Message ----------------------------------------------
  
  s_req_soundtype* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_req_soundtype& from);
  void MergeFrom(const s_req_soundtype& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lSoundType = 1;
  inline bool has_m_lsoundtype() const;
  inline void clear_m_lsoundtype();
  static const int kMLSoundTypeFieldNumber = 1;
  inline ::google::protobuf::int32 m_lsoundtype() const;
  inline void set_m_lsoundtype(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:s_req_soundtype)
 private:
  inline void set_has_m_lsoundtype();
  inline void clear_has_m_lsoundtype();
  
  ::google::protobuf::int32 m_lsoundtype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_req_soundtype* default_instance_;
};
// -------------------------------------------------------------------

class s_req_abuse : public ::google::protobuf::MessageLite {
 public:
  s_req_abuse();
  virtual ~s_req_abuse();
  
  s_req_abuse(const s_req_abuse& from);
  
  inline s_req_abuse& operator=(const s_req_abuse& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_req_abuse& default_instance();
  
  void Swap(s_req_abuse* other);
  
  // implements Message ----------------------------------------------
  
  s_req_abuse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_req_abuse& from);
  void MergeFrom(const s_req_abuse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lType = 1;
  inline bool has_m_ltype() const;
  inline void clear_m_ltype();
  static const int kMLTypeFieldNumber = 1;
  inline ::google::protobuf::int32 m_ltype() const;
  inline void set_m_ltype(::google::protobuf::int32 value);
  
  // required string m_sDay = 2;
  inline bool has_m_sday() const;
  inline void clear_m_sday();
  static const int kMSDayFieldNumber = 2;
  inline const ::std::string& m_sday() const;
  inline void set_m_sday(const ::std::string& value);
  inline void set_m_sday(const char* value);
  inline void set_m_sday(const char* value, size_t size);
  inline ::std::string* mutable_m_sday();
  inline ::std::string* release_m_sday();
  
  // @@protoc_insertion_point(class_scope:s_req_abuse)
 private:
  inline void set_has_m_ltype();
  inline void clear_has_m_ltype();
  inline void set_has_m_sday();
  inline void clear_has_m_sday();
  
  ::std::string* m_sday_;
  ::google::protobuf::int32 m_ltype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_req_abuse* default_instance_;
};
// -------------------------------------------------------------------

class s_req_observe : public ::google::protobuf::MessageLite {
 public:
  s_req_observe();
  virtual ~s_req_observe();
  
  s_req_observe(const s_req_observe& from);
  
  inline s_req_observe& operator=(const s_req_observe& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_req_observe& default_instance();
  
  void Swap(s_req_observe* other);
  
  // implements Message ----------------------------------------------
  
  s_req_observe* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_req_observe& from);
  void MergeFrom(const s_req_observe& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:s_req_observe)
 private:
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_req_observe* default_instance_;
};
// -------------------------------------------------------------------

class GLReqGameProtocol : public ::google::protobuf::MessageLite {
 public:
  GLReqGameProtocol();
  virtual ~GLReqGameProtocol();
  
  GLReqGameProtocol(const GLReqGameProtocol& from);
  
  inline GLReqGameProtocol& operator=(const GLReqGameProtocol& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLReqGameProtocol& default_instance();
  
  void Swap(GLReqGameProtocol* other);
  
  // implements Message ----------------------------------------------
  
  GLReqGameProtocol* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLReqGameProtocol& from);
  void MergeFrom(const GLReqGameProtocol& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef GLReqGameProtocol_Type Type;
  static const Type NONE = GLReqGameProtocol_Type_NONE;
  static const Type req_game_test_packet = GLReqGameProtocol_Type_req_game_test_packet;
  static const Type req_send_cmd = GLReqGameProtocol_Type_req_send_cmd;
  static const Type req_join_room = GLReqGameProtocol_Type_req_join_room;
  static const Type req_send_start = GLReqGameProtocol_Type_req_send_start;
  static const Type req_send_select_card = GLReqGameProtocol_Type_req_send_select_card;
  static const Type req_betting = GLReqGameProtocol_Type_req_betting;
  static const Type req_ping = GLReqGameProtocol_Type_req_ping;
  static const Type req_entry = GLReqGameProtocol_Type_req_entry;
  static const Type req_continue = GLReqGameProtocol_Type_req_continue;
  static const Type req_ruleset = GLReqGameProtocol_Type_req_ruleset;
  static const Type req_jokboset = GLReqGameProtocol_Type_req_jokboset;
  static const Type req_ack = GLReqGameProtocol_Type_req_ack;
  static const Type req_choiceremovecard = GLReqGameProtocol_Type_req_choiceremovecard;
  static const Type req_purge = GLReqGameProtocol_Type_req_purge;
  static const Type req_exitque = GLReqGameProtocol_Type_req_exitque;
  static const Type req_soundtype = GLReqGameProtocol_Type_req_soundtype;
  static const Type req_abuse = GLReqGameProtocol_Type_req_abuse;
  static const Type req_observe = GLReqGameProtocol_Type_req_observe;
  static inline bool Type_IsValid(int value) {
    return GLReqGameProtocol_Type_IsValid(value);
  }
  static const Type Type_MIN =
    GLReqGameProtocol_Type_Type_MIN;
  static const Type Type_MAX =
    GLReqGameProtocol_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    GLReqGameProtocol_Type_Type_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required .GLReqGameProtocol.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::GLReqGameProtocol_Type type() const;
  inline void set_type(::GLReqGameProtocol_Type value);
  
  // optional .s_req_game_test_packet m_req_game_test_packet = 2;
  inline bool has_m_req_game_test_packet() const;
  inline void clear_m_req_game_test_packet();
  static const int kMReqGameTestPacketFieldNumber = 2;
  inline const ::s_req_game_test_packet& m_req_game_test_packet() const;
  inline ::s_req_game_test_packet* mutable_m_req_game_test_packet();
  inline ::s_req_game_test_packet* release_m_req_game_test_packet();
  
  // optional .s_req_send_cmd m_req_send_cmd = 3;
  inline bool has_m_req_send_cmd() const;
  inline void clear_m_req_send_cmd();
  static const int kMReqSendCmdFieldNumber = 3;
  inline const ::s_req_send_cmd& m_req_send_cmd() const;
  inline ::s_req_send_cmd* mutable_m_req_send_cmd();
  inline ::s_req_send_cmd* release_m_req_send_cmd();
  
  // optional .s_req_join_room m_req_join_room = 4;
  inline bool has_m_req_join_room() const;
  inline void clear_m_req_join_room();
  static const int kMReqJoinRoomFieldNumber = 4;
  inline const ::s_req_join_room& m_req_join_room() const;
  inline ::s_req_join_room* mutable_m_req_join_room();
  inline ::s_req_join_room* release_m_req_join_room();
  
  // optional .s_req_send_start m_req_send_start = 5;
  inline bool has_m_req_send_start() const;
  inline void clear_m_req_send_start();
  static const int kMReqSendStartFieldNumber = 5;
  inline const ::s_req_send_start& m_req_send_start() const;
  inline ::s_req_send_start* mutable_m_req_send_start();
  inline ::s_req_send_start* release_m_req_send_start();
  
  // optional .s_req_send_select_card m_req_send_select_card = 6;
  inline bool has_m_req_send_select_card() const;
  inline void clear_m_req_send_select_card();
  static const int kMReqSendSelectCardFieldNumber = 6;
  inline const ::s_req_send_select_card& m_req_send_select_card() const;
  inline ::s_req_send_select_card* mutable_m_req_send_select_card();
  inline ::s_req_send_select_card* release_m_req_send_select_card();
  
  // optional .s_req_betting m_req_betting = 7;
  inline bool has_m_req_betting() const;
  inline void clear_m_req_betting();
  static const int kMReqBettingFieldNumber = 7;
  inline const ::s_req_betting& m_req_betting() const;
  inline ::s_req_betting* mutable_m_req_betting();
  inline ::s_req_betting* release_m_req_betting();
  
  // optional .s_req_ping m_req_ping = 8;
  inline bool has_m_req_ping() const;
  inline void clear_m_req_ping();
  static const int kMReqPingFieldNumber = 8;
  inline const ::s_req_ping& m_req_ping() const;
  inline ::s_req_ping* mutable_m_req_ping();
  inline ::s_req_ping* release_m_req_ping();
  
  // optional .s_req_entry m_req_entry = 9;
  inline bool has_m_req_entry() const;
  inline void clear_m_req_entry();
  static const int kMReqEntryFieldNumber = 9;
  inline const ::s_req_entry& m_req_entry() const;
  inline ::s_req_entry* mutable_m_req_entry();
  inline ::s_req_entry* release_m_req_entry();
  
  // optional .s_req_continue m_req_continue = 10;
  inline bool has_m_req_continue() const;
  inline void clear_m_req_continue();
  static const int kMReqContinueFieldNumber = 10;
  inline const ::s_req_continue& m_req_continue() const;
  inline ::s_req_continue* mutable_m_req_continue();
  inline ::s_req_continue* release_m_req_continue();
  
  // optional .s_req_ruleset m_req_ruleset = 11;
  inline bool has_m_req_ruleset() const;
  inline void clear_m_req_ruleset();
  static const int kMReqRulesetFieldNumber = 11;
  inline const ::s_req_ruleset& m_req_ruleset() const;
  inline ::s_req_ruleset* mutable_m_req_ruleset();
  inline ::s_req_ruleset* release_m_req_ruleset();
  
  // optional .s_req_jokboset m_req_jokboset = 12;
  inline bool has_m_req_jokboset() const;
  inline void clear_m_req_jokboset();
  static const int kMReqJokbosetFieldNumber = 12;
  inline const ::s_req_jokboset& m_req_jokboset() const;
  inline ::s_req_jokboset* mutable_m_req_jokboset();
  inline ::s_req_jokboset* release_m_req_jokboset();
  
  // optional .s_req_ack m_req_ack = 13;
  inline bool has_m_req_ack() const;
  inline void clear_m_req_ack();
  static const int kMReqAckFieldNumber = 13;
  inline const ::s_req_ack& m_req_ack() const;
  inline ::s_req_ack* mutable_m_req_ack();
  inline ::s_req_ack* release_m_req_ack();
  
  // optional .s_req_choiceremovecard m_req_choiceremovecard = 14;
  inline bool has_m_req_choiceremovecard() const;
  inline void clear_m_req_choiceremovecard();
  static const int kMReqChoiceremovecardFieldNumber = 14;
  inline const ::s_req_choiceremovecard& m_req_choiceremovecard() const;
  inline ::s_req_choiceremovecard* mutable_m_req_choiceremovecard();
  inline ::s_req_choiceremovecard* release_m_req_choiceremovecard();
  
  // optional .s_req_purge m_req_purge = 15;
  inline bool has_m_req_purge() const;
  inline void clear_m_req_purge();
  static const int kMReqPurgeFieldNumber = 15;
  inline const ::s_req_purge& m_req_purge() const;
  inline ::s_req_purge* mutable_m_req_purge();
  inline ::s_req_purge* release_m_req_purge();
  
  // optional .s_req_exitque m_req_exitque = 16;
  inline bool has_m_req_exitque() const;
  inline void clear_m_req_exitque();
  static const int kMReqExitqueFieldNumber = 16;
  inline const ::s_req_exitque& m_req_exitque() const;
  inline ::s_req_exitque* mutable_m_req_exitque();
  inline ::s_req_exitque* release_m_req_exitque();
  
  // optional .s_req_soundtype m_req_soundtype = 17;
  inline bool has_m_req_soundtype() const;
  inline void clear_m_req_soundtype();
  static const int kMReqSoundtypeFieldNumber = 17;
  inline const ::s_req_soundtype& m_req_soundtype() const;
  inline ::s_req_soundtype* mutable_m_req_soundtype();
  inline ::s_req_soundtype* release_m_req_soundtype();
  
  // optional .s_req_abuse m_req_abuse = 18;
  inline bool has_m_req_abuse() const;
  inline void clear_m_req_abuse();
  static const int kMReqAbuseFieldNumber = 18;
  inline const ::s_req_abuse& m_req_abuse() const;
  inline ::s_req_abuse* mutable_m_req_abuse();
  inline ::s_req_abuse* release_m_req_abuse();
  
  // optional .s_req_observe m_req_observe = 19;
  inline bool has_m_req_observe() const;
  inline void clear_m_req_observe();
  static const int kMReqObserveFieldNumber = 19;
  inline const ::s_req_observe& m_req_observe() const;
  inline ::s_req_observe* mutable_m_req_observe();
  inline ::s_req_observe* release_m_req_observe();
  
  // @@protoc_insertion_point(class_scope:GLReqGameProtocol)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_m_req_game_test_packet();
  inline void clear_has_m_req_game_test_packet();
  inline void set_has_m_req_send_cmd();
  inline void clear_has_m_req_send_cmd();
  inline void set_has_m_req_join_room();
  inline void clear_has_m_req_join_room();
  inline void set_has_m_req_send_start();
  inline void clear_has_m_req_send_start();
  inline void set_has_m_req_send_select_card();
  inline void clear_has_m_req_send_select_card();
  inline void set_has_m_req_betting();
  inline void clear_has_m_req_betting();
  inline void set_has_m_req_ping();
  inline void clear_has_m_req_ping();
  inline void set_has_m_req_entry();
  inline void clear_has_m_req_entry();
  inline void set_has_m_req_continue();
  inline void clear_has_m_req_continue();
  inline void set_has_m_req_ruleset();
  inline void clear_has_m_req_ruleset();
  inline void set_has_m_req_jokboset();
  inline void clear_has_m_req_jokboset();
  inline void set_has_m_req_ack();
  inline void clear_has_m_req_ack();
  inline void set_has_m_req_choiceremovecard();
  inline void clear_has_m_req_choiceremovecard();
  inline void set_has_m_req_purge();
  inline void clear_has_m_req_purge();
  inline void set_has_m_req_exitque();
  inline void clear_has_m_req_exitque();
  inline void set_has_m_req_soundtype();
  inline void clear_has_m_req_soundtype();
  inline void set_has_m_req_abuse();
  inline void clear_has_m_req_abuse();
  inline void set_has_m_req_observe();
  inline void clear_has_m_req_observe();
  
  ::s_req_game_test_packet* m_req_game_test_packet_;
  ::s_req_send_cmd* m_req_send_cmd_;
  ::s_req_join_room* m_req_join_room_;
  ::s_req_send_start* m_req_send_start_;
  ::s_req_send_select_card* m_req_send_select_card_;
  ::s_req_betting* m_req_betting_;
  ::s_req_ping* m_req_ping_;
  ::s_req_entry* m_req_entry_;
  ::s_req_continue* m_req_continue_;
  ::s_req_ruleset* m_req_ruleset_;
  ::s_req_jokboset* m_req_jokboset_;
  ::s_req_ack* m_req_ack_;
  ::s_req_choiceremovecard* m_req_choiceremovecard_;
  ::s_req_purge* m_req_purge_;
  ::s_req_exitque* m_req_exitque_;
  ::s_req_soundtype* m_req_soundtype_;
  ::s_req_abuse* m_req_abuse_;
  ::s_req_observe* m_req_observe_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(19 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLReqGameProtocol* default_instance_;
};
// -------------------------------------------------------------------

class s_ans_game_test_packet : public ::google::protobuf::MessageLite {
 public:
  s_ans_game_test_packet();
  virtual ~s_ans_game_test_packet();
  
  s_ans_game_test_packet(const s_ans_game_test_packet& from);
  
  inline s_ans_game_test_packet& operator=(const s_ans_game_test_packet& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_ans_game_test_packet& default_instance();
  
  void Swap(s_ans_game_test_packet* other);
  
  // implements Message ----------------------------------------------
  
  s_ans_game_test_packet* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_ans_game_test_packet& from);
  void MergeFrom(const s_ans_game_test_packet& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 test_int = 2;
  inline bool has_test_int() const;
  inline void clear_test_int();
  static const int kTestIntFieldNumber = 2;
  inline ::google::protobuf::int32 test_int() const;
  inline void set_test_int(::google::protobuf::int32 value);
  
  // required string test_string = 3;
  inline bool has_test_string() const;
  inline void clear_test_string();
  static const int kTestStringFieldNumber = 3;
  inline const ::std::string& test_string() const;
  inline void set_test_string(const ::std::string& value);
  inline void set_test_string(const char* value);
  inline void set_test_string(const char* value, size_t size);
  inline ::std::string* mutable_test_string();
  inline ::std::string* release_test_string();
  
  // @@protoc_insertion_point(class_scope:s_ans_game_test_packet)
 private:
  inline void set_has_test_int();
  inline void clear_has_test_int();
  inline void set_has_test_string();
  inline void clear_has_test_string();
  
  ::std::string* test_string_;
  ::google::protobuf::int32 test_int_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_ans_game_test_packet* default_instance_;
};
// -------------------------------------------------------------------

class s_ans_join_room : public ::google::protobuf::MessageLite {
 public:
  s_ans_join_room();
  virtual ~s_ans_join_room();
  
  s_ans_join_room(const s_ans_join_room& from);
  
  inline s_ans_join_room& operator=(const s_ans_join_room& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_ans_join_room& default_instance();
  
  void Swap(s_ans_join_room* other);
  
  // implements Message ----------------------------------------------
  
  s_ans_join_room* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_ans_join_room& from);
  void MergeFrom(const s_ans_join_room& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .GameRoomInfo gameroominfo = 1;
  inline bool has_gameroominfo() const;
  inline void clear_gameroominfo();
  static const int kGameroominfoFieldNumber = 1;
  inline const ::GameRoomInfo& gameroominfo() const;
  inline ::GameRoomInfo* mutable_gameroominfo();
  inline ::GameRoomInfo* release_gameroominfo();
  
  // @@protoc_insertion_point(class_scope:s_ans_join_room)
 private:
  inline void set_has_gameroominfo();
  inline void clear_has_gameroominfo();
  
  ::GameRoomInfo* gameroominfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_ans_join_room* default_instance_;
};
// -------------------------------------------------------------------

class s_ans_deal_card : public ::google::protobuf::MessageLite {
 public:
  s_ans_deal_card();
  virtual ~s_ans_deal_card();
  
  s_ans_deal_card(const s_ans_deal_card& from);
  
  inline s_ans_deal_card& operator=(const s_ans_deal_card& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_ans_deal_card& default_instance();
  
  void Swap(s_ans_deal_card* other);
  
  // implements Message ----------------------------------------------
  
  s_ans_deal_card* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_ans_deal_card& from);
  void MergeFrom(const s_ans_deal_card& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lBossUSN = 1;
  inline bool has_m_lbossusn() const;
  inline void clear_m_lbossusn();
  static const int kMLBossUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lbossusn() const;
  inline void set_m_lbossusn(::google::protobuf::int32 value);
  
  // required int32 m_nType = 2;
  inline bool has_m_ntype() const;
  inline void clear_m_ntype();
  static const int kMNTypeFieldNumber = 2;
  inline ::google::protobuf::int32 m_ntype() const;
  inline void set_m_ntype(::google::protobuf::int32 value);
  
  // required sint32 m_lCardsDealt = 3;
  inline bool has_m_lcardsdealt() const;
  inline void clear_m_lcardsdealt();
  static const int kMLCardsDealtFieldNumber = 3;
  inline ::google::protobuf::int32 m_lcardsdealt() const;
  inline void set_m_lcardsdealt(::google::protobuf::int32 value);
  
  // repeated .PKOneCard m_vtOneCard = 4;
  inline int m_vtonecard_size() const;
  inline void clear_m_vtonecard();
  static const int kMVtOneCardFieldNumber = 4;
  inline const ::PKOneCard& m_vtonecard(int index) const;
  inline ::PKOneCard* mutable_m_vtonecard(int index);
  inline ::PKOneCard* add_m_vtonecard();
  inline const ::google::protobuf::RepeatedPtrField< ::PKOneCard >&
      m_vtonecard() const;
  inline ::google::protobuf::RepeatedPtrField< ::PKOneCard >*
      mutable_m_vtonecard();
  
  // @@protoc_insertion_point(class_scope:s_ans_deal_card)
 private:
  inline void set_has_m_lbossusn();
  inline void clear_has_m_lbossusn();
  inline void set_has_m_ntype();
  inline void clear_has_m_ntype();
  inline void set_has_m_lcardsdealt();
  inline void clear_has_m_lcardsdealt();
  
  ::google::protobuf::int32 m_lbossusn_;
  ::google::protobuf::int32 m_ntype_;
  ::google::protobuf::RepeatedPtrField< ::PKOneCard > m_vtonecard_;
  ::google::protobuf::int32 m_lcardsdealt_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_ans_deal_card* default_instance_;
};
// -------------------------------------------------------------------

class s_ans_deal_cards : public ::google::protobuf::MessageLite {
 public:
  s_ans_deal_cards();
  virtual ~s_ans_deal_cards();
  
  s_ans_deal_cards(const s_ans_deal_cards& from);
  
  inline s_ans_deal_cards& operator=(const s_ans_deal_cards& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_ans_deal_cards& default_instance();
  
  void Swap(s_ans_deal_cards* other);
  
  // implements Message ----------------------------------------------
  
  s_ans_deal_cards* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_ans_deal_cards& from);
  void MergeFrom(const s_ans_deal_cards& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lBossUSN = 1;
  inline bool has_m_lbossusn() const;
  inline void clear_m_lbossusn();
  static const int kMLBossUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lbossusn() const;
  inline void set_m_lbossusn(::google::protobuf::int32 value);
  
  // required sint32 m_lState = 2;
  inline bool has_m_lstate() const;
  inline void clear_m_lstate();
  static const int kMLStateFieldNumber = 2;
  inline ::google::protobuf::int32 m_lstate() const;
  inline void set_m_lstate(::google::protobuf::int32 value);
  
  // required int32 m_nType = 3;
  inline bool has_m_ntype() const;
  inline void clear_m_ntype();
  static const int kMNTypeFieldNumber = 3;
  inline ::google::protobuf::int32 m_ntype() const;
  inline void set_m_ntype(::google::protobuf::int32 value);
  
  // repeated .PKCards m_tblCard = 4;
  inline int m_tblcard_size() const;
  inline void clear_m_tblcard();
  static const int kMTblCardFieldNumber = 4;
  inline const ::PKCards& m_tblcard(int index) const;
  inline ::PKCards* mutable_m_tblcard(int index);
  inline ::PKCards* add_m_tblcard();
  inline const ::google::protobuf::RepeatedPtrField< ::PKCards >&
      m_tblcard() const;
  inline ::google::protobuf::RepeatedPtrField< ::PKCards >*
      mutable_m_tblcard();
  
  // repeated .PKMoney m_tblMoney = 5;
  inline int m_tblmoney_size() const;
  inline void clear_m_tblmoney();
  static const int kMTblMoneyFieldNumber = 5;
  inline const ::PKMoney& m_tblmoney(int index) const;
  inline ::PKMoney* mutable_m_tblmoney(int index);
  inline ::PKMoney* add_m_tblmoney();
  inline const ::google::protobuf::RepeatedPtrField< ::PKMoney >&
      m_tblmoney() const;
  inline ::google::protobuf::RepeatedPtrField< ::PKMoney >*
      mutable_m_tblmoney();
  
  // required sint64 m_llPoolMoney = 6;
  inline bool has_m_llpoolmoney() const;
  inline void clear_m_llpoolmoney();
  static const int kMLlPoolMoneyFieldNumber = 6;
  inline ::google::protobuf::int64 m_llpoolmoney() const;
  inline void set_m_llpoolmoney(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:s_ans_deal_cards)
 private:
  inline void set_has_m_lbossusn();
  inline void clear_has_m_lbossusn();
  inline void set_has_m_lstate();
  inline void clear_has_m_lstate();
  inline void set_has_m_ntype();
  inline void clear_has_m_ntype();
  inline void set_has_m_llpoolmoney();
  inline void clear_has_m_llpoolmoney();
  
  ::google::protobuf::int32 m_lbossusn_;
  ::google::protobuf::int32 m_lstate_;
  ::google::protobuf::RepeatedPtrField< ::PKCards > m_tblcard_;
  ::google::protobuf::RepeatedPtrField< ::PKMoney > m_tblmoney_;
  ::google::protobuf::int64 m_llpoolmoney_;
  ::google::protobuf::int32 m_ntype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_ans_deal_cards* default_instance_;
};
// -------------------------------------------------------------------

class s_ans_send_ante : public ::google::protobuf::MessageLite {
 public:
  s_ans_send_ante();
  virtual ~s_ans_send_ante();
  
  s_ans_send_ante(const s_ans_send_ante& from);
  
  inline s_ans_send_ante& operator=(const s_ans_send_ante& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_ans_send_ante& default_instance();
  
  void Swap(s_ans_send_ante* other);
  
  // implements Message ----------------------------------------------
  
  s_ans_send_ante* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_ans_send_ante& from);
  void MergeFrom(const s_ans_send_ante& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint64 m_llAnteMoney = 1;
  inline bool has_m_llantemoney() const;
  inline void clear_m_llantemoney();
  static const int kMLlAnteMoneyFieldNumber = 1;
  inline ::google::protobuf::int64 m_llantemoney() const;
  inline void set_m_llantemoney(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:s_ans_send_ante)
 private:
  inline void set_has_m_llantemoney();
  inline void clear_has_m_llantemoney();
  
  ::google::protobuf::int64 m_llantemoney_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_ans_send_ante* default_instance_;
};
// -------------------------------------------------------------------

class s_ans_select_card : public ::google::protobuf::MessageLite {
 public:
  s_ans_select_card();
  virtual ~s_ans_select_card();
  
  s_ans_select_card(const s_ans_select_card& from);
  
  inline s_ans_select_card& operator=(const s_ans_select_card& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_ans_select_card& default_instance();
  
  void Swap(s_ans_select_card* other);
  
  // implements Message ----------------------------------------------
  
  s_ans_select_card* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_ans_select_card& from);
  void MergeFrom(const s_ans_select_card& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lUSN = 1;
  inline bool has_m_lusn() const;
  inline void clear_m_lusn();
  static const int kMLUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lusn() const;
  inline void set_m_lusn(::google::protobuf::int32 value);
  
  // required int32 m_nSelect = 2;
  inline bool has_m_nselect() const;
  inline void clear_m_nselect();
  static const int kMNSelectFieldNumber = 2;
  inline ::google::protobuf::int32 m_nselect() const;
  inline void set_m_nselect(::google::protobuf::int32 value);
  
  // required sint32 m_lCardIndex = 3;
  inline bool has_m_lcardindex() const;
  inline void clear_m_lcardindex();
  static const int kMLCardIndexFieldNumber = 3;
  inline ::google::protobuf::int32 m_lcardindex() const;
  inline void set_m_lcardindex(::google::protobuf::int32 value);
  
  // required sint32 m_lChoiceType = 4;
  inline bool has_m_lchoicetype() const;
  inline void clear_m_lchoicetype();
  static const int kMLChoiceTypeFieldNumber = 4;
  inline ::google::protobuf::int32 m_lchoicetype() const;
  inline void set_m_lchoicetype(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:s_ans_select_card)
 private:
  inline void set_has_m_lusn();
  inline void clear_has_m_lusn();
  inline void set_has_m_nselect();
  inline void clear_has_m_nselect();
  inline void set_has_m_lcardindex();
  inline void clear_has_m_lcardindex();
  inline void set_has_m_lchoicetype();
  inline void clear_has_m_lchoicetype();
  
  ::google::protobuf::int32 m_lusn_;
  ::google::protobuf::int32 m_nselect_;
  ::google::protobuf::int32 m_lcardindex_;
  ::google::protobuf::int32 m_lchoicetype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_ans_select_card* default_instance_;
};
// -------------------------------------------------------------------

class s_ans_opencard : public ::google::protobuf::MessageLite {
 public:
  s_ans_opencard();
  virtual ~s_ans_opencard();
  
  s_ans_opencard(const s_ans_opencard& from);
  
  inline s_ans_opencard& operator=(const s_ans_opencard& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_ans_opencard& default_instance();
  
  void Swap(s_ans_opencard* other);
  
  // implements Message ----------------------------------------------
  
  s_ans_opencard* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_ans_opencard& from);
  void MergeFrom(const s_ans_opencard& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lState = 1;
  inline bool has_m_lstate() const;
  inline void clear_m_lstate();
  static const int kMLStateFieldNumber = 1;
  inline ::google::protobuf::int32 m_lstate() const;
  inline void set_m_lstate(::google::protobuf::int32 value);
  
  // repeated .PKCards m_tblCard = 2;
  inline int m_tblcard_size() const;
  inline void clear_m_tblcard();
  static const int kMTblCardFieldNumber = 2;
  inline const ::PKCards& m_tblcard(int index) const;
  inline ::PKCards* mutable_m_tblcard(int index);
  inline ::PKCards* add_m_tblcard();
  inline const ::google::protobuf::RepeatedPtrField< ::PKCards >&
      m_tblcard() const;
  inline ::google::protobuf::RepeatedPtrField< ::PKCards >*
      mutable_m_tblcard();
  
  // repeated sint32 m_vtState = 3;
  inline int m_vtstate_size() const;
  inline void clear_m_vtstate();
  static const int kMVtStateFieldNumber = 3;
  inline ::google::protobuf::int32 m_vtstate(int index) const;
  inline void set_m_vtstate(int index, ::google::protobuf::int32 value);
  inline void add_m_vtstate(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      m_vtstate() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_m_vtstate();
  
  // @@protoc_insertion_point(class_scope:s_ans_opencard)
 private:
  inline void set_has_m_lstate();
  inline void clear_has_m_lstate();
  
  ::google::protobuf::RepeatedPtrField< ::PKCards > m_tblcard_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > m_vtstate_;
  ::google::protobuf::int32 m_lstate_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_ans_opencard* default_instance_;
};
// -------------------------------------------------------------------

class s_ans_boss : public ::google::protobuf::MessageLite {
 public:
  s_ans_boss();
  virtual ~s_ans_boss();
  
  s_ans_boss(const s_ans_boss& from);
  
  inline s_ans_boss& operator=(const s_ans_boss& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_ans_boss& default_instance();
  
  void Swap(s_ans_boss* other);
  
  // implements Message ----------------------------------------------
  
  s_ans_boss* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_ans_boss& from);
  void MergeFrom(const s_ans_boss& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lBossUSN = 1;
  inline bool has_m_lbossusn() const;
  inline void clear_m_lbossusn();
  static const int kMLBossUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lbossusn() const;
  inline void set_m_lbossusn(::google::protobuf::int32 value);
  
  // required int32 m_nBossRank = 2;
  inline bool has_m_nbossrank() const;
  inline void clear_m_nbossrank();
  static const int kMNBossRankFieldNumber = 2;
  inline ::google::protobuf::int32 m_nbossrank() const;
  inline void set_m_nbossrank(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:s_ans_boss)
 private:
  inline void set_has_m_lbossusn();
  inline void clear_has_m_lbossusn();
  inline void set_has_m_nbossrank();
  inline void clear_has_m_nbossrank();
  
  ::google::protobuf::int32 m_lbossusn_;
  ::google::protobuf::int32 m_nbossrank_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_ans_boss* default_instance_;
};
// -------------------------------------------------------------------

class s_ans_deal_hiddencard : public ::google::protobuf::MessageLite {
 public:
  s_ans_deal_hiddencard();
  virtual ~s_ans_deal_hiddencard();
  
  s_ans_deal_hiddencard(const s_ans_deal_hiddencard& from);
  
  inline s_ans_deal_hiddencard& operator=(const s_ans_deal_hiddencard& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_ans_deal_hiddencard& default_instance();
  
  void Swap(s_ans_deal_hiddencard* other);
  
  // implements Message ----------------------------------------------
  
  s_ans_deal_hiddencard* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_ans_deal_hiddencard& from);
  void MergeFrom(const s_ans_deal_hiddencard& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lBossUSN = 1;
  inline bool has_m_lbossusn() const;
  inline void clear_m_lbossusn();
  static const int kMLBossUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lbossusn() const;
  inline void set_m_lbossusn(::google::protobuf::int32 value);
  
  // required sint32 m_lCardsDealt = 2;
  inline bool has_m_lcardsdealt() const;
  inline void clear_m_lcardsdealt();
  static const int kMLCardsDealtFieldNumber = 2;
  inline ::google::protobuf::int32 m_lcardsdealt() const;
  inline void set_m_lcardsdealt(::google::protobuf::int32 value);
  
  // repeated .PKOneCard m_vtOneCard = 3;
  inline int m_vtonecard_size() const;
  inline void clear_m_vtonecard();
  static const int kMVtOneCardFieldNumber = 3;
  inline const ::PKOneCard& m_vtonecard(int index) const;
  inline ::PKOneCard* mutable_m_vtonecard(int index);
  inline ::PKOneCard* add_m_vtonecard();
  inline const ::google::protobuf::RepeatedPtrField< ::PKOneCard >&
      m_vtonecard() const;
  inline ::google::protobuf::RepeatedPtrField< ::PKOneCard >*
      mutable_m_vtonecard();
  
  // @@protoc_insertion_point(class_scope:s_ans_deal_hiddencard)
 private:
  inline void set_has_m_lbossusn();
  inline void clear_has_m_lbossusn();
  inline void set_has_m_lcardsdealt();
  inline void clear_has_m_lcardsdealt();
  
  ::google::protobuf::int32 m_lbossusn_;
  ::google::protobuf::int32 m_lcardsdealt_;
  ::google::protobuf::RepeatedPtrField< ::PKOneCard > m_vtonecard_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_ans_deal_hiddencard* default_instance_;
};
// -------------------------------------------------------------------

class s_ans_betting : public ::google::protobuf::MessageLite {
 public:
  s_ans_betting();
  virtual ~s_ans_betting();
  
  s_ans_betting(const s_ans_betting& from);
  
  inline s_ans_betting& operator=(const s_ans_betting& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_ans_betting& default_instance();
  
  void Swap(s_ans_betting* other);
  
  // implements Message ----------------------------------------------
  
  s_ans_betting* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_ans_betting& from);
  void MergeFrom(const s_ans_betting& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 m_lUSN = 1;
  inline bool has_m_lusn() const;
  inline void clear_m_lusn();
  static const int kMLUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lusn() const;
  inline void set_m_lusn(::google::protobuf::int32 value);
  
  // required int32 m_BetType = 2;
  inline bool has_m_bettype() const;
  inline void clear_m_bettype();
  static const int kMBetTypeFieldNumber = 2;
  inline ::google::protobuf::int32 m_bettype() const;
  inline void set_m_bettype(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:s_ans_betting)
 private:
  inline void set_has_m_lusn();
  inline void clear_has_m_lusn();
  inline void set_has_m_bettype();
  inline void clear_has_m_bettype();
  
  ::google::protobuf::int32 m_lusn_;
  ::google::protobuf::int32 m_bettype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_ans_betting* default_instance_;
};
// -------------------------------------------------------------------

class s_ans_pong : public ::google::protobuf::MessageLite {
 public:
  s_ans_pong();
  virtual ~s_ans_pong();
  
  s_ans_pong(const s_ans_pong& from);
  
  inline s_ans_pong& operator=(const s_ans_pong& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_ans_pong& default_instance();
  
  void Swap(s_ans_pong* other);
  
  // implements Message ----------------------------------------------
  
  s_ans_pong* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_ans_pong& from);
  void MergeFrom(const s_ans_pong& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::int32 error_code() const;
  inline void set_error_code(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:s_ans_pong)
 private:
  inline void set_has_error_code();
  inline void clear_has_error_code();
  
  ::google::protobuf::int32 error_code_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_ans_pong* default_instance_;
};
// -------------------------------------------------------------------

class s_ans_entry : public ::google::protobuf::MessageLite {
 public:
  s_ans_entry();
  virtual ~s_ans_entry();
  
  s_ans_entry(const s_ans_entry& from);
  
  inline s_ans_entry& operator=(const s_ans_entry& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_ans_entry& default_instance();
  
  void Swap(s_ans_entry* other);
  
  // implements Message ----------------------------------------------
  
  s_ans_entry* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_ans_entry& from);
  void MergeFrom(const s_ans_entry& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lUSN = 1;
  inline bool has_m_lusn() const;
  inline void clear_m_lusn();
  static const int kMLUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lusn() const;
  inline void set_m_lusn(::google::protobuf::int32 value);
  
  // required int32 m_nIndex = 2;
  inline bool has_m_nindex() const;
  inline void clear_m_nindex();
  static const int kMNIndexFieldNumber = 2;
  inline ::google::protobuf::int32 m_nindex() const;
  inline void set_m_nindex(::google::protobuf::int32 value);
  
  // required sint32 m_lOwnerUSN = 3;
  inline bool has_m_lownerusn() const;
  inline void clear_m_lownerusn();
  static const int kMLOwnerUSNFieldNumber = 3;
  inline ::google::protobuf::int32 m_lownerusn() const;
  inline void set_m_lownerusn(::google::protobuf::int32 value);
  
  // repeated .PKUserInfo m_tblUI = 4;
  inline int m_tblui_size() const;
  inline void clear_m_tblui();
  static const int kMTblUIFieldNumber = 4;
  inline const ::PKUserInfo& m_tblui(int index) const;
  inline ::PKUserInfo* mutable_m_tblui(int index);
  inline ::PKUserInfo* add_m_tblui();
  inline const ::google::protobuf::RepeatedPtrField< ::PKUserInfo >&
      m_tblui() const;
  inline ::google::protobuf::RepeatedPtrField< ::PKUserInfo >*
      mutable_m_tblui();
  
  // repeated .PKMoney m_tblMoney = 5;
  inline int m_tblmoney_size() const;
  inline void clear_m_tblmoney();
  static const int kMTblMoneyFieldNumber = 5;
  inline const ::PKMoney& m_tblmoney(int index) const;
  inline ::PKMoney* mutable_m_tblmoney(int index);
  inline ::PKMoney* add_m_tblmoney();
  inline const ::google::protobuf::RepeatedPtrField< ::PKMoney >&
      m_tblmoney() const;
  inline ::google::protobuf::RepeatedPtrField< ::PKMoney >*
      mutable_m_tblmoney();
  
  // required sint32 m_bWelcomeSound = 6;
  inline bool has_m_bwelcomesound() const;
  inline void clear_m_bwelcomesound();
  static const int kMBWelcomeSoundFieldNumber = 6;
  inline ::google::protobuf::int32 m_bwelcomesound() const;
  inline void set_m_bwelcomesound(::google::protobuf::int32 value);
  
  // required sint32 m_lObserveCnt = 7;
  inline bool has_m_lobservecnt() const;
  inline void clear_m_lobservecnt();
  static const int kMLObserveCntFieldNumber = 7;
  inline ::google::protobuf::int32 m_lobservecnt() const;
  inline void set_m_lobservecnt(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:s_ans_entry)
 private:
  inline void set_has_m_lusn();
  inline void clear_has_m_lusn();
  inline void set_has_m_nindex();
  inline void clear_has_m_nindex();
  inline void set_has_m_lownerusn();
  inline void clear_has_m_lownerusn();
  inline void set_has_m_bwelcomesound();
  inline void clear_has_m_bwelcomesound();
  inline void set_has_m_lobservecnt();
  inline void clear_has_m_lobservecnt();
  
  ::google::protobuf::int32 m_lusn_;
  ::google::protobuf::int32 m_nindex_;
  ::google::protobuf::RepeatedPtrField< ::PKUserInfo > m_tblui_;
  ::google::protobuf::int32 m_lownerusn_;
  ::google::protobuf::int32 m_bwelcomesound_;
  ::google::protobuf::RepeatedPtrField< ::PKMoney > m_tblmoney_;
  ::google::protobuf::int32 m_lobservecnt_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_ans_entry* default_instance_;
};
// -------------------------------------------------------------------

class s_betting_msg : public ::google::protobuf::MessageLite {
 public:
  s_betting_msg();
  virtual ~s_betting_msg();
  
  s_betting_msg(const s_betting_msg& from);
  
  inline s_betting_msg& operator=(const s_betting_msg& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_betting_msg& default_instance();
  
  void Swap(s_betting_msg* other);
  
  // implements Message ----------------------------------------------
  
  s_betting_msg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_betting_msg& from);
  void MergeFrom(const s_betting_msg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 m_lUSN = 1;
  inline bool has_m_lusn() const;
  inline void clear_m_lusn();
  static const int kMLUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lusn() const;
  inline void set_m_lusn(::google::protobuf::int32 value);
  
  // required int32 m_nIndex = 2;
  inline bool has_m_nindex() const;
  inline void clear_m_nindex();
  static const int kMNIndexFieldNumber = 2;
  inline ::google::protobuf::int32 m_nindex() const;
  inline void set_m_nindex(::google::protobuf::int32 value);
  
  // required int32 m_BetType = 3;
  inline bool has_m_bettype() const;
  inline void clear_m_bettype();
  static const int kMBetTypeFieldNumber = 3;
  inline ::google::protobuf::int32 m_bettype() const;
  inline void set_m_bettype(::google::protobuf::int32 value);
  
  // required int32 m_bBettingMoney = 4;
  inline bool has_m_bbettingmoney() const;
  inline void clear_m_bbettingmoney();
  static const int kMBBettingMoneyFieldNumber = 4;
  inline ::google::protobuf::int32 m_bbettingmoney() const;
  inline void set_m_bbettingmoney(::google::protobuf::int32 value);
  
  // required int32 m_bMoneyLack = 5;
  inline bool has_m_bmoneylack() const;
  inline void clear_m_bmoneylack();
  static const int kMBMoneyLackFieldNumber = 5;
  inline ::google::protobuf::int32 m_bmoneylack() const;
  inline void set_m_bmoneylack(::google::protobuf::int32 value);
  
  // required int32 m_bCallMoneyZero = 6;
  inline bool has_m_bcallmoneyzero() const;
  inline void clear_m_bcallmoneyzero();
  static const int kMBCallMoneyZeroFieldNumber = 6;
  inline ::google::protobuf::int32 m_bcallmoneyzero() const;
  inline void set_m_bcallmoneyzero(::google::protobuf::int32 value);
  
  // required int64 m_llCallMoney = 7;
  inline bool has_m_llcallmoney() const;
  inline void clear_m_llcallmoney();
  static const int kMLlCallMoneyFieldNumber = 7;
  inline ::google::protobuf::int64 m_llcallmoney() const;
  inline void set_m_llcallmoney(::google::protobuf::int64 value);
  
  // required int64 m_llRaiseMoney = 8;
  inline bool has_m_llraisemoney() const;
  inline void clear_m_llraisemoney();
  static const int kMLlRaiseMoneyFieldNumber = 8;
  inline ::google::protobuf::int64 m_llraisemoney() const;
  inline void set_m_llraisemoney(::google::protobuf::int64 value);
  
  // required int64 m_llSideMoney = 9;
  inline bool has_m_llsidemoney() const;
  inline void clear_m_llsidemoney();
  static const int kMLlSideMoneyFieldNumber = 9;
  inline ::google::protobuf::int64 m_llsidemoney() const;
  inline void set_m_llsidemoney(::google::protobuf::int64 value);
  
  // required int32 m_lBetTurn = 10;
  inline bool has_m_lbetturn() const;
  inline void clear_m_lbetturn();
  static const int kMLBetTurnFieldNumber = 10;
  inline ::google::protobuf::int32 m_lbetturn() const;
  inline void set_m_lbetturn(::google::protobuf::int32 value);
  
  // required .PKMoney m_money = 11;
  inline bool has_m_money() const;
  inline void clear_m_money();
  static const int kMMoneyFieldNumber = 11;
  inline const ::PKMoney& m_money() const;
  inline ::PKMoney* mutable_m_money();
  inline ::PKMoney* release_m_money();
  
  // repeated int64 m_vtCallMoney = 12;
  inline int m_vtcallmoney_size() const;
  inline void clear_m_vtcallmoney();
  static const int kMVtCallMoneyFieldNumber = 12;
  inline ::google::protobuf::int64 m_vtcallmoney(int index) const;
  inline void set_m_vtcallmoney(int index, ::google::protobuf::int64 value);
  inline void add_m_vtcallmoney(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      m_vtcallmoney() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_m_vtcallmoney();
  
  // required int64 m_llPoolMoney = 13;
  inline bool has_m_llpoolmoney() const;
  inline void clear_m_llpoolmoney();
  static const int kMLlPoolMoneyFieldNumber = 13;
  inline ::google::protobuf::int64 m_llpoolmoney() const;
  inline void set_m_llpoolmoney(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:s_betting_msg)
 private:
  inline void set_has_m_lusn();
  inline void clear_has_m_lusn();
  inline void set_has_m_nindex();
  inline void clear_has_m_nindex();
  inline void set_has_m_bettype();
  inline void clear_has_m_bettype();
  inline void set_has_m_bbettingmoney();
  inline void clear_has_m_bbettingmoney();
  inline void set_has_m_bmoneylack();
  inline void clear_has_m_bmoneylack();
  inline void set_has_m_bcallmoneyzero();
  inline void clear_has_m_bcallmoneyzero();
  inline void set_has_m_llcallmoney();
  inline void clear_has_m_llcallmoney();
  inline void set_has_m_llraisemoney();
  inline void clear_has_m_llraisemoney();
  inline void set_has_m_llsidemoney();
  inline void clear_has_m_llsidemoney();
  inline void set_has_m_lbetturn();
  inline void clear_has_m_lbetturn();
  inline void set_has_m_money();
  inline void clear_has_m_money();
  inline void set_has_m_llpoolmoney();
  inline void clear_has_m_llpoolmoney();
  
  ::google::protobuf::int32 m_lusn_;
  ::google::protobuf::int32 m_nindex_;
  ::google::protobuf::int32 m_bettype_;
  ::google::protobuf::int32 m_bbettingmoney_;
  ::google::protobuf::int32 m_bmoneylack_;
  ::google::protobuf::int32 m_bcallmoneyzero_;
  ::google::protobuf::int64 m_llcallmoney_;
  ::google::protobuf::int64 m_llraisemoney_;
  ::google::protobuf::int64 m_llsidemoney_;
  ::PKMoney* m_money_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > m_vtcallmoney_;
  ::google::protobuf::int64 m_llpoolmoney_;
  ::google::protobuf::int32 m_lbetturn_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_betting_msg* default_instance_;
};
// -------------------------------------------------------------------

class s_finished : public ::google::protobuf::MessageLite {
 public:
  s_finished();
  virtual ~s_finished();
  
  s_finished(const s_finished& from);
  
  inline s_finished& operator=(const s_finished& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_finished& default_instance();
  
  void Swap(s_finished* other);
  
  // implements Message ----------------------------------------------
  
  s_finished* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_finished& from);
  void MergeFrom(const s_finished& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lState = 1;
  inline bool has_m_lstate() const;
  inline void clear_m_lstate();
  static const int kMLStateFieldNumber = 1;
  inline ::google::protobuf::int32 m_lstate() const;
  inline void set_m_lstate(::google::protobuf::int32 value);
  
  // required sint32 m_bGiveUp = 2;
  inline bool has_m_bgiveup() const;
  inline void clear_m_bgiveup();
  static const int kMBGiveUpFieldNumber = 2;
  inline ::google::protobuf::int32 m_bgiveup() const;
  inline void set_m_bgiveup(::google::protobuf::int32 value);
  
  // required sint32 m_lRank = 3;
  inline bool has_m_lrank() const;
  inline void clear_m_lrank();
  static const int kMLRankFieldNumber = 3;
  inline ::google::protobuf::int32 m_lrank() const;
  inline void set_m_lrank(::google::protobuf::int32 value);
  
  // required sint32 m_lBossUSN = 4;
  inline bool has_m_lbossusn() const;
  inline void clear_m_lbossusn();
  static const int kMLBossUSNFieldNumber = 4;
  inline ::google::protobuf::int32 m_lbossusn() const;
  inline void set_m_lbossusn(::google::protobuf::int32 value);
  
  // required sint64 m_llGiveMoney = 5;
  inline bool has_m_llgivemoney() const;
  inline void clear_m_llgivemoney();
  static const int kMLlGiveMoneyFieldNumber = 5;
  inline ::google::protobuf::int64 m_llgivemoney() const;
  inline void set_m_llgivemoney(::google::protobuf::int64 value);
  
  // repeated int32 m_vtWin = 6;
  inline int m_vtwin_size() const;
  inline void clear_m_vtwin();
  static const int kMVtWinFieldNumber = 6;
  inline ::google::protobuf::int32 m_vtwin(int index) const;
  inline void set_m_vtwin(int index, ::google::protobuf::int32 value);
  inline void add_m_vtwin(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      m_vtwin() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_m_vtwin();
  
  // repeated int32 m_vtResult = 7;
  inline int m_vtresult_size() const;
  inline void clear_m_vtresult();
  static const int kMVtResultFieldNumber = 7;
  inline ::google::protobuf::int32 m_vtresult(int index) const;
  inline void set_m_vtresult(int index, ::google::protobuf::int32 value);
  inline void add_m_vtresult(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      m_vtresult() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_m_vtresult();
  
  // repeated sint64 m_vtGiveMoney = 8;
  inline int m_vtgivemoney_size() const;
  inline void clear_m_vtgivemoney();
  static const int kMVtGiveMoneyFieldNumber = 8;
  inline ::google::protobuf::int64 m_vtgivemoney(int index) const;
  inline void set_m_vtgivemoney(int index, ::google::protobuf::int64 value);
  inline void add_m_vtgivemoney(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      m_vtgivemoney() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_m_vtgivemoney();
  
  // repeated .PKCards m_tblCard = 9;
  inline int m_tblcard_size() const;
  inline void clear_m_tblcard();
  static const int kMTblCardFieldNumber = 9;
  inline const ::PKCards& m_tblcard(int index) const;
  inline ::PKCards* mutable_m_tblcard(int index);
  inline ::PKCards* add_m_tblcard();
  inline const ::google::protobuf::RepeatedPtrField< ::PKCards >&
      m_tblcard() const;
  inline ::google::protobuf::RepeatedPtrField< ::PKCards >*
      mutable_m_tblcard();
  
  // repeated .PKMoney m_tblMoney = 10;
  inline int m_tblmoney_size() const;
  inline void clear_m_tblmoney();
  static const int kMTblMoneyFieldNumber = 10;
  inline const ::PKMoney& m_tblmoney(int index) const;
  inline ::PKMoney* mutable_m_tblmoney(int index);
  inline ::PKMoney* add_m_tblmoney();
  inline const ::google::protobuf::RepeatedPtrField< ::PKMoney >&
      m_tblmoney() const;
  inline ::google::protobuf::RepeatedPtrField< ::PKMoney >*
      mutable_m_tblmoney();
  
  // required sint64 m_llPoolMoney = 11;
  inline bool has_m_llpoolmoney() const;
  inline void clear_m_llpoolmoney();
  static const int kMLlPoolMoneyFieldNumber = 11;
  inline ::google::protobuf::int64 m_llpoolmoney() const;
  inline void set_m_llpoolmoney(::google::protobuf::int64 value);
  
  // repeated .UserMoney m_vtUserMoney = 12;
  inline int m_vtusermoney_size() const;
  inline void clear_m_vtusermoney();
  static const int kMVtUserMoneyFieldNumber = 12;
  inline const ::UserMoney& m_vtusermoney(int index) const;
  inline ::UserMoney* mutable_m_vtusermoney(int index);
  inline ::UserMoney* add_m_vtusermoney();
  inline const ::google::protobuf::RepeatedPtrField< ::UserMoney >&
      m_vtusermoney() const;
  inline ::google::protobuf::RepeatedPtrField< ::UserMoney >*
      mutable_m_vtusermoney();
  
  // required sint32 m_lResultIdx = 13;
  inline bool has_m_lresultidx() const;
  inline void clear_m_lresultidx();
  static const int kMLResultIdxFieldNumber = 13;
  inline ::google::protobuf::int32 m_lresultidx() const;
  inline void set_m_lresultidx(::google::protobuf::int32 value);
  
  // required sint64 m_llJackpot = 14;
  inline bool has_m_lljackpot() const;
  inline void clear_m_lljackpot();
  static const int kMLlJackpotFieldNumber = 14;
  inline ::google::protobuf::int64 m_lljackpot() const;
  inline void set_m_lljackpot(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:s_finished)
 private:
  inline void set_has_m_lstate();
  inline void clear_has_m_lstate();
  inline void set_has_m_bgiveup();
  inline void clear_has_m_bgiveup();
  inline void set_has_m_lrank();
  inline void clear_has_m_lrank();
  inline void set_has_m_lbossusn();
  inline void clear_has_m_lbossusn();
  inline void set_has_m_llgivemoney();
  inline void clear_has_m_llgivemoney();
  inline void set_has_m_llpoolmoney();
  inline void clear_has_m_llpoolmoney();
  inline void set_has_m_lresultidx();
  inline void clear_has_m_lresultidx();
  inline void set_has_m_lljackpot();
  inline void clear_has_m_lljackpot();
  
  ::google::protobuf::int32 m_lstate_;
  ::google::protobuf::int32 m_bgiveup_;
  ::google::protobuf::int32 m_lrank_;
  ::google::protobuf::int32 m_lbossusn_;
  ::google::protobuf::int64 m_llgivemoney_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > m_vtwin_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > m_vtresult_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > m_vtgivemoney_;
  ::google::protobuf::RepeatedPtrField< ::PKCards > m_tblcard_;
  ::google::protobuf::RepeatedPtrField< ::PKMoney > m_tblmoney_;
  ::google::protobuf::int64 m_llpoolmoney_;
  ::google::protobuf::RepeatedPtrField< ::UserMoney > m_vtusermoney_;
  ::google::protobuf::int64 m_lljackpot_;
  ::google::protobuf::int32 m_lresultidx_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_finished* default_instance_;
};
// -------------------------------------------------------------------

class s_jackpotmoneyntf : public ::google::protobuf::MessageLite {
 public:
  s_jackpotmoneyntf();
  virtual ~s_jackpotmoneyntf();
  
  s_jackpotmoneyntf(const s_jackpotmoneyntf& from);
  
  inline s_jackpotmoneyntf& operator=(const s_jackpotmoneyntf& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_jackpotmoneyntf& default_instance();
  
  void Swap(s_jackpotmoneyntf* other);
  
  // implements Message ----------------------------------------------
  
  s_jackpotmoneyntf* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_jackpotmoneyntf& from);
  void MergeFrom(const s_jackpotmoneyntf& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lUSN = 1;
  inline bool has_m_lusn() const;
  inline void clear_m_lusn();
  static const int kMLUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lusn() const;
  inline void set_m_lusn(::google::protobuf::int32 value);
  
  // required sint64 m_llJackpotMoney = 2;
  inline bool has_m_lljackpotmoney() const;
  inline void clear_m_lljackpotmoney();
  static const int kMLlJackpotMoneyFieldNumber = 2;
  inline ::google::protobuf::int64 m_lljackpotmoney() const;
  inline void set_m_lljackpotmoney(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:s_jackpotmoneyntf)
 private:
  inline void set_has_m_lusn();
  inline void clear_has_m_lusn();
  inline void set_has_m_lljackpotmoney();
  inline void clear_has_m_lljackpotmoney();
  
  ::google::protobuf::int64 m_lljackpotmoney_;
  ::google::protobuf::int32 m_lusn_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_jackpotmoneyntf* default_instance_;
};
// -------------------------------------------------------------------

class s_ans_continue : public ::google::protobuf::MessageLite {
 public:
  s_ans_continue();
  virtual ~s_ans_continue();
  
  s_ans_continue(const s_ans_continue& from);
  
  inline s_ans_continue& operator=(const s_ans_continue& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_ans_continue& default_instance();
  
  void Swap(s_ans_continue* other);
  
  // implements Message ----------------------------------------------
  
  s_ans_continue* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_ans_continue& from);
  void MergeFrom(const s_ans_continue& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lUSN = 1;
  inline bool has_m_lusn() const;
  inline void clear_m_lusn();
  static const int kMLUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lusn() const;
  inline void set_m_lusn(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:s_ans_continue)
 private:
  inline void set_has_m_lusn();
  inline void clear_has_m_lusn();
  
  ::google::protobuf::int32 m_lusn_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_ans_continue* default_instance_;
};
// -------------------------------------------------------------------

class s_ans_ruleset : public ::google::protobuf::MessageLite {
 public:
  s_ans_ruleset();
  virtual ~s_ans_ruleset();
  
  s_ans_ruleset(const s_ans_ruleset& from);
  
  inline s_ans_ruleset& operator=(const s_ans_ruleset& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_ans_ruleset& default_instance();
  
  void Swap(s_ans_ruleset* other);
  
  // implements Message ----------------------------------------------
  
  s_ans_ruleset* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_ans_ruleset& from);
  void MergeFrom(const s_ans_ruleset& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 m_nRuleIdx = 1;
  inline bool has_m_nruleidx() const;
  inline void clear_m_nruleidx();
  static const int kMNRuleIdxFieldNumber = 1;
  inline ::google::protobuf::int32 m_nruleidx() const;
  inline void set_m_nruleidx(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:s_ans_ruleset)
 private:
  inline void set_has_m_nruleidx();
  inline void clear_has_m_nruleidx();
  
  ::google::protobuf::int32 m_nruleidx_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_ans_ruleset* default_instance_;
};
// -------------------------------------------------------------------

class s_ans_start : public ::google::protobuf::MessageLite {
 public:
  s_ans_start();
  virtual ~s_ans_start();
  
  s_ans_start(const s_ans_start& from);
  
  inline s_ans_start& operator=(const s_ans_start& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_ans_start& default_instance();
  
  void Swap(s_ans_start* other);
  
  // implements Message ----------------------------------------------
  
  s_ans_start* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_ans_start& from);
  void MergeFrom(const s_ans_start& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lState = 1;
  inline bool has_m_lstate() const;
  inline void clear_m_lstate();
  static const int kMLStateFieldNumber = 1;
  inline ::google::protobuf::int32 m_lstate() const;
  inline void set_m_lstate(::google::protobuf::int32 value);
  
  // repeated sint32 m_vtState = 2;
  inline int m_vtstate_size() const;
  inline void clear_m_vtstate();
  static const int kMVtStateFieldNumber = 2;
  inline ::google::protobuf::int32 m_vtstate(int index) const;
  inline void set_m_vtstate(int index, ::google::protobuf::int32 value);
  inline void add_m_vtstate(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      m_vtstate() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_m_vtstate();
  
  // required sint64 m_llSystemTime = 3;
  inline bool has_m_llsystemtime() const;
  inline void clear_m_llsystemtime();
  static const int kMLlSystemTimeFieldNumber = 3;
  inline ::google::protobuf::int64 m_llsystemtime() const;
  inline void set_m_llsystemtime(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:s_ans_start)
 private:
  inline void set_has_m_lstate();
  inline void clear_has_m_lstate();
  inline void set_has_m_llsystemtime();
  inline void clear_has_m_llsystemtime();
  
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > m_vtstate_;
  ::google::protobuf::int64 m_llsystemtime_;
  ::google::protobuf::int32 m_lstate_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_ans_start* default_instance_;
};
// -------------------------------------------------------------------

class s_carddata : public ::google::protobuf::MessageLite {
 public:
  s_carddata();
  virtual ~s_carddata();
  
  s_carddata(const s_carddata& from);
  
  inline s_carddata& operator=(const s_carddata& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_carddata& default_instance();
  
  void Swap(s_carddata* other);
  
  // implements Message ----------------------------------------------
  
  s_carddata* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_carddata& from);
  void MergeFrom(const s_carddata& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 m_nDealCnt = 1;
  inline bool has_m_ndealcnt() const;
  inline void clear_m_ndealcnt();
  static const int kMNDealCntFieldNumber = 1;
  inline ::google::protobuf::int32 m_ndealcnt() const;
  inline void set_m_ndealcnt(::google::protobuf::int32 value);
  
  // required sint32 m_lCardsDealt = 2;
  inline bool has_m_lcardsdealt() const;
  inline void clear_m_lcardsdealt();
  static const int kMLCardsDealtFieldNumber = 2;
  inline ::google::protobuf::int32 m_lcardsdealt() const;
  inline void set_m_lcardsdealt(::google::protobuf::int32 value);
  
  // repeated .PKCards m_tblCard = 3;
  inline int m_tblcard_size() const;
  inline void clear_m_tblcard();
  static const int kMTblCardFieldNumber = 3;
  inline const ::PKCards& m_tblcard(int index) const;
  inline ::PKCards* mutable_m_tblcard(int index);
  inline ::PKCards* add_m_tblcard();
  inline const ::google::protobuf::RepeatedPtrField< ::PKCards >&
      m_tblcard() const;
  inline ::google::protobuf::RepeatedPtrField< ::PKCards >*
      mutable_m_tblcard();
  
  // repeated .PKMoney m_tblMoney = 4;
  inline int m_tblmoney_size() const;
  inline void clear_m_tblmoney();
  static const int kMTblMoneyFieldNumber = 4;
  inline const ::PKMoney& m_tblmoney(int index) const;
  inline ::PKMoney* mutable_m_tblmoney(int index);
  inline ::PKMoney* add_m_tblmoney();
  inline const ::google::protobuf::RepeatedPtrField< ::PKMoney >&
      m_tblmoney() const;
  inline ::google::protobuf::RepeatedPtrField< ::PKMoney >*
      mutable_m_tblmoney();
  
  // required sint64 m_llPoolMoney = 5;
  inline bool has_m_llpoolmoney() const;
  inline void clear_m_llpoolmoney();
  static const int kMLlPoolMoneyFieldNumber = 5;
  inline ::google::protobuf::int64 m_llpoolmoney() const;
  inline void set_m_llpoolmoney(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:s_carddata)
 private:
  inline void set_has_m_ndealcnt();
  inline void clear_has_m_ndealcnt();
  inline void set_has_m_lcardsdealt();
  inline void clear_has_m_lcardsdealt();
  inline void set_has_m_llpoolmoney();
  inline void clear_has_m_llpoolmoney();
  
  ::google::protobuf::int32 m_ndealcnt_;
  ::google::protobuf::int32 m_lcardsdealt_;
  ::google::protobuf::RepeatedPtrField< ::PKCards > m_tblcard_;
  ::google::protobuf::RepeatedPtrField< ::PKMoney > m_tblmoney_;
  ::google::protobuf::int64 m_llpoolmoney_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_carddata* default_instance_;
};
// -------------------------------------------------------------------

class s_entryreject : public ::google::protobuf::MessageLite {
 public:
  s_entryreject();
  virtual ~s_entryreject();
  
  s_entryreject(const s_entryreject& from);
  
  inline s_entryreject& operator=(const s_entryreject& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_entryreject& default_instance();
  
  void Swap(s_entryreject* other);
  
  // implements Message ----------------------------------------------
  
  s_entryreject* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_entryreject& from);
  void MergeFrom(const s_entryreject& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lType = 1;
  inline bool has_m_ltype() const;
  inline void clear_m_ltype();
  static const int kMLTypeFieldNumber = 1;
  inline ::google::protobuf::int32 m_ltype() const;
  inline void set_m_ltype(::google::protobuf::int32 value);
  
  // required sint64 m_llCMoney = 2;
  inline bool has_m_llcmoney() const;
  inline void clear_m_llcmoney();
  static const int kMLlCMoneyFieldNumber = 2;
  inline ::google::protobuf::int64 m_llcmoney() const;
  inline void set_m_llcmoney(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:s_entryreject)
 private:
  inline void set_has_m_ltype();
  inline void clear_has_m_ltype();
  inline void set_has_m_llcmoney();
  inline void clear_has_m_llcmoney();
  
  ::google::protobuf::int64 m_llcmoney_;
  ::google::protobuf::int32 m_ltype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_entryreject* default_instance_;
};
// -------------------------------------------------------------------

class s_nostart : public ::google::protobuf::MessageLite {
 public:
  s_nostart();
  virtual ~s_nostart();
  
  s_nostart(const s_nostart& from);
  
  inline s_nostart& operator=(const s_nostart& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_nostart& default_instance();
  
  void Swap(s_nostart* other);
  
  // implements Message ----------------------------------------------
  
  s_nostart* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_nostart& from);
  void MergeFrom(const s_nostart& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:s_nostart)
 private:
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_nostart* default_instance_;
};
// -------------------------------------------------------------------

class s_newgame : public ::google::protobuf::MessageLite {
 public:
  s_newgame();
  virtual ~s_newgame();
  
  s_newgame(const s_newgame& from);
  
  inline s_newgame& operator=(const s_newgame& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_newgame& default_instance();
  
  void Swap(s_newgame* other);
  
  // implements Message ----------------------------------------------
  
  s_newgame* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_newgame& from);
  void MergeFrom(const s_newgame& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .PKWinLoseInfo m_vtWinLoseInfo = 1;
  inline int m_vtwinloseinfo_size() const;
  inline void clear_m_vtwinloseinfo();
  static const int kMVtWinLoseInfoFieldNumber = 1;
  inline const ::PKWinLoseInfo& m_vtwinloseinfo(int index) const;
  inline ::PKWinLoseInfo* mutable_m_vtwinloseinfo(int index);
  inline ::PKWinLoseInfo* add_m_vtwinloseinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::PKWinLoseInfo >&
      m_vtwinloseinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::PKWinLoseInfo >*
      mutable_m_vtwinloseinfo();
  
  // @@protoc_insertion_point(class_scope:s_newgame)
 private:
  
  ::google::protobuf::RepeatedPtrField< ::PKWinLoseInfo > m_vtwinloseinfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_newgame* default_instance_;
};
// -------------------------------------------------------------------

class s_ans_purge : public ::google::protobuf::MessageLite {
 public:
  s_ans_purge();
  virtual ~s_ans_purge();
  
  s_ans_purge(const s_ans_purge& from);
  
  inline s_ans_purge& operator=(const s_ans_purge& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_ans_purge& default_instance();
  
  void Swap(s_ans_purge* other);
  
  // implements Message ----------------------------------------------
  
  s_ans_purge* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_ans_purge& from);
  void MergeFrom(const s_ans_purge& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:s_ans_purge)
 private:
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_ans_purge* default_instance_;
};
// -------------------------------------------------------------------

class s_purgeinfo : public ::google::protobuf::MessageLite {
 public:
  s_purgeinfo();
  virtual ~s_purgeinfo();
  
  s_purgeinfo(const s_purgeinfo& from);
  
  inline s_purgeinfo& operator=(const s_purgeinfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_purgeinfo& default_instance();
  
  void Swap(s_purgeinfo* other);
  
  // implements Message ----------------------------------------------
  
  s_purgeinfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_purgeinfo& from);
  void MergeFrom(const s_purgeinfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .PKVecUSN m_vtPurgeUSN = 1;
  inline int m_vtpurgeusn_size() const;
  inline void clear_m_vtpurgeusn();
  static const int kMVtPurgeUSNFieldNumber = 1;
  inline const ::PKVecUSN& m_vtpurgeusn(int index) const;
  inline ::PKVecUSN* mutable_m_vtpurgeusn(int index);
  inline ::PKVecUSN* add_m_vtpurgeusn();
  inline const ::google::protobuf::RepeatedPtrField< ::PKVecUSN >&
      m_vtpurgeusn() const;
  inline ::google::protobuf::RepeatedPtrField< ::PKVecUSN >*
      mutable_m_vtpurgeusn();
  
  // required int32 m_nCount = 2;
  inline bool has_m_ncount() const;
  inline void clear_m_ncount();
  static const int kMNCountFieldNumber = 2;
  inline ::google::protobuf::int32 m_ncount() const;
  inline void set_m_ncount(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:s_purgeinfo)
 private:
  inline void set_has_m_ncount();
  inline void clear_has_m_ncount();
  
  ::google::protobuf::RepeatedPtrField< ::PKVecUSN > m_vtpurgeusn_;
  ::google::protobuf::int32 m_ncount_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_purgeinfo* default_instance_;
};
// -------------------------------------------------------------------

class s_systemmsg : public ::google::protobuf::MessageLite {
 public:
  s_systemmsg();
  virtual ~s_systemmsg();
  
  s_systemmsg(const s_systemmsg& from);
  
  inline s_systemmsg& operator=(const s_systemmsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_systemmsg& default_instance();
  
  void Swap(s_systemmsg* other);
  
  // implements Message ----------------------------------------------
  
  s_systemmsg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_systemmsg& from);
  void MergeFrom(const s_systemmsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lType = 1;
  inline bool has_m_ltype() const;
  inline void clear_m_ltype();
  static const int kMLTypeFieldNumber = 1;
  inline ::google::protobuf::int32 m_ltype() const;
  inline void set_m_ltype(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:s_systemmsg)
 private:
  inline void set_has_m_ltype();
  inline void clear_has_m_ltype();
  
  ::google::protobuf::int32 m_ltype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_systemmsg* default_instance_;
};
// -------------------------------------------------------------------

class s_exitntf : public ::google::protobuf::MessageLite {
 public:
  s_exitntf();
  virtual ~s_exitntf();
  
  s_exitntf(const s_exitntf& from);
  
  inline s_exitntf& operator=(const s_exitntf& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_exitntf& default_instance();
  
  void Swap(s_exitntf* other);
  
  // implements Message ----------------------------------------------
  
  s_exitntf* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_exitntf& from);
  void MergeFrom(const s_exitntf& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lUSN = 1;
  inline bool has_m_lusn() const;
  inline void clear_m_lusn();
  static const int kMLUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lusn() const;
  inline void set_m_lusn(::google::protobuf::int32 value);
  
  // required int32 m_nIndex = 2;
  inline bool has_m_nindex() const;
  inline void clear_m_nindex();
  static const int kMNIndexFieldNumber = 2;
  inline ::google::protobuf::int32 m_nindex() const;
  inline void set_m_nindex(::google::protobuf::int32 value);
  
  // required sint32 m_lExit = 3;
  inline bool has_m_lexit() const;
  inline void clear_m_lexit();
  static const int kMLExitFieldNumber = 3;
  inline ::google::protobuf::int32 m_lexit() const;
  inline void set_m_lexit(::google::protobuf::int32 value);
  
  // required sint32 m_bExit = 4;
  inline bool has_m_bexit() const;
  inline void clear_m_bexit();
  static const int kMBExitFieldNumber = 4;
  inline ::google::protobuf::int32 m_bexit() const;
  inline void set_m_bexit(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:s_exitntf)
 private:
  inline void set_has_m_lusn();
  inline void clear_has_m_lusn();
  inline void set_has_m_nindex();
  inline void clear_has_m_nindex();
  inline void set_has_m_lexit();
  inline void clear_has_m_lexit();
  inline void set_has_m_bexit();
  inline void clear_has_m_bexit();
  
  ::google::protobuf::int32 m_lusn_;
  ::google::protobuf::int32 m_nindex_;
  ::google::protobuf::int32 m_lexit_;
  ::google::protobuf::int32 m_bexit_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_exitntf* default_instance_;
};
// -------------------------------------------------------------------

class s_refillmoneyntf : public ::google::protobuf::MessageLite {
 public:
  s_refillmoneyntf();
  virtual ~s_refillmoneyntf();
  
  s_refillmoneyntf(const s_refillmoneyntf& from);
  
  inline s_refillmoneyntf& operator=(const s_refillmoneyntf& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_refillmoneyntf& default_instance();
  
  void Swap(s_refillmoneyntf* other);
  
  // implements Message ----------------------------------------------
  
  s_refillmoneyntf* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_refillmoneyntf& from);
  void MergeFrom(const s_refillmoneyntf& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lUSN = 1;
  inline bool has_m_lusn() const;
  inline void clear_m_lusn();
  static const int kMLUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lusn() const;
  inline void set_m_lusn(::google::protobuf::int32 value);
  
  // required int32 m_nRefillCnt = 2;
  inline bool has_m_nrefillcnt() const;
  inline void clear_m_nrefillcnt();
  static const int kMNRefillCntFieldNumber = 2;
  inline ::google::protobuf::int32 m_nrefillcnt() const;
  inline void set_m_nrefillcnt(::google::protobuf::int32 value);
  
  // required sint64 m_llRefillMoney = 3;
  inline bool has_m_llrefillmoney() const;
  inline void clear_m_llrefillmoney();
  static const int kMLlRefillMoneyFieldNumber = 3;
  inline ::google::protobuf::int64 m_llrefillmoney() const;
  inline void set_m_llrefillmoney(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:s_refillmoneyntf)
 private:
  inline void set_has_m_lusn();
  inline void clear_has_m_lusn();
  inline void set_has_m_nrefillcnt();
  inline void clear_has_m_nrefillcnt();
  inline void set_has_m_llrefillmoney();
  inline void clear_has_m_llrefillmoney();
  
  ::google::protobuf::int32 m_lusn_;
  ::google::protobuf::int32 m_nrefillcnt_;
  ::google::protobuf::int64 m_llrefillmoney_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_refillmoneyntf* default_instance_;
};
// -------------------------------------------------------------------

class s_bonus : public ::google::protobuf::MessageLite {
 public:
  s_bonus();
  virtual ~s_bonus();
  
  s_bonus(const s_bonus& from);
  
  inline s_bonus& operator=(const s_bonus& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_bonus& default_instance();
  
  void Swap(s_bonus* other);
  
  // implements Message ----------------------------------------------
  
  s_bonus* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_bonus& from);
  void MergeFrom(const s_bonus& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint64 m_llBonus = 1;
  inline bool has_m_llbonus() const;
  inline void clear_m_llbonus();
  static const int kMLlBonusFieldNumber = 1;
  inline ::google::protobuf::int64 m_llbonus() const;
  inline void set_m_llbonus(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:s_bonus)
 private:
  inline void set_has_m_llbonus();
  inline void clear_has_m_llbonus();
  
  ::google::protobuf::int64 m_llbonus_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_bonus* default_instance_;
};
// -------------------------------------------------------------------

class s_userjoinerr : public ::google::protobuf::MessageLite {
 public:
  s_userjoinerr();
  virtual ~s_userjoinerr();
  
  s_userjoinerr(const s_userjoinerr& from);
  
  inline s_userjoinerr& operator=(const s_userjoinerr& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_userjoinerr& default_instance();
  
  void Swap(s_userjoinerr* other);
  
  // implements Message ----------------------------------------------
  
  s_userjoinerr* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_userjoinerr& from);
  void MergeFrom(const s_userjoinerr& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lUSN = 1;
  inline bool has_m_lusn() const;
  inline void clear_m_lusn();
  static const int kMLUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lusn() const;
  inline void set_m_lusn(::google::protobuf::int32 value);
  
  // required sint32 m_lErrorCode = 2;
  inline bool has_m_lerrorcode() const;
  inline void clear_m_lerrorcode();
  static const int kMLErrorCodeFieldNumber = 2;
  inline ::google::protobuf::int32 m_lerrorcode() const;
  inline void set_m_lerrorcode(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:s_userjoinerr)
 private:
  inline void set_has_m_lusn();
  inline void clear_has_m_lusn();
  inline void set_has_m_lerrorcode();
  inline void clear_has_m_lerrorcode();
  
  ::google::protobuf::int32 m_lusn_;
  ::google::protobuf::int32 m_lerrorcode_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_userjoinerr* default_instance_;
};
// -------------------------------------------------------------------

class s_userdisconnect : public ::google::protobuf::MessageLite {
 public:
  s_userdisconnect();
  virtual ~s_userdisconnect();
  
  s_userdisconnect(const s_userdisconnect& from);
  
  inline s_userdisconnect& operator=(const s_userdisconnect& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_userdisconnect& default_instance();
  
  void Swap(s_userdisconnect* other);
  
  // implements Message ----------------------------------------------
  
  s_userdisconnect* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_userdisconnect& from);
  void MergeFrom(const s_userdisconnect& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lUSN = 1;
  inline bool has_m_lusn() const;
  inline void clear_m_lusn();
  static const int kMLUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lusn() const;
  inline void set_m_lusn(::google::protobuf::int32 value);
  
  // required .PKUserInfo m_uinfo = 2;
  inline bool has_m_uinfo() const;
  inline void clear_m_uinfo();
  static const int kMUinfoFieldNumber = 2;
  inline const ::PKUserInfo& m_uinfo() const;
  inline ::PKUserInfo* mutable_m_uinfo();
  inline ::PKUserInfo* release_m_uinfo();
  
  // required sint32 m_lState = 3;
  inline bool has_m_lstate() const;
  inline void clear_m_lstate();
  static const int kMLStateFieldNumber = 3;
  inline ::google::protobuf::int32 m_lstate() const;
  inline void set_m_lstate(::google::protobuf::int32 value);
  
  // required sint32 m_lOwnerUSN = 4;
  inline bool has_m_lownerusn() const;
  inline void clear_m_lownerusn();
  static const int kMLOwnerUSNFieldNumber = 4;
  inline ::google::protobuf::int32 m_lownerusn() const;
  inline void set_m_lownerusn(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:s_userdisconnect)
 private:
  inline void set_has_m_lusn();
  inline void clear_has_m_lusn();
  inline void set_has_m_uinfo();
  inline void clear_has_m_uinfo();
  inline void set_has_m_lstate();
  inline void clear_has_m_lstate();
  inline void set_has_m_lownerusn();
  inline void clear_has_m_lownerusn();
  
  ::PKUserInfo* m_uinfo_;
  ::google::protobuf::int32 m_lusn_;
  ::google::protobuf::int32 m_lstate_;
  ::google::protobuf::int32 m_lownerusn_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_userdisconnect* default_instance_;
};
// -------------------------------------------------------------------

class s_soundtypeans : public ::google::protobuf::MessageLite {
 public:
  s_soundtypeans();
  virtual ~s_soundtypeans();
  
  s_soundtypeans(const s_soundtypeans& from);
  
  inline s_soundtypeans& operator=(const s_soundtypeans& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_soundtypeans& default_instance();
  
  void Swap(s_soundtypeans* other);
  
  // implements Message ----------------------------------------------
  
  s_soundtypeans* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_soundtypeans& from);
  void MergeFrom(const s_soundtypeans& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lUSN = 1;
  inline bool has_m_lusn() const;
  inline void clear_m_lusn();
  static const int kMLUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lusn() const;
  inline void set_m_lusn(::google::protobuf::int32 value);
  
  // required int32 m_nIndex = 2;
  inline bool has_m_nindex() const;
  inline void clear_m_nindex();
  static const int kMNIndexFieldNumber = 2;
  inline ::google::protobuf::int32 m_nindex() const;
  inline void set_m_nindex(::google::protobuf::int32 value);
  
  // required sint32 m_lSoundType = 3;
  inline bool has_m_lsoundtype() const;
  inline void clear_m_lsoundtype();
  static const int kMLSoundTypeFieldNumber = 3;
  inline ::google::protobuf::int32 m_lsoundtype() const;
  inline void set_m_lsoundtype(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:s_soundtypeans)
 private:
  inline void set_has_m_lusn();
  inline void clear_has_m_lusn();
  inline void set_has_m_nindex();
  inline void clear_has_m_nindex();
  inline void set_has_m_lsoundtype();
  inline void clear_has_m_lsoundtype();
  
  ::google::protobuf::int32 m_lusn_;
  ::google::protobuf::int32 m_nindex_;
  ::google::protobuf::int32 m_lsoundtype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_soundtypeans* default_instance_;
};
// -------------------------------------------------------------------

class s_userjoinans : public ::google::protobuf::MessageLite {
 public:
  s_userjoinans();
  virtual ~s_userjoinans();
  
  s_userjoinans(const s_userjoinans& from);
  
  inline s_userjoinans& operator=(const s_userjoinans& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_userjoinans& default_instance();
  
  void Swap(s_userjoinans* other);
  
  // implements Message ----------------------------------------------
  
  s_userjoinans* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_userjoinans& from);
  void MergeFrom(const s_userjoinans& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lState = 1;
  inline bool has_m_lstate() const;
  inline void clear_m_lstate();
  static const int kMLStateFieldNumber = 1;
  inline ::google::protobuf::int32 m_lstate() const;
  inline void set_m_lstate(::google::protobuf::int32 value);
  
  // required int32 m_nEnter = 2;
  inline bool has_m_nenter() const;
  inline void clear_m_nenter();
  static const int kMNEnterFieldNumber = 2;
  inline ::google::protobuf::int32 m_nenter() const;
  inline void set_m_nenter(::google::protobuf::int32 value);
  
  // required int32 m_nSet = 3;
  inline bool has_m_nset() const;
  inline void clear_m_nset();
  static const int kMNSetFieldNumber = 3;
  inline ::google::protobuf::int32 m_nset() const;
  inline void set_m_nset(::google::protobuf::int32 value);
  
  // required int32 m_lChannel_idx = 4;
  inline bool has_m_lchannel_idx() const;
  inline void clear_m_lchannel_idx();
  static const int kMLChannelIdxFieldNumber = 4;
  inline ::google::protobuf::int32 m_lchannel_idx() const;
  inline void set_m_lchannel_idx(::google::protobuf::int32 value);
  
  // required sint32 m_lOwnerUSN = 5;
  inline bool has_m_lownerusn() const;
  inline void clear_m_lownerusn();
  static const int kMLOwnerUSNFieldNumber = 5;
  inline ::google::protobuf::int32 m_lownerusn() const;
  inline void set_m_lownerusn(::google::protobuf::int32 value);
  
  // required sint32 m_lBossUSN = 6;
  inline bool has_m_lbossusn() const;
  inline void clear_m_lbossusn();
  static const int kMLBossUSNFieldNumber = 6;
  inline ::google::protobuf::int32 m_lbossusn() const;
  inline void set_m_lbossusn(::google::protobuf::int32 value);
  
  // required int32 m_nRoomPurgeCnt = 7;
  inline bool has_m_nroompurgecnt() const;
  inline void clear_m_nroompurgecnt();
  static const int kMNRoomPurgeCntFieldNumber = 7;
  inline ::google::protobuf::int32 m_nroompurgecnt() const;
  inline void set_m_nroompurgecnt(::google::protobuf::int32 value);
  
  // required .PKOption m_option = 8;
  inline bool has_m_option() const;
  inline void clear_m_option();
  static const int kMOptionFieldNumber = 8;
  inline const ::PKOption& m_option() const;
  inline ::PKOption* mutable_m_option();
  inline ::PKOption* release_m_option();
  
  // @@protoc_insertion_point(class_scope:s_userjoinans)
 private:
  inline void set_has_m_lstate();
  inline void clear_has_m_lstate();
  inline void set_has_m_nenter();
  inline void clear_has_m_nenter();
  inline void set_has_m_nset();
  inline void clear_has_m_nset();
  inline void set_has_m_lchannel_idx();
  inline void clear_has_m_lchannel_idx();
  inline void set_has_m_lownerusn();
  inline void clear_has_m_lownerusn();
  inline void set_has_m_lbossusn();
  inline void clear_has_m_lbossusn();
  inline void set_has_m_nroompurgecnt();
  inline void clear_has_m_nroompurgecnt();
  inline void set_has_m_option();
  inline void clear_has_m_option();
  
  ::google::protobuf::int32 m_lstate_;
  ::google::protobuf::int32 m_nenter_;
  ::google::protobuf::int32 m_nset_;
  ::google::protobuf::int32 m_lchannel_idx_;
  ::google::protobuf::int32 m_lownerusn_;
  ::google::protobuf::int32 m_lbossusn_;
  ::PKOption* m_option_;
  ::google::protobuf::int32 m_nroompurgecnt_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_userjoinans* default_instance_;
};
// -------------------------------------------------------------------

class s_startreq : public ::google::protobuf::MessageLite {
 public:
  s_startreq();
  virtual ~s_startreq();
  
  s_startreq(const s_startreq& from);
  
  inline s_startreq& operator=(const s_startreq& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_startreq& default_instance();
  
  void Swap(s_startreq* other);
  
  // implements Message ----------------------------------------------
  
  s_startreq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_startreq& from);
  void MergeFrom(const s_startreq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:s_startreq)
 private:
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_startreq* default_instance_;
};
// -------------------------------------------------------------------

class s_ans_abuse : public ::google::protobuf::MessageLite {
 public:
  s_ans_abuse();
  virtual ~s_ans_abuse();
  
  s_ans_abuse(const s_ans_abuse& from);
  
  inline s_ans_abuse& operator=(const s_ans_abuse& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_ans_abuse& default_instance();
  
  void Swap(s_ans_abuse* other);
  
  // implements Message ----------------------------------------------
  
  s_ans_abuse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_ans_abuse& from);
  void MergeFrom(const s_ans_abuse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:s_ans_abuse)
 private:
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_ans_abuse* default_instance_;
};
// -------------------------------------------------------------------

class s_continue_msg : public ::google::protobuf::MessageLite {
 public:
  s_continue_msg();
  virtual ~s_continue_msg();
  
  s_continue_msg(const s_continue_msg& from);
  
  inline s_continue_msg& operator=(const s_continue_msg& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_continue_msg& default_instance();
  
  void Swap(s_continue_msg* other);
  
  // implements Message ----------------------------------------------
  
  s_continue_msg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_continue_msg& from);
  void MergeFrom(const s_continue_msg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .PKWinLoseInfo m_vtWinLoseInfo = 1;
  inline int m_vtwinloseinfo_size() const;
  inline void clear_m_vtwinloseinfo();
  static const int kMVtWinLoseInfoFieldNumber = 1;
  inline const ::PKWinLoseInfo& m_vtwinloseinfo(int index) const;
  inline ::PKWinLoseInfo* mutable_m_vtwinloseinfo(int index);
  inline ::PKWinLoseInfo* add_m_vtwinloseinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::PKWinLoseInfo >&
      m_vtwinloseinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::PKWinLoseInfo >*
      mutable_m_vtwinloseinfo();
  
  // @@protoc_insertion_point(class_scope:s_continue_msg)
 private:
  
  ::google::protobuf::RepeatedPtrField< ::PKWinLoseInfo > m_vtwinloseinfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_continue_msg* default_instance_;
};
// -------------------------------------------------------------------

class s_ans_observe : public ::google::protobuf::MessageLite {
 public:
  s_ans_observe();
  virtual ~s_ans_observe();
  
  s_ans_observe(const s_ans_observe& from);
  
  inline s_ans_observe& operator=(const s_ans_observe& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_ans_observe& default_instance();
  
  void Swap(s_ans_observe* other);
  
  // implements Message ----------------------------------------------
  
  s_ans_observe* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_ans_observe& from);
  void MergeFrom(const s_ans_observe& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lUSN = 1;
  inline bool has_m_lusn() const;
  inline void clear_m_lusn();
  static const int kMLUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lusn() const;
  inline void set_m_lusn(::google::protobuf::int32 value);
  
  // required int32 m_nIndex = 2;
  inline bool has_m_nindex() const;
  inline void clear_m_nindex();
  static const int kMNIndexFieldNumber = 2;
  inline ::google::protobuf::int32 m_nindex() const;
  inline void set_m_nindex(::google::protobuf::int32 value);
  
  // required sint32 m_lOwnerUSN = 3;
  inline bool has_m_lownerusn() const;
  inline void clear_m_lownerusn();
  static const int kMLOwnerUSNFieldNumber = 3;
  inline ::google::protobuf::int32 m_lownerusn() const;
  inline void set_m_lownerusn(::google::protobuf::int32 value);
  
  // required .PKUserInfo m_uinfo = 4;
  inline bool has_m_uinfo() const;
  inline void clear_m_uinfo();
  static const int kMUinfoFieldNumber = 4;
  inline const ::PKUserInfo& m_uinfo() const;
  inline ::PKUserInfo* mutable_m_uinfo();
  inline ::PKUserInfo* release_m_uinfo();
  
  // required .PKMoney m_money = 5;
  inline bool has_m_money() const;
  inline void clear_m_money();
  static const int kMMoneyFieldNumber = 5;
  inline const ::PKMoney& m_money() const;
  inline ::PKMoney* mutable_m_money();
  inline ::PKMoney* release_m_money();
  
  // @@protoc_insertion_point(class_scope:s_ans_observe)
 private:
  inline void set_has_m_lusn();
  inline void clear_has_m_lusn();
  inline void set_has_m_nindex();
  inline void clear_has_m_nindex();
  inline void set_has_m_lownerusn();
  inline void clear_has_m_lownerusn();
  inline void set_has_m_uinfo();
  inline void clear_has_m_uinfo();
  inline void set_has_m_money();
  inline void clear_has_m_money();
  
  ::google::protobuf::int32 m_lusn_;
  ::google::protobuf::int32 m_nindex_;
  ::PKUserInfo* m_uinfo_;
  ::PKMoney* m_money_;
  ::google::protobuf::int32 m_lownerusn_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_ans_observe* default_instance_;
};
// -------------------------------------------------------------------

class s_observercnt : public ::google::protobuf::MessageLite {
 public:
  s_observercnt();
  virtual ~s_observercnt();
  
  s_observercnt(const s_observercnt& from);
  
  inline s_observercnt& operator=(const s_observercnt& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_observercnt& default_instance();
  
  void Swap(s_observercnt* other);
  
  // implements Message ----------------------------------------------
  
  s_observercnt* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_observercnt& from);
  void MergeFrom(const s_observercnt& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 m_nObserverCnt = 1;
  inline bool has_m_nobservercnt() const;
  inline void clear_m_nobservercnt();
  static const int kMNObserverCntFieldNumber = 1;
  inline ::google::protobuf::int32 m_nobservercnt() const;
  inline void set_m_nobservercnt(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:s_observercnt)
 private:
  inline void set_has_m_nobservercnt();
  inline void clear_has_m_nobservercnt();
  
  ::google::protobuf::int32 m_nobservercnt_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_observercnt* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameProtocol : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameProtocol();
  virtual ~GLAnsGameProtocol();
  
  GLAnsGameProtocol(const GLAnsGameProtocol& from);
  
  inline GLAnsGameProtocol& operator=(const GLAnsGameProtocol& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameProtocol& default_instance();
  
  void Swap(GLAnsGameProtocol* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameProtocol* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameProtocol& from);
  void MergeFrom(const GLAnsGameProtocol& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef GLAnsGameProtocol_Type Type;
  static const Type NONE = GLAnsGameProtocol_Type_NONE;
  static const Type ans_game_test_packet = GLAnsGameProtocol_Type_ans_game_test_packet;
  static const Type ans_join_room = GLAnsGameProtocol_Type_ans_join_room;
  static const Type ans_deal_card = GLAnsGameProtocol_Type_ans_deal_card;
  static const Type ans_send_ante = GLAnsGameProtocol_Type_ans_send_ante;
  static const Type ans_select_card = GLAnsGameProtocol_Type_ans_select_card;
  static const Type ans_opencard = GLAnsGameProtocol_Type_ans_opencard;
  static const Type ans_boss = GLAnsGameProtocol_Type_ans_boss;
  static const Type ans_deal_hiddencard = GLAnsGameProtocol_Type_ans_deal_hiddencard;
  static const Type ans_betting = GLAnsGameProtocol_Type_ans_betting;
  static const Type ans_pong = GLAnsGameProtocol_Type_ans_pong;
  static const Type ans_entry = GLAnsGameProtocol_Type_ans_entry;
  static const Type ans_deal_cards = GLAnsGameProtocol_Type_ans_deal_cards;
  static const Type betting_msg = GLAnsGameProtocol_Type_betting_msg;
  static const Type finished = GLAnsGameProtocol_Type_finished;
  static const Type jackpotmoneyntf = GLAnsGameProtocol_Type_jackpotmoneyntf;
  static const Type ans_continue = GLAnsGameProtocol_Type_ans_continue;
  static const Type ans_ruleset = GLAnsGameProtocol_Type_ans_ruleset;
  static const Type ans_start = GLAnsGameProtocol_Type_ans_start;
  static const Type carddata = GLAnsGameProtocol_Type_carddata;
  static const Type entryreject = GLAnsGameProtocol_Type_entryreject;
  static const Type nostart = GLAnsGameProtocol_Type_nostart;
  static const Type newgame = GLAnsGameProtocol_Type_newgame;
  static const Type ans_purge = GLAnsGameProtocol_Type_ans_purge;
  static const Type purgeinfo = GLAnsGameProtocol_Type_purgeinfo;
  static const Type exitntf = GLAnsGameProtocol_Type_exitntf;
  static const Type refillmoneyntf = GLAnsGameProtocol_Type_refillmoneyntf;
  static const Type bonus = GLAnsGameProtocol_Type_bonus;
  static const Type systemmsg = GLAnsGameProtocol_Type_systemmsg;
  static const Type userjoinerr = GLAnsGameProtocol_Type_userjoinerr;
  static const Type userdisconnect = GLAnsGameProtocol_Type_userdisconnect;
  static const Type soundtypeans = GLAnsGameProtocol_Type_soundtypeans;
  static const Type userjoinans = GLAnsGameProtocol_Type_userjoinans;
  static const Type startreq = GLAnsGameProtocol_Type_startreq;
  static const Type ans_abuse = GLAnsGameProtocol_Type_ans_abuse;
  static const Type continue_msg = GLAnsGameProtocol_Type_continue_msg;
  static const Type ans_observe = GLAnsGameProtocol_Type_ans_observe;
  static const Type observercnt = GLAnsGameProtocol_Type_observercnt;
  static inline bool Type_IsValid(int value) {
    return GLAnsGameProtocol_Type_IsValid(value);
  }
  static const Type Type_MIN =
    GLAnsGameProtocol_Type_Type_MIN;
  static const Type Type_MAX =
    GLAnsGameProtocol_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    GLAnsGameProtocol_Type_Type_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required .GLAnsGameProtocol.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::GLAnsGameProtocol_Type type() const;
  inline void set_type(::GLAnsGameProtocol_Type value);
  
  // optional .s_ans_game_test_packet m_ans_game_test_packet = 2;
  inline bool has_m_ans_game_test_packet() const;
  inline void clear_m_ans_game_test_packet();
  static const int kMAnsGameTestPacketFieldNumber = 2;
  inline const ::s_ans_game_test_packet& m_ans_game_test_packet() const;
  inline ::s_ans_game_test_packet* mutable_m_ans_game_test_packet();
  inline ::s_ans_game_test_packet* release_m_ans_game_test_packet();
  
  // optional .s_ans_join_room m_ans_join_room = 3;
  inline bool has_m_ans_join_room() const;
  inline void clear_m_ans_join_room();
  static const int kMAnsJoinRoomFieldNumber = 3;
  inline const ::s_ans_join_room& m_ans_join_room() const;
  inline ::s_ans_join_room* mutable_m_ans_join_room();
  inline ::s_ans_join_room* release_m_ans_join_room();
  
  // optional .s_ans_deal_card m_ans_deal_card = 4;
  inline bool has_m_ans_deal_card() const;
  inline void clear_m_ans_deal_card();
  static const int kMAnsDealCardFieldNumber = 4;
  inline const ::s_ans_deal_card& m_ans_deal_card() const;
  inline ::s_ans_deal_card* mutable_m_ans_deal_card();
  inline ::s_ans_deal_card* release_m_ans_deal_card();
  
  // optional .s_ans_send_ante m_ans_send_ante = 5;
  inline bool has_m_ans_send_ante() const;
  inline void clear_m_ans_send_ante();
  static const int kMAnsSendAnteFieldNumber = 5;
  inline const ::s_ans_send_ante& m_ans_send_ante() const;
  inline ::s_ans_send_ante* mutable_m_ans_send_ante();
  inline ::s_ans_send_ante* release_m_ans_send_ante();
  
  // optional .s_ans_select_card m_ans_select_card = 6;
  inline bool has_m_ans_select_card() const;
  inline void clear_m_ans_select_card();
  static const int kMAnsSelectCardFieldNumber = 6;
  inline const ::s_ans_select_card& m_ans_select_card() const;
  inline ::s_ans_select_card* mutable_m_ans_select_card();
  inline ::s_ans_select_card* release_m_ans_select_card();
  
  // optional .s_ans_opencard m_ans_opencard = 7;
  inline bool has_m_ans_opencard() const;
  inline void clear_m_ans_opencard();
  static const int kMAnsOpencardFieldNumber = 7;
  inline const ::s_ans_opencard& m_ans_opencard() const;
  inline ::s_ans_opencard* mutable_m_ans_opencard();
  inline ::s_ans_opencard* release_m_ans_opencard();
  
  // optional .s_ans_boss m_ans_boss = 8;
  inline bool has_m_ans_boss() const;
  inline void clear_m_ans_boss();
  static const int kMAnsBossFieldNumber = 8;
  inline const ::s_ans_boss& m_ans_boss() const;
  inline ::s_ans_boss* mutable_m_ans_boss();
  inline ::s_ans_boss* release_m_ans_boss();
  
  // optional .s_ans_deal_hiddencard m_ans_deal_hiddencard = 9;
  inline bool has_m_ans_deal_hiddencard() const;
  inline void clear_m_ans_deal_hiddencard();
  static const int kMAnsDealHiddencardFieldNumber = 9;
  inline const ::s_ans_deal_hiddencard& m_ans_deal_hiddencard() const;
  inline ::s_ans_deal_hiddencard* mutable_m_ans_deal_hiddencard();
  inline ::s_ans_deal_hiddencard* release_m_ans_deal_hiddencard();
  
  // optional .s_ans_betting m_ans_betting = 10;
  inline bool has_m_ans_betting() const;
  inline void clear_m_ans_betting();
  static const int kMAnsBettingFieldNumber = 10;
  inline const ::s_ans_betting& m_ans_betting() const;
  inline ::s_ans_betting* mutable_m_ans_betting();
  inline ::s_ans_betting* release_m_ans_betting();
  
  // optional .s_ans_pong m_ans_pong = 11;
  inline bool has_m_ans_pong() const;
  inline void clear_m_ans_pong();
  static const int kMAnsPongFieldNumber = 11;
  inline const ::s_ans_pong& m_ans_pong() const;
  inline ::s_ans_pong* mutable_m_ans_pong();
  inline ::s_ans_pong* release_m_ans_pong();
  
  // optional .s_ans_entry m_ans_entry = 12;
  inline bool has_m_ans_entry() const;
  inline void clear_m_ans_entry();
  static const int kMAnsEntryFieldNumber = 12;
  inline const ::s_ans_entry& m_ans_entry() const;
  inline ::s_ans_entry* mutable_m_ans_entry();
  inline ::s_ans_entry* release_m_ans_entry();
  
  // optional .s_ans_deal_cards m_ans_deal_cards = 13;
  inline bool has_m_ans_deal_cards() const;
  inline void clear_m_ans_deal_cards();
  static const int kMAnsDealCardsFieldNumber = 13;
  inline const ::s_ans_deal_cards& m_ans_deal_cards() const;
  inline ::s_ans_deal_cards* mutable_m_ans_deal_cards();
  inline ::s_ans_deal_cards* release_m_ans_deal_cards();
  
  // optional .s_betting_msg m_betting_msg = 14;
  inline bool has_m_betting_msg() const;
  inline void clear_m_betting_msg();
  static const int kMBettingMsgFieldNumber = 14;
  inline const ::s_betting_msg& m_betting_msg() const;
  inline ::s_betting_msg* mutable_m_betting_msg();
  inline ::s_betting_msg* release_m_betting_msg();
  
  // optional .s_finished m_finished = 15;
  inline bool has_m_finished() const;
  inline void clear_m_finished();
  static const int kMFinishedFieldNumber = 15;
  inline const ::s_finished& m_finished() const;
  inline ::s_finished* mutable_m_finished();
  inline ::s_finished* release_m_finished();
  
  // optional .s_jackpotmoneyntf m_jackpotmoneyntf = 16;
  inline bool has_m_jackpotmoneyntf() const;
  inline void clear_m_jackpotmoneyntf();
  static const int kMJackpotmoneyntfFieldNumber = 16;
  inline const ::s_jackpotmoneyntf& m_jackpotmoneyntf() const;
  inline ::s_jackpotmoneyntf* mutable_m_jackpotmoneyntf();
  inline ::s_jackpotmoneyntf* release_m_jackpotmoneyntf();
  
  // optional .s_ans_continue m_ans_continue = 17;
  inline bool has_m_ans_continue() const;
  inline void clear_m_ans_continue();
  static const int kMAnsContinueFieldNumber = 17;
  inline const ::s_ans_continue& m_ans_continue() const;
  inline ::s_ans_continue* mutable_m_ans_continue();
  inline ::s_ans_continue* release_m_ans_continue();
  
  // optional .s_ans_ruleset m_ans_ruleset = 18;
  inline bool has_m_ans_ruleset() const;
  inline void clear_m_ans_ruleset();
  static const int kMAnsRulesetFieldNumber = 18;
  inline const ::s_ans_ruleset& m_ans_ruleset() const;
  inline ::s_ans_ruleset* mutable_m_ans_ruleset();
  inline ::s_ans_ruleset* release_m_ans_ruleset();
  
  // optional .s_ans_start m_ans_start = 19;
  inline bool has_m_ans_start() const;
  inline void clear_m_ans_start();
  static const int kMAnsStartFieldNumber = 19;
  inline const ::s_ans_start& m_ans_start() const;
  inline ::s_ans_start* mutable_m_ans_start();
  inline ::s_ans_start* release_m_ans_start();
  
  // optional .s_carddata m_carddata = 20;
  inline bool has_m_carddata() const;
  inline void clear_m_carddata();
  static const int kMCarddataFieldNumber = 20;
  inline const ::s_carddata& m_carddata() const;
  inline ::s_carddata* mutable_m_carddata();
  inline ::s_carddata* release_m_carddata();
  
  // optional .s_entryreject m_entryreject = 21;
  inline bool has_m_entryreject() const;
  inline void clear_m_entryreject();
  static const int kMEntryrejectFieldNumber = 21;
  inline const ::s_entryreject& m_entryreject() const;
  inline ::s_entryreject* mutable_m_entryreject();
  inline ::s_entryreject* release_m_entryreject();
  
  // optional .s_nostart m_nostart = 22;
  inline bool has_m_nostart() const;
  inline void clear_m_nostart();
  static const int kMNostartFieldNumber = 22;
  inline const ::s_nostart& m_nostart() const;
  inline ::s_nostart* mutable_m_nostart();
  inline ::s_nostart* release_m_nostart();
  
  // optional .s_newgame m_newgame = 23;
  inline bool has_m_newgame() const;
  inline void clear_m_newgame();
  static const int kMNewgameFieldNumber = 23;
  inline const ::s_newgame& m_newgame() const;
  inline ::s_newgame* mutable_m_newgame();
  inline ::s_newgame* release_m_newgame();
  
  // optional .s_ans_purge m_ans_purge = 24;
  inline bool has_m_ans_purge() const;
  inline void clear_m_ans_purge();
  static const int kMAnsPurgeFieldNumber = 24;
  inline const ::s_ans_purge& m_ans_purge() const;
  inline ::s_ans_purge* mutable_m_ans_purge();
  inline ::s_ans_purge* release_m_ans_purge();
  
  // optional .s_purgeinfo m_purgeinfo = 25;
  inline bool has_m_purgeinfo() const;
  inline void clear_m_purgeinfo();
  static const int kMPurgeinfoFieldNumber = 25;
  inline const ::s_purgeinfo& m_purgeinfo() const;
  inline ::s_purgeinfo* mutable_m_purgeinfo();
  inline ::s_purgeinfo* release_m_purgeinfo();
  
  // optional .s_exitntf m_exitntf = 26;
  inline bool has_m_exitntf() const;
  inline void clear_m_exitntf();
  static const int kMExitntfFieldNumber = 26;
  inline const ::s_exitntf& m_exitntf() const;
  inline ::s_exitntf* mutable_m_exitntf();
  inline ::s_exitntf* release_m_exitntf();
  
  // optional .s_refillmoneyntf m_refillmoneyntf = 27;
  inline bool has_m_refillmoneyntf() const;
  inline void clear_m_refillmoneyntf();
  static const int kMRefillmoneyntfFieldNumber = 27;
  inline const ::s_refillmoneyntf& m_refillmoneyntf() const;
  inline ::s_refillmoneyntf* mutable_m_refillmoneyntf();
  inline ::s_refillmoneyntf* release_m_refillmoneyntf();
  
  // optional .s_bonus m_bonus = 28;
  inline bool has_m_bonus() const;
  inline void clear_m_bonus();
  static const int kMBonusFieldNumber = 28;
  inline const ::s_bonus& m_bonus() const;
  inline ::s_bonus* mutable_m_bonus();
  inline ::s_bonus* release_m_bonus();
  
  // optional .s_systemmsg m_systemmsg = 29;
  inline bool has_m_systemmsg() const;
  inline void clear_m_systemmsg();
  static const int kMSystemmsgFieldNumber = 29;
  inline const ::s_systemmsg& m_systemmsg() const;
  inline ::s_systemmsg* mutable_m_systemmsg();
  inline ::s_systemmsg* release_m_systemmsg();
  
  // optional .s_userjoinerr m_userjoinerr = 30;
  inline bool has_m_userjoinerr() const;
  inline void clear_m_userjoinerr();
  static const int kMUserjoinerrFieldNumber = 30;
  inline const ::s_userjoinerr& m_userjoinerr() const;
  inline ::s_userjoinerr* mutable_m_userjoinerr();
  inline ::s_userjoinerr* release_m_userjoinerr();
  
  // optional .s_userdisconnect m_userdisconnect = 31;
  inline bool has_m_userdisconnect() const;
  inline void clear_m_userdisconnect();
  static const int kMUserdisconnectFieldNumber = 31;
  inline const ::s_userdisconnect& m_userdisconnect() const;
  inline ::s_userdisconnect* mutable_m_userdisconnect();
  inline ::s_userdisconnect* release_m_userdisconnect();
  
  // optional .s_soundtypeans m_soundtypeans = 32;
  inline bool has_m_soundtypeans() const;
  inline void clear_m_soundtypeans();
  static const int kMSoundtypeansFieldNumber = 32;
  inline const ::s_soundtypeans& m_soundtypeans() const;
  inline ::s_soundtypeans* mutable_m_soundtypeans();
  inline ::s_soundtypeans* release_m_soundtypeans();
  
  // optional .s_userjoinans m_userjoinans = 33;
  inline bool has_m_userjoinans() const;
  inline void clear_m_userjoinans();
  static const int kMUserjoinansFieldNumber = 33;
  inline const ::s_userjoinans& m_userjoinans() const;
  inline ::s_userjoinans* mutable_m_userjoinans();
  inline ::s_userjoinans* release_m_userjoinans();
  
  // optional .s_startreq m_startreq = 34;
  inline bool has_m_startreq() const;
  inline void clear_m_startreq();
  static const int kMStartreqFieldNumber = 34;
  inline const ::s_startreq& m_startreq() const;
  inline ::s_startreq* mutable_m_startreq();
  inline ::s_startreq* release_m_startreq();
  
  // optional .s_ans_abuse m_ans_abuse = 35;
  inline bool has_m_ans_abuse() const;
  inline void clear_m_ans_abuse();
  static const int kMAnsAbuseFieldNumber = 35;
  inline const ::s_ans_abuse& m_ans_abuse() const;
  inline ::s_ans_abuse* mutable_m_ans_abuse();
  inline ::s_ans_abuse* release_m_ans_abuse();
  
  // optional .s_continue_msg m_continue_msg = 36;
  inline bool has_m_continue_msg() const;
  inline void clear_m_continue_msg();
  static const int kMContinueMsgFieldNumber = 36;
  inline const ::s_continue_msg& m_continue_msg() const;
  inline ::s_continue_msg* mutable_m_continue_msg();
  inline ::s_continue_msg* release_m_continue_msg();
  
  // optional .s_ans_observe m_ans_observe = 37;
  inline bool has_m_ans_observe() const;
  inline void clear_m_ans_observe();
  static const int kMAnsObserveFieldNumber = 37;
  inline const ::s_ans_observe& m_ans_observe() const;
  inline ::s_ans_observe* mutable_m_ans_observe();
  inline ::s_ans_observe* release_m_ans_observe();
  
  // optional .s_observercnt m_observercnt = 38;
  inline bool has_m_observercnt() const;
  inline void clear_m_observercnt();
  static const int kMObservercntFieldNumber = 38;
  inline const ::s_observercnt& m_observercnt() const;
  inline ::s_observercnt* mutable_m_observercnt();
  inline ::s_observercnt* release_m_observercnt();
  
  // @@protoc_insertion_point(class_scope:GLAnsGameProtocol)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_m_ans_game_test_packet();
  inline void clear_has_m_ans_game_test_packet();
  inline void set_has_m_ans_join_room();
  inline void clear_has_m_ans_join_room();
  inline void set_has_m_ans_deal_card();
  inline void clear_has_m_ans_deal_card();
  inline void set_has_m_ans_send_ante();
  inline void clear_has_m_ans_send_ante();
  inline void set_has_m_ans_select_card();
  inline void clear_has_m_ans_select_card();
  inline void set_has_m_ans_opencard();
  inline void clear_has_m_ans_opencard();
  inline void set_has_m_ans_boss();
  inline void clear_has_m_ans_boss();
  inline void set_has_m_ans_deal_hiddencard();
  inline void clear_has_m_ans_deal_hiddencard();
  inline void set_has_m_ans_betting();
  inline void clear_has_m_ans_betting();
  inline void set_has_m_ans_pong();
  inline void clear_has_m_ans_pong();
  inline void set_has_m_ans_entry();
  inline void clear_has_m_ans_entry();
  inline void set_has_m_ans_deal_cards();
  inline void clear_has_m_ans_deal_cards();
  inline void set_has_m_betting_msg();
  inline void clear_has_m_betting_msg();
  inline void set_has_m_finished();
  inline void clear_has_m_finished();
  inline void set_has_m_jackpotmoneyntf();
  inline void clear_has_m_jackpotmoneyntf();
  inline void set_has_m_ans_continue();
  inline void clear_has_m_ans_continue();
  inline void set_has_m_ans_ruleset();
  inline void clear_has_m_ans_ruleset();
  inline void set_has_m_ans_start();
  inline void clear_has_m_ans_start();
  inline void set_has_m_carddata();
  inline void clear_has_m_carddata();
  inline void set_has_m_entryreject();
  inline void clear_has_m_entryreject();
  inline void set_has_m_nostart();
  inline void clear_has_m_nostart();
  inline void set_has_m_newgame();
  inline void clear_has_m_newgame();
  inline void set_has_m_ans_purge();
  inline void clear_has_m_ans_purge();
  inline void set_has_m_purgeinfo();
  inline void clear_has_m_purgeinfo();
  inline void set_has_m_exitntf();
  inline void clear_has_m_exitntf();
  inline void set_has_m_refillmoneyntf();
  inline void clear_has_m_refillmoneyntf();
  inline void set_has_m_bonus();
  inline void clear_has_m_bonus();
  inline void set_has_m_systemmsg();
  inline void clear_has_m_systemmsg();
  inline void set_has_m_userjoinerr();
  inline void clear_has_m_userjoinerr();
  inline void set_has_m_userdisconnect();
  inline void clear_has_m_userdisconnect();
  inline void set_has_m_soundtypeans();
  inline void clear_has_m_soundtypeans();
  inline void set_has_m_userjoinans();
  inline void clear_has_m_userjoinans();
  inline void set_has_m_startreq();
  inline void clear_has_m_startreq();
  inline void set_has_m_ans_abuse();
  inline void clear_has_m_ans_abuse();
  inline void set_has_m_continue_msg();
  inline void clear_has_m_continue_msg();
  inline void set_has_m_ans_observe();
  inline void clear_has_m_ans_observe();
  inline void set_has_m_observercnt();
  inline void clear_has_m_observercnt();
  
  ::s_ans_game_test_packet* m_ans_game_test_packet_;
  ::s_ans_join_room* m_ans_join_room_;
  ::s_ans_deal_card* m_ans_deal_card_;
  ::s_ans_send_ante* m_ans_send_ante_;
  ::s_ans_select_card* m_ans_select_card_;
  ::s_ans_opencard* m_ans_opencard_;
  ::s_ans_boss* m_ans_boss_;
  ::s_ans_deal_hiddencard* m_ans_deal_hiddencard_;
  ::s_ans_betting* m_ans_betting_;
  ::s_ans_pong* m_ans_pong_;
  ::s_ans_entry* m_ans_entry_;
  ::s_ans_deal_cards* m_ans_deal_cards_;
  ::s_betting_msg* m_betting_msg_;
  ::s_finished* m_finished_;
  ::s_jackpotmoneyntf* m_jackpotmoneyntf_;
  ::s_ans_continue* m_ans_continue_;
  ::s_ans_ruleset* m_ans_ruleset_;
  ::s_ans_start* m_ans_start_;
  ::s_carddata* m_carddata_;
  ::s_entryreject* m_entryreject_;
  ::s_nostart* m_nostart_;
  ::s_newgame* m_newgame_;
  ::s_ans_purge* m_ans_purge_;
  ::s_purgeinfo* m_purgeinfo_;
  ::s_exitntf* m_exitntf_;
  ::s_refillmoneyntf* m_refillmoneyntf_;
  ::s_bonus* m_bonus_;
  ::s_systemmsg* m_systemmsg_;
  ::s_userjoinerr* m_userjoinerr_;
  ::s_userdisconnect* m_userdisconnect_;
  ::s_soundtypeans* m_soundtypeans_;
  ::s_userjoinans* m_userjoinans_;
  ::s_startreq* m_startreq_;
  ::s_ans_abuse* m_ans_abuse_;
  ::s_continue_msg* m_continue_msg_;
  ::s_ans_observe* m_ans_observe_;
  ::s_observercnt* m_observercnt_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(38 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameProtocol* default_instance_;
};
// -------------------------------------------------------------------

class PKCards : public ::google::protobuf::MessageLite {
 public:
  PKCards();
  virtual ~PKCards();
  
  PKCards(const PKCards& from);
  
  inline PKCards& operator=(const PKCards& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKCards& default_instance();
  
  void Swap(PKCards* other);
  
  // implements Message ----------------------------------------------
  
  PKCards* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKCards& from);
  void MergeFrom(const PKCards& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef PKCards_state state;
  static const state CARDTYPE_NORMAL = PKCards_state_CARDTYPE_NORMAL;
  static const state CARDTYPE_HIDDEN = PKCards_state_CARDTYPE_HIDDEN;
  static const state CARDTYPE_SAME = PKCards_state_CARDTYPE_SAME;
  static inline bool state_IsValid(int value) {
    return PKCards_state_IsValid(value);
  }
  static const state state_MIN =
    PKCards_state_state_MIN;
  static const state state_MAX =
    PKCards_state_state_MAX;
  static const int state_ARRAYSIZE =
    PKCards_state_state_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // repeated int32 m_vtCards = 1;
  inline int m_vtcards_size() const;
  inline void clear_m_vtcards();
  static const int kMVtCardsFieldNumber = 1;
  inline ::google::protobuf::int32 m_vtcards(int index) const;
  inline void set_m_vtcards(int index, ::google::protobuf::int32 value);
  inline void add_m_vtcards(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      m_vtcards() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_m_vtcards();
  
  // required int32 m_lResultIdx = 2;
  inline bool has_m_lresultidx() const;
  inline void clear_m_lresultidx();
  static const int kMLResultIdxFieldNumber = 2;
  inline ::google::protobuf::int32 m_lresultidx() const;
  inline void set_m_lresultidx(::google::protobuf::int32 value);
  
  // repeated .PKVecUSN m_vUserUSN = 3;
  inline int m_vuserusn_size() const;
  inline void clear_m_vuserusn();
  static const int kMVUserUSNFieldNumber = 3;
  inline const ::PKVecUSN& m_vuserusn(int index) const;
  inline ::PKVecUSN* mutable_m_vuserusn(int index);
  inline ::PKVecUSN* add_m_vuserusn();
  inline const ::google::protobuf::RepeatedPtrField< ::PKVecUSN >&
      m_vuserusn() const;
  inline ::google::protobuf::RepeatedPtrField< ::PKVecUSN >*
      mutable_m_vuserusn();
  
  // @@protoc_insertion_point(class_scope:PKCards)
 private:
  inline void set_has_m_lresultidx();
  inline void clear_has_m_lresultidx();
  
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > m_vtcards_;
  ::google::protobuf::RepeatedPtrField< ::PKVecUSN > m_vuserusn_;
  ::google::protobuf::int32 m_lresultidx_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKCards* default_instance_;
};
// -------------------------------------------------------------------

class PKMoney : public ::google::protobuf::MessageLite {
 public:
  PKMoney();
  virtual ~PKMoney();
  
  PKMoney(const PKMoney& from);
  
  inline PKMoney& operator=(const PKMoney& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMoney& default_instance();
  
  void Swap(PKMoney* other);
  
  // implements Message ----------------------------------------------
  
  PKMoney* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMoney& from);
  void MergeFrom(const PKMoney& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint64 m_llCMoney = 1;
  inline bool has_m_llcmoney() const;
  inline void clear_m_llcmoney();
  static const int kMLlCMoneyFieldNumber = 1;
  inline ::google::protobuf::int64 m_llcmoney() const;
  inline void set_m_llcmoney(::google::protobuf::int64 value);
  
  // required sint64 m_llCallMoney = 2;
  inline bool has_m_llcallmoney() const;
  inline void clear_m_llcallmoney();
  static const int kMLlCallMoneyFieldNumber = 2;
  inline ::google::protobuf::int64 m_llcallmoney() const;
  inline void set_m_llcallmoney(::google::protobuf::int64 value);
  
  // required sint64 m_llSideMoney = 3;
  inline bool has_m_llsidemoney() const;
  inline void clear_m_llsidemoney();
  static const int kMLlSideMoneyFieldNumber = 3;
  inline ::google::protobuf::int64 m_llsidemoney() const;
  inline void set_m_llsidemoney(::google::protobuf::int64 value);
  
  // required sint64 m_llCallHabMoney = 4;
  inline bool has_m_llcallhabmoney() const;
  inline void clear_m_llcallhabmoney();
  static const int kMLlCallHabMoneyFieldNumber = 4;
  inline ::google::protobuf::int64 m_llcallhabmoney() const;
  inline void set_m_llcallhabmoney(::google::protobuf::int64 value);
  
  // required sint64 m_llTakeMoney = 5;
  inline bool has_m_lltakemoney() const;
  inline void clear_m_lltakemoney();
  static const int kMLlTakeMoneyFieldNumber = 5;
  inline ::google::protobuf::int64 m_lltakemoney() const;
  inline void set_m_lltakemoney(::google::protobuf::int64 value);
  
  // required sint64 m_llJackpotMoney = 6;
  inline bool has_m_lljackpotmoney() const;
  inline void clear_m_lljackpotmoney();
  static const int kMLlJackpotMoneyFieldNumber = 6;
  inline ::google::protobuf::int64 m_lljackpotmoney() const;
  inline void set_m_lljackpotmoney(::google::protobuf::int64 value);
  
  // required sint32 m_lBetState = 7;
  inline bool has_m_lbetstate() const;
  inline void clear_m_lbetstate();
  static const int kMLBetStateFieldNumber = 7;
  inline ::google::protobuf::int32 m_lbetstate() const;
  inline void set_m_lbetstate(::google::protobuf::int32 value);
  
  // required sint32 m_lBetReceive = 8;
  inline bool has_m_lbetreceive() const;
  inline void clear_m_lbetreceive();
  static const int kMLBetReceiveFieldNumber = 8;
  inline ::google::protobuf::int32 m_lbetreceive() const;
  inline void set_m_lbetreceive(::google::protobuf::int32 value);
  
  // required sint32 m_lBetCount = 9;
  inline bool has_m_lbetcount() const;
  inline void clear_m_lbetcount();
  static const int kMLBetCountFieldNumber = 9;
  inline ::google::protobuf::int32 m_lbetcount() const;
  inline void set_m_lbetcount(::google::protobuf::int32 value);
  
  // required sint32 m_lResultIdx = 10;
  inline bool has_m_lresultidx() const;
  inline void clear_m_lresultidx();
  static const int kMLResultIdxFieldNumber = 10;
  inline ::google::protobuf::int32 m_lresultidx() const;
  inline void set_m_lresultidx(::google::protobuf::int32 value);
  
  // required string m_sMoneyMsg = 11;
  inline bool has_m_smoneymsg() const;
  inline void clear_m_smoneymsg();
  static const int kMSMoneyMsgFieldNumber = 11;
  inline const ::std::string& m_smoneymsg() const;
  inline void set_m_smoneymsg(const ::std::string& value);
  inline void set_m_smoneymsg(const char* value);
  inline void set_m_smoneymsg(const char* value, size_t size);
  inline ::std::string* mutable_m_smoneymsg();
  inline ::std::string* release_m_smoneymsg();
  
  // @@protoc_insertion_point(class_scope:PKMoney)
 private:
  inline void set_has_m_llcmoney();
  inline void clear_has_m_llcmoney();
  inline void set_has_m_llcallmoney();
  inline void clear_has_m_llcallmoney();
  inline void set_has_m_llsidemoney();
  inline void clear_has_m_llsidemoney();
  inline void set_has_m_llcallhabmoney();
  inline void clear_has_m_llcallhabmoney();
  inline void set_has_m_lltakemoney();
  inline void clear_has_m_lltakemoney();
  inline void set_has_m_lljackpotmoney();
  inline void clear_has_m_lljackpotmoney();
  inline void set_has_m_lbetstate();
  inline void clear_has_m_lbetstate();
  inline void set_has_m_lbetreceive();
  inline void clear_has_m_lbetreceive();
  inline void set_has_m_lbetcount();
  inline void clear_has_m_lbetcount();
  inline void set_has_m_lresultidx();
  inline void clear_has_m_lresultidx();
  inline void set_has_m_smoneymsg();
  inline void clear_has_m_smoneymsg();
  
  ::google::protobuf::int64 m_llcmoney_;
  ::google::protobuf::int64 m_llcallmoney_;
  ::google::protobuf::int64 m_llsidemoney_;
  ::google::protobuf::int64 m_llcallhabmoney_;
  ::google::protobuf::int64 m_lltakemoney_;
  ::google::protobuf::int64 m_lljackpotmoney_;
  ::google::protobuf::int32 m_lbetstate_;
  ::google::protobuf::int32 m_lbetreceive_;
  ::google::protobuf::int32 m_lbetcount_;
  ::google::protobuf::int32 m_lresultidx_;
  ::std::string* m_smoneymsg_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMoney* default_instance_;
};
// -------------------------------------------------------------------

class UserMoney : public ::google::protobuf::MessageLite {
 public:
  UserMoney();
  virtual ~UserMoney();
  
  UserMoney(const UserMoney& from);
  
  inline UserMoney& operator=(const UserMoney& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const UserMoney& default_instance();
  
  void Swap(UserMoney* other);
  
  // implements Message ----------------------------------------------
  
  UserMoney* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserMoney& from);
  void MergeFrom(const UserMoney& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lUSN = 1;
  inline bool has_m_lusn() const;
  inline void clear_m_lusn();
  static const int kMLUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lusn() const;
  inline void set_m_lusn(::google::protobuf::int32 value);
  
  // required sint32 m_lState = 2;
  inline bool has_m_lstate() const;
  inline void clear_m_lstate();
  static const int kMLStateFieldNumber = 2;
  inline ::google::protobuf::int32 m_lstate() const;
  inline void set_m_lstate(::google::protobuf::int32 value);
  
  // required sint64 m_llMoney = 3;
  inline bool has_m_llmoney() const;
  inline void clear_m_llmoney();
  static const int kMLlMoneyFieldNumber = 3;
  inline ::google::protobuf::int64 m_llmoney() const;
  inline void set_m_llmoney(::google::protobuf::int64 value);
  
  // required sint64 m_llCallHabMoney = 4;
  inline bool has_m_llcallhabmoney() const;
  inline void clear_m_llcallhabmoney();
  static const int kMLlCallHabMoneyFieldNumber = 4;
  inline ::google::protobuf::int64 m_llcallhabmoney() const;
  inline void set_m_llcallhabmoney(::google::protobuf::int64 value);
  
  // required sint64 m_llTakeMoney = 5;
  inline bool has_m_lltakemoney() const;
  inline void clear_m_lltakemoney();
  static const int kMLlTakeMoneyFieldNumber = 5;
  inline ::google::protobuf::int64 m_lltakemoney() const;
  inline void set_m_lltakemoney(::google::protobuf::int64 value);
  
  // required sint64 m_llDealMoney = 6;
  inline bool has_m_lldealmoney() const;
  inline void clear_m_lldealmoney();
  static const int kMLlDealMoneyFieldNumber = 6;
  inline ::google::protobuf::int64 m_lldealmoney() const;
  inline void set_m_lldealmoney(::google::protobuf::int64 value);
  
  // required string m_sNickName = 7;
  inline bool has_m_snickname() const;
  inline void clear_m_snickname();
  static const int kMSNickNameFieldNumber = 7;
  inline const ::std::string& m_snickname() const;
  inline void set_m_snickname(const ::std::string& value);
  inline void set_m_snickname(const char* value);
  inline void set_m_snickname(const char* value, size_t size);
  inline ::std::string* mutable_m_snickname();
  inline ::std::string* release_m_snickname();
  
  // required string m_sDealerTax = 8;
  inline bool has_m_sdealertax() const;
  inline void clear_m_sdealertax();
  static const int kMSDealerTaxFieldNumber = 8;
  inline const ::std::string& m_sdealertax() const;
  inline void set_m_sdealertax(const ::std::string& value);
  inline void set_m_sdealertax(const char* value);
  inline void set_m_sdealertax(const char* value, size_t size);
  inline ::std::string* mutable_m_sdealertax();
  inline ::std::string* release_m_sdealertax();
  
  // @@protoc_insertion_point(class_scope:UserMoney)
 private:
  inline void set_has_m_lusn();
  inline void clear_has_m_lusn();
  inline void set_has_m_lstate();
  inline void clear_has_m_lstate();
  inline void set_has_m_llmoney();
  inline void clear_has_m_llmoney();
  inline void set_has_m_llcallhabmoney();
  inline void clear_has_m_llcallhabmoney();
  inline void set_has_m_lltakemoney();
  inline void clear_has_m_lltakemoney();
  inline void set_has_m_lldealmoney();
  inline void clear_has_m_lldealmoney();
  inline void set_has_m_snickname();
  inline void clear_has_m_snickname();
  inline void set_has_m_sdealertax();
  inline void clear_has_m_sdealertax();
  
  ::google::protobuf::int32 m_lusn_;
  ::google::protobuf::int32 m_lstate_;
  ::google::protobuf::int64 m_llmoney_;
  ::google::protobuf::int64 m_llcallhabmoney_;
  ::google::protobuf::int64 m_lltakemoney_;
  ::google::protobuf::int64 m_lldealmoney_;
  ::std::string* m_snickname_;
  ::std::string* m_sdealertax_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static UserMoney* default_instance_;
};
// -------------------------------------------------------------------

class PKCWinLose : public ::google::protobuf::MessageLite {
 public:
  PKCWinLose();
  virtual ~PKCWinLose();
  
  PKCWinLose(const PKCWinLose& from);
  
  inline PKCWinLose& operator=(const PKCWinLose& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKCWinLose& default_instance();
  
  void Swap(PKCWinLose* other);
  
  // implements Message ----------------------------------------------
  
  PKCWinLose* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKCWinLose& from);
  void MergeFrom(const PKCWinLose& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lWin = 1;
  inline bool has_m_lwin() const;
  inline void clear_m_lwin();
  static const int kMLWinFieldNumber = 1;
  inline ::google::protobuf::int32 m_lwin() const;
  inline void set_m_lwin(::google::protobuf::int32 value);
  
  // required sint32 m_lLose = 2;
  inline bool has_m_llose() const;
  inline void clear_m_llose();
  static const int kMLLoseFieldNumber = 2;
  inline ::google::protobuf::int32 m_llose() const;
  inline void set_m_llose(::google::protobuf::int32 value);
  
  // required sint32 m_lContinue = 3;
  inline bool has_m_lcontinue() const;
  inline void clear_m_lcontinue();
  static const int kMLContinueFieldNumber = 3;
  inline ::google::protobuf::int32 m_lcontinue() const;
  inline void set_m_lcontinue(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PKCWinLose)
 private:
  inline void set_has_m_lwin();
  inline void clear_has_m_lwin();
  inline void set_has_m_llose();
  inline void clear_has_m_llose();
  inline void set_has_m_lcontinue();
  inline void clear_has_m_lcontinue();
  
  ::google::protobuf::int32 m_lwin_;
  ::google::protobuf::int32 m_llose_;
  ::google::protobuf::int32 m_lcontinue_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKCWinLose* default_instance_;
};
// -------------------------------------------------------------------

class PKUserInfo : public ::google::protobuf::MessageLite {
 public:
  PKUserInfo();
  virtual ~PKUserInfo();
  
  PKUserInfo(const PKUserInfo& from);
  
  inline PKUserInfo& operator=(const PKUserInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKUserInfo& default_instance();
  
  void Swap(PKUserInfo* other);
  
  // implements Message ----------------------------------------------
  
  PKUserInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKUserInfo& from);
  void MergeFrom(const PKUserInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lUSN = 1;
  inline bool has_m_lusn() const;
  inline void clear_m_lusn();
  static const int kMLUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lusn() const;
  inline void set_m_lusn(::google::protobuf::int32 value);
  
  // required sint32 m_nIndex = 2;
  inline bool has_m_nindex() const;
  inline void clear_m_nindex();
  static const int kMNIndexFieldNumber = 2;
  inline ::google::protobuf::int32 m_nindex() const;
  inline void set_m_nindex(::google::protobuf::int32 value);
  
  // required string m_sNickName = 3;
  inline bool has_m_snickname() const;
  inline void clear_m_snickname();
  static const int kMSNickNameFieldNumber = 3;
  inline const ::std::string& m_snickname() const;
  inline void set_m_snickname(const ::std::string& value);
  inline void set_m_snickname(const char* value);
  inline void set_m_snickname(const char* value, size_t size);
  inline ::std::string* mutable_m_snickname();
  inline ::std::string* release_m_snickname();
  
  // required string m_sID = 4;
  inline bool has_m_sid() const;
  inline void clear_m_sid();
  static const int kMSIDFieldNumber = 4;
  inline const ::std::string& m_sid() const;
  inline void set_m_sid(const ::std::string& value);
  inline void set_m_sid(const char* value);
  inline void set_m_sid(const char* value, size_t size);
  inline ::std::string* mutable_m_sid();
  inline ::std::string* release_m_sid();
  
  // required sint32 m_lCLevel = 5;
  inline bool has_m_lclevel() const;
  inline void clear_m_lclevel();
  static const int kMLCLevelFieldNumber = 5;
  inline ::google::protobuf::int32 m_lclevel() const;
  inline void set_m_lclevel(::google::protobuf::int32 value);
  
  // required sint32 m_lSoundType = 6;
  inline bool has_m_lsoundtype() const;
  inline void clear_m_lsoundtype();
  static const int kMLSoundTypeFieldNumber = 6;
  inline ::google::protobuf::int32 m_lsoundtype() const;
  inline void set_m_lsoundtype(::google::protobuf::int32 value);
  
  // required string m_sAvt = 7;
  inline bool has_m_savt() const;
  inline void clear_m_savt();
  static const int kMSAvtFieldNumber = 7;
  inline const ::std::string& m_savt() const;
  inline void set_m_savt(const ::std::string& value);
  inline void set_m_savt(const char* value);
  inline void set_m_savt(const char* value, size_t size);
  inline ::std::string* mutable_m_savt();
  inline ::std::string* release_m_savt();
  
  // required sint32 m_lUserState = 8;
  inline bool has_m_luserstate() const;
  inline void clear_m_luserstate();
  static const int kMLUserStateFieldNumber = 8;
  inline ::google::protobuf::int32 m_luserstate() const;
  inline void set_m_luserstate(::google::protobuf::int32 value);
  
  // required .PKCWinLose m_cWinLose = 9;
  inline bool has_m_cwinlose() const;
  inline void clear_m_cwinlose();
  static const int kMCWinLoseFieldNumber = 9;
  inline const ::PKCWinLose& m_cwinlose() const;
  inline ::PKCWinLose* mutable_m_cwinlose();
  inline ::PKCWinLose* release_m_cwinlose();
  
  // required .PKCWinLose m_cWinLose_Today = 10;
  inline bool has_m_cwinlose_today() const;
  inline void clear_m_cwinlose_today();
  static const int kMCWinLoseTodayFieldNumber = 10;
  inline const ::PKCWinLose& m_cwinlose_today() const;
  inline ::PKCWinLose* mutable_m_cwinlose_today();
  inline ::PKCWinLose* release_m_cwinlose_today();
  
  // required .PKCWinLose m_cWinLose_Room = 11;
  inline bool has_m_cwinlose_room() const;
  inline void clear_m_cwinlose_room();
  static const int kMCWinLoseRoomFieldNumber = 11;
  inline const ::PKCWinLose& m_cwinlose_room() const;
  inline ::PKCWinLose* mutable_m_cwinlose_room();
  inline ::PKCWinLose* release_m_cwinlose_room();
  
  // required sint64 m_llCMoney = 12;
  inline bool has_m_llcmoney() const;
  inline void clear_m_llcmoney();
  static const int kMLlCMoneyFieldNumber = 12;
  inline ::google::protobuf::int64 m_llcmoney() const;
  inline void set_m_llcmoney(::google::protobuf::int64 value);
  
  // required sint64 m_llFMoney = 13;
  inline bool has_m_llfmoney() const;
  inline void clear_m_llfmoney();
  static const int kMLlFMoneyFieldNumber = 13;
  inline ::google::protobuf::int64 m_llfmoney() const;
  inline void set_m_llfmoney(::google::protobuf::int64 value);
  
  // required sint32 m_lExit = 14;
  inline bool has_m_lexit() const;
  inline void clear_m_lexit();
  static const int kMLExitFieldNumber = 14;
  inline ::google::protobuf::int32 m_lexit() const;
  inline void set_m_lexit(::google::protobuf::int32 value);
  
  // required sint32 m_nItemType = 15;
  inline bool has_m_nitemtype() const;
  inline void clear_m_nitemtype();
  static const int kMNItemTypeFieldNumber = 15;
  inline ::google::protobuf::int32 m_nitemtype() const;
  inline void set_m_nitemtype(::google::protobuf::int32 value);
  
  // required sint32 m_lAck = 16;
  inline bool has_m_lack() const;
  inline void clear_m_lack();
  static const int kMLAckFieldNumber = 16;
  inline ::google::protobuf::int32 m_lack() const;
  inline void set_m_lack(::google::protobuf::int32 value);
  
  // required sint32 m_lJackpot = 17;
  inline bool has_m_ljackpot() const;
  inline void clear_m_ljackpot();
  static const int kMLJackpotFieldNumber = 17;
  inline ::google::protobuf::int32 m_ljackpot() const;
  inline void set_m_ljackpot(::google::protobuf::int32 value);
  
  // required sint32 m_lDieCardsDealt = 18;
  inline bool has_m_ldiecardsdealt() const;
  inline void clear_m_ldiecardsdealt();
  static const int kMLDieCardsDealtFieldNumber = 18;
  inline ::google::protobuf::int32 m_ldiecardsdealt() const;
  inline void set_m_ldiecardsdealt(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PKUserInfo)
 private:
  inline void set_has_m_lusn();
  inline void clear_has_m_lusn();
  inline void set_has_m_nindex();
  inline void clear_has_m_nindex();
  inline void set_has_m_snickname();
  inline void clear_has_m_snickname();
  inline void set_has_m_sid();
  inline void clear_has_m_sid();
  inline void set_has_m_lclevel();
  inline void clear_has_m_lclevel();
  inline void set_has_m_lsoundtype();
  inline void clear_has_m_lsoundtype();
  inline void set_has_m_savt();
  inline void clear_has_m_savt();
  inline void set_has_m_luserstate();
  inline void clear_has_m_luserstate();
  inline void set_has_m_cwinlose();
  inline void clear_has_m_cwinlose();
  inline void set_has_m_cwinlose_today();
  inline void clear_has_m_cwinlose_today();
  inline void set_has_m_cwinlose_room();
  inline void clear_has_m_cwinlose_room();
  inline void set_has_m_llcmoney();
  inline void clear_has_m_llcmoney();
  inline void set_has_m_llfmoney();
  inline void clear_has_m_llfmoney();
  inline void set_has_m_lexit();
  inline void clear_has_m_lexit();
  inline void set_has_m_nitemtype();
  inline void clear_has_m_nitemtype();
  inline void set_has_m_lack();
  inline void clear_has_m_lack();
  inline void set_has_m_ljackpot();
  inline void clear_has_m_ljackpot();
  inline void set_has_m_ldiecardsdealt();
  inline void clear_has_m_ldiecardsdealt();
  
  ::google::protobuf::int32 m_lusn_;
  ::google::protobuf::int32 m_nindex_;
  ::std::string* m_snickname_;
  ::std::string* m_sid_;
  ::google::protobuf::int32 m_lclevel_;
  ::google::protobuf::int32 m_lsoundtype_;
  ::std::string* m_savt_;
  ::PKCWinLose* m_cwinlose_;
  ::PKCWinLose* m_cwinlose_today_;
  ::PKCWinLose* m_cwinlose_room_;
  ::google::protobuf::int32 m_luserstate_;
  ::google::protobuf::int32 m_lexit_;
  ::google::protobuf::int64 m_llcmoney_;
  ::google::protobuf::int64 m_llfmoney_;
  ::google::protobuf::int32 m_nitemtype_;
  ::google::protobuf::int32 m_lack_;
  ::google::protobuf::int32 m_ljackpot_;
  ::google::protobuf::int32 m_ldiecardsdealt_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(18 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKUserInfo* default_instance_;
};
// -------------------------------------------------------------------

class PKOneCard : public ::google::protobuf::MessageLite {
 public:
  PKOneCard();
  virtual ~PKOneCard();
  
  PKOneCard(const PKOneCard& from);
  
  inline PKOneCard& operator=(const PKOneCard& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKOneCard& default_instance();
  
  void Swap(PKOneCard* other);
  
  // implements Message ----------------------------------------------
  
  PKOneCard* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKOneCard& from);
  void MergeFrom(const PKOneCard& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 m_nIndex = 1;
  inline bool has_m_nindex() const;
  inline void clear_m_nindex();
  static const int kMNIndexFieldNumber = 1;
  inline ::google::protobuf::int32 m_nindex() const;
  inline void set_m_nindex(::google::protobuf::int32 value);
  
  // required int32 m_lCardIndex = 2;
  inline bool has_m_lcardindex() const;
  inline void clear_m_lcardindex();
  static const int kMLCardIndexFieldNumber = 2;
  inline ::google::protobuf::int32 m_lcardindex() const;
  inline void set_m_lcardindex(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PKOneCard)
 private:
  inline void set_has_m_nindex();
  inline void clear_has_m_nindex();
  inline void set_has_m_lcardindex();
  inline void clear_has_m_lcardindex();
  
  ::google::protobuf::int32 m_nindex_;
  ::google::protobuf::int32 m_lcardindex_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKOneCard* default_instance_;
};
// -------------------------------------------------------------------

class PKVecMoney : public ::google::protobuf::MessageLite {
 public:
  PKVecMoney();
  virtual ~PKVecMoney();
  
  PKVecMoney(const PKVecMoney& from);
  
  inline PKVecMoney& operator=(const PKVecMoney& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKVecMoney& default_instance();
  
  void Swap(PKVecMoney* other);
  
  // implements Message ----------------------------------------------
  
  PKVecMoney* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKVecMoney& from);
  void MergeFrom(const PKVecMoney& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint64 VecMoney = 1;
  inline bool has_vecmoney() const;
  inline void clear_vecmoney();
  static const int kVecMoneyFieldNumber = 1;
  inline ::google::protobuf::int64 vecmoney() const;
  inline void set_vecmoney(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:PKVecMoney)
 private:
  inline void set_has_vecmoney();
  inline void clear_has_vecmoney();
  
  ::google::protobuf::int64 vecmoney_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKVecMoney* default_instance_;
};
// -------------------------------------------------------------------

class PKWinLoseInfo : public ::google::protobuf::MessageLite {
 public:
  PKWinLoseInfo();
  virtual ~PKWinLoseInfo();
  
  PKWinLoseInfo(const PKWinLoseInfo& from);
  
  inline PKWinLoseInfo& operator=(const PKWinLoseInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKWinLoseInfo& default_instance();
  
  void Swap(PKWinLoseInfo* other);
  
  // implements Message ----------------------------------------------
  
  PKWinLoseInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKWinLoseInfo& from);
  void MergeFrom(const PKWinLoseInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint64 m_llCMoney = 1;
  inline bool has_m_llcmoney() const;
  inline void clear_m_llcmoney();
  static const int kMLlCMoneyFieldNumber = 1;
  inline ::google::protobuf::int64 m_llcmoney() const;
  inline void set_m_llcmoney(::google::protobuf::int64 value);
  
  // required sint32 m_lWin = 2;
  inline bool has_m_lwin() const;
  inline void clear_m_lwin();
  static const int kMLWinFieldNumber = 2;
  inline ::google::protobuf::int32 m_lwin() const;
  inline void set_m_lwin(::google::protobuf::int32 value);
  
  // required sint32 m_lLose = 3;
  inline bool has_m_llose() const;
  inline void clear_m_llose();
  static const int kMLLoseFieldNumber = 3;
  inline ::google::protobuf::int32 m_llose() const;
  inline void set_m_llose(::google::protobuf::int32 value);
  
  // required sint32 m_lReserved = 4;
  inline bool has_m_lreserved() const;
  inline void clear_m_lreserved();
  static const int kMLReservedFieldNumber = 4;
  inline ::google::protobuf::int32 m_lreserved() const;
  inline void set_m_lreserved(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PKWinLoseInfo)
 private:
  inline void set_has_m_llcmoney();
  inline void clear_has_m_llcmoney();
  inline void set_has_m_lwin();
  inline void clear_has_m_lwin();
  inline void set_has_m_llose();
  inline void clear_has_m_llose();
  inline void set_has_m_lreserved();
  inline void clear_has_m_lreserved();
  
  ::google::protobuf::int64 m_llcmoney_;
  ::google::protobuf::int32 m_lwin_;
  ::google::protobuf::int32 m_llose_;
  ::google::protobuf::int32 m_lreserved_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKWinLoseInfo* default_instance_;
};
// -------------------------------------------------------------------

class PKVecUSN : public ::google::protobuf::MessageLite {
 public:
  PKVecUSN();
  virtual ~PKVecUSN();
  
  PKVecUSN(const PKVecUSN& from);
  
  inline PKVecUSN& operator=(const PKVecUSN& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKVecUSN& default_instance();
  
  void Swap(PKVecUSN* other);
  
  // implements Message ----------------------------------------------
  
  PKVecUSN* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKVecUSN& from);
  void MergeFrom(const PKVecUSN& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int64 USN = 1;
  inline bool has_usn() const;
  inline void clear_usn();
  static const int kUSNFieldNumber = 1;
  inline ::google::protobuf::int64 usn() const;
  inline void set_usn(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:PKVecUSN)
 private:
  inline void set_has_usn();
  inline void clear_has_usn();
  
  ::google::protobuf::int64 usn_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKVecUSN* default_instance_;
};
// -------------------------------------------------------------------

class PKWAITINGUSERDATA : public ::google::protobuf::MessageLite {
 public:
  PKWAITINGUSERDATA();
  virtual ~PKWAITINGUSERDATA();
  
  PKWAITINGUSERDATA(const PKWAITINGUSERDATA& from);
  
  inline PKWAITINGUSERDATA& operator=(const PKWAITINGUSERDATA& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKWAITINGUSERDATA& default_instance();
  
  void Swap(PKWAITINGUSERDATA* other);
  
  // implements Message ----------------------------------------------
  
  PKWAITINGUSERDATA* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKWAITINGUSERDATA& from);
  void MergeFrom(const PKWAITINGUSERDATA& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 m_lUSN = 1;
  inline bool has_m_lusn() const;
  inline void clear_m_lusn();
  static const int kMLUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lusn() const;
  inline void set_m_lusn(::google::protobuf::int32 value);
  
  // required int32 m_lTicketNum = 2;
  inline bool has_m_lticketnum() const;
  inline void clear_m_lticketnum();
  static const int kMLTicketNumFieldNumber = 2;
  inline ::google::protobuf::int32 m_lticketnum() const;
  inline void set_m_lticketnum(::google::protobuf::int32 value);
  
  // required int32 m_lBackColor = 3;
  inline bool has_m_lbackcolor() const;
  inline void clear_m_lbackcolor();
  static const int kMLBackColorFieldNumber = 3;
  inline ::google::protobuf::int32 m_lbackcolor() const;
  inline void set_m_lbackcolor(::google::protobuf::int32 value);
  
  // required int32 m_bCallWeb = 4;
  inline bool has_m_bcallweb() const;
  inline void clear_m_bcallweb();
  static const int kMBCallWebFieldNumber = 4;
  inline ::google::protobuf::int32 m_bcallweb() const;
  inline void set_m_bcallweb(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PKWAITINGUSERDATA)
 private:
  inline void set_has_m_lusn();
  inline void clear_has_m_lusn();
  inline void set_has_m_lticketnum();
  inline void clear_has_m_lticketnum();
  inline void set_has_m_lbackcolor();
  inline void clear_has_m_lbackcolor();
  inline void set_has_m_bcallweb();
  inline void clear_has_m_bcallweb();
  
  ::google::protobuf::int32 m_lusn_;
  ::google::protobuf::int32 m_lticketnum_;
  ::google::protobuf::int32 m_lbackcolor_;
  ::google::protobuf::int32 m_bcallweb_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKWAITINGUSERDATA* default_instance_;
};
// -------------------------------------------------------------------

class CRefill : public ::google::protobuf::MessageLite {
 public:
  CRefill();
  virtual ~CRefill();
  
  CRefill(const CRefill& from);
  
  inline CRefill& operator=(const CRefill& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const CRefill& default_instance();
  
  void Swap(CRefill* other);
  
  // implements Message ----------------------------------------------
  
  CRefill* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CRefill& from);
  void MergeFrom(const CRefill& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int64 m_llTime = 1;
  inline bool has_m_lltime() const;
  inline void clear_m_lltime();
  static const int kMLlTimeFieldNumber = 1;
  inline ::google::protobuf::int64 m_lltime() const;
  inline void set_m_lltime(::google::protobuf::int64 value);
  
  // required int32 m_nCnt = 2;
  inline bool has_m_ncnt() const;
  inline void clear_m_ncnt();
  static const int kMNCntFieldNumber = 2;
  inline ::google::protobuf::int32 m_ncnt() const;
  inline void set_m_ncnt(::google::protobuf::int32 value);
  
  // required int32 m_lPLevel = 3;
  inline bool has_m_lplevel() const;
  inline void clear_m_lplevel();
  static const int kMLPLevelFieldNumber = 3;
  inline ::google::protobuf::int32 m_lplevel() const;
  inline void set_m_lplevel(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:CRefill)
 private:
  inline void set_has_m_lltime();
  inline void clear_has_m_lltime();
  inline void set_has_m_ncnt();
  inline void clear_has_m_ncnt();
  inline void set_has_m_lplevel();
  inline void clear_has_m_lplevel();
  
  ::google::protobuf::int64 m_lltime_;
  ::google::protobuf::int32 m_ncnt_;
  ::google::protobuf::int32 m_lplevel_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static CRefill* default_instance_;
};
// -------------------------------------------------------------------

class PKItemList : public ::google::protobuf::MessageLite {
 public:
  PKItemList();
  virtual ~PKItemList();
  
  PKItemList(const PKItemList& from);
  
  inline PKItemList& operator=(const PKItemList& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKItemList& default_instance();
  
  void Swap(PKItemList* other);
  
  // implements Message ----------------------------------------------
  
  PKItemList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKItemList& from);
  void MergeFrom(const PKItemList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .PKItem m_lstItem = 1;
  inline int m_lstitem_size() const;
  inline void clear_m_lstitem();
  static const int kMLstItemFieldNumber = 1;
  inline const ::PKItem& m_lstitem(int index) const;
  inline ::PKItem* mutable_m_lstitem(int index);
  inline ::PKItem* add_m_lstitem();
  inline const ::google::protobuf::RepeatedPtrField< ::PKItem >&
      m_lstitem() const;
  inline ::google::protobuf::RepeatedPtrField< ::PKItem >*
      mutable_m_lstitem();
  
  // @@protoc_insertion_point(class_scope:PKItemList)
 private:
  
  ::google::protobuf::RepeatedPtrField< ::PKItem > m_lstitem_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKItemList* default_instance_;
};
// -------------------------------------------------------------------

class PKItem : public ::google::protobuf::MessageLite {
 public:
  PKItem();
  virtual ~PKItem();
  
  PKItem(const PKItem& from);
  
  inline PKItem& operator=(const PKItem& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKItem& default_instance();
  
  void Swap(PKItem* other);
  
  // implements Message ----------------------------------------------
  
  PKItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKItem& from);
  void MergeFrom(const PKItem& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 m_lFucnsrl = 1;
  inline bool has_m_lfucnsrl() const;
  inline void clear_m_lfucnsrl();
  static const int kMLFucnsrlFieldNumber = 1;
  inline ::google::protobuf::int32 m_lfucnsrl() const;
  inline void set_m_lfucnsrl(::google::protobuf::int32 value);
  
  // required int64 m_llStartTime = 2;
  inline bool has_m_llstarttime() const;
  inline void clear_m_llstarttime();
  static const int kMLlStartTimeFieldNumber = 2;
  inline ::google::protobuf::int64 m_llstarttime() const;
  inline void set_m_llstarttime(::google::protobuf::int64 value);
  
  // required int64 m_llEndTime = 3;
  inline bool has_m_llendtime() const;
  inline void clear_m_llendtime();
  static const int kMLlEndTimeFieldNumber = 3;
  inline ::google::protobuf::int64 m_llendtime() const;
  inline void set_m_llendtime(::google::protobuf::int64 value);
  
  // required int64 m_llCount = 4;
  inline bool has_m_llcount() const;
  inline void clear_m_llcount();
  static const int kMLlCountFieldNumber = 4;
  inline ::google::protobuf::int64 m_llcount() const;
  inline void set_m_llcount(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:PKItem)
 private:
  inline void set_has_m_lfucnsrl();
  inline void clear_has_m_lfucnsrl();
  inline void set_has_m_llstarttime();
  inline void clear_has_m_llstarttime();
  inline void set_has_m_llendtime();
  inline void clear_has_m_llendtime();
  inline void set_has_m_llcount();
  inline void clear_has_m_llcount();
  
  ::google::protobuf::int64 m_llstarttime_;
  ::google::protobuf::int64 m_llendtime_;
  ::google::protobuf::int64 m_llcount_;
  ::google::protobuf::int32 m_lfucnsrl_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKItem* default_instance_;
};
// -------------------------------------------------------------------

class PKRCUserData : public ::google::protobuf::MessageLite {
 public:
  PKRCUserData();
  virtual ~PKRCUserData();
  
  PKRCUserData(const PKRCUserData& from);
  
  inline PKRCUserData& operator=(const PKRCUserData& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKRCUserData& default_instance();
  
  void Swap(PKRCUserData* other);
  
  // implements Message ----------------------------------------------
  
  PKRCUserData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKRCUserData& from);
  void MergeFrom(const PKRCUserData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:PKRCUserData)
 private:
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKRCUserData* default_instance_;
};
// -------------------------------------------------------------------

class PKOption : public ::google::protobuf::MessageLite {
 public:
  PKOption();
  virtual ~PKOption();
  
  PKOption(const PKOption& from);
  
  inline PKOption& operator=(const PKOption& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKOption& default_instance();
  
  void Swap(PKOption* other);
  
  // implements Message ----------------------------------------------
  
  PKOption* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKOption& from);
  void MergeFrom(const PKOption& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string m_sRoomTitle = 1;
  inline bool has_m_sroomtitle() const;
  inline void clear_m_sroomtitle();
  static const int kMSRoomTitleFieldNumber = 1;
  inline const ::std::string& m_sroomtitle() const;
  inline void set_m_sroomtitle(const ::std::string& value);
  inline void set_m_sroomtitle(const char* value);
  inline void set_m_sroomtitle(const char* value, size_t size);
  inline ::std::string* mutable_m_sroomtitle();
  inline ::std::string* release_m_sroomtitle();
  
  // required string m_sPassword = 2;
  inline bool has_m_spassword() const;
  inline void clear_m_spassword();
  static const int kMSPasswordFieldNumber = 2;
  inline const ::std::string& m_spassword() const;
  inline void set_m_spassword(const ::std::string& value);
  inline void set_m_spassword(const char* value);
  inline void set_m_spassword(const char* value, size_t size);
  inline ::std::string* mutable_m_spassword();
  inline ::std::string* release_m_spassword();
  
  // required int32 m_lMaxUserCnt = 3;
  inline bool has_m_lmaxusercnt() const;
  inline void clear_m_lmaxusercnt();
  static const int kMLMaxUserCntFieldNumber = 3;
  inline ::google::protobuf::int32 m_lmaxusercnt() const;
  inline void set_m_lmaxusercnt(::google::protobuf::int32 value);
  
  // required int32 m_lMaxPlayerUserCnt = 4;
  inline bool has_m_lmaxplayerusercnt() const;
  inline void clear_m_lmaxplayerusercnt();
  static const int kMLMaxPlayerUserCntFieldNumber = 4;
  inline ::google::protobuf::int32 m_lmaxplayerusercnt() const;
  inline void set_m_lmaxplayerusercnt(::google::protobuf::int32 value);
  
  // required int32 m_lMaxPlayerCardCnt = 5;
  inline bool has_m_lmaxplayercardcnt() const;
  inline void clear_m_lmaxplayercardcnt();
  static const int kMLMaxPlayerCardCntFieldNumber = 5;
  inline ::google::protobuf::int32 m_lmaxplayercardcnt() const;
  inline void set_m_lmaxplayercardcnt(::google::protobuf::int32 value);
  
  // required int32 m_lChoiceMode = 6;
  inline bool has_m_lchoicemode() const;
  inline void clear_m_lchoicemode();
  static const int kMLChoiceModeFieldNumber = 6;
  inline ::google::protobuf::int32 m_lchoicemode() const;
  inline void set_m_lchoicemode(::google::protobuf::int32 value);
  
  // required int32 m_lRoomType = 7;
  inline bool has_m_lroomtype() const;
  inline void clear_m_lroomtype();
  static const int kMLRoomTypeFieldNumber = 7;
  inline ::google::protobuf::int32 m_lroomtype() const;
  inline void set_m_lroomtype(::google::protobuf::int32 value);
  
  // required int32 m_lBetRule = 8;
  inline bool has_m_lbetrule() const;
  inline void clear_m_lbetrule();
  static const int kMLBetRuleFieldNumber = 8;
  inline ::google::protobuf::int32 m_lbetrule() const;
  inline void set_m_lbetrule(::google::protobuf::int32 value);
  
  // required int32 m_lBetType = 9;
  inline bool has_m_lbettype() const;
  inline void clear_m_lbettype();
  static const int kMLBetTypeFieldNumber = 9;
  inline ::google::protobuf::int32 m_lbettype() const;
  inline void set_m_lbettype(::google::protobuf::int32 value);
  
  // required int32 m_lAddRule = 10;
  inline bool has_m_laddrule() const;
  inline void clear_m_laddrule();
  static const int kMLAddRuleFieldNumber = 10;
  inline ::google::protobuf::int32 m_laddrule() const;
  inline void set_m_laddrule(::google::protobuf::int32 value);
  
  // required int32 m_lRematchJoin = 11;
  inline bool has_m_lrematchjoin() const;
  inline void clear_m_lrematchjoin();
  static const int kMLRematchJoinFieldNumber = 11;
  inline ::google::protobuf::int32 m_lrematchjoin() const;
  inline void set_m_lrematchjoin(::google::protobuf::int32 value);
  
  // required int32 m_lLimitMoney = 12;
  inline bool has_m_llimitmoney() const;
  inline void clear_m_llimitmoney();
  static const int kMLLimitMoneyFieldNumber = 12;
  inline ::google::protobuf::int32 m_llimitmoney() const;
  inline void set_m_llimitmoney(::google::protobuf::int32 value);
  
  // required sint64 m_llGameAnteMoney = 13;
  inline bool has_m_llgameantemoney() const;
  inline void clear_m_llgameantemoney();
  static const int kMLlGameAnteMoneyFieldNumber = 13;
  inline ::google::protobuf::int64 m_llgameantemoney() const;
  inline void set_m_llgameantemoney(::google::protobuf::int64 value);
  
  // required int32 m_bEcho = 14;
  inline bool has_m_becho() const;
  inline void clear_m_becho();
  static const int kMBEchoFieldNumber = 14;
  inline ::google::protobuf::int32 m_becho() const;
  inline void set_m_becho(::google::protobuf::int32 value);
  
  // required int32 m_lMakeUSN = 15;
  inline bool has_m_lmakeusn() const;
  inline void clear_m_lmakeusn();
  static const int kMLMakeUSNFieldNumber = 15;
  inline ::google::protobuf::int32 m_lmakeusn() const;
  inline void set_m_lmakeusn(::google::protobuf::int32 value);
  
  // required int32 m_lCategory = 16;
  inline bool has_m_lcategory() const;
  inline void clear_m_lcategory();
  static const int kMLCategoryFieldNumber = 16;
  inline ::google::protobuf::int32 m_lcategory() const;
  inline void set_m_lcategory(::google::protobuf::int32 value);
  
  // required int32 m_lChannelID = 17;
  inline bool has_m_lchannelid() const;
  inline void clear_m_lchannelid();
  static const int kMLChannelIDFieldNumber = 17;
  inline ::google::protobuf::int32 m_lchannelid() const;
  inline void set_m_lchannelid(::google::protobuf::int32 value);
  
  // required sint64 m_llAnteMoney = 18;
  inline bool has_m_llantemoney() const;
  inline void clear_m_llantemoney();
  static const int kMLlAnteMoneyFieldNumber = 18;
  inline ::google::protobuf::int64 m_llantemoney() const;
  inline void set_m_llantemoney(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:PKOption)
 private:
  inline void set_has_m_sroomtitle();
  inline void clear_has_m_sroomtitle();
  inline void set_has_m_spassword();
  inline void clear_has_m_spassword();
  inline void set_has_m_lmaxusercnt();
  inline void clear_has_m_lmaxusercnt();
  inline void set_has_m_lmaxplayerusercnt();
  inline void clear_has_m_lmaxplayerusercnt();
  inline void set_has_m_lmaxplayercardcnt();
  inline void clear_has_m_lmaxplayercardcnt();
  inline void set_has_m_lchoicemode();
  inline void clear_has_m_lchoicemode();
  inline void set_has_m_lroomtype();
  inline void clear_has_m_lroomtype();
  inline void set_has_m_lbetrule();
  inline void clear_has_m_lbetrule();
  inline void set_has_m_lbettype();
  inline void clear_has_m_lbettype();
  inline void set_has_m_laddrule();
  inline void clear_has_m_laddrule();
  inline void set_has_m_lrematchjoin();
  inline void clear_has_m_lrematchjoin();
  inline void set_has_m_llimitmoney();
  inline void clear_has_m_llimitmoney();
  inline void set_has_m_llgameantemoney();
  inline void clear_has_m_llgameantemoney();
  inline void set_has_m_becho();
  inline void clear_has_m_becho();
  inline void set_has_m_lmakeusn();
  inline void clear_has_m_lmakeusn();
  inline void set_has_m_lcategory();
  inline void clear_has_m_lcategory();
  inline void set_has_m_lchannelid();
  inline void clear_has_m_lchannelid();
  inline void set_has_m_llantemoney();
  inline void clear_has_m_llantemoney();
  
  ::std::string* m_sroomtitle_;
  ::std::string* m_spassword_;
  ::google::protobuf::int32 m_lmaxusercnt_;
  ::google::protobuf::int32 m_lmaxplayerusercnt_;
  ::google::protobuf::int32 m_lmaxplayercardcnt_;
  ::google::protobuf::int32 m_lchoicemode_;
  ::google::protobuf::int32 m_lroomtype_;
  ::google::protobuf::int32 m_lbetrule_;
  ::google::protobuf::int32 m_lbettype_;
  ::google::protobuf::int32 m_laddrule_;
  ::google::protobuf::int32 m_lrematchjoin_;
  ::google::protobuf::int32 m_llimitmoney_;
  ::google::protobuf::int64 m_llgameantemoney_;
  ::google::protobuf::int32 m_becho_;
  ::google::protobuf::int32 m_lmakeusn_;
  ::google::protobuf::int32 m_lcategory_;
  ::google::protobuf::int32 m_lchannelid_;
  ::google::protobuf::int64 m_llantemoney_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(18 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKOption* default_instance_;
};
// -------------------------------------------------------------------

class PKRCUser : public ::google::protobuf::MessageLite {
 public:
  PKRCUser();
  virtual ~PKRCUser();
  
  PKRCUser(const PKRCUser& from);
  
  inline PKRCUser& operator=(const PKRCUser& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKRCUser& default_instance();
  
  void Swap(PKRCUser* other);
  
  // implements Message ----------------------------------------------
  
  PKRCUser* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKRCUser& from);
  void MergeFrom(const PKRCUser& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 m_lUSN = 1;
  inline bool has_m_lusn() const;
  inline void clear_m_lusn();
  static const int kMLUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lusn() const;
  inline void set_m_lusn(::google::protobuf::int32 value);
  
  // required int32 m_lJumin = 2;
  inline bool has_m_ljumin() const;
  inline void clear_m_ljumin();
  static const int kMLJuminFieldNumber = 2;
  inline ::google::protobuf::int32 m_ljumin() const;
  inline void set_m_ljumin(::google::protobuf::int32 value);
  
  // required int32 m_lFirstUSN = 3;
  inline bool has_m_lfirstusn() const;
  inline void clear_m_lfirstusn();
  static const int kMLFirstUSNFieldNumber = 3;
  inline ::google::protobuf::int32 m_lfirstusn() const;
  inline void set_m_lfirstusn(::google::protobuf::int32 value);
  
  // required int32 m_lAgeIndex = 4;
  inline bool has_m_lageindex() const;
  inline void clear_m_lageindex();
  static const int kMLAgeIndexFieldNumber = 4;
  inline ::google::protobuf::int32 m_lageindex() const;
  inline void set_m_lageindex(::google::protobuf::int32 value);
  
  // required int32 m_lJobIndex = 5;
  inline bool has_m_ljobindex() const;
  inline void clear_m_ljobindex();
  static const int kMLJobIndexFieldNumber = 5;
  inline ::google::protobuf::int32 m_ljobindex() const;
  inline void set_m_ljobindex(::google::protobuf::int32 value);
  
  // required int32 m_lRegionIndex = 6;
  inline bool has_m_lregionindex() const;
  inline void clear_m_lregionindex();
  static const int kMLRegionIndexFieldNumber = 6;
  inline ::google::protobuf::int32 m_lregionindex() const;
  inline void set_m_lregionindex(::google::protobuf::int32 value);
  
  // required int32 m_lGuildIndex = 7;
  inline bool has_m_lguildindex() const;
  inline void clear_m_lguildindex();
  static const int kMLGuildIndexFieldNumber = 7;
  inline ::google::protobuf::int32 m_lguildindex() const;
  inline void set_m_lguildindex(::google::protobuf::int32 value);
  
  // required int32 m_lMemberIndex = 8;
  inline bool has_m_lmemberindex() const;
  inline void clear_m_lmemberindex();
  static const int kMLMemberIndexFieldNumber = 8;
  inline ::google::protobuf::int32 m_lmemberindex() const;
  inline void set_m_lmemberindex(::google::protobuf::int32 value);
  
  // required int32 m_lClientIP = 9;
  inline bool has_m_lclientip() const;
  inline void clear_m_lclientip();
  static const int kMLClientIPFieldNumber = 9;
  inline ::google::protobuf::int32 m_lclientip() const;
  inline void set_m_lclientip(::google::protobuf::int32 value);
  
  // required int32 m_lGatewayIP = 10;
  inline bool has_m_lgatewayip() const;
  inline void clear_m_lgatewayip();
  static const int kMLGatewayIPFieldNumber = 10;
  inline ::google::protobuf::int32 m_lgatewayip() const;
  inline void set_m_lgatewayip(::google::protobuf::int32 value);
  
  // required int32 m_lMacAddress = 11;
  inline bool has_m_lmacaddress() const;
  inline void clear_m_lmacaddress();
  static const int kMLMacAddressFieldNumber = 11;
  inline ::google::protobuf::int32 m_lmacaddress() const;
  inline void set_m_lmacaddress(::google::protobuf::int32 value);
  
  // required string m_sMobileInfo = 12;
  inline bool has_m_smobileinfo() const;
  inline void clear_m_smobileinfo();
  static const int kMSMobileInfoFieldNumber = 12;
  inline const ::std::string& m_smobileinfo() const;
  inline void set_m_smobileinfo(const ::std::string& value);
  inline void set_m_smobileinfo(const char* value);
  inline void set_m_smobileinfo(const char* value, size_t size);
  inline ::std::string* mutable_m_smobileinfo();
  inline ::std::string* release_m_smobileinfo();
  
  // required string m_sAuthKey = 13;
  inline bool has_m_sauthkey() const;
  inline void clear_m_sauthkey();
  static const int kMSAuthKeyFieldNumber = 13;
  inline const ::std::string& m_sauthkey() const;
  inline void set_m_sauthkey(const ::std::string& value);
  inline void set_m_sauthkey(const char* value);
  inline void set_m_sauthkey(const char* value, size_t size);
  inline ::std::string* mutable_m_sauthkey();
  inline ::std::string* release_m_sauthkey();
  
  // required string m_sUserGameData = 14;
  inline bool has_m_susergamedata() const;
  inline void clear_m_susergamedata();
  static const int kMSUserGameDataFieldNumber = 14;
  inline const ::std::string& m_susergamedata() const;
  inline void set_m_susergamedata(const ::std::string& value);
  inline void set_m_susergamedata(const char* value);
  inline void set_m_susergamedata(const char* value, size_t size);
  inline ::std::string* mutable_m_susergamedata();
  inline ::std::string* release_m_susergamedata();
  
  // required int32 m_nIndex = 15;
  inline bool has_m_nindex() const;
  inline void clear_m_nindex();
  static const int kMNIndexFieldNumber = 15;
  inline ::google::protobuf::int32 m_nindex() const;
  inline void set_m_nindex(::google::protobuf::int32 value);
  
  // required string m_sNickName = 16;
  inline bool has_m_snickname() const;
  inline void clear_m_snickname();
  static const int kMSNickNameFieldNumber = 16;
  inline const ::std::string& m_snickname() const;
  inline void set_m_snickname(const ::std::string& value);
  inline void set_m_snickname(const char* value);
  inline void set_m_snickname(const char* value, size_t size);
  inline ::std::string* mutable_m_snickname();
  inline ::std::string* release_m_snickname();
  
  // required string m_sUserID = 17;
  inline bool has_m_suserid() const;
  inline void clear_m_suserid();
  static const int kMSUserIDFieldNumber = 17;
  inline const ::std::string& m_suserid() const;
  inline void set_m_suserid(const ::std::string& value);
  inline void set_m_suserid(const char* value);
  inline void set_m_suserid(const char* value, size_t size);
  inline ::std::string* mutable_m_suserid();
  inline ::std::string* release_m_suserid();
  
  // required string m_sAvt = 18;
  inline bool has_m_savt() const;
  inline void clear_m_savt();
  static const int kMSAvtFieldNumber = 18;
  inline const ::std::string& m_savt() const;
  inline void set_m_savt(const ::std::string& value);
  inline void set_m_savt(const char* value);
  inline void set_m_savt(const char* value, size_t size);
  inline ::std::string* mutable_m_savt();
  inline ::std::string* release_m_savt();
  
  // required int32 m_lCLevel = 19;
  inline bool has_m_lclevel() const;
  inline void clear_m_lclevel();
  static const int kMLCLevelFieldNumber = 19;
  inline ::google::protobuf::int32 m_lclevel() const;
  inline void set_m_lclevel(::google::protobuf::int32 value);
  
  // required int32 m_lSex = 20;
  inline bool has_m_lsex() const;
  inline void clear_m_lsex();
  static const int kMLSexFieldNumber = 20;
  inline ::google::protobuf::int32 m_lsex() const;
  inline void set_m_lsex(::google::protobuf::int32 value);
  
  // required int64 m_llCMoney = 21;
  inline bool has_m_llcmoney() const;
  inline void clear_m_llcmoney();
  static const int kMLlCMoneyFieldNumber = 21;
  inline ::google::protobuf::int64 m_llcmoney() const;
  inline void set_m_llcmoney(::google::protobuf::int64 value);
  
  // required int64 m_llFMoney = 22;
  inline bool has_m_llfmoney() const;
  inline void clear_m_llfmoney();
  static const int kMLlFMoneyFieldNumber = 22;
  inline ::google::protobuf::int64 m_llfmoney() const;
  inline void set_m_llfmoney(::google::protobuf::int64 value);
  
  // required int64 m_llSafeMoney = 23;
  inline bool has_m_llsafemoney() const;
  inline void clear_m_llsafemoney();
  static const int kMLlSafeMoneyFieldNumber = 23;
  inline ::google::protobuf::int64 m_llsafemoney() const;
  inline void set_m_llsafemoney(::google::protobuf::int64 value);
  
  // required int64 m_llPlastAllinDate = 24;
  inline bool has_m_llplastallindate() const;
  inline void clear_m_llplastallindate();
  static const int kMLlPlastAllinDateFieldNumber = 24;
  inline ::google::protobuf::int64 m_llplastallindate() const;
  inline void set_m_llplastallindate(::google::protobuf::int64 value);
  
  // required int64 m_llPlastLogonDay = 25;
  inline bool has_m_llplastlogonday() const;
  inline void clear_m_llplastlogonday();
  static const int kMLlPlastLogonDayFieldNumber = 25;
  inline ::google::protobuf::int64 m_llplastlogonday() const;
  inline void set_m_llplastlogonday(::google::protobuf::int64 value);
  
  // required int32 m_lMTodayPlayCount = 26;
  inline bool has_m_lmtodayplaycount() const;
  inline void clear_m_lmtodayplaycount();
  static const int kMLMTodayPlayCountFieldNumber = 26;
  inline ::google::protobuf::int32 m_lmtodayplaycount() const;
  inline void set_m_lmtodayplaycount(::google::protobuf::int32 value);
  
  // required int32 m_lMTodayPlayTime = 27;
  inline bool has_m_lmtodayplaytime() const;
  inline void clear_m_lmtodayplaytime();
  static const int kMLMTodayPlayTimeFieldNumber = 27;
  inline ::google::protobuf::int32 m_lmtodayplaytime() const;
  inline void set_m_lmtodayplaytime(::google::protobuf::int32 value);
  
  // required int32 m_lPTotalPlayCount = 28;
  inline bool has_m_lptotalplaycount() const;
  inline void clear_m_lptotalplaycount();
  static const int kMLPTotalPlayCountFieldNumber = 28;
  inline ::google::protobuf::int32 m_lptotalplaycount() const;
  inline void set_m_lptotalplaycount(::google::protobuf::int32 value);
  
  // required .CRefill m_cRefill = 29;
  inline bool has_m_crefill() const;
  inline void clear_m_crefill();
  static const int kMCRefillFieldNumber = 29;
  inline const ::CRefill& m_crefill() const;
  inline ::CRefill* mutable_m_crefill();
  inline ::CRefill* release_m_crefill();
  
  // required int64 m_llPExtMoney = 30;
  inline bool has_m_llpextmoney() const;
  inline void clear_m_llpextmoney();
  static const int kMLlPExtMoneyFieldNumber = 30;
  inline ::google::protobuf::int64 m_llpextmoney() const;
  inline void set_m_llpextmoney(::google::protobuf::int64 value);
  
  // required int64 m_llPExtendDate = 31;
  inline bool has_m_llpextenddate() const;
  inline void clear_m_llpextenddate();
  static const int kMLlPExtendDateFieldNumber = 31;
  inline ::google::protobuf::int64 m_llpextenddate() const;
  inline void set_m_llpextenddate(::google::protobuf::int64 value);
  
  // required int64 m_llPBonusDate = 32;
  inline bool has_m_llpbonusdate() const;
  inline void clear_m_llpbonusdate();
  static const int kMLlPBonusDateFieldNumber = 32;
  inline ::google::protobuf::int64 m_llpbonusdate() const;
  inline void set_m_llpbonusdate(::google::protobuf::int64 value);
  
  // required int32 m_lMMonthPlayCount = 33;
  inline bool has_m_lmmonthplaycount() const;
  inline void clear_m_lmmonthplaycount();
  static const int kMLMMonthPlayCountFieldNumber = 33;
  inline ::google::protobuf::int32 m_lmmonthplaycount() const;
  inline void set_m_lmmonthplaycount(::google::protobuf::int32 value);
  
  // required int32 m_lMMonthPlayTime = 34;
  inline bool has_m_lmmonthplaytime() const;
  inline void clear_m_lmmonthplaytime();
  static const int kMLMMonthPlayTimeFieldNumber = 34;
  inline ::google::protobuf::int32 m_lmmonthplaytime() const;
  inline void set_m_lmmonthplaytime(::google::protobuf::int32 value);
  
  // required .PKCWinLose m_cWinLose = 35;
  inline bool has_m_cwinlose() const;
  inline void clear_m_cwinlose();
  static const int kMCWinLoseFieldNumber = 35;
  inline const ::PKCWinLose& m_cwinlose() const;
  inline ::PKCWinLose* mutable_m_cwinlose();
  inline ::PKCWinLose* release_m_cwinlose();
  
  // required int32 m_lGDisCnt = 36;
  inline bool has_m_lgdiscnt() const;
  inline void clear_m_lgdiscnt();
  static const int kMLGDisCntFieldNumber = 36;
  inline ::google::protobuf::int32 m_lgdiscnt() const;
  inline void set_m_lgdiscnt(::google::protobuf::int32 value);
  
  // required int64 m_llGlastLogonDay = 37;
  inline bool has_m_llglastlogonday() const;
  inline void clear_m_llglastlogonday();
  static const int kMLlGlastLogonDayFieldNumber = 37;
  inline ::google::protobuf::int64 m_llglastlogonday() const;
  inline void set_m_llglastlogonday(::google::protobuf::int64 value);
  
  // required int64 m_llGRegDate = 38;
  inline bool has_m_llgregdate() const;
  inline void clear_m_llgregdate();
  static const int kMLlGRegDateFieldNumber = 38;
  inline ::google::protobuf::int64 m_llgregdate() const;
  inline void set_m_llgregdate(::google::protobuf::int64 value);
  
  // required int64 m_llGFirstPlayDate = 39;
  inline bool has_m_llgfirstplaydate() const;
  inline void clear_m_llgfirstplaydate();
  static const int kMLlGFirstPlayDateFieldNumber = 39;
  inline ::google::protobuf::int64 m_llgfirstplaydate() const;
  inline void set_m_llgfirstplaydate(::google::protobuf::int64 value);
  
  // required int32 m_lGTodayPlayCount = 40;
  inline bool has_m_lgtodayplaycount() const;
  inline void clear_m_lgtodayplaycount();
  static const int kMLGTodayPlayCountFieldNumber = 40;
  inline ::google::protobuf::int32 m_lgtodayplaycount() const;
  inline void set_m_lgtodayplaycount(::google::protobuf::int32 value);
  
  // required int32 m_lGTodayPlayTime = 41;
  inline bool has_m_lgtodayplaytime() const;
  inline void clear_m_lgtodayplaytime();
  static const int kMLGTodayPlayTimeFieldNumber = 41;
  inline ::google::protobuf::int32 m_lgtodayplaytime() const;
  inline void set_m_lgtodayplaytime(::google::protobuf::int32 value);
  
  // required int32 m_lGTotalPlayCount = 42;
  inline bool has_m_lgtotalplaycount() const;
  inline void clear_m_lgtotalplaycount();
  static const int kMLGTotalPlayCountFieldNumber = 42;
  inline ::google::protobuf::int32 m_lgtotalplaycount() const;
  inline void set_m_lgtotalplaycount(::google::protobuf::int32 value);
  
  // required int32 m_lGTotalPlayTime = 43;
  inline bool has_m_lgtotalplaytime() const;
  inline void clear_m_lgtotalplaytime();
  static const int kMLGTotalPlayTimeFieldNumber = 43;
  inline ::google::protobuf::int32 m_lgtotalplaytime() const;
  inline void set_m_lgtotalplaytime(::google::protobuf::int32 value);
  
  // required int32 m_lGAllinCnt = 44;
  inline bool has_m_lgallincnt() const;
  inline void clear_m_lgallincnt();
  static const int kMLGAllinCntFieldNumber = 44;
  inline ::google::protobuf::int32 m_lgallincnt() const;
  inline void set_m_lgallincnt(::google::protobuf::int32 value);
  
  // required int32 m_lGAllinOut = 45;
  inline bool has_m_lgallinout() const;
  inline void clear_m_lgallinout();
  static const int kMLGAllinOutFieldNumber = 45;
  inline ::google::protobuf::int32 m_lgallinout() const;
  inline void set_m_lgallinout(::google::protobuf::int32 value);
  
  // required int64 m_llGLastAllinDate = 46;
  inline bool has_m_llglastallindate() const;
  inline void clear_m_llglastallindate();
  static const int kMLlGLastAllinDateFieldNumber = 46;
  inline ::google::protobuf::int64 m_llglastallindate() const;
  inline void set_m_llglastallindate(::google::protobuf::int64 value);
  
  // required .PKCWinLose m_cWinLose_Today = 47;
  inline bool has_m_cwinlose_today() const;
  inline void clear_m_cwinlose_today();
  static const int kMCWinLoseTodayFieldNumber = 47;
  inline const ::PKCWinLose& m_cwinlose_today() const;
  inline ::PKCWinLose* mutable_m_cwinlose_today();
  inline ::PKCWinLose* release_m_cwinlose_today();
  
  // required int64 m_llGTodayMoney = 48;
  inline bool has_m_llgtodaymoney() const;
  inline void clear_m_llgtodaymoney();
  static const int kMLlGTodayMoneyFieldNumber = 48;
  inline ::google::protobuf::int64 m_llgtodaymoney() const;
  inline void set_m_llgtodaymoney(::google::protobuf::int64 value);
  
  // required int32 m_lFourCardCnt = 49;
  inline bool has_m_lfourcardcnt() const;
  inline void clear_m_lfourcardcnt();
  static const int kMLFourCardCntFieldNumber = 49;
  inline ::google::protobuf::int32 m_lfourcardcnt() const;
  inline void set_m_lfourcardcnt(::google::protobuf::int32 value);
  
  // required int32 m_lStraightFlushCnt = 50;
  inline bool has_m_lstraightflushcnt() const;
  inline void clear_m_lstraightflushcnt();
  static const int kMLStraightFlushCntFieldNumber = 50;
  inline ::google::protobuf::int32 m_lstraightflushcnt() const;
  inline void set_m_lstraightflushcnt(::google::protobuf::int32 value);
  
  // required int32 m_lRoyalStraightFlushCnt = 51;
  inline bool has_m_lroyalstraightflushcnt() const;
  inline void clear_m_lroyalstraightflushcnt();
  static const int kMLRoyalStraightFlushCntFieldNumber = 51;
  inline ::google::protobuf::int32 m_lroyalstraightflushcnt() const;
  inline void set_m_lroyalstraightflushcnt(::google::protobuf::int32 value);
  
  // required int32 m_nReserve01 = 52;
  inline bool has_m_nreserve01() const;
  inline void clear_m_nreserve01();
  static const int kMNReserve01FieldNumber = 52;
  inline ::google::protobuf::int32 m_nreserve01() const;
  inline void set_m_nreserve01(::google::protobuf::int32 value);
  
  // required int32 m_nReserve02 = 53;
  inline bool has_m_nreserve02() const;
  inline void clear_m_nreserve02();
  static const int kMNReserve02FieldNumber = 53;
  inline ::google::protobuf::int32 m_nreserve02() const;
  inline void set_m_nreserve02(::google::protobuf::int32 value);
  
  // required .PKItemList m_ItemList = 54;
  inline bool has_m_itemlist() const;
  inline void clear_m_itemlist();
  static const int kMItemListFieldNumber = 54;
  inline const ::PKItemList& m_itemlist() const;
  inline ::PKItemList* mutable_m_itemlist();
  inline ::PKItemList* release_m_itemlist();
  
  // required int64 m_llJoinDate = 55;
  inline bool has_m_lljoindate() const;
  inline void clear_m_lljoindate();
  static const int kMLlJoinDateFieldNumber = 55;
  inline ::google::protobuf::int64 m_lljoindate() const;
  inline void set_m_lljoindate(::google::protobuf::int64 value);
  
  // required int64 m_llPlayDate = 56;
  inline bool has_m_llplaydate() const;
  inline void clear_m_llplaydate();
  static const int kMLlPlayDateFieldNumber = 56;
  inline ::google::protobuf::int64 m_llplaydate() const;
  inline void set_m_llplaydate(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:PKRCUser)
 private:
  inline void set_has_m_lusn();
  inline void clear_has_m_lusn();
  inline void set_has_m_ljumin();
  inline void clear_has_m_ljumin();
  inline void set_has_m_lfirstusn();
  inline void clear_has_m_lfirstusn();
  inline void set_has_m_lageindex();
  inline void clear_has_m_lageindex();
  inline void set_has_m_ljobindex();
  inline void clear_has_m_ljobindex();
  inline void set_has_m_lregionindex();
  inline void clear_has_m_lregionindex();
  inline void set_has_m_lguildindex();
  inline void clear_has_m_lguildindex();
  inline void set_has_m_lmemberindex();
  inline void clear_has_m_lmemberindex();
  inline void set_has_m_lclientip();
  inline void clear_has_m_lclientip();
  inline void set_has_m_lgatewayip();
  inline void clear_has_m_lgatewayip();
  inline void set_has_m_lmacaddress();
  inline void clear_has_m_lmacaddress();
  inline void set_has_m_smobileinfo();
  inline void clear_has_m_smobileinfo();
  inline void set_has_m_sauthkey();
  inline void clear_has_m_sauthkey();
  inline void set_has_m_susergamedata();
  inline void clear_has_m_susergamedata();
  inline void set_has_m_nindex();
  inline void clear_has_m_nindex();
  inline void set_has_m_snickname();
  inline void clear_has_m_snickname();
  inline void set_has_m_suserid();
  inline void clear_has_m_suserid();
  inline void set_has_m_savt();
  inline void clear_has_m_savt();
  inline void set_has_m_lclevel();
  inline void clear_has_m_lclevel();
  inline void set_has_m_lsex();
  inline void clear_has_m_lsex();
  inline void set_has_m_llcmoney();
  inline void clear_has_m_llcmoney();
  inline void set_has_m_llfmoney();
  inline void clear_has_m_llfmoney();
  inline void set_has_m_llsafemoney();
  inline void clear_has_m_llsafemoney();
  inline void set_has_m_llplastallindate();
  inline void clear_has_m_llplastallindate();
  inline void set_has_m_llplastlogonday();
  inline void clear_has_m_llplastlogonday();
  inline void set_has_m_lmtodayplaycount();
  inline void clear_has_m_lmtodayplaycount();
  inline void set_has_m_lmtodayplaytime();
  inline void clear_has_m_lmtodayplaytime();
  inline void set_has_m_lptotalplaycount();
  inline void clear_has_m_lptotalplaycount();
  inline void set_has_m_crefill();
  inline void clear_has_m_crefill();
  inline void set_has_m_llpextmoney();
  inline void clear_has_m_llpextmoney();
  inline void set_has_m_llpextenddate();
  inline void clear_has_m_llpextenddate();
  inline void set_has_m_llpbonusdate();
  inline void clear_has_m_llpbonusdate();
  inline void set_has_m_lmmonthplaycount();
  inline void clear_has_m_lmmonthplaycount();
  inline void set_has_m_lmmonthplaytime();
  inline void clear_has_m_lmmonthplaytime();
  inline void set_has_m_cwinlose();
  inline void clear_has_m_cwinlose();
  inline void set_has_m_lgdiscnt();
  inline void clear_has_m_lgdiscnt();
  inline void set_has_m_llglastlogonday();
  inline void clear_has_m_llglastlogonday();
  inline void set_has_m_llgregdate();
  inline void clear_has_m_llgregdate();
  inline void set_has_m_llgfirstplaydate();
  inline void clear_has_m_llgfirstplaydate();
  inline void set_has_m_lgtodayplaycount();
  inline void clear_has_m_lgtodayplaycount();
  inline void set_has_m_lgtodayplaytime();
  inline void clear_has_m_lgtodayplaytime();
  inline void set_has_m_lgtotalplaycount();
  inline void clear_has_m_lgtotalplaycount();
  inline void set_has_m_lgtotalplaytime();
  inline void clear_has_m_lgtotalplaytime();
  inline void set_has_m_lgallincnt();
  inline void clear_has_m_lgallincnt();
  inline void set_has_m_lgallinout();
  inline void clear_has_m_lgallinout();
  inline void set_has_m_llglastallindate();
  inline void clear_has_m_llglastallindate();
  inline void set_has_m_cwinlose_today();
  inline void clear_has_m_cwinlose_today();
  inline void set_has_m_llgtodaymoney();
  inline void clear_has_m_llgtodaymoney();
  inline void set_has_m_lfourcardcnt();
  inline void clear_has_m_lfourcardcnt();
  inline void set_has_m_lstraightflushcnt();
  inline void clear_has_m_lstraightflushcnt();
  inline void set_has_m_lroyalstraightflushcnt();
  inline void clear_has_m_lroyalstraightflushcnt();
  inline void set_has_m_nreserve01();
  inline void clear_has_m_nreserve01();
  inline void set_has_m_nreserve02();
  inline void clear_has_m_nreserve02();
  inline void set_has_m_itemlist();
  inline void clear_has_m_itemlist();
  inline void set_has_m_lljoindate();
  inline void clear_has_m_lljoindate();
  inline void set_has_m_llplaydate();
  inline void clear_has_m_llplaydate();
  
  ::google::protobuf::int32 m_lusn_;
  ::google::protobuf::int32 m_ljumin_;
  ::google::protobuf::int32 m_lfirstusn_;
  ::google::protobuf::int32 m_lageindex_;
  ::google::protobuf::int32 m_ljobindex_;
  ::google::protobuf::int32 m_lregionindex_;
  ::google::protobuf::int32 m_lguildindex_;
  ::google::protobuf::int32 m_lmemberindex_;
  ::google::protobuf::int32 m_lclientip_;
  ::google::protobuf::int32 m_lgatewayip_;
  ::std::string* m_smobileinfo_;
  ::std::string* m_sauthkey_;
  ::google::protobuf::int32 m_lmacaddress_;
  ::google::protobuf::int32 m_nindex_;
  ::std::string* m_susergamedata_;
  ::std::string* m_snickname_;
  ::std::string* m_suserid_;
  ::std::string* m_savt_;
  ::google::protobuf::int32 m_lclevel_;
  ::google::protobuf::int32 m_lsex_;
  ::google::protobuf::int64 m_llcmoney_;
  ::google::protobuf::int64 m_llfmoney_;
  ::google::protobuf::int64 m_llsafemoney_;
  ::google::protobuf::int64 m_llplastallindate_;
  ::google::protobuf::int64 m_llplastlogonday_;
  ::google::protobuf::int32 m_lmtodayplaycount_;
  ::google::protobuf::int32 m_lmtodayplaytime_;
  ::CRefill* m_crefill_;
  ::google::protobuf::int64 m_llpextmoney_;
  ::google::protobuf::int32 m_lptotalplaycount_;
  ::google::protobuf::int32 m_lmmonthplaycount_;
  ::google::protobuf::int64 m_llpextenddate_;
  ::google::protobuf::int64 m_llpbonusdate_;
  ::PKCWinLose* m_cwinlose_;
  ::google::protobuf::int32 m_lmmonthplaytime_;
  ::google::protobuf::int32 m_lgdiscnt_;
  ::google::protobuf::int64 m_llglastlogonday_;
  ::google::protobuf::int64 m_llgregdate_;
  ::google::protobuf::int64 m_llgfirstplaydate_;
  ::google::protobuf::int32 m_lgtodayplaycount_;
  ::google::protobuf::int32 m_lgtodayplaytime_;
  ::google::protobuf::int32 m_lgtotalplaycount_;
  ::google::protobuf::int32 m_lgtotalplaytime_;
  ::google::protobuf::int32 m_lgallincnt_;
  ::google::protobuf::int32 m_lgallinout_;
  ::google::protobuf::int64 m_llglastallindate_;
  ::PKCWinLose* m_cwinlose_today_;
  ::google::protobuf::int64 m_llgtodaymoney_;
  ::google::protobuf::int32 m_lfourcardcnt_;
  ::google::protobuf::int32 m_lstraightflushcnt_;
  ::google::protobuf::int32 m_lroyalstraightflushcnt_;
  ::google::protobuf::int32 m_nreserve01_;
  ::PKItemList* m_itemlist_;
  ::google::protobuf::int64 m_lljoindate_;
  ::google::protobuf::int64 m_llplaydate_;
  ::google::protobuf::int32 m_nreserve02_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(56 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKRCUser* default_instance_;
};
// -------------------------------------------------------------------

class PKBettingMsg : public ::google::protobuf::MessageLite {
 public:
  PKBettingMsg();
  virtual ~PKBettingMsg();
  
  PKBettingMsg(const PKBettingMsg& from);
  
  inline PKBettingMsg& operator=(const PKBettingMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKBettingMsg& default_instance();
  
  void Swap(PKBettingMsg* other);
  
  // implements Message ----------------------------------------------
  
  PKBettingMsg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKBettingMsg& from);
  void MergeFrom(const PKBettingMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 m_lUSN = 1;
  inline bool has_m_lusn() const;
  inline void clear_m_lusn();
  static const int kMLUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lusn() const;
  inline void set_m_lusn(::google::protobuf::int32 value);
  
  // required int32 m_nIndex = 2;
  inline bool has_m_nindex() const;
  inline void clear_m_nindex();
  static const int kMNIndexFieldNumber = 2;
  inline ::google::protobuf::int32 m_nindex() const;
  inline void set_m_nindex(::google::protobuf::int32 value);
  
  // required int32 m_BetType = 3;
  inline bool has_m_bettype() const;
  inline void clear_m_bettype();
  static const int kMBetTypeFieldNumber = 3;
  inline ::google::protobuf::int32 m_bettype() const;
  inline void set_m_bettype(::google::protobuf::int32 value);
  
  // required int32 m_bBettingMoney = 4;
  inline bool has_m_bbettingmoney() const;
  inline void clear_m_bbettingmoney();
  static const int kMBBettingMoneyFieldNumber = 4;
  inline ::google::protobuf::int32 m_bbettingmoney() const;
  inline void set_m_bbettingmoney(::google::protobuf::int32 value);
  
  // required int32 m_bMoneyLack = 5;
  inline bool has_m_bmoneylack() const;
  inline void clear_m_bmoneylack();
  static const int kMBMoneyLackFieldNumber = 5;
  inline ::google::protobuf::int32 m_bmoneylack() const;
  inline void set_m_bmoneylack(::google::protobuf::int32 value);
  
  // required int32 m_bCallMoneyZero = 6;
  inline bool has_m_bcallmoneyzero() const;
  inline void clear_m_bcallmoneyzero();
  static const int kMBCallMoneyZeroFieldNumber = 6;
  inline ::google::protobuf::int32 m_bcallmoneyzero() const;
  inline void set_m_bcallmoneyzero(::google::protobuf::int32 value);
  
  // required int64 m_llCallMoney = 7;
  inline bool has_m_llcallmoney() const;
  inline void clear_m_llcallmoney();
  static const int kMLlCallMoneyFieldNumber = 7;
  inline ::google::protobuf::int64 m_llcallmoney() const;
  inline void set_m_llcallmoney(::google::protobuf::int64 value);
  
  // required int64 m_llRaiseMoney = 8;
  inline bool has_m_llraisemoney() const;
  inline void clear_m_llraisemoney();
  static const int kMLlRaiseMoneyFieldNumber = 8;
  inline ::google::protobuf::int64 m_llraisemoney() const;
  inline void set_m_llraisemoney(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:PKBettingMsg)
 private:
  inline void set_has_m_lusn();
  inline void clear_has_m_lusn();
  inline void set_has_m_nindex();
  inline void clear_has_m_nindex();
  inline void set_has_m_bettype();
  inline void clear_has_m_bettype();
  inline void set_has_m_bbettingmoney();
  inline void clear_has_m_bbettingmoney();
  inline void set_has_m_bmoneylack();
  inline void clear_has_m_bmoneylack();
  inline void set_has_m_bcallmoneyzero();
  inline void clear_has_m_bcallmoneyzero();
  inline void set_has_m_llcallmoney();
  inline void clear_has_m_llcallmoney();
  inline void set_has_m_llraisemoney();
  inline void clear_has_m_llraisemoney();
  
  ::google::protobuf::int32 m_lusn_;
  ::google::protobuf::int32 m_nindex_;
  ::google::protobuf::int32 m_bettype_;
  ::google::protobuf::int32 m_bbettingmoney_;
  ::google::protobuf::int32 m_bmoneylack_;
  ::google::protobuf::int32 m_bcallmoneyzero_;
  ::google::protobuf::int64 m_llcallmoney_;
  ::google::protobuf::int64 m_llraisemoney_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKBettingMsg* default_instance_;
};
// -------------------------------------------------------------------

class PKBettingMsgTable : public ::google::protobuf::MessageLite {
 public:
  PKBettingMsgTable();
  virtual ~PKBettingMsgTable();
  
  PKBettingMsgTable(const PKBettingMsgTable& from);
  
  inline PKBettingMsgTable& operator=(const PKBettingMsgTable& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKBettingMsgTable& default_instance();
  
  void Swap(PKBettingMsgTable* other);
  
  // implements Message ----------------------------------------------
  
  PKBettingMsgTable* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKBettingMsgTable& from);
  void MergeFrom(const PKBettingMsgTable& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .PKBettingMsg BettingMsgTable = 1;
  inline int bettingmsgtable_size() const;
  inline void clear_bettingmsgtable();
  static const int kBettingMsgTableFieldNumber = 1;
  inline const ::PKBettingMsg& bettingmsgtable(int index) const;
  inline ::PKBettingMsg* mutable_bettingmsgtable(int index);
  inline ::PKBettingMsg* add_bettingmsgtable();
  inline const ::google::protobuf::RepeatedPtrField< ::PKBettingMsg >&
      bettingmsgtable() const;
  inline ::google::protobuf::RepeatedPtrField< ::PKBettingMsg >*
      mutable_bettingmsgtable();
  
  // @@protoc_insertion_point(class_scope:PKBettingMsgTable)
 private:
  
  ::google::protobuf::RepeatedPtrField< ::PKBettingMsg > bettingmsgtable_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKBettingMsgTable* default_instance_;
};
// -------------------------------------------------------------------

class PKMoneyTable : public ::google::protobuf::MessageLite {
 public:
  PKMoneyTable();
  virtual ~PKMoneyTable();
  
  PKMoneyTable(const PKMoneyTable& from);
  
  inline PKMoneyTable& operator=(const PKMoneyTable& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMoneyTable& default_instance();
  
  void Swap(PKMoneyTable* other);
  
  // implements Message ----------------------------------------------
  
  PKMoneyTable* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMoneyTable& from);
  void MergeFrom(const PKMoneyTable& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .PKMoney MoneyTable = 1;
  inline int moneytable_size() const;
  inline void clear_moneytable();
  static const int kMoneyTableFieldNumber = 1;
  inline const ::PKMoney& moneytable(int index) const;
  inline ::PKMoney* mutable_moneytable(int index);
  inline ::PKMoney* add_moneytable();
  inline const ::google::protobuf::RepeatedPtrField< ::PKMoney >&
      moneytable() const;
  inline ::google::protobuf::RepeatedPtrField< ::PKMoney >*
      mutable_moneytable();
  
  // @@protoc_insertion_point(class_scope:PKMoneyTable)
 private:
  
  ::google::protobuf::RepeatedPtrField< ::PKMoney > moneytable_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMoneyTable* default_instance_;
};
// -------------------------------------------------------------------

class PKCardTable : public ::google::protobuf::MessageLite {
 public:
  PKCardTable();
  virtual ~PKCardTable();
  
  PKCardTable(const PKCardTable& from);
  
  inline PKCardTable& operator=(const PKCardTable& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKCardTable& default_instance();
  
  void Swap(PKCardTable* other);
  
  // implements Message ----------------------------------------------
  
  PKCardTable* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKCardTable& from);
  void MergeFrom(const PKCardTable& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .PKCards CardTable = 1;
  inline int cardtable_size() const;
  inline void clear_cardtable();
  static const int kCardTableFieldNumber = 1;
  inline const ::PKCards& cardtable(int index) const;
  inline ::PKCards* mutable_cardtable(int index);
  inline ::PKCards* add_cardtable();
  inline const ::google::protobuf::RepeatedPtrField< ::PKCards >&
      cardtable() const;
  inline ::google::protobuf::RepeatedPtrField< ::PKCards >*
      mutable_cardtable();
  
  // @@protoc_insertion_point(class_scope:PKCardTable)
 private:
  
  ::google::protobuf::RepeatedPtrField< ::PKCards > cardtable_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKCardTable* default_instance_;
};
// -------------------------------------------------------------------

class PKUITable : public ::google::protobuf::MessageLite {
 public:
  PKUITable();
  virtual ~PKUITable();
  
  PKUITable(const PKUITable& from);
  
  inline PKUITable& operator=(const PKUITable& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKUITable& default_instance();
  
  void Swap(PKUITable* other);
  
  // implements Message ----------------------------------------------
  
  PKUITable* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKUITable& from);
  void MergeFrom(const PKUITable& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .PKUserInfo UITable = 1;
  inline int uitable_size() const;
  inline void clear_uitable();
  static const int kUITableFieldNumber = 1;
  inline const ::PKUserInfo& uitable(int index) const;
  inline ::PKUserInfo* mutable_uitable(int index);
  inline ::PKUserInfo* add_uitable();
  inline const ::google::protobuf::RepeatedPtrField< ::PKUserInfo >&
      uitable() const;
  inline ::google::protobuf::RepeatedPtrField< ::PKUserInfo >*
      mutable_uitable();
  
  // @@protoc_insertion_point(class_scope:PKUITable)
 private:
  
  ::google::protobuf::RepeatedPtrField< ::PKUserInfo > uitable_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKUITable* default_instance_;
};
// -------------------------------------------------------------------

class PKRCRoomData : public ::google::protobuf::MessageLite {
 public:
  PKRCRoomData();
  virtual ~PKRCRoomData();
  
  PKRCRoomData(const PKRCRoomData& from);
  
  inline PKRCRoomData& operator=(const PKRCRoomData& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKRCRoomData& default_instance();
  
  void Swap(PKRCRoomData* other);
  
  // implements Message ----------------------------------------------
  
  PKRCRoomData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKRCRoomData& from);
  void MergeFrom(const PKRCRoomData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 m_lGameMaster = 1;
  inline bool has_m_lgamemaster() const;
  inline void clear_m_lgamemaster();
  static const int kMLGameMasterFieldNumber = 1;
  inline ::google::protobuf::int32 m_lgamemaster() const;
  inline void set_m_lgamemaster(::google::protobuf::int32 value);
  
  // required int32 m_lRoomIndex = 2;
  inline bool has_m_lroomindex() const;
  inline void clear_m_lroomindex();
  static const int kMLRoomIndexFieldNumber = 2;
  inline ::google::protobuf::int32 m_lroomindex() const;
  inline void set_m_lroomindex(::google::protobuf::int32 value);
  
  // required int32 m_lState = 3;
  inline bool has_m_lstate() const;
  inline void clear_m_lstate();
  static const int kMLStateFieldNumber = 3;
  inline ::google::protobuf::int32 m_lstate() const;
  inline void set_m_lstate(::google::protobuf::int32 value);
  
  // required .PKOption m_option = 4;
  inline bool has_m_option() const;
  inline void clear_m_option();
  static const int kMOptionFieldNumber = 4;
  inline const ::PKOption& m_option() const;
  inline ::PKOption* mutable_m_option();
  inline ::PKOption* release_m_option();
  
  // optional .PKUITable m_tblUI = 5;
  inline bool has_m_tblui() const;
  inline void clear_m_tblui();
  static const int kMTblUIFieldNumber = 5;
  inline const ::PKUITable& m_tblui() const;
  inline ::PKUITable* mutable_m_tblui();
  inline ::PKUITable* release_m_tblui();
  
  // optional .PKCardTable m_tblCard = 6;
  inline bool has_m_tblcard() const;
  inline void clear_m_tblcard();
  static const int kMTblCardFieldNumber = 6;
  inline const ::PKCardTable& m_tblcard() const;
  inline ::PKCardTable* mutable_m_tblcard();
  inline ::PKCardTable* release_m_tblcard();
  
  // optional .PKMoneyTable m_tblMoney = 7;
  inline bool has_m_tblmoney() const;
  inline void clear_m_tblmoney();
  static const int kMTblMoneyFieldNumber = 7;
  inline const ::PKMoneyTable& m_tblmoney() const;
  inline ::PKMoneyTable* mutable_m_tblmoney();
  inline ::PKMoneyTable* release_m_tblmoney();
  
  // optional .PKBettingMsgTable m_tblBettingMsg = 8;
  inline bool has_m_tblbettingmsg() const;
  inline void clear_m_tblbettingmsg();
  static const int kMTblBettingMsgFieldNumber = 8;
  inline const ::PKBettingMsgTable& m_tblbettingmsg() const;
  inline ::PKBettingMsgTable* mutable_m_tblbettingmsg();
  inline ::PKBettingMsgTable* release_m_tblbettingmsg();
  
  // @@protoc_insertion_point(class_scope:PKRCRoomData)
 private:
  inline void set_has_m_lgamemaster();
  inline void clear_has_m_lgamemaster();
  inline void set_has_m_lroomindex();
  inline void clear_has_m_lroomindex();
  inline void set_has_m_lstate();
  inline void clear_has_m_lstate();
  inline void set_has_m_option();
  inline void clear_has_m_option();
  inline void set_has_m_tblui();
  inline void clear_has_m_tblui();
  inline void set_has_m_tblcard();
  inline void clear_has_m_tblcard();
  inline void set_has_m_tblmoney();
  inline void clear_has_m_tblmoney();
  inline void set_has_m_tblbettingmsg();
  inline void clear_has_m_tblbettingmsg();
  
  ::google::protobuf::int32 m_lgamemaster_;
  ::google::protobuf::int32 m_lroomindex_;
  ::PKOption* m_option_;
  ::PKUITable* m_tblui_;
  ::PKCardTable* m_tblcard_;
  ::PKMoneyTable* m_tblmoney_;
  ::PKBettingMsgTable* m_tblbettingmsg_;
  ::google::protobuf::int32 m_lstate_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKRCRoomData* default_instance_;
};
// -------------------------------------------------------------------

class PKSPUserBaseInfo : public ::google::protobuf::MessageLite {
 public:
  PKSPUserBaseInfo();
  virtual ~PKSPUserBaseInfo();
  
  PKSPUserBaseInfo(const PKSPUserBaseInfo& from);
  
  inline PKSPUserBaseInfo& operator=(const PKSPUserBaseInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKSPUserBaseInfo& default_instance();
  
  void Swap(PKSPUserBaseInfo* other);
  
  // implements Message ----------------------------------------------
  
  PKSPUserBaseInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKSPUserBaseInfo& from);
  void MergeFrom(const PKSPUserBaseInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 m_lUSN = 1;
  inline bool has_m_lusn() const;
  inline void clear_m_lusn();
  static const int kMLUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lusn() const;
  inline void set_m_lusn(::google::protobuf::int32 value);
  
  // required string m_sUserID = 2;
  inline bool has_m_suserid() const;
  inline void clear_m_suserid();
  static const int kMSUserIDFieldNumber = 2;
  inline const ::std::string& m_suserid() const;
  inline void set_m_suserid(const ::std::string& value);
  inline void set_m_suserid(const char* value);
  inline void set_m_suserid(const char* value, size_t size);
  inline ::std::string* mutable_m_suserid();
  inline ::std::string* release_m_suserid();
  
  // required string m_sNickName = 3;
  inline bool has_m_snickname() const;
  inline void clear_m_snickname();
  static const int kMSNickNameFieldNumber = 3;
  inline const ::std::string& m_snickname() const;
  inline void set_m_snickname(const ::std::string& value);
  inline void set_m_snickname(const char* value);
  inline void set_m_snickname(const char* value, size_t size);
  inline ::std::string* mutable_m_snickname();
  inline ::std::string* release_m_snickname();
  
  // required int32 m_lUSC = 4;
  inline bool has_m_lusc() const;
  inline void clear_m_lusc();
  static const int kMLUSCFieldNumber = 4;
  inline ::google::protobuf::int32 m_lusc() const;
  inline void set_m_lusc(::google::protobuf::int32 value);
  
  // required int32 m_lJumin = 5;
  inline bool has_m_ljumin() const;
  inline void clear_m_ljumin();
  static const int kMLJuminFieldNumber = 5;
  inline ::google::protobuf::int32 m_ljumin() const;
  inline void set_m_ljumin(::google::protobuf::int32 value);
  
  // required int32 m_lFirstUSN = 6;
  inline bool has_m_lfirstusn() const;
  inline void clear_m_lfirstusn();
  static const int kMLFirstUSNFieldNumber = 6;
  inline ::google::protobuf::int32 m_lfirstusn() const;
  inline void set_m_lfirstusn(::google::protobuf::int32 value);
  
  // required int32 m_lAgeIndex = 7;
  inline bool has_m_lageindex() const;
  inline void clear_m_lageindex();
  static const int kMLAgeIndexFieldNumber = 7;
  inline ::google::protobuf::int32 m_lageindex() const;
  inline void set_m_lageindex(::google::protobuf::int32 value);
  
  // required int32 m_lJobIndex = 8;
  inline bool has_m_ljobindex() const;
  inline void clear_m_ljobindex();
  static const int kMLJobIndexFieldNumber = 8;
  inline ::google::protobuf::int32 m_ljobindex() const;
  inline void set_m_ljobindex(::google::protobuf::int32 value);
  
  // required int32 m_lRegionIndex = 9;
  inline bool has_m_lregionindex() const;
  inline void clear_m_lregionindex();
  static const int kMLRegionIndexFieldNumber = 9;
  inline ::google::protobuf::int32 m_lregionindex() const;
  inline void set_m_lregionindex(::google::protobuf::int32 value);
  
  // required int32 m_lGuildIndex = 10;
  inline bool has_m_lguildindex() const;
  inline void clear_m_lguildindex();
  static const int kMLGuildIndexFieldNumber = 10;
  inline ::google::protobuf::int32 m_lguildindex() const;
  inline void set_m_lguildindex(::google::protobuf::int32 value);
  
  // required int32 m_lMemberIndex = 11;
  inline bool has_m_lmemberindex() const;
  inline void clear_m_lmemberindex();
  static const int kMLMemberIndexFieldNumber = 11;
  inline ::google::protobuf::int32 m_lmemberindex() const;
  inline void set_m_lmemberindex(::google::protobuf::int32 value);
  
  // required int32 m_lClientIP = 12;
  inline bool has_m_lclientip() const;
  inline void clear_m_lclientip();
  static const int kMLClientIPFieldNumber = 12;
  inline ::google::protobuf::int32 m_lclientip() const;
  inline void set_m_lclientip(::google::protobuf::int32 value);
  
  // required int32 m_lGatewayIP = 13;
  inline bool has_m_lgatewayip() const;
  inline void clear_m_lgatewayip();
  static const int kMLGatewayIPFieldNumber = 13;
  inline ::google::protobuf::int32 m_lgatewayip() const;
  inline void set_m_lgatewayip(::google::protobuf::int32 value);
  
  // required int32 m_lMacAddress = 14;
  inline bool has_m_lmacaddress() const;
  inline void clear_m_lmacaddress();
  static const int kMLMacAddressFieldNumber = 14;
  inline ::google::protobuf::int32 m_lmacaddress() const;
  inline void set_m_lmacaddress(::google::protobuf::int32 value);
  
  // required string m_sMobileInfo = 15;
  inline bool has_m_smobileinfo() const;
  inline void clear_m_smobileinfo();
  static const int kMSMobileInfoFieldNumber = 15;
  inline const ::std::string& m_smobileinfo() const;
  inline void set_m_smobileinfo(const ::std::string& value);
  inline void set_m_smobileinfo(const char* value);
  inline void set_m_smobileinfo(const char* value, size_t size);
  inline ::std::string* mutable_m_smobileinfo();
  inline ::std::string* release_m_smobileinfo();
  
  // required string m_sAuthKey = 16;
  inline bool has_m_sauthkey() const;
  inline void clear_m_sauthkey();
  static const int kMSAuthKeyFieldNumber = 16;
  inline const ::std::string& m_sauthkey() const;
  inline void set_m_sauthkey(const ::std::string& value);
  inline void set_m_sauthkey(const char* value);
  inline void set_m_sauthkey(const char* value, size_t size);
  inline ::std::string* mutable_m_sauthkey();
  inline ::std::string* release_m_sauthkey();
  
  // @@protoc_insertion_point(class_scope:PKSPUserBaseInfo)
 private:
  inline void set_has_m_lusn();
  inline void clear_has_m_lusn();
  inline void set_has_m_suserid();
  inline void clear_has_m_suserid();
  inline void set_has_m_snickname();
  inline void clear_has_m_snickname();
  inline void set_has_m_lusc();
  inline void clear_has_m_lusc();
  inline void set_has_m_ljumin();
  inline void clear_has_m_ljumin();
  inline void set_has_m_lfirstusn();
  inline void clear_has_m_lfirstusn();
  inline void set_has_m_lageindex();
  inline void clear_has_m_lageindex();
  inline void set_has_m_ljobindex();
  inline void clear_has_m_ljobindex();
  inline void set_has_m_lregionindex();
  inline void clear_has_m_lregionindex();
  inline void set_has_m_lguildindex();
  inline void clear_has_m_lguildindex();
  inline void set_has_m_lmemberindex();
  inline void clear_has_m_lmemberindex();
  inline void set_has_m_lclientip();
  inline void clear_has_m_lclientip();
  inline void set_has_m_lgatewayip();
  inline void clear_has_m_lgatewayip();
  inline void set_has_m_lmacaddress();
  inline void clear_has_m_lmacaddress();
  inline void set_has_m_smobileinfo();
  inline void clear_has_m_smobileinfo();
  inline void set_has_m_sauthkey();
  inline void clear_has_m_sauthkey();
  
  ::std::string* m_suserid_;
  ::google::protobuf::int32 m_lusn_;
  ::google::protobuf::int32 m_lusc_;
  ::std::string* m_snickname_;
  ::google::protobuf::int32 m_ljumin_;
  ::google::protobuf::int32 m_lfirstusn_;
  ::google::protobuf::int32 m_lageindex_;
  ::google::protobuf::int32 m_ljobindex_;
  ::google::protobuf::int32 m_lregionindex_;
  ::google::protobuf::int32 m_lguildindex_;
  ::google::protobuf::int32 m_lmemberindex_;
  ::google::protobuf::int32 m_lclientip_;
  ::google::protobuf::int32 m_lgatewayip_;
  ::google::protobuf::int32 m_lmacaddress_;
  ::std::string* m_smobileinfo_;
  ::std::string* m_sauthkey_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKSPUserBaseInfo* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgCS_Entry : public ::google::protobuf::MessageLite {
 public:
  PKMsgCS_Entry();
  virtual ~PKMsgCS_Entry();
  
  PKMsgCS_Entry(const PKMsgCS_Entry& from);
  
  inline PKMsgCS_Entry& operator=(const PKMsgCS_Entry& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgCS_Entry& default_instance();
  
  void Swap(PKMsgCS_Entry* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgCS_Entry* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgCS_Entry& from);
  void MergeFrom(const PKMsgCS_Entry& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 m_nVersion = 1;
  inline bool has_m_nversion() const;
  inline void clear_m_nversion();
  static const int kMNVersionFieldNumber = 1;
  inline ::google::protobuf::int32 m_nversion() const;
  inline void set_m_nversion(::google::protobuf::int32 value);
  
  // required sint32 m_bWelcomeSound = 2;
  inline bool has_m_bwelcomesound() const;
  inline void clear_m_bwelcomesound();
  static const int kMBWelcomeSoundFieldNumber = 2;
  inline ::google::protobuf::int32 m_bwelcomesound() const;
  inline void set_m_bwelcomesound(::google::protobuf::int32 value);
  
  // required sint32 m_lSoundType = 3;
  inline bool has_m_lsoundtype() const;
  inline void clear_m_lsoundtype();
  static const int kMLSoundTypeFieldNumber = 3;
  inline ::google::protobuf::int32 m_lsoundtype() const;
  inline void set_m_lsoundtype(::google::protobuf::int32 value);
  
  // required string m_sNickName = 4;
  inline bool has_m_snickname() const;
  inline void clear_m_snickname();
  static const int kMSNickNameFieldNumber = 4;
  inline const ::std::string& m_snickname() const;
  inline void set_m_snickname(const ::std::string& value);
  inline void set_m_snickname(const char* value);
  inline void set_m_snickname(const char* value, size_t size);
  inline ::std::string* mutable_m_snickname();
  inline ::std::string* release_m_snickname();
  
  // required string m_sAvt = 5;
  inline bool has_m_savt() const;
  inline void clear_m_savt();
  static const int kMSAvtFieldNumber = 5;
  inline const ::std::string& m_savt() const;
  inline void set_m_savt(const ::std::string& value);
  inline void set_m_savt(const char* value);
  inline void set_m_savt(const char* value, size_t size);
  inline ::std::string* mutable_m_savt();
  inline ::std::string* release_m_savt();
  
  // required sint32 m_lCLevel = 6;
  inline bool has_m_lclevel() const;
  inline void clear_m_lclevel();
  static const int kMLCLevelFieldNumber = 6;
  inline ::google::protobuf::int32 m_lclevel() const;
  inline void set_m_lclevel(::google::protobuf::int32 value);
  
  // required sint32 m_lSex = 7;
  inline bool has_m_lsex() const;
  inline void clear_m_lsex();
  static const int kMLSexFieldNumber = 7;
  inline ::google::protobuf::int32 m_lsex() const;
  inline void set_m_lsex(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PKMsgCS_Entry)
 private:
  inline void set_has_m_nversion();
  inline void clear_has_m_nversion();
  inline void set_has_m_bwelcomesound();
  inline void clear_has_m_bwelcomesound();
  inline void set_has_m_lsoundtype();
  inline void clear_has_m_lsoundtype();
  inline void set_has_m_snickname();
  inline void clear_has_m_snickname();
  inline void set_has_m_savt();
  inline void clear_has_m_savt();
  inline void set_has_m_lclevel();
  inline void clear_has_m_lclevel();
  inline void set_has_m_lsex();
  inline void clear_has_m_lsex();
  
  ::google::protobuf::int32 m_nversion_;
  ::google::protobuf::int32 m_bwelcomesound_;
  ::std::string* m_snickname_;
  ::google::protobuf::int32 m_lsoundtype_;
  ::google::protobuf::int32 m_lclevel_;
  ::std::string* m_savt_;
  ::google::protobuf::int32 m_lsex_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgCS_Entry* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgCS_Observe : public ::google::protobuf::MessageLite {
 public:
  PKMsgCS_Observe();
  virtual ~PKMsgCS_Observe();
  
  PKMsgCS_Observe(const PKMsgCS_Observe& from);
  
  inline PKMsgCS_Observe& operator=(const PKMsgCS_Observe& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgCS_Observe& default_instance();
  
  void Swap(PKMsgCS_Observe* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgCS_Observe* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgCS_Observe& from);
  void MergeFrom(const PKMsgCS_Observe& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:PKMsgCS_Observe)
 private:
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgCS_Observe* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgCS_Start : public ::google::protobuf::MessageLite {
 public:
  PKMsgCS_Start();
  virtual ~PKMsgCS_Start();
  
  PKMsgCS_Start(const PKMsgCS_Start& from);
  
  inline PKMsgCS_Start& operator=(const PKMsgCS_Start& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgCS_Start& default_instance();
  
  void Swap(PKMsgCS_Start* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgCS_Start* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgCS_Start& from);
  void MergeFrom(const PKMsgCS_Start& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:PKMsgCS_Start)
 private:
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgCS_Start* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgCS_SelectedCardReq : public ::google::protobuf::MessageLite {
 public:
  PKMsgCS_SelectedCardReq();
  virtual ~PKMsgCS_SelectedCardReq();
  
  PKMsgCS_SelectedCardReq(const PKMsgCS_SelectedCardReq& from);
  
  inline PKMsgCS_SelectedCardReq& operator=(const PKMsgCS_SelectedCardReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgCS_SelectedCardReq& default_instance();
  
  void Swap(PKMsgCS_SelectedCardReq* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgCS_SelectedCardReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgCS_SelectedCardReq& from);
  void MergeFrom(const PKMsgCS_SelectedCardReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lCardIdx = 1;
  inline bool has_m_lcardidx() const;
  inline void clear_m_lcardidx();
  static const int kMLCardIdxFieldNumber = 1;
  inline ::google::protobuf::int32 m_lcardidx() const;
  inline void set_m_lcardidx(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PKMsgCS_SelectedCardReq)
 private:
  inline void set_has_m_lcardidx();
  inline void clear_has_m_lcardidx();
  
  ::google::protobuf::int32 m_lcardidx_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgCS_SelectedCardReq* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgCS_BettingReq : public ::google::protobuf::MessageLite {
 public:
  PKMsgCS_BettingReq();
  virtual ~PKMsgCS_BettingReq();
  
  PKMsgCS_BettingReq(const PKMsgCS_BettingReq& from);
  
  inline PKMsgCS_BettingReq& operator=(const PKMsgCS_BettingReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgCS_BettingReq& default_instance();
  
  void Swap(PKMsgCS_BettingReq* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgCS_BettingReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgCS_BettingReq& from);
  void MergeFrom(const PKMsgCS_BettingReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lBetType = 1;
  inline bool has_m_lbettype() const;
  inline void clear_m_lbettype();
  static const int kMLBetTypeFieldNumber = 1;
  inline ::google::protobuf::int32 m_lbettype() const;
  inline void set_m_lbettype(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PKMsgCS_BettingReq)
 private:
  inline void set_has_m_lbettype();
  inline void clear_has_m_lbettype();
  
  ::google::protobuf::int32 m_lbettype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgCS_BettingReq* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgCS_ChoiceRemoveCard : public ::google::protobuf::MessageLite {
 public:
  PKMsgCS_ChoiceRemoveCard();
  virtual ~PKMsgCS_ChoiceRemoveCard();
  
  PKMsgCS_ChoiceRemoveCard(const PKMsgCS_ChoiceRemoveCard& from);
  
  inline PKMsgCS_ChoiceRemoveCard& operator=(const PKMsgCS_ChoiceRemoveCard& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgCS_ChoiceRemoveCard& default_instance();
  
  void Swap(PKMsgCS_ChoiceRemoveCard* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgCS_ChoiceRemoveCard* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgCS_ChoiceRemoveCard& from);
  void MergeFrom(const PKMsgCS_ChoiceRemoveCard& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lUSN = 1;
  inline bool has_m_lusn() const;
  inline void clear_m_lusn();
  static const int kMLUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lusn() const;
  inline void set_m_lusn(::google::protobuf::int32 value);
  
  // required int32 m_nRemoveCardIndex = 2;
  inline bool has_m_nremovecardindex() const;
  inline void clear_m_nremovecardindex();
  static const int kMNRemoveCardIndexFieldNumber = 2;
  inline ::google::protobuf::int32 m_nremovecardindex() const;
  inline void set_m_nremovecardindex(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PKMsgCS_ChoiceRemoveCard)
 private:
  inline void set_has_m_lusn();
  inline void clear_has_m_lusn();
  inline void set_has_m_nremovecardindex();
  inline void clear_has_m_nremovecardindex();
  
  ::google::protobuf::int32 m_lusn_;
  ::google::protobuf::int32 m_nremovecardindex_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgCS_ChoiceRemoveCard* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgCS_Purge : public ::google::protobuf::MessageLite {
 public:
  PKMsgCS_Purge();
  virtual ~PKMsgCS_Purge();
  
  PKMsgCS_Purge(const PKMsgCS_Purge& from);
  
  inline PKMsgCS_Purge& operator=(const PKMsgCS_Purge& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgCS_Purge& default_instance();
  
  void Swap(PKMsgCS_Purge* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgCS_Purge* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgCS_Purge& from);
  void MergeFrom(const PKMsgCS_Purge& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lType = 1;
  inline bool has_m_ltype() const;
  inline void clear_m_ltype();
  static const int kMLTypeFieldNumber = 1;
  inline ::google::protobuf::int32 m_ltype() const;
  inline void set_m_ltype(::google::protobuf::int32 value);
  
  // required sint32 m_lPurgeUSN = 2;
  inline bool has_m_lpurgeusn() const;
  inline void clear_m_lpurgeusn();
  static const int kMLPurgeUSNFieldNumber = 2;
  inline ::google::protobuf::int32 m_lpurgeusn() const;
  inline void set_m_lpurgeusn(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PKMsgCS_Purge)
 private:
  inline void set_has_m_ltype();
  inline void clear_has_m_ltype();
  inline void set_has_m_lpurgeusn();
  inline void clear_has_m_lpurgeusn();
  
  ::google::protobuf::int32 m_ltype_;
  ::google::protobuf::int32 m_lpurgeusn_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgCS_Purge* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgCS_Abuse : public ::google::protobuf::MessageLite {
 public:
  PKMsgCS_Abuse();
  virtual ~PKMsgCS_Abuse();
  
  PKMsgCS_Abuse(const PKMsgCS_Abuse& from);
  
  inline PKMsgCS_Abuse& operator=(const PKMsgCS_Abuse& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgCS_Abuse& default_instance();
  
  void Swap(PKMsgCS_Abuse* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgCS_Abuse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgCS_Abuse& from);
  void MergeFrom(const PKMsgCS_Abuse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lType = 1;
  inline bool has_m_ltype() const;
  inline void clear_m_ltype();
  static const int kMLTypeFieldNumber = 1;
  inline ::google::protobuf::int32 m_ltype() const;
  inline void set_m_ltype(::google::protobuf::int32 value);
  
  // required string m_sDay = 2;
  inline bool has_m_sday() const;
  inline void clear_m_sday();
  static const int kMSDayFieldNumber = 2;
  inline const ::std::string& m_sday() const;
  inline void set_m_sday(const ::std::string& value);
  inline void set_m_sday(const char* value);
  inline void set_m_sday(const char* value, size_t size);
  inline ::std::string* mutable_m_sday();
  inline ::std::string* release_m_sday();
  
  // @@protoc_insertion_point(class_scope:PKMsgCS_Abuse)
 private:
  inline void set_has_m_ltype();
  inline void clear_has_m_ltype();
  inline void set_has_m_sday();
  inline void clear_has_m_sday();
  
  ::std::string* m_sday_;
  ::google::protobuf::int32 m_ltype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgCS_Abuse* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgCS_AskPurgeVote : public ::google::protobuf::MessageLite {
 public:
  PKMsgCS_AskPurgeVote();
  virtual ~PKMsgCS_AskPurgeVote();
  
  PKMsgCS_AskPurgeVote(const PKMsgCS_AskPurgeVote& from);
  
  inline PKMsgCS_AskPurgeVote& operator=(const PKMsgCS_AskPurgeVote& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgCS_AskPurgeVote& default_instance();
  
  void Swap(PKMsgCS_AskPurgeVote* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgCS_AskPurgeVote* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgCS_AskPurgeVote& from);
  void MergeFrom(const PKMsgCS_AskPurgeVote& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lPurgeUSN = 1;
  inline bool has_m_lpurgeusn() const;
  inline void clear_m_lpurgeusn();
  static const int kMLPurgeUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lpurgeusn() const;
  inline void set_m_lpurgeusn(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PKMsgCS_AskPurgeVote)
 private:
  inline void set_has_m_lpurgeusn();
  inline void clear_has_m_lpurgeusn();
  
  ::google::protobuf::int32 m_lpurgeusn_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgCS_AskPurgeVote* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgCS_AnswerPurgeVote : public ::google::protobuf::MessageLite {
 public:
  PKMsgCS_AnswerPurgeVote();
  virtual ~PKMsgCS_AnswerPurgeVote();
  
  PKMsgCS_AnswerPurgeVote(const PKMsgCS_AnswerPurgeVote& from);
  
  inline PKMsgCS_AnswerPurgeVote& operator=(const PKMsgCS_AnswerPurgeVote& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgCS_AnswerPurgeVote& default_instance();
  
  void Swap(PKMsgCS_AnswerPurgeVote* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgCS_AnswerPurgeVote* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgCS_AnswerPurgeVote& from);
  void MergeFrom(const PKMsgCS_AnswerPurgeVote& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lAnswer = 1;
  inline bool has_m_lanswer() const;
  inline void clear_m_lanswer();
  static const int kMLAnswerFieldNumber = 1;
  inline ::google::protobuf::int32 m_lanswer() const;
  inline void set_m_lanswer(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PKMsgCS_AnswerPurgeVote)
 private:
  inline void set_has_m_lanswer();
  inline void clear_has_m_lanswer();
  
  ::google::protobuf::int32 m_lanswer_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgCS_AnswerPurgeVote* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgCS_WaitingUserTicketReq : public ::google::protobuf::MessageLite {
 public:
  PKMsgCS_WaitingUserTicketReq();
  virtual ~PKMsgCS_WaitingUserTicketReq();
  
  PKMsgCS_WaitingUserTicketReq(const PKMsgCS_WaitingUserTicketReq& from);
  
  inline PKMsgCS_WaitingUserTicketReq& operator=(const PKMsgCS_WaitingUserTicketReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgCS_WaitingUserTicketReq& default_instance();
  
  void Swap(PKMsgCS_WaitingUserTicketReq* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgCS_WaitingUserTicketReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgCS_WaitingUserTicketReq& from);
  void MergeFrom(const PKMsgCS_WaitingUserTicketReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 m_nType = 1;
  inline bool has_m_ntype() const;
  inline void clear_m_ntype();
  static const int kMNTypeFieldNumber = 1;
  inline ::google::protobuf::int32 m_ntype() const;
  inline void set_m_ntype(::google::protobuf::int32 value);
  
  // required sint32 m_bValue = 2;
  inline bool has_m_bvalue() const;
  inline void clear_m_bvalue();
  static const int kMBValueFieldNumber = 2;
  inline ::google::protobuf::int32 m_bvalue() const;
  inline void set_m_bvalue(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PKMsgCS_WaitingUserTicketReq)
 private:
  inline void set_has_m_ntype();
  inline void clear_has_m_ntype();
  inline void set_has_m_bvalue();
  inline void clear_has_m_bvalue();
  
  ::google::protobuf::int32 m_ntype_;
  ::google::protobuf::int32 m_bvalue_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgCS_WaitingUserTicketReq* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgCS_UpdateWaitingUserInfoReq : public ::google::protobuf::MessageLite {
 public:
  PKMsgCS_UpdateWaitingUserInfoReq();
  virtual ~PKMsgCS_UpdateWaitingUserInfoReq();
  
  PKMsgCS_UpdateWaitingUserInfoReq(const PKMsgCS_UpdateWaitingUserInfoReq& from);
  
  inline PKMsgCS_UpdateWaitingUserInfoReq& operator=(const PKMsgCS_UpdateWaitingUserInfoReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgCS_UpdateWaitingUserInfoReq& default_instance();
  
  void Swap(PKMsgCS_UpdateWaitingUserInfoReq* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgCS_UpdateWaitingUserInfoReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgCS_UpdateWaitingUserInfoReq& from);
  void MergeFrom(const PKMsgCS_UpdateWaitingUserInfoReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:PKMsgCS_UpdateWaitingUserInfoReq)
 private:
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgCS_UpdateWaitingUserInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgCS_SoundType : public ::google::protobuf::MessageLite {
 public:
  PKMsgCS_SoundType();
  virtual ~PKMsgCS_SoundType();
  
  PKMsgCS_SoundType(const PKMsgCS_SoundType& from);
  
  inline PKMsgCS_SoundType& operator=(const PKMsgCS_SoundType& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgCS_SoundType& default_instance();
  
  void Swap(PKMsgCS_SoundType* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgCS_SoundType* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgCS_SoundType& from);
  void MergeFrom(const PKMsgCS_SoundType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lSoundType = 1;
  inline bool has_m_lsoundtype() const;
  inline void clear_m_lsoundtype();
  static const int kMLSoundTypeFieldNumber = 1;
  inline ::google::protobuf::int32 m_lsoundtype() const;
  inline void set_m_lsoundtype(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PKMsgCS_SoundType)
 private:
  inline void set_has_m_lsoundtype();
  inline void clear_has_m_lsoundtype();
  
  ::google::protobuf::int32 m_lsoundtype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgCS_SoundType* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgCS_ExitQue : public ::google::protobuf::MessageLite {
 public:
  PKMsgCS_ExitQue();
  virtual ~PKMsgCS_ExitQue();
  
  PKMsgCS_ExitQue(const PKMsgCS_ExitQue& from);
  
  inline PKMsgCS_ExitQue& operator=(const PKMsgCS_ExitQue& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgCS_ExitQue& default_instance();
  
  void Swap(PKMsgCS_ExitQue* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgCS_ExitQue* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgCS_ExitQue& from);
  void MergeFrom(const PKMsgCS_ExitQue& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lExit = 1;
  inline bool has_m_lexit() const;
  inline void clear_m_lexit();
  static const int kMLExitFieldNumber = 1;
  inline ::google::protobuf::int32 m_lexit() const;
  inline void set_m_lexit(::google::protobuf::int32 value);
  
  // required sint32 m_bAction = 2;
  inline bool has_m_baction() const;
  inline void clear_m_baction();
  static const int kMBActionFieldNumber = 2;
  inline ::google::protobuf::int32 m_baction() const;
  inline void set_m_baction(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PKMsgCS_ExitQue)
 private:
  inline void set_has_m_lexit();
  inline void clear_has_m_lexit();
  inline void set_has_m_baction();
  inline void clear_has_m_baction();
  
  ::google::protobuf::int32 m_lexit_;
  ::google::protobuf::int32 m_baction_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgCS_ExitQue* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgCS_Continue : public ::google::protobuf::MessageLite {
 public:
  PKMsgCS_Continue();
  virtual ~PKMsgCS_Continue();
  
  PKMsgCS_Continue(const PKMsgCS_Continue& from);
  
  inline PKMsgCS_Continue& operator=(const PKMsgCS_Continue& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgCS_Continue& default_instance();
  
  void Swap(PKMsgCS_Continue* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgCS_Continue* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgCS_Continue& from);
  void MergeFrom(const PKMsgCS_Continue& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lExit = 1;
  inline bool has_m_lexit() const;
  inline void clear_m_lexit();
  static const int kMLExitFieldNumber = 1;
  inline ::google::protobuf::int32 m_lexit() const;
  inline void set_m_lexit(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PKMsgCS_Continue)
 private:
  inline void set_has_m_lexit();
  inline void clear_has_m_lexit();
  
  ::google::protobuf::int32 m_lexit_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgCS_Continue* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgCS_RuleSet : public ::google::protobuf::MessageLite {
 public:
  PKMsgCS_RuleSet();
  virtual ~PKMsgCS_RuleSet();
  
  PKMsgCS_RuleSet(const PKMsgCS_RuleSet& from);
  
  inline PKMsgCS_RuleSet& operator=(const PKMsgCS_RuleSet& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgCS_RuleSet& default_instance();
  
  void Swap(PKMsgCS_RuleSet* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgCS_RuleSet* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgCS_RuleSet& from);
  void MergeFrom(const PKMsgCS_RuleSet& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 m_nRuleIdx = 1;
  inline bool has_m_nruleidx() const;
  inline void clear_m_nruleidx();
  static const int kMNRuleIdxFieldNumber = 1;
  inline ::google::protobuf::int32 m_nruleidx() const;
  inline void set_m_nruleidx(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PKMsgCS_RuleSet)
 private:
  inline void set_has_m_nruleidx();
  inline void clear_has_m_nruleidx();
  
  ::google::protobuf::int32 m_nruleidx_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgCS_RuleSet* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgCS_GameMasterCall : public ::google::protobuf::MessageLite {
 public:
  PKMsgCS_GameMasterCall();
  virtual ~PKMsgCS_GameMasterCall();
  
  PKMsgCS_GameMasterCall(const PKMsgCS_GameMasterCall& from);
  
  inline PKMsgCS_GameMasterCall& operator=(const PKMsgCS_GameMasterCall& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgCS_GameMasterCall& default_instance();
  
  void Swap(PKMsgCS_GameMasterCall* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgCS_GameMasterCall* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgCS_GameMasterCall& from);
  void MergeFrom(const PKMsgCS_GameMasterCall& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:PKMsgCS_GameMasterCall)
 private:
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgCS_GameMasterCall* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgCS_FieldReserved : public ::google::protobuf::MessageLite {
 public:
  PKMsgCS_FieldReserved();
  virtual ~PKMsgCS_FieldReserved();
  
  PKMsgCS_FieldReserved(const PKMsgCS_FieldReserved& from);
  
  inline PKMsgCS_FieldReserved& operator=(const PKMsgCS_FieldReserved& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgCS_FieldReserved& default_instance();
  
  void Swap(PKMsgCS_FieldReserved* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgCS_FieldReserved* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgCS_FieldReserved& from);
  void MergeFrom(const PKMsgCS_FieldReserved& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 m_nReserved1 = 1;
  inline bool has_m_nreserved1() const;
  inline void clear_m_nreserved1();
  static const int kMNReserved1FieldNumber = 1;
  inline ::google::protobuf::int32 m_nreserved1() const;
  inline void set_m_nreserved1(::google::protobuf::int32 value);
  
  // required int32 m_nReserved2 = 2;
  inline bool has_m_nreserved2() const;
  inline void clear_m_nreserved2();
  static const int kMNReserved2FieldNumber = 2;
  inline ::google::protobuf::int32 m_nreserved2() const;
  inline void set_m_nreserved2(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PKMsgCS_FieldReserved)
 private:
  inline void set_has_m_nreserved1();
  inline void clear_has_m_nreserved1();
  inline void set_has_m_nreserved2();
  inline void clear_has_m_nreserved2();
  
  ::google::protobuf::int32 m_nreserved1_;
  ::google::protobuf::int32 m_nreserved2_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgCS_FieldReserved* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgCS_JokboSet : public ::google::protobuf::MessageLite {
 public:
  PKMsgCS_JokboSet();
  virtual ~PKMsgCS_JokboSet();
  
  PKMsgCS_JokboSet(const PKMsgCS_JokboSet& from);
  
  inline PKMsgCS_JokboSet& operator=(const PKMsgCS_JokboSet& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgCS_JokboSet& default_instance();
  
  void Swap(PKMsgCS_JokboSet* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgCS_JokboSet* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgCS_JokboSet& from);
  void MergeFrom(const PKMsgCS_JokboSet& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lKey1 = 1;
  inline bool has_m_lkey1() const;
  inline void clear_m_lkey1();
  static const int kMLKey1FieldNumber = 1;
  inline ::google::protobuf::int32 m_lkey1() const;
  inline void set_m_lkey1(::google::protobuf::int32 value);
  
  // required sint32 m_lKey2 = 2;
  inline bool has_m_lkey2() const;
  inline void clear_m_lkey2();
  static const int kMLKey2FieldNumber = 2;
  inline ::google::protobuf::int32 m_lkey2() const;
  inline void set_m_lkey2(::google::protobuf::int32 value);
  
  // required sint32 m_lKey3 = 3;
  inline bool has_m_lkey3() const;
  inline void clear_m_lkey3();
  static const int kMLKey3FieldNumber = 3;
  inline ::google::protobuf::int32 m_lkey3() const;
  inline void set_m_lkey3(::google::protobuf::int32 value);
  
  // required sint32 m_lKey4 = 4;
  inline bool has_m_lkey4() const;
  inline void clear_m_lkey4();
  static const int kMLKey4FieldNumber = 4;
  inline ::google::protobuf::int32 m_lkey4() const;
  inline void set_m_lkey4(::google::protobuf::int32 value);
  
  // required sint32 m_lKey5 = 5;
  inline bool has_m_lkey5() const;
  inline void clear_m_lkey5();
  static const int kMLKey5FieldNumber = 5;
  inline ::google::protobuf::int32 m_lkey5() const;
  inline void set_m_lkey5(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PKMsgCS_JokboSet)
 private:
  inline void set_has_m_lkey1();
  inline void clear_has_m_lkey1();
  inline void set_has_m_lkey2();
  inline void clear_has_m_lkey2();
  inline void set_has_m_lkey3();
  inline void clear_has_m_lkey3();
  inline void set_has_m_lkey4();
  inline void clear_has_m_lkey4();
  inline void set_has_m_lkey5();
  inline void clear_has_m_lkey5();
  
  ::google::protobuf::int32 m_lkey1_;
  ::google::protobuf::int32 m_lkey2_;
  ::google::protobuf::int32 m_lkey3_;
  ::google::protobuf::int32 m_lkey4_;
  ::google::protobuf::int32 m_lkey5_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgCS_JokboSet* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgCS_TestKeySetting : public ::google::protobuf::MessageLite {
 public:
  PKMsgCS_TestKeySetting();
  virtual ~PKMsgCS_TestKeySetting();
  
  PKMsgCS_TestKeySetting(const PKMsgCS_TestKeySetting& from);
  
  inline PKMsgCS_TestKeySetting& operator=(const PKMsgCS_TestKeySetting& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgCS_TestKeySetting& default_instance();
  
  void Swap(PKMsgCS_TestKeySetting* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgCS_TestKeySetting* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgCS_TestKeySetting& from);
  void MergeFrom(const PKMsgCS_TestKeySetting& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 m_nChar = 1;
  inline bool has_m_nchar() const;
  inline void clear_m_nchar();
  static const int kMNCharFieldNumber = 1;
  inline ::google::protobuf::uint32 m_nchar() const;
  inline void set_m_nchar(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:PKMsgCS_TestKeySetting)
 private:
  inline void set_has_m_nchar();
  inline void clear_has_m_nchar();
  
  ::google::protobuf::uint32 m_nchar_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgCS_TestKeySetting* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgCS_CheckNotice : public ::google::protobuf::MessageLite {
 public:
  PKMsgCS_CheckNotice();
  virtual ~PKMsgCS_CheckNotice();
  
  PKMsgCS_CheckNotice(const PKMsgCS_CheckNotice& from);
  
  inline PKMsgCS_CheckNotice& operator=(const PKMsgCS_CheckNotice& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgCS_CheckNotice& default_instance();
  
  void Swap(PKMsgCS_CheckNotice* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgCS_CheckNotice* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgCS_CheckNotice& from);
  void MergeFrom(const PKMsgCS_CheckNotice& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 m_nType = 1;
  inline bool has_m_ntype() const;
  inline void clear_m_ntype();
  static const int kMNTypeFieldNumber = 1;
  inline ::google::protobuf::int32 m_ntype() const;
  inline void set_m_ntype(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PKMsgCS_CheckNotice)
 private:
  inline void set_has_m_ntype();
  inline void clear_has_m_ntype();
  
  ::google::protobuf::int32 m_ntype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgCS_CheckNotice* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgCS_Ack : public ::google::protobuf::MessageLite {
 public:
  PKMsgCS_Ack();
  virtual ~PKMsgCS_Ack();
  
  PKMsgCS_Ack(const PKMsgCS_Ack& from);
  
  inline PKMsgCS_Ack& operator=(const PKMsgCS_Ack& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgCS_Ack& default_instance();
  
  void Swap(PKMsgCS_Ack* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgCS_Ack* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgCS_Ack& from);
  void MergeFrom(const PKMsgCS_Ack& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 m_nTagID = 1;
  inline bool has_m_ntagid() const;
  inline void clear_m_ntagid();
  static const int kMNTagIDFieldNumber = 1;
  inline ::google::protobuf::int32 m_ntagid() const;
  inline void set_m_ntagid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PKMsgCS_Ack)
 private:
  inline void set_has_m_ntagid();
  inline void clear_has_m_ntagid();
  
  ::google::protobuf::int32 m_ntagid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgCS_Ack* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgCS_Ping : public ::google::protobuf::MessageLite {
 public:
  PKMsgCS_Ping();
  virtual ~PKMsgCS_Ping();
  
  PKMsgCS_Ping(const PKMsgCS_Ping& from);
  
  inline PKMsgCS_Ping& operator=(const PKMsgCS_Ping& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgCS_Ping& default_instance();
  
  void Swap(PKMsgCS_Ping* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgCS_Ping* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgCS_Ping& from);
  void MergeFrom(const PKMsgCS_Ping& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:PKMsgCS_Ping)
 private:
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgCS_Ping* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_UserJoinAns : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_UserJoinAns();
  virtual ~PKMsgSC_UserJoinAns();
  
  PKMsgSC_UserJoinAns(const PKMsgSC_UserJoinAns& from);
  
  inline PKMsgSC_UserJoinAns& operator=(const PKMsgSC_UserJoinAns& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_UserJoinAns& default_instance();
  
  void Swap(PKMsgSC_UserJoinAns* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_UserJoinAns* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_UserJoinAns& from);
  void MergeFrom(const PKMsgSC_UserJoinAns& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lState = 1;
  inline bool has_m_lstate() const;
  inline void clear_m_lstate();
  static const int kMLStateFieldNumber = 1;
  inline ::google::protobuf::int32 m_lstate() const;
  inline void set_m_lstate(::google::protobuf::int32 value);
  
  // required int32 m_nEnter = 2;
  inline bool has_m_nenter() const;
  inline void clear_m_nenter();
  static const int kMNEnterFieldNumber = 2;
  inline ::google::protobuf::int32 m_nenter() const;
  inline void set_m_nenter(::google::protobuf::int32 value);
  
  // required int32 m_nSet = 3;
  inline bool has_m_nset() const;
  inline void clear_m_nset();
  static const int kMNSetFieldNumber = 3;
  inline ::google::protobuf::int32 m_nset() const;
  inline void set_m_nset(::google::protobuf::int32 value);
  
  // required int32 m_lChannel_idx = 4;
  inline bool has_m_lchannel_idx() const;
  inline void clear_m_lchannel_idx();
  static const int kMLChannelIdxFieldNumber = 4;
  inline ::google::protobuf::int32 m_lchannel_idx() const;
  inline void set_m_lchannel_idx(::google::protobuf::int32 value);
  
  // required sint32 m_lOwnerUSN = 5;
  inline bool has_m_lownerusn() const;
  inline void clear_m_lownerusn();
  static const int kMLOwnerUSNFieldNumber = 5;
  inline ::google::protobuf::int32 m_lownerusn() const;
  inline void set_m_lownerusn(::google::protobuf::int32 value);
  
  // required sint32 m_lBossUSN = 6;
  inline bool has_m_lbossusn() const;
  inline void clear_m_lbossusn();
  static const int kMLBossUSNFieldNumber = 6;
  inline ::google::protobuf::int32 m_lbossusn() const;
  inline void set_m_lbossusn(::google::protobuf::int32 value);
  
  // required int32 m_nRoomPurgeCnt = 7;
  inline bool has_m_nroompurgecnt() const;
  inline void clear_m_nroompurgecnt();
  static const int kMNRoomPurgeCntFieldNumber = 7;
  inline ::google::protobuf::int32 m_nroompurgecnt() const;
  inline void set_m_nroompurgecnt(::google::protobuf::int32 value);
  
  // required .PKOption m_option = 8;
  inline bool has_m_option() const;
  inline void clear_m_option();
  static const int kMOptionFieldNumber = 8;
  inline const ::PKOption& m_option() const;
  inline ::PKOption* mutable_m_option();
  inline ::PKOption* release_m_option();
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_UserJoinAns)
 private:
  inline void set_has_m_lstate();
  inline void clear_has_m_lstate();
  inline void set_has_m_nenter();
  inline void clear_has_m_nenter();
  inline void set_has_m_nset();
  inline void clear_has_m_nset();
  inline void set_has_m_lchannel_idx();
  inline void clear_has_m_lchannel_idx();
  inline void set_has_m_lownerusn();
  inline void clear_has_m_lownerusn();
  inline void set_has_m_lbossusn();
  inline void clear_has_m_lbossusn();
  inline void set_has_m_nroompurgecnt();
  inline void clear_has_m_nroompurgecnt();
  inline void set_has_m_option();
  inline void clear_has_m_option();
  
  ::google::protobuf::int32 m_lstate_;
  ::google::protobuf::int32 m_nenter_;
  ::google::protobuf::int32 m_nset_;
  ::google::protobuf::int32 m_lchannel_idx_;
  ::google::protobuf::int32 m_lownerusn_;
  ::google::protobuf::int32 m_lbossusn_;
  ::PKOption* m_option_;
  ::google::protobuf::int32 m_nroompurgecnt_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_UserJoinAns* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_UserJoinErr : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_UserJoinErr();
  virtual ~PKMsgSC_UserJoinErr();
  
  PKMsgSC_UserJoinErr(const PKMsgSC_UserJoinErr& from);
  
  inline PKMsgSC_UserJoinErr& operator=(const PKMsgSC_UserJoinErr& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_UserJoinErr& default_instance();
  
  void Swap(PKMsgSC_UserJoinErr* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_UserJoinErr* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_UserJoinErr& from);
  void MergeFrom(const PKMsgSC_UserJoinErr& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lUSN = 1;
  inline bool has_m_lusn() const;
  inline void clear_m_lusn();
  static const int kMLUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lusn() const;
  inline void set_m_lusn(::google::protobuf::int32 value);
  
  // required sint32 m_lErrorCode = 2;
  inline bool has_m_lerrorcode() const;
  inline void clear_m_lerrorcode();
  static const int kMLErrorCodeFieldNumber = 2;
  inline ::google::protobuf::int32 m_lerrorcode() const;
  inline void set_m_lerrorcode(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_UserJoinErr)
 private:
  inline void set_has_m_lusn();
  inline void clear_has_m_lusn();
  inline void set_has_m_lerrorcode();
  inline void clear_has_m_lerrorcode();
  
  ::google::protobuf::int32 m_lusn_;
  ::google::protobuf::int32 m_lerrorcode_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_UserJoinErr* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_UserDisconnect : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_UserDisconnect();
  virtual ~PKMsgSC_UserDisconnect();
  
  PKMsgSC_UserDisconnect(const PKMsgSC_UserDisconnect& from);
  
  inline PKMsgSC_UserDisconnect& operator=(const PKMsgSC_UserDisconnect& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_UserDisconnect& default_instance();
  
  void Swap(PKMsgSC_UserDisconnect* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_UserDisconnect* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_UserDisconnect& from);
  void MergeFrom(const PKMsgSC_UserDisconnect& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lUSN = 1;
  inline bool has_m_lusn() const;
  inline void clear_m_lusn();
  static const int kMLUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lusn() const;
  inline void set_m_lusn(::google::protobuf::int32 value);
  
  // required .PKUserInfo m_uinfo = 2;
  inline bool has_m_uinfo() const;
  inline void clear_m_uinfo();
  static const int kMUinfoFieldNumber = 2;
  inline const ::PKUserInfo& m_uinfo() const;
  inline ::PKUserInfo* mutable_m_uinfo();
  inline ::PKUserInfo* release_m_uinfo();
  
  // required sint32 m_lState = 3;
  inline bool has_m_lstate() const;
  inline void clear_m_lstate();
  static const int kMLStateFieldNumber = 3;
  inline ::google::protobuf::int32 m_lstate() const;
  inline void set_m_lstate(::google::protobuf::int32 value);
  
  // required sint32 m_lOwnerUSN = 4;
  inline bool has_m_lownerusn() const;
  inline void clear_m_lownerusn();
  static const int kMLOwnerUSNFieldNumber = 4;
  inline ::google::protobuf::int32 m_lownerusn() const;
  inline void set_m_lownerusn(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_UserDisconnect)
 private:
  inline void set_has_m_lusn();
  inline void clear_has_m_lusn();
  inline void set_has_m_uinfo();
  inline void clear_has_m_uinfo();
  inline void set_has_m_lstate();
  inline void clear_has_m_lstate();
  inline void set_has_m_lownerusn();
  inline void clear_has_m_lownerusn();
  
  ::PKUserInfo* m_uinfo_;
  ::google::protobuf::int32 m_lusn_;
  ::google::protobuf::int32 m_lstate_;
  ::google::protobuf::int32 m_lownerusn_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_UserDisconnect* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_CardData : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_CardData();
  virtual ~PKMsgSC_CardData();
  
  PKMsgSC_CardData(const PKMsgSC_CardData& from);
  
  inline PKMsgSC_CardData& operator=(const PKMsgSC_CardData& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_CardData& default_instance();
  
  void Swap(PKMsgSC_CardData* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_CardData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_CardData& from);
  void MergeFrom(const PKMsgSC_CardData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 m_nDealCnt = 1;
  inline bool has_m_ndealcnt() const;
  inline void clear_m_ndealcnt();
  static const int kMNDealCntFieldNumber = 1;
  inline ::google::protobuf::int32 m_ndealcnt() const;
  inline void set_m_ndealcnt(::google::protobuf::int32 value);
  
  // required sint32 m_lCardsDealt = 2;
  inline bool has_m_lcardsdealt() const;
  inline void clear_m_lcardsdealt();
  static const int kMLCardsDealtFieldNumber = 2;
  inline ::google::protobuf::int32 m_lcardsdealt() const;
  inline void set_m_lcardsdealt(::google::protobuf::int32 value);
  
  // repeated .PKCards m_tblCard = 3;
  inline int m_tblcard_size() const;
  inline void clear_m_tblcard();
  static const int kMTblCardFieldNumber = 3;
  inline const ::PKCards& m_tblcard(int index) const;
  inline ::PKCards* mutable_m_tblcard(int index);
  inline ::PKCards* add_m_tblcard();
  inline const ::google::protobuf::RepeatedPtrField< ::PKCards >&
      m_tblcard() const;
  inline ::google::protobuf::RepeatedPtrField< ::PKCards >*
      mutable_m_tblcard();
  
  // repeated .PKMoney m_tblMoney = 4;
  inline int m_tblmoney_size() const;
  inline void clear_m_tblmoney();
  static const int kMTblMoneyFieldNumber = 4;
  inline const ::PKMoney& m_tblmoney(int index) const;
  inline ::PKMoney* mutable_m_tblmoney(int index);
  inline ::PKMoney* add_m_tblmoney();
  inline const ::google::protobuf::RepeatedPtrField< ::PKMoney >&
      m_tblmoney() const;
  inline ::google::protobuf::RepeatedPtrField< ::PKMoney >*
      mutable_m_tblmoney();
  
  // required sint64 m_llPoolMoney = 5;
  inline bool has_m_llpoolmoney() const;
  inline void clear_m_llpoolmoney();
  static const int kMLlPoolMoneyFieldNumber = 5;
  inline ::google::protobuf::int64 m_llpoolmoney() const;
  inline void set_m_llpoolmoney(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_CardData)
 private:
  inline void set_has_m_ndealcnt();
  inline void clear_has_m_ndealcnt();
  inline void set_has_m_lcardsdealt();
  inline void clear_has_m_lcardsdealt();
  inline void set_has_m_llpoolmoney();
  inline void clear_has_m_llpoolmoney();
  
  ::google::protobuf::int32 m_ndealcnt_;
  ::google::protobuf::int32 m_lcardsdealt_;
  ::google::protobuf::RepeatedPtrField< ::PKCards > m_tblcard_;
  ::google::protobuf::RepeatedPtrField< ::PKMoney > m_tblmoney_;
  ::google::protobuf::int64 m_llpoolmoney_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_CardData* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_EntryAns : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_EntryAns();
  virtual ~PKMsgSC_EntryAns();
  
  PKMsgSC_EntryAns(const PKMsgSC_EntryAns& from);
  
  inline PKMsgSC_EntryAns& operator=(const PKMsgSC_EntryAns& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_EntryAns& default_instance();
  
  void Swap(PKMsgSC_EntryAns* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_EntryAns* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_EntryAns& from);
  void MergeFrom(const PKMsgSC_EntryAns& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lUSN = 1;
  inline bool has_m_lusn() const;
  inline void clear_m_lusn();
  static const int kMLUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lusn() const;
  inline void set_m_lusn(::google::protobuf::int32 value);
  
  // required int32 m_nIndex = 2;
  inline bool has_m_nindex() const;
  inline void clear_m_nindex();
  static const int kMNIndexFieldNumber = 2;
  inline ::google::protobuf::int32 m_nindex() const;
  inline void set_m_nindex(::google::protobuf::int32 value);
  
  // required sint32 m_lOwnerUSN = 3;
  inline bool has_m_lownerusn() const;
  inline void clear_m_lownerusn();
  static const int kMLOwnerUSNFieldNumber = 3;
  inline ::google::protobuf::int32 m_lownerusn() const;
  inline void set_m_lownerusn(::google::protobuf::int32 value);
  
  // repeated .PKUserInfo m_tblUI = 4;
  inline int m_tblui_size() const;
  inline void clear_m_tblui();
  static const int kMTblUIFieldNumber = 4;
  inline const ::PKUserInfo& m_tblui(int index) const;
  inline ::PKUserInfo* mutable_m_tblui(int index);
  inline ::PKUserInfo* add_m_tblui();
  inline const ::google::protobuf::RepeatedPtrField< ::PKUserInfo >&
      m_tblui() const;
  inline ::google::protobuf::RepeatedPtrField< ::PKUserInfo >*
      mutable_m_tblui();
  
  // repeated .PKMoney m_tblMoney = 5;
  inline int m_tblmoney_size() const;
  inline void clear_m_tblmoney();
  static const int kMTblMoneyFieldNumber = 5;
  inline const ::PKMoney& m_tblmoney(int index) const;
  inline ::PKMoney* mutable_m_tblmoney(int index);
  inline ::PKMoney* add_m_tblmoney();
  inline const ::google::protobuf::RepeatedPtrField< ::PKMoney >&
      m_tblmoney() const;
  inline ::google::protobuf::RepeatedPtrField< ::PKMoney >*
      mutable_m_tblmoney();
  
  // required sint32 m_bWelcomeSound = 6;
  inline bool has_m_bwelcomesound() const;
  inline void clear_m_bwelcomesound();
  static const int kMBWelcomeSoundFieldNumber = 6;
  inline ::google::protobuf::int32 m_bwelcomesound() const;
  inline void set_m_bwelcomesound(::google::protobuf::int32 value);
  
  // required sint32 m_lObserveCnt = 7;
  inline bool has_m_lobservecnt() const;
  inline void clear_m_lobservecnt();
  static const int kMLObserveCntFieldNumber = 7;
  inline ::google::protobuf::int32 m_lobservecnt() const;
  inline void set_m_lobservecnt(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_EntryAns)
 private:
  inline void set_has_m_lusn();
  inline void clear_has_m_lusn();
  inline void set_has_m_nindex();
  inline void clear_has_m_nindex();
  inline void set_has_m_lownerusn();
  inline void clear_has_m_lownerusn();
  inline void set_has_m_bwelcomesound();
  inline void clear_has_m_bwelcomesound();
  inline void set_has_m_lobservecnt();
  inline void clear_has_m_lobservecnt();
  
  ::google::protobuf::int32 m_lusn_;
  ::google::protobuf::int32 m_nindex_;
  ::google::protobuf::RepeatedPtrField< ::PKUserInfo > m_tblui_;
  ::google::protobuf::int32 m_lownerusn_;
  ::google::protobuf::int32 m_bwelcomesound_;
  ::google::protobuf::RepeatedPtrField< ::PKMoney > m_tblmoney_;
  ::google::protobuf::int32 m_lobservecnt_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_EntryAns* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_EntryReject : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_EntryReject();
  virtual ~PKMsgSC_EntryReject();
  
  PKMsgSC_EntryReject(const PKMsgSC_EntryReject& from);
  
  inline PKMsgSC_EntryReject& operator=(const PKMsgSC_EntryReject& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_EntryReject& default_instance();
  
  void Swap(PKMsgSC_EntryReject* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_EntryReject* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_EntryReject& from);
  void MergeFrom(const PKMsgSC_EntryReject& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lType = 1;
  inline bool has_m_ltype() const;
  inline void clear_m_ltype();
  static const int kMLTypeFieldNumber = 1;
  inline ::google::protobuf::int32 m_ltype() const;
  inline void set_m_ltype(::google::protobuf::int32 value);
  
  // required sint64 m_llCMoney = 2;
  inline bool has_m_llcmoney() const;
  inline void clear_m_llcmoney();
  static const int kMLlCMoneyFieldNumber = 2;
  inline ::google::protobuf::int64 m_llcmoney() const;
  inline void set_m_llcmoney(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_EntryReject)
 private:
  inline void set_has_m_ltype();
  inline void clear_has_m_ltype();
  inline void set_has_m_llcmoney();
  inline void clear_has_m_llcmoney();
  
  ::google::protobuf::int64 m_llcmoney_;
  ::google::protobuf::int32 m_ltype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_EntryReject* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_ObserveAns : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_ObserveAns();
  virtual ~PKMsgSC_ObserveAns();
  
  PKMsgSC_ObserveAns(const PKMsgSC_ObserveAns& from);
  
  inline PKMsgSC_ObserveAns& operator=(const PKMsgSC_ObserveAns& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_ObserveAns& default_instance();
  
  void Swap(PKMsgSC_ObserveAns* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_ObserveAns* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_ObserveAns& from);
  void MergeFrom(const PKMsgSC_ObserveAns& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lUSN = 1;
  inline bool has_m_lusn() const;
  inline void clear_m_lusn();
  static const int kMLUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lusn() const;
  inline void set_m_lusn(::google::protobuf::int32 value);
  
  // required int32 m_nIndex = 2;
  inline bool has_m_nindex() const;
  inline void clear_m_nindex();
  static const int kMNIndexFieldNumber = 2;
  inline ::google::protobuf::int32 m_nindex() const;
  inline void set_m_nindex(::google::protobuf::int32 value);
  
  // required sint32 m_lOwnerUSN = 3;
  inline bool has_m_lownerusn() const;
  inline void clear_m_lownerusn();
  static const int kMLOwnerUSNFieldNumber = 3;
  inline ::google::protobuf::int32 m_lownerusn() const;
  inline void set_m_lownerusn(::google::protobuf::int32 value);
  
  // required .PKUserInfo m_uinfo = 4;
  inline bool has_m_uinfo() const;
  inline void clear_m_uinfo();
  static const int kMUinfoFieldNumber = 4;
  inline const ::PKUserInfo& m_uinfo() const;
  inline ::PKUserInfo* mutable_m_uinfo();
  inline ::PKUserInfo* release_m_uinfo();
  
  // required .PKMoney m_money = 5;
  inline bool has_m_money() const;
  inline void clear_m_money();
  static const int kMMoneyFieldNumber = 5;
  inline const ::PKMoney& m_money() const;
  inline ::PKMoney* mutable_m_money();
  inline ::PKMoney* release_m_money();
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_ObserveAns)
 private:
  inline void set_has_m_lusn();
  inline void clear_has_m_lusn();
  inline void set_has_m_nindex();
  inline void clear_has_m_nindex();
  inline void set_has_m_lownerusn();
  inline void clear_has_m_lownerusn();
  inline void set_has_m_uinfo();
  inline void clear_has_m_uinfo();
  inline void set_has_m_money();
  inline void clear_has_m_money();
  
  ::google::protobuf::int32 m_lusn_;
  ::google::protobuf::int32 m_nindex_;
  ::PKUserInfo* m_uinfo_;
  ::PKMoney* m_money_;
  ::google::protobuf::int32 m_lownerusn_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_ObserveAns* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_StartReq : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_StartReq();
  virtual ~PKMsgSC_StartReq();
  
  PKMsgSC_StartReq(const PKMsgSC_StartReq& from);
  
  inline PKMsgSC_StartReq& operator=(const PKMsgSC_StartReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_StartReq& default_instance();
  
  void Swap(PKMsgSC_StartReq* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_StartReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_StartReq& from);
  void MergeFrom(const PKMsgSC_StartReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_StartReq)
 private:
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_StartReq* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_StartAns : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_StartAns();
  virtual ~PKMsgSC_StartAns();
  
  PKMsgSC_StartAns(const PKMsgSC_StartAns& from);
  
  inline PKMsgSC_StartAns& operator=(const PKMsgSC_StartAns& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_StartAns& default_instance();
  
  void Swap(PKMsgSC_StartAns* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_StartAns* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_StartAns& from);
  void MergeFrom(const PKMsgSC_StartAns& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lState = 1;
  inline bool has_m_lstate() const;
  inline void clear_m_lstate();
  static const int kMLStateFieldNumber = 1;
  inline ::google::protobuf::int32 m_lstate() const;
  inline void set_m_lstate(::google::protobuf::int32 value);
  
  // repeated sint32 m_vtState = 2;
  inline int m_vtstate_size() const;
  inline void clear_m_vtstate();
  static const int kMVtStateFieldNumber = 2;
  inline ::google::protobuf::int32 m_vtstate(int index) const;
  inline void set_m_vtstate(int index, ::google::protobuf::int32 value);
  inline void add_m_vtstate(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      m_vtstate() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_m_vtstate();
  
  // required sint64 m_llSystemTime = 3;
  inline bool has_m_llsystemtime() const;
  inline void clear_m_llsystemtime();
  static const int kMLlSystemTimeFieldNumber = 3;
  inline ::google::protobuf::int64 m_llsystemtime() const;
  inline void set_m_llsystemtime(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_StartAns)
 private:
  inline void set_has_m_lstate();
  inline void clear_has_m_lstate();
  inline void set_has_m_llsystemtime();
  inline void clear_has_m_llsystemtime();
  
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > m_vtstate_;
  ::google::protobuf::int64 m_llsystemtime_;
  ::google::protobuf::int32 m_lstate_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_StartAns* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_NoStart : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_NoStart();
  virtual ~PKMsgSC_NoStart();
  
  PKMsgSC_NoStart(const PKMsgSC_NoStart& from);
  
  inline PKMsgSC_NoStart& operator=(const PKMsgSC_NoStart& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_NoStart& default_instance();
  
  void Swap(PKMsgSC_NoStart* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_NoStart* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_NoStart& from);
  void MergeFrom(const PKMsgSC_NoStart& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_NoStart)
 private:
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_NoStart* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_DealCards : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_DealCards();
  virtual ~PKMsgSC_DealCards();
  
  PKMsgSC_DealCards(const PKMsgSC_DealCards& from);
  
  inline PKMsgSC_DealCards& operator=(const PKMsgSC_DealCards& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_DealCards& default_instance();
  
  void Swap(PKMsgSC_DealCards* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_DealCards* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_DealCards& from);
  void MergeFrom(const PKMsgSC_DealCards& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lBossUSN = 1;
  inline bool has_m_lbossusn() const;
  inline void clear_m_lbossusn();
  static const int kMLBossUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lbossusn() const;
  inline void set_m_lbossusn(::google::protobuf::int32 value);
  
  // required sint32 m_lState = 2;
  inline bool has_m_lstate() const;
  inline void clear_m_lstate();
  static const int kMLStateFieldNumber = 2;
  inline ::google::protobuf::int32 m_lstate() const;
  inline void set_m_lstate(::google::protobuf::int32 value);
  
  // required int32 m_nType = 3;
  inline bool has_m_ntype() const;
  inline void clear_m_ntype();
  static const int kMNTypeFieldNumber = 3;
  inline ::google::protobuf::int32 m_ntype() const;
  inline void set_m_ntype(::google::protobuf::int32 value);
  
  // repeated .PKCards m_tblCard = 4;
  inline int m_tblcard_size() const;
  inline void clear_m_tblcard();
  static const int kMTblCardFieldNumber = 4;
  inline const ::PKCards& m_tblcard(int index) const;
  inline ::PKCards* mutable_m_tblcard(int index);
  inline ::PKCards* add_m_tblcard();
  inline const ::google::protobuf::RepeatedPtrField< ::PKCards >&
      m_tblcard() const;
  inline ::google::protobuf::RepeatedPtrField< ::PKCards >*
      mutable_m_tblcard();
  
  // repeated .PKMoney m_tblMoney = 5;
  inline int m_tblmoney_size() const;
  inline void clear_m_tblmoney();
  static const int kMTblMoneyFieldNumber = 5;
  inline const ::PKMoney& m_tblmoney(int index) const;
  inline ::PKMoney* mutable_m_tblmoney(int index);
  inline ::PKMoney* add_m_tblmoney();
  inline const ::google::protobuf::RepeatedPtrField< ::PKMoney >&
      m_tblmoney() const;
  inline ::google::protobuf::RepeatedPtrField< ::PKMoney >*
      mutable_m_tblmoney();
  
  // required sint64 m_llPoolMoney = 6;
  inline bool has_m_llpoolmoney() const;
  inline void clear_m_llpoolmoney();
  static const int kMLlPoolMoneyFieldNumber = 6;
  inline ::google::protobuf::int64 m_llpoolmoney() const;
  inline void set_m_llpoolmoney(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_DealCards)
 private:
  inline void set_has_m_lbossusn();
  inline void clear_has_m_lbossusn();
  inline void set_has_m_lstate();
  inline void clear_has_m_lstate();
  inline void set_has_m_ntype();
  inline void clear_has_m_ntype();
  inline void set_has_m_llpoolmoney();
  inline void clear_has_m_llpoolmoney();
  
  ::google::protobuf::int32 m_lbossusn_;
  ::google::protobuf::int32 m_lstate_;
  ::google::protobuf::RepeatedPtrField< ::PKCards > m_tblcard_;
  ::google::protobuf::RepeatedPtrField< ::PKMoney > m_tblmoney_;
  ::google::protobuf::int64 m_llpoolmoney_;
  ::google::protobuf::int32 m_ntype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_DealCards* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_SelectedCardAns : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_SelectedCardAns();
  virtual ~PKMsgSC_SelectedCardAns();
  
  PKMsgSC_SelectedCardAns(const PKMsgSC_SelectedCardAns& from);
  
  inline PKMsgSC_SelectedCardAns& operator=(const PKMsgSC_SelectedCardAns& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_SelectedCardAns& default_instance();
  
  void Swap(PKMsgSC_SelectedCardAns* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_SelectedCardAns* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_SelectedCardAns& from);
  void MergeFrom(const PKMsgSC_SelectedCardAns& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lUSN = 1;
  inline bool has_m_lusn() const;
  inline void clear_m_lusn();
  static const int kMLUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lusn() const;
  inline void set_m_lusn(::google::protobuf::int32 value);
  
  // required int32 m_nSelect = 2;
  inline bool has_m_nselect() const;
  inline void clear_m_nselect();
  static const int kMNSelectFieldNumber = 2;
  inline ::google::protobuf::int32 m_nselect() const;
  inline void set_m_nselect(::google::protobuf::int32 value);
  
  // required sint32 m_lCardIndex = 3;
  inline bool has_m_lcardindex() const;
  inline void clear_m_lcardindex();
  static const int kMLCardIndexFieldNumber = 3;
  inline ::google::protobuf::int32 m_lcardindex() const;
  inline void set_m_lcardindex(::google::protobuf::int32 value);
  
  // required sint32 m_lChoiceType = 4;
  inline bool has_m_lchoicetype() const;
  inline void clear_m_lchoicetype();
  static const int kMLChoiceTypeFieldNumber = 4;
  inline ::google::protobuf::int32 m_lchoicetype() const;
  inline void set_m_lchoicetype(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_SelectedCardAns)
 private:
  inline void set_has_m_lusn();
  inline void clear_has_m_lusn();
  inline void set_has_m_nselect();
  inline void clear_has_m_nselect();
  inline void set_has_m_lcardindex();
  inline void clear_has_m_lcardindex();
  inline void set_has_m_lchoicetype();
  inline void clear_has_m_lchoicetype();
  
  ::google::protobuf::int32 m_lusn_;
  ::google::protobuf::int32 m_nselect_;
  ::google::protobuf::int32 m_lcardindex_;
  ::google::protobuf::int32 m_lchoicetype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_SelectedCardAns* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_DealOpenCard : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_DealOpenCard();
  virtual ~PKMsgSC_DealOpenCard();
  
  PKMsgSC_DealOpenCard(const PKMsgSC_DealOpenCard& from);
  
  inline PKMsgSC_DealOpenCard& operator=(const PKMsgSC_DealOpenCard& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_DealOpenCard& default_instance();
  
  void Swap(PKMsgSC_DealOpenCard* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_DealOpenCard* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_DealOpenCard& from);
  void MergeFrom(const PKMsgSC_DealOpenCard& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lState = 1;
  inline bool has_m_lstate() const;
  inline void clear_m_lstate();
  static const int kMLStateFieldNumber = 1;
  inline ::google::protobuf::int32 m_lstate() const;
  inline void set_m_lstate(::google::protobuf::int32 value);
  
  // repeated .PKCards m_tblCard = 2;
  inline int m_tblcard_size() const;
  inline void clear_m_tblcard();
  static const int kMTblCardFieldNumber = 2;
  inline const ::PKCards& m_tblcard(int index) const;
  inline ::PKCards* mutable_m_tblcard(int index);
  inline ::PKCards* add_m_tblcard();
  inline const ::google::protobuf::RepeatedPtrField< ::PKCards >&
      m_tblcard() const;
  inline ::google::protobuf::RepeatedPtrField< ::PKCards >*
      mutable_m_tblcard();
  
  // repeated sint32 m_vtState = 3;
  inline int m_vtstate_size() const;
  inline void clear_m_vtstate();
  static const int kMVtStateFieldNumber = 3;
  inline ::google::protobuf::int32 m_vtstate(int index) const;
  inline void set_m_vtstate(int index, ::google::protobuf::int32 value);
  inline void add_m_vtstate(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      m_vtstate() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_m_vtstate();
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_DealOpenCard)
 private:
  inline void set_has_m_lstate();
  inline void clear_has_m_lstate();
  
  ::google::protobuf::RepeatedPtrField< ::PKCards > m_tblcard_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > m_vtstate_;
  ::google::protobuf::int32 m_lstate_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_DealOpenCard* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_DealCard : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_DealCard();
  virtual ~PKMsgSC_DealCard();
  
  PKMsgSC_DealCard(const PKMsgSC_DealCard& from);
  
  inline PKMsgSC_DealCard& operator=(const PKMsgSC_DealCard& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_DealCard& default_instance();
  
  void Swap(PKMsgSC_DealCard* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_DealCard* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_DealCard& from);
  void MergeFrom(const PKMsgSC_DealCard& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lBossUSN = 1;
  inline bool has_m_lbossusn() const;
  inline void clear_m_lbossusn();
  static const int kMLBossUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lbossusn() const;
  inline void set_m_lbossusn(::google::protobuf::int32 value);
  
  // required int32 m_nType = 2;
  inline bool has_m_ntype() const;
  inline void clear_m_ntype();
  static const int kMNTypeFieldNumber = 2;
  inline ::google::protobuf::int32 m_ntype() const;
  inline void set_m_ntype(::google::protobuf::int32 value);
  
  // required sint32 m_lCardsDealt = 3;
  inline bool has_m_lcardsdealt() const;
  inline void clear_m_lcardsdealt();
  static const int kMLCardsDealtFieldNumber = 3;
  inline ::google::protobuf::int32 m_lcardsdealt() const;
  inline void set_m_lcardsdealt(::google::protobuf::int32 value);
  
  // repeated .PKOneCard m_vtOneCard = 4;
  inline int m_vtonecard_size() const;
  inline void clear_m_vtonecard();
  static const int kMVtOneCardFieldNumber = 4;
  inline const ::PKOneCard& m_vtonecard(int index) const;
  inline ::PKOneCard* mutable_m_vtonecard(int index);
  inline ::PKOneCard* add_m_vtonecard();
  inline const ::google::protobuf::RepeatedPtrField< ::PKOneCard >&
      m_vtonecard() const;
  inline ::google::protobuf::RepeatedPtrField< ::PKOneCard >*
      mutable_m_vtonecard();
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_DealCard)
 private:
  inline void set_has_m_lbossusn();
  inline void clear_has_m_lbossusn();
  inline void set_has_m_ntype();
  inline void clear_has_m_ntype();
  inline void set_has_m_lcardsdealt();
  inline void clear_has_m_lcardsdealt();
  
  ::google::protobuf::int32 m_lbossusn_;
  ::google::protobuf::int32 m_ntype_;
  ::google::protobuf::RepeatedPtrField< ::PKOneCard > m_vtonecard_;
  ::google::protobuf::int32 m_lcardsdealt_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_DealCard* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_Boss : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_Boss();
  virtual ~PKMsgSC_Boss();
  
  PKMsgSC_Boss(const PKMsgSC_Boss& from);
  
  inline PKMsgSC_Boss& operator=(const PKMsgSC_Boss& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_Boss& default_instance();
  
  void Swap(PKMsgSC_Boss* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_Boss* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_Boss& from);
  void MergeFrom(const PKMsgSC_Boss& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lBossUSN = 1;
  inline bool has_m_lbossusn() const;
  inline void clear_m_lbossusn();
  static const int kMLBossUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lbossusn() const;
  inline void set_m_lbossusn(::google::protobuf::int32 value);
  
  // required int32 m_nBossRank = 2;
  inline bool has_m_nbossrank() const;
  inline void clear_m_nbossrank();
  static const int kMNBossRankFieldNumber = 2;
  inline ::google::protobuf::int32 m_nbossrank() const;
  inline void set_m_nbossrank(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_Boss)
 private:
  inline void set_has_m_lbossusn();
  inline void clear_has_m_lbossusn();
  inline void set_has_m_nbossrank();
  inline void clear_has_m_nbossrank();
  
  ::google::protobuf::int32 m_lbossusn_;
  ::google::protobuf::int32 m_nbossrank_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_Boss* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_Betting : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_Betting();
  virtual ~PKMsgSC_Betting();
  
  PKMsgSC_Betting(const PKMsgSC_Betting& from);
  
  inline PKMsgSC_Betting& operator=(const PKMsgSC_Betting& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_Betting& default_instance();
  
  void Swap(PKMsgSC_Betting* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_Betting* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_Betting& from);
  void MergeFrom(const PKMsgSC_Betting& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lBetUSN = 1;
  inline bool has_m_lbetusn() const;
  inline void clear_m_lbetusn();
  static const int kMLBetUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lbetusn() const;
  inline void set_m_lbetusn(::google::protobuf::int32 value);
  
  // required sint32 m_lBetBtnType = 2;
  inline bool has_m_lbetbtntype() const;
  inline void clear_m_lbetbtntype();
  static const int kMLBetBtnTypeFieldNumber = 2;
  inline ::google::protobuf::int32 m_lbetbtntype() const;
  inline void set_m_lbetbtntype(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_Betting)
 private:
  inline void set_has_m_lbetusn();
  inline void clear_has_m_lbetusn();
  inline void set_has_m_lbetbtntype();
  inline void clear_has_m_lbetbtntype();
  
  ::google::protobuf::int32 m_lbetusn_;
  ::google::protobuf::int32 m_lbetbtntype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_Betting* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_BettingAns : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_BettingAns();
  virtual ~PKMsgSC_BettingAns();
  
  PKMsgSC_BettingAns(const PKMsgSC_BettingAns& from);
  
  inline PKMsgSC_BettingAns& operator=(const PKMsgSC_BettingAns& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_BettingAns& default_instance();
  
  void Swap(PKMsgSC_BettingAns* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_BettingAns* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_BettingAns& from);
  void MergeFrom(const PKMsgSC_BettingAns& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 m_nIndex = 1;
  inline bool has_m_nindex() const;
  inline void clear_m_nindex();
  static const int kMNIndexFieldNumber = 1;
  inline ::google::protobuf::int32 m_nindex() const;
  inline void set_m_nindex(::google::protobuf::int32 value);
  
  // required sint32 m_lBetType = 2;
  inline bool has_m_lbettype() const;
  inline void clear_m_lbettype();
  static const int kMLBetTypeFieldNumber = 2;
  inline ::google::protobuf::int32 m_lbettype() const;
  inline void set_m_lbettype(::google::protobuf::int32 value);
  
  // required .PKMoney m_money = 3;
  inline bool has_m_money() const;
  inline void clear_m_money();
  static const int kMMoneyFieldNumber = 3;
  inline const ::PKMoney& m_money() const;
  inline ::PKMoney* mutable_m_money();
  inline ::PKMoney* release_m_money();
  
  // repeated .PKVecMoney m_vtCallMoney = 4;
  inline int m_vtcallmoney_size() const;
  inline void clear_m_vtcallmoney();
  static const int kMVtCallMoneyFieldNumber = 4;
  inline const ::PKVecMoney& m_vtcallmoney(int index) const;
  inline ::PKVecMoney* mutable_m_vtcallmoney(int index);
  inline ::PKVecMoney* add_m_vtcallmoney();
  inline const ::google::protobuf::RepeatedPtrField< ::PKVecMoney >&
      m_vtcallmoney() const;
  inline ::google::protobuf::RepeatedPtrField< ::PKVecMoney >*
      mutable_m_vtcallmoney();
  
  // required sint64 m_lPoolMoney = 5;
  inline bool has_m_lpoolmoney() const;
  inline void clear_m_lpoolmoney();
  static const int kMLPoolMoneyFieldNumber = 5;
  inline ::google::protobuf::int64 m_lpoolmoney() const;
  inline void set_m_lpoolmoney(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_BettingAns)
 private:
  inline void set_has_m_nindex();
  inline void clear_has_m_nindex();
  inline void set_has_m_lbettype();
  inline void clear_has_m_lbettype();
  inline void set_has_m_money();
  inline void clear_has_m_money();
  inline void set_has_m_lpoolmoney();
  inline void clear_has_m_lpoolmoney();
  
  ::google::protobuf::int32 m_nindex_;
  ::google::protobuf::int32 m_lbettype_;
  ::PKMoney* m_money_;
  ::google::protobuf::RepeatedPtrField< ::PKVecMoney > m_vtcallmoney_;
  ::google::protobuf::int64 m_lpoolmoney_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_BettingAns* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_BettingAnsMsg : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_BettingAnsMsg();
  virtual ~PKMsgSC_BettingAnsMsg();
  
  PKMsgSC_BettingAnsMsg(const PKMsgSC_BettingAnsMsg& from);
  
  inline PKMsgSC_BettingAnsMsg& operator=(const PKMsgSC_BettingAnsMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_BettingAnsMsg& default_instance();
  
  void Swap(PKMsgSC_BettingAnsMsg* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_BettingAnsMsg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_BettingAnsMsg& from);
  void MergeFrom(const PKMsgSC_BettingAnsMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lUSN = 1;
  inline bool has_m_lusn() const;
  inline void clear_m_lusn();
  static const int kMLUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lusn() const;
  inline void set_m_lusn(::google::protobuf::int32 value);
  
  // required int32 m_nIndex = 2;
  inline bool has_m_nindex() const;
  inline void clear_m_nindex();
  static const int kMNIndexFieldNumber = 2;
  inline ::google::protobuf::int32 m_nindex() const;
  inline void set_m_nindex(::google::protobuf::int32 value);
  
  // required sint32 m_BetType = 3;
  inline bool has_m_bettype() const;
  inline void clear_m_bettype();
  static const int kMBetTypeFieldNumber = 3;
  inline ::google::protobuf::int32 m_bettype() const;
  inline void set_m_bettype(::google::protobuf::int32 value);
  
  // required sint32 m_bBettingMoney = 4;
  inline bool has_m_bbettingmoney() const;
  inline void clear_m_bbettingmoney();
  static const int kMBBettingMoneyFieldNumber = 4;
  inline ::google::protobuf::int32 m_bbettingmoney() const;
  inline void set_m_bbettingmoney(::google::protobuf::int32 value);
  
  // required sint32 m_bMoneyLack = 5;
  inline bool has_m_bmoneylack() const;
  inline void clear_m_bmoneylack();
  static const int kMBMoneyLackFieldNumber = 5;
  inline ::google::protobuf::int32 m_bmoneylack() const;
  inline void set_m_bmoneylack(::google::protobuf::int32 value);
  
  // required sint32 m_bCallMoneyZero = 6;
  inline bool has_m_bcallmoneyzero() const;
  inline void clear_m_bcallmoneyzero();
  static const int kMBCallMoneyZeroFieldNumber = 6;
  inline ::google::protobuf::int32 m_bcallmoneyzero() const;
  inline void set_m_bcallmoneyzero(::google::protobuf::int32 value);
  
  // required sint64 m_llCallMoney = 7;
  inline bool has_m_llcallmoney() const;
  inline void clear_m_llcallmoney();
  static const int kMLlCallMoneyFieldNumber = 7;
  inline ::google::protobuf::int64 m_llcallmoney() const;
  inline void set_m_llcallmoney(::google::protobuf::int64 value);
  
  // required sint64 m_llRaiseMoney = 8;
  inline bool has_m_llraisemoney() const;
  inline void clear_m_llraisemoney();
  static const int kMLlRaiseMoneyFieldNumber = 8;
  inline ::google::protobuf::int64 m_llraisemoney() const;
  inline void set_m_llraisemoney(::google::protobuf::int64 value);
  
  // required sint64 m_llSideMoney = 9;
  inline bool has_m_llsidemoney() const;
  inline void clear_m_llsidemoney();
  static const int kMLlSideMoneyFieldNumber = 9;
  inline ::google::protobuf::int64 m_llsidemoney() const;
  inline void set_m_llsidemoney(::google::protobuf::int64 value);
  
  // required sint32 m_lBetType = 10;
  inline bool has_m_lbettype() const;
  inline void clear_m_lbettype();
  static const int kMLBetTypeFieldNumber = 10;
  inline ::google::protobuf::int32 m_lbettype() const;
  inline void set_m_lbettype(::google::protobuf::int32 value);
  
  // required sint32 m_lBetTurn = 11;
  inline bool has_m_lbetturn() const;
  inline void clear_m_lbetturn();
  static const int kMLBetTurnFieldNumber = 11;
  inline ::google::protobuf::int32 m_lbetturn() const;
  inline void set_m_lbetturn(::google::protobuf::int32 value);
  
  // required .PKMoney m_money = 12;
  inline bool has_m_money() const;
  inline void clear_m_money();
  static const int kMMoneyFieldNumber = 12;
  inline const ::PKMoney& m_money() const;
  inline ::PKMoney* mutable_m_money();
  inline ::PKMoney* release_m_money();
  
  // repeated .PKVecMoney m_vtCallMoney = 13;
  inline int m_vtcallmoney_size() const;
  inline void clear_m_vtcallmoney();
  static const int kMVtCallMoneyFieldNumber = 13;
  inline const ::PKVecMoney& m_vtcallmoney(int index) const;
  inline ::PKVecMoney* mutable_m_vtcallmoney(int index);
  inline ::PKVecMoney* add_m_vtcallmoney();
  inline const ::google::protobuf::RepeatedPtrField< ::PKVecMoney >&
      m_vtcallmoney() const;
  inline ::google::protobuf::RepeatedPtrField< ::PKVecMoney >*
      mutable_m_vtcallmoney();
  
  // required sint64 m_llPoolMoney = 14;
  inline bool has_m_llpoolmoney() const;
  inline void clear_m_llpoolmoney();
  static const int kMLlPoolMoneyFieldNumber = 14;
  inline ::google::protobuf::int64 m_llpoolmoney() const;
  inline void set_m_llpoolmoney(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_BettingAnsMsg)
 private:
  inline void set_has_m_lusn();
  inline void clear_has_m_lusn();
  inline void set_has_m_nindex();
  inline void clear_has_m_nindex();
  inline void set_has_m_bettype();
  inline void clear_has_m_bettype();
  inline void set_has_m_bbettingmoney();
  inline void clear_has_m_bbettingmoney();
  inline void set_has_m_bmoneylack();
  inline void clear_has_m_bmoneylack();
  inline void set_has_m_bcallmoneyzero();
  inline void clear_has_m_bcallmoneyzero();
  inline void set_has_m_llcallmoney();
  inline void clear_has_m_llcallmoney();
  inline void set_has_m_llraisemoney();
  inline void clear_has_m_llraisemoney();
  inline void set_has_m_llsidemoney();
  inline void clear_has_m_llsidemoney();
  inline void set_has_m_lbettype();
  inline void clear_has_m_lbettype();
  inline void set_has_m_lbetturn();
  inline void clear_has_m_lbetturn();
  inline void set_has_m_money();
  inline void clear_has_m_money();
  inline void set_has_m_llpoolmoney();
  inline void clear_has_m_llpoolmoney();
  
  ::google::protobuf::int32 m_lusn_;
  ::google::protobuf::int32 m_nindex_;
  ::google::protobuf::int32 m_bettype_;
  ::google::protobuf::int32 m_bbettingmoney_;
  ::google::protobuf::int32 m_bmoneylack_;
  ::google::protobuf::int32 m_bcallmoneyzero_;
  ::google::protobuf::int64 m_llcallmoney_;
  ::google::protobuf::int64 m_llraisemoney_;
  ::google::protobuf::int64 m_llsidemoney_;
  ::google::protobuf::int32 m_lbettype_;
  ::google::protobuf::int32 m_lbetturn_;
  ::PKMoney* m_money_;
  ::google::protobuf::RepeatedPtrField< ::PKVecMoney > m_vtcallmoney_;
  ::google::protobuf::int64 m_llpoolmoney_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_BettingAnsMsg* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_DealHiddenCard : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_DealHiddenCard();
  virtual ~PKMsgSC_DealHiddenCard();
  
  PKMsgSC_DealHiddenCard(const PKMsgSC_DealHiddenCard& from);
  
  inline PKMsgSC_DealHiddenCard& operator=(const PKMsgSC_DealHiddenCard& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_DealHiddenCard& default_instance();
  
  void Swap(PKMsgSC_DealHiddenCard* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_DealHiddenCard* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_DealHiddenCard& from);
  void MergeFrom(const PKMsgSC_DealHiddenCard& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lBossUSN = 1;
  inline bool has_m_lbossusn() const;
  inline void clear_m_lbossusn();
  static const int kMLBossUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lbossusn() const;
  inline void set_m_lbossusn(::google::protobuf::int32 value);
  
  // required sint32 m_lCardsDealt = 2;
  inline bool has_m_lcardsdealt() const;
  inline void clear_m_lcardsdealt();
  static const int kMLCardsDealtFieldNumber = 2;
  inline ::google::protobuf::int32 m_lcardsdealt() const;
  inline void set_m_lcardsdealt(::google::protobuf::int32 value);
  
  // repeated .PKOneCard m_vtOneCard = 3;
  inline int m_vtonecard_size() const;
  inline void clear_m_vtonecard();
  static const int kMVtOneCardFieldNumber = 3;
  inline const ::PKOneCard& m_vtonecard(int index) const;
  inline ::PKOneCard* mutable_m_vtonecard(int index);
  inline ::PKOneCard* add_m_vtonecard();
  inline const ::google::protobuf::RepeatedPtrField< ::PKOneCard >&
      m_vtonecard() const;
  inline ::google::protobuf::RepeatedPtrField< ::PKOneCard >*
      mutable_m_vtonecard();
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_DealHiddenCard)
 private:
  inline void set_has_m_lbossusn();
  inline void clear_has_m_lbossusn();
  inline void set_has_m_lcardsdealt();
  inline void clear_has_m_lcardsdealt();
  
  ::google::protobuf::int32 m_lbossusn_;
  ::google::protobuf::int32 m_lcardsdealt_;
  ::google::protobuf::RepeatedPtrField< ::PKOneCard > m_vtonecard_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_DealHiddenCard* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_AnteMoney : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_AnteMoney();
  virtual ~PKMsgSC_AnteMoney();
  
  PKMsgSC_AnteMoney(const PKMsgSC_AnteMoney& from);
  
  inline PKMsgSC_AnteMoney& operator=(const PKMsgSC_AnteMoney& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_AnteMoney& default_instance();
  
  void Swap(PKMsgSC_AnteMoney* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_AnteMoney* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_AnteMoney& from);
  void MergeFrom(const PKMsgSC_AnteMoney& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint64 m_llAnteMoney = 1;
  inline bool has_m_llantemoney() const;
  inline void clear_m_llantemoney();
  static const int kMLlAnteMoneyFieldNumber = 1;
  inline ::google::protobuf::int64 m_llantemoney() const;
  inline void set_m_llantemoney(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_AnteMoney)
 private:
  inline void set_has_m_llantemoney();
  inline void clear_has_m_llantemoney();
  
  ::google::protobuf::int64 m_llantemoney_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_AnteMoney* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_RuleQuaterHalf : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_RuleQuaterHalf();
  virtual ~PKMsgSC_RuleQuaterHalf();
  
  PKMsgSC_RuleQuaterHalf(const PKMsgSC_RuleQuaterHalf& from);
  
  inline PKMsgSC_RuleQuaterHalf& operator=(const PKMsgSC_RuleQuaterHalf& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_RuleQuaterHalf& default_instance();
  
  void Swap(PKMsgSC_RuleQuaterHalf* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_RuleQuaterHalf* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_RuleQuaterHalf& from);
  void MergeFrom(const PKMsgSC_RuleQuaterHalf& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint64 m_llRuleQuaterHalf = 1;
  inline bool has_m_llrulequaterhalf() const;
  inline void clear_m_llrulequaterhalf();
  static const int kMLlRuleQuaterHalfFieldNumber = 1;
  inline ::google::protobuf::int64 m_llrulequaterhalf() const;
  inline void set_m_llrulequaterhalf(::google::protobuf::int64 value);
  
  // required sint64 m_llPoolMoney = 2;
  inline bool has_m_llpoolmoney() const;
  inline void clear_m_llpoolmoney();
  static const int kMLlPoolMoneyFieldNumber = 2;
  inline ::google::protobuf::int64 m_llpoolmoney() const;
  inline void set_m_llpoolmoney(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_RuleQuaterHalf)
 private:
  inline void set_has_m_llrulequaterhalf();
  inline void clear_has_m_llrulequaterhalf();
  inline void set_has_m_llpoolmoney();
  inline void clear_has_m_llpoolmoney();
  
  ::google::protobuf::int64 m_llrulequaterhalf_;
  ::google::protobuf::int64 m_llpoolmoney_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_RuleQuaterHalf* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_Finished : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_Finished();
  virtual ~PKMsgSC_Finished();
  
  PKMsgSC_Finished(const PKMsgSC_Finished& from);
  
  inline PKMsgSC_Finished& operator=(const PKMsgSC_Finished& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_Finished& default_instance();
  
  void Swap(PKMsgSC_Finished* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_Finished* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_Finished& from);
  void MergeFrom(const PKMsgSC_Finished& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lState = 1;
  inline bool has_m_lstate() const;
  inline void clear_m_lstate();
  static const int kMLStateFieldNumber = 1;
  inline ::google::protobuf::int32 m_lstate() const;
  inline void set_m_lstate(::google::protobuf::int32 value);
  
  // required sint32 m_bGiveUp = 2;
  inline bool has_m_bgiveup() const;
  inline void clear_m_bgiveup();
  static const int kMBGiveUpFieldNumber = 2;
  inline ::google::protobuf::int32 m_bgiveup() const;
  inline void set_m_bgiveup(::google::protobuf::int32 value);
  
  // required sint32 m_lRank = 3;
  inline bool has_m_lrank() const;
  inline void clear_m_lrank();
  static const int kMLRankFieldNumber = 3;
  inline ::google::protobuf::int32 m_lrank() const;
  inline void set_m_lrank(::google::protobuf::int32 value);
  
  // required sint32 m_lBossUSN = 4;
  inline bool has_m_lbossusn() const;
  inline void clear_m_lbossusn();
  static const int kMLBossUSNFieldNumber = 4;
  inline ::google::protobuf::int32 m_lbossusn() const;
  inline void set_m_lbossusn(::google::protobuf::int32 value);
  
  // required sint64 m_llGiveMoney = 5;
  inline bool has_m_llgivemoney() const;
  inline void clear_m_llgivemoney();
  static const int kMLlGiveMoneyFieldNumber = 5;
  inline ::google::protobuf::int64 m_llgivemoney() const;
  inline void set_m_llgivemoney(::google::protobuf::int64 value);
  
  // repeated int32 m_vtWin = 6;
  inline int m_vtwin_size() const;
  inline void clear_m_vtwin();
  static const int kMVtWinFieldNumber = 6;
  inline ::google::protobuf::int32 m_vtwin(int index) const;
  inline void set_m_vtwin(int index, ::google::protobuf::int32 value);
  inline void add_m_vtwin(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      m_vtwin() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_m_vtwin();
  
  // repeated int32 m_vtResult = 7;
  inline int m_vtresult_size() const;
  inline void clear_m_vtresult();
  static const int kMVtResultFieldNumber = 7;
  inline ::google::protobuf::int32 m_vtresult(int index) const;
  inline void set_m_vtresult(int index, ::google::protobuf::int32 value);
  inline void add_m_vtresult(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      m_vtresult() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_m_vtresult();
  
  // repeated sint64 m_vtGiveMoney = 8;
  inline int m_vtgivemoney_size() const;
  inline void clear_m_vtgivemoney();
  static const int kMVtGiveMoneyFieldNumber = 8;
  inline ::google::protobuf::int64 m_vtgivemoney(int index) const;
  inline void set_m_vtgivemoney(int index, ::google::protobuf::int64 value);
  inline void add_m_vtgivemoney(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      m_vtgivemoney() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_m_vtgivemoney();
  
  // repeated .PKCards m_tblCard = 9;
  inline int m_tblcard_size() const;
  inline void clear_m_tblcard();
  static const int kMTblCardFieldNumber = 9;
  inline const ::PKCards& m_tblcard(int index) const;
  inline ::PKCards* mutable_m_tblcard(int index);
  inline ::PKCards* add_m_tblcard();
  inline const ::google::protobuf::RepeatedPtrField< ::PKCards >&
      m_tblcard() const;
  inline ::google::protobuf::RepeatedPtrField< ::PKCards >*
      mutable_m_tblcard();
  
  // repeated .PKMoney m_tblMoney = 10;
  inline int m_tblmoney_size() const;
  inline void clear_m_tblmoney();
  static const int kMTblMoneyFieldNumber = 10;
  inline const ::PKMoney& m_tblmoney(int index) const;
  inline ::PKMoney* mutable_m_tblmoney(int index);
  inline ::PKMoney* add_m_tblmoney();
  inline const ::google::protobuf::RepeatedPtrField< ::PKMoney >&
      m_tblmoney() const;
  inline ::google::protobuf::RepeatedPtrField< ::PKMoney >*
      mutable_m_tblmoney();
  
  // required sint64 m_llPoolMoney = 11;
  inline bool has_m_llpoolmoney() const;
  inline void clear_m_llpoolmoney();
  static const int kMLlPoolMoneyFieldNumber = 11;
  inline ::google::protobuf::int64 m_llpoolmoney() const;
  inline void set_m_llpoolmoney(::google::protobuf::int64 value);
  
  // repeated .UserMoney m_vtUserMoney = 12;
  inline int m_vtusermoney_size() const;
  inline void clear_m_vtusermoney();
  static const int kMVtUserMoneyFieldNumber = 12;
  inline const ::UserMoney& m_vtusermoney(int index) const;
  inline ::UserMoney* mutable_m_vtusermoney(int index);
  inline ::UserMoney* add_m_vtusermoney();
  inline const ::google::protobuf::RepeatedPtrField< ::UserMoney >&
      m_vtusermoney() const;
  inline ::google::protobuf::RepeatedPtrField< ::UserMoney >*
      mutable_m_vtusermoney();
  
  // required sint32 m_lResultIdx = 13;
  inline bool has_m_lresultidx() const;
  inline void clear_m_lresultidx();
  static const int kMLResultIdxFieldNumber = 13;
  inline ::google::protobuf::int32 m_lresultidx() const;
  inline void set_m_lresultidx(::google::protobuf::int32 value);
  
  // required sint64 m_llJackpot = 14;
  inline bool has_m_lljackpot() const;
  inline void clear_m_lljackpot();
  static const int kMLlJackpotFieldNumber = 14;
  inline ::google::protobuf::int64 m_lljackpot() const;
  inline void set_m_lljackpot(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_Finished)
 private:
  inline void set_has_m_lstate();
  inline void clear_has_m_lstate();
  inline void set_has_m_bgiveup();
  inline void clear_has_m_bgiveup();
  inline void set_has_m_lrank();
  inline void clear_has_m_lrank();
  inline void set_has_m_lbossusn();
  inline void clear_has_m_lbossusn();
  inline void set_has_m_llgivemoney();
  inline void clear_has_m_llgivemoney();
  inline void set_has_m_llpoolmoney();
  inline void clear_has_m_llpoolmoney();
  inline void set_has_m_lresultidx();
  inline void clear_has_m_lresultidx();
  inline void set_has_m_lljackpot();
  inline void clear_has_m_lljackpot();
  
  ::google::protobuf::int32 m_lstate_;
  ::google::protobuf::int32 m_bgiveup_;
  ::google::protobuf::int32 m_lrank_;
  ::google::protobuf::int32 m_lbossusn_;
  ::google::protobuf::int64 m_llgivemoney_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > m_vtwin_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > m_vtresult_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > m_vtgivemoney_;
  ::google::protobuf::RepeatedPtrField< ::PKCards > m_tblcard_;
  ::google::protobuf::RepeatedPtrField< ::PKMoney > m_tblmoney_;
  ::google::protobuf::int64 m_llpoolmoney_;
  ::google::protobuf::RepeatedPtrField< ::UserMoney > m_vtusermoney_;
  ::google::protobuf::int64 m_lljackpot_;
  ::google::protobuf::int32 m_lresultidx_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_Finished* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_NewGame : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_NewGame();
  virtual ~PKMsgSC_NewGame();
  
  PKMsgSC_NewGame(const PKMsgSC_NewGame& from);
  
  inline PKMsgSC_NewGame& operator=(const PKMsgSC_NewGame& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_NewGame& default_instance();
  
  void Swap(PKMsgSC_NewGame* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_NewGame* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_NewGame& from);
  void MergeFrom(const PKMsgSC_NewGame& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .PKWinLoseInfo m_vtWinLoseInfo = 1;
  inline int m_vtwinloseinfo_size() const;
  inline void clear_m_vtwinloseinfo();
  static const int kMVtWinLoseInfoFieldNumber = 1;
  inline const ::PKWinLoseInfo& m_vtwinloseinfo(int index) const;
  inline ::PKWinLoseInfo* mutable_m_vtwinloseinfo(int index);
  inline ::PKWinLoseInfo* add_m_vtwinloseinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::PKWinLoseInfo >&
      m_vtwinloseinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::PKWinLoseInfo >*
      mutable_m_vtwinloseinfo();
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_NewGame)
 private:
  
  ::google::protobuf::RepeatedPtrField< ::PKWinLoseInfo > m_vtwinloseinfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_NewGame* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_ContinueAns : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_ContinueAns();
  virtual ~PKMsgSC_ContinueAns();
  
  PKMsgSC_ContinueAns(const PKMsgSC_ContinueAns& from);
  
  inline PKMsgSC_ContinueAns& operator=(const PKMsgSC_ContinueAns& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_ContinueAns& default_instance();
  
  void Swap(PKMsgSC_ContinueAns* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_ContinueAns* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_ContinueAns& from);
  void MergeFrom(const PKMsgSC_ContinueAns& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lUSN = 1;
  inline bool has_m_lusn() const;
  inline void clear_m_lusn();
  static const int kMLUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lusn() const;
  inline void set_m_lusn(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_ContinueAns)
 private:
  inline void set_has_m_lusn();
  inline void clear_has_m_lusn();
  
  ::google::protobuf::int32 m_lusn_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_ContinueAns* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_Continue : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_Continue();
  virtual ~PKMsgSC_Continue();
  
  PKMsgSC_Continue(const PKMsgSC_Continue& from);
  
  inline PKMsgSC_Continue& operator=(const PKMsgSC_Continue& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_Continue& default_instance();
  
  void Swap(PKMsgSC_Continue* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_Continue* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_Continue& from);
  void MergeFrom(const PKMsgSC_Continue& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .PKWinLoseInfo m_vtWinLoseInfo = 1;
  inline int m_vtwinloseinfo_size() const;
  inline void clear_m_vtwinloseinfo();
  static const int kMVtWinLoseInfoFieldNumber = 1;
  inline const ::PKWinLoseInfo& m_vtwinloseinfo(int index) const;
  inline ::PKWinLoseInfo* mutable_m_vtwinloseinfo(int index);
  inline ::PKWinLoseInfo* add_m_vtwinloseinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::PKWinLoseInfo >&
      m_vtwinloseinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::PKWinLoseInfo >*
      mutable_m_vtwinloseinfo();
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_Continue)
 private:
  
  ::google::protobuf::RepeatedPtrField< ::PKWinLoseInfo > m_vtwinloseinfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_Continue* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_SystemMsg : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_SystemMsg();
  virtual ~PKMsgSC_SystemMsg();
  
  PKMsgSC_SystemMsg(const PKMsgSC_SystemMsg& from);
  
  inline PKMsgSC_SystemMsg& operator=(const PKMsgSC_SystemMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_SystemMsg& default_instance();
  
  void Swap(PKMsgSC_SystemMsg* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_SystemMsg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_SystemMsg& from);
  void MergeFrom(const PKMsgSC_SystemMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lType = 1;
  inline bool has_m_ltype() const;
  inline void clear_m_ltype();
  static const int kMLTypeFieldNumber = 1;
  inline ::google::protobuf::int32 m_ltype() const;
  inline void set_m_ltype(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_SystemMsg)
 private:
  inline void set_has_m_ltype();
  inline void clear_has_m_ltype();
  
  ::google::protobuf::int32 m_ltype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_SystemMsg* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_PurgeAns : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_PurgeAns();
  virtual ~PKMsgSC_PurgeAns();
  
  PKMsgSC_PurgeAns(const PKMsgSC_PurgeAns& from);
  
  inline PKMsgSC_PurgeAns& operator=(const PKMsgSC_PurgeAns& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_PurgeAns& default_instance();
  
  void Swap(PKMsgSC_PurgeAns* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_PurgeAns* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_PurgeAns& from);
  void MergeFrom(const PKMsgSC_PurgeAns& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_PurgeAns)
 private:
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_PurgeAns* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_PurgeInfo : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_PurgeInfo();
  virtual ~PKMsgSC_PurgeInfo();
  
  PKMsgSC_PurgeInfo(const PKMsgSC_PurgeInfo& from);
  
  inline PKMsgSC_PurgeInfo& operator=(const PKMsgSC_PurgeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_PurgeInfo& default_instance();
  
  void Swap(PKMsgSC_PurgeInfo* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_PurgeInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_PurgeInfo& from);
  void MergeFrom(const PKMsgSC_PurgeInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .PKVecUSN m_vtPurgeUSN = 1;
  inline int m_vtpurgeusn_size() const;
  inline void clear_m_vtpurgeusn();
  static const int kMVtPurgeUSNFieldNumber = 1;
  inline const ::PKVecUSN& m_vtpurgeusn(int index) const;
  inline ::PKVecUSN* mutable_m_vtpurgeusn(int index);
  inline ::PKVecUSN* add_m_vtpurgeusn();
  inline const ::google::protobuf::RepeatedPtrField< ::PKVecUSN >&
      m_vtpurgeusn() const;
  inline ::google::protobuf::RepeatedPtrField< ::PKVecUSN >*
      mutable_m_vtpurgeusn();
  
  // required int32 m_nCount = 2;
  inline bool has_m_ncount() const;
  inline void clear_m_ncount();
  static const int kMNCountFieldNumber = 2;
  inline ::google::protobuf::int32 m_ncount() const;
  inline void set_m_ncount(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_PurgeInfo)
 private:
  inline void set_has_m_ncount();
  inline void clear_has_m_ncount();
  
  ::google::protobuf::RepeatedPtrField< ::PKVecUSN > m_vtpurgeusn_;
  ::google::protobuf::int32 m_ncount_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_PurgeInfo* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_SetPurgeMoney : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_SetPurgeMoney();
  virtual ~PKMsgSC_SetPurgeMoney();
  
  PKMsgSC_SetPurgeMoney(const PKMsgSC_SetPurgeMoney& from);
  
  inline PKMsgSC_SetPurgeMoney& operator=(const PKMsgSC_SetPurgeMoney& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_SetPurgeMoney& default_instance();
  
  void Swap(PKMsgSC_SetPurgeMoney* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_SetPurgeMoney* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_SetPurgeMoney& from);
  void MergeFrom(const PKMsgSC_SetPurgeMoney& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lUSN = 1;
  inline bool has_m_lusn() const;
  inline void clear_m_lusn();
  static const int kMLUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lusn() const;
  inline void set_m_lusn(::google::protobuf::int32 value);
  
  // required .PKMoney m_money = 2;
  inline bool has_m_money() const;
  inline void clear_m_money();
  static const int kMMoneyFieldNumber = 2;
  inline const ::PKMoney& m_money() const;
  inline ::PKMoney* mutable_m_money();
  inline ::PKMoney* release_m_money();
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_SetPurgeMoney)
 private:
  inline void set_has_m_lusn();
  inline void clear_has_m_lusn();
  inline void set_has_m_money();
  inline void clear_has_m_money();
  
  ::PKMoney* m_money_;
  ::google::protobuf::int32 m_lusn_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_SetPurgeMoney* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_AssaItemNotify : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_AssaItemNotify();
  virtual ~PKMsgSC_AssaItemNotify();
  
  PKMsgSC_AssaItemNotify(const PKMsgSC_AssaItemNotify& from);
  
  inline PKMsgSC_AssaItemNotify& operator=(const PKMsgSC_AssaItemNotify& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_AssaItemNotify& default_instance();
  
  void Swap(PKMsgSC_AssaItemNotify* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_AssaItemNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_AssaItemNotify& from);
  void MergeFrom(const PKMsgSC_AssaItemNotify& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lUSN = 1;
  inline bool has_m_lusn() const;
  inline void clear_m_lusn();
  static const int kMLUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lusn() const;
  inline void set_m_lusn(::google::protobuf::int32 value);
  
  // required sint32 m_lRankType = 2;
  inline bool has_m_lranktype() const;
  inline void clear_m_lranktype();
  static const int kMLRankTypeFieldNumber = 2;
  inline ::google::protobuf::int32 m_lranktype() const;
  inline void set_m_lranktype(::google::protobuf::int32 value);
  
  // required string m_sItem = 3;
  inline bool has_m_sitem() const;
  inline void clear_m_sitem();
  static const int kMSItemFieldNumber = 3;
  inline const ::std::string& m_sitem() const;
  inline void set_m_sitem(const ::std::string& value);
  inline void set_m_sitem(const char* value);
  inline void set_m_sitem(const char* value, size_t size);
  inline ::std::string* mutable_m_sitem();
  inline ::std::string* release_m_sitem();
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_AssaItemNotify)
 private:
  inline void set_has_m_lusn();
  inline void clear_has_m_lusn();
  inline void set_has_m_lranktype();
  inline void clear_has_m_lranktype();
  inline void set_has_m_sitem();
  inline void clear_has_m_sitem();
  
  ::google::protobuf::int32 m_lusn_;
  ::google::protobuf::int32 m_lranktype_;
  ::std::string* m_sitem_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_AssaItemNotify* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_ThankYouItemNotify : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_ThankYouItemNotify();
  virtual ~PKMsgSC_ThankYouItemNotify();
  
  PKMsgSC_ThankYouItemNotify(const PKMsgSC_ThankYouItemNotify& from);
  
  inline PKMsgSC_ThankYouItemNotify& operator=(const PKMsgSC_ThankYouItemNotify& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_ThankYouItemNotify& default_instance();
  
  void Swap(PKMsgSC_ThankYouItemNotify* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_ThankYouItemNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_ThankYouItemNotify& from);
  void MergeFrom(const PKMsgSC_ThankYouItemNotify& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lUSN = 1;
  inline bool has_m_lusn() const;
  inline void clear_m_lusn();
  static const int kMLUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lusn() const;
  inline void set_m_lusn(::google::protobuf::int32 value);
  
  // required sint32 m_lRankType = 2;
  inline bool has_m_lranktype() const;
  inline void clear_m_lranktype();
  static const int kMLRankTypeFieldNumber = 2;
  inline ::google::protobuf::int32 m_lranktype() const;
  inline void set_m_lranktype(::google::protobuf::int32 value);
  
  // required sint64 m_llBasicDDangMoney = 3;
  inline bool has_m_llbasicddangmoney() const;
  inline void clear_m_llbasicddangmoney();
  static const int kMLlBasicDDangMoneyFieldNumber = 3;
  inline ::google::protobuf::int64 m_llbasicddangmoney() const;
  inline void set_m_llbasicddangmoney(::google::protobuf::int64 value);
  
  // required string m_sItem = 4;
  inline bool has_m_sitem() const;
  inline void clear_m_sitem();
  static const int kMSItemFieldNumber = 4;
  inline const ::std::string& m_sitem() const;
  inline void set_m_sitem(const ::std::string& value);
  inline void set_m_sitem(const char* value);
  inline void set_m_sitem(const char* value, size_t size);
  inline ::std::string* mutable_m_sitem();
  inline ::std::string* release_m_sitem();
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_ThankYouItemNotify)
 private:
  inline void set_has_m_lusn();
  inline void clear_has_m_lusn();
  inline void set_has_m_lranktype();
  inline void clear_has_m_lranktype();
  inline void set_has_m_llbasicddangmoney();
  inline void clear_has_m_llbasicddangmoney();
  inline void set_has_m_sitem();
  inline void clear_has_m_sitem();
  
  ::google::protobuf::int32 m_lusn_;
  ::google::protobuf::int32 m_lranktype_;
  ::google::protobuf::int64 m_llbasicddangmoney_;
  ::std::string* m_sitem_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_ThankYouItemNotify* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_MadeItemNotify : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_MadeItemNotify();
  virtual ~PKMsgSC_MadeItemNotify();
  
  PKMsgSC_MadeItemNotify(const PKMsgSC_MadeItemNotify& from);
  
  inline PKMsgSC_MadeItemNotify& operator=(const PKMsgSC_MadeItemNotify& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_MadeItemNotify& default_instance();
  
  void Swap(PKMsgSC_MadeItemNotify* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_MadeItemNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_MadeItemNotify& from);
  void MergeFrom(const PKMsgSC_MadeItemNotify& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lUSN = 1;
  inline bool has_m_lusn() const;
  inline void clear_m_lusn();
  static const int kMLUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lusn() const;
  inline void set_m_lusn(::google::protobuf::int32 value);
  
  // required sint32 m_lRankType = 2;
  inline bool has_m_lranktype() const;
  inline void clear_m_lranktype();
  static const int kMLRankTypeFieldNumber = 2;
  inline ::google::protobuf::int32 m_lranktype() const;
  inline void set_m_lranktype(::google::protobuf::int32 value);
  
  // required string m_sItem = 3;
  inline bool has_m_sitem() const;
  inline void clear_m_sitem();
  static const int kMSItemFieldNumber = 3;
  inline const ::std::string& m_sitem() const;
  inline void set_m_sitem(const ::std::string& value);
  inline void set_m_sitem(const char* value);
  inline void set_m_sitem(const char* value, size_t size);
  inline ::std::string* mutable_m_sitem();
  inline ::std::string* release_m_sitem();
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_MadeItemNotify)
 private:
  inline void set_has_m_lusn();
  inline void clear_has_m_lusn();
  inline void set_has_m_lranktype();
  inline void clear_has_m_lranktype();
  inline void set_has_m_sitem();
  inline void clear_has_m_sitem();
  
  ::google::protobuf::int32 m_lusn_;
  ::google::protobuf::int32 m_lranktype_;
  ::std::string* m_sitem_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_MadeItemNotify* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_ExtMoneyNotify : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_ExtMoneyNotify();
  virtual ~PKMsgSC_ExtMoneyNotify();
  
  PKMsgSC_ExtMoneyNotify(const PKMsgSC_ExtMoneyNotify& from);
  
  inline PKMsgSC_ExtMoneyNotify& operator=(const PKMsgSC_ExtMoneyNotify& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_ExtMoneyNotify& default_instance();
  
  void Swap(PKMsgSC_ExtMoneyNotify* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_ExtMoneyNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_ExtMoneyNotify& from);
  void MergeFrom(const PKMsgSC_ExtMoneyNotify& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lUSN = 1;
  inline bool has_m_lusn() const;
  inline void clear_m_lusn();
  static const int kMLUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lusn() const;
  inline void set_m_lusn(::google::protobuf::int32 value);
  
  // required sint32 m_bExtType = 2;
  inline bool has_m_bexttype() const;
  inline void clear_m_bexttype();
  static const int kMBExtTypeFieldNumber = 2;
  inline ::google::protobuf::int32 m_bexttype() const;
  inline void set_m_bexttype(::google::protobuf::int32 value);
  
  // required sint64 m_llCMoney = 3;
  inline bool has_m_llcmoney() const;
  inline void clear_m_llcmoney();
  static const int kMLlCMoneyFieldNumber = 3;
  inline ::google::protobuf::int64 m_llcmoney() const;
  inline void set_m_llcmoney(::google::protobuf::int64 value);
  
  // required sint64 m_llCashBox = 4;
  inline bool has_m_llcashbox() const;
  inline void clear_m_llcashbox();
  static const int kMLlCashBoxFieldNumber = 4;
  inline ::google::protobuf::int64 m_llcashbox() const;
  inline void set_m_llcashbox(::google::protobuf::int64 value);
  
  // required sint64 m_llExtMoney = 5;
  inline bool has_m_llextmoney() const;
  inline void clear_m_llextmoney();
  static const int kMLlExtMoneyFieldNumber = 5;
  inline ::google::protobuf::int64 m_llextmoney() const;
  inline void set_m_llextmoney(::google::protobuf::int64 value);
  
  // required sint64 m_llExtDate = 6;
  inline bool has_m_llextdate() const;
  inline void clear_m_llextdate();
  static const int kMLlExtDateFieldNumber = 6;
  inline ::google::protobuf::int64 m_llextdate() const;
  inline void set_m_llextdate(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_ExtMoneyNotify)
 private:
  inline void set_has_m_lusn();
  inline void clear_has_m_lusn();
  inline void set_has_m_bexttype();
  inline void clear_has_m_bexttype();
  inline void set_has_m_llcmoney();
  inline void clear_has_m_llcmoney();
  inline void set_has_m_llcashbox();
  inline void clear_has_m_llcashbox();
  inline void set_has_m_llextmoney();
  inline void clear_has_m_llextmoney();
  inline void set_has_m_llextdate();
  inline void clear_has_m_llextdate();
  
  ::google::protobuf::int32 m_lusn_;
  ::google::protobuf::int32 m_bexttype_;
  ::google::protobuf::int64 m_llcmoney_;
  ::google::protobuf::int64 m_llcashbox_;
  ::google::protobuf::int64 m_llextmoney_;
  ::google::protobuf::int64 m_llextdate_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_ExtMoneyNotify* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_GameEndSystemMsg : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_GameEndSystemMsg();
  virtual ~PKMsgSC_GameEndSystemMsg();
  
  PKMsgSC_GameEndSystemMsg(const PKMsgSC_GameEndSystemMsg& from);
  
  inline PKMsgSC_GameEndSystemMsg& operator=(const PKMsgSC_GameEndSystemMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_GameEndSystemMsg& default_instance();
  
  void Swap(PKMsgSC_GameEndSystemMsg* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_GameEndSystemMsg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_GameEndSystemMsg& from);
  void MergeFrom(const PKMsgSC_GameEndSystemMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lType = 1;
  inline bool has_m_ltype() const;
  inline void clear_m_ltype();
  static const int kMLTypeFieldNumber = 1;
  inline ::google::protobuf::int32 m_ltype() const;
  inline void set_m_ltype(::google::protobuf::int32 value);
  
  // required sint32 m_lUSN = 2;
  inline bool has_m_lusn() const;
  inline void clear_m_lusn();
  static const int kMLUSNFieldNumber = 2;
  inline ::google::protobuf::int32 m_lusn() const;
  inline void set_m_lusn(::google::protobuf::int32 value);
  
  // required sint32 m_bGiveUp = 3;
  inline bool has_m_bgiveup() const;
  inline void clear_m_bgiveup();
  static const int kMBGiveUpFieldNumber = 3;
  inline ::google::protobuf::int32 m_bgiveup() const;
  inline void set_m_bgiveup(::google::protobuf::int32 value);
  
  // required sint64 m_llMoney = 4;
  inline bool has_m_llmoney() const;
  inline void clear_m_llmoney();
  static const int kMLlMoneyFieldNumber = 4;
  inline ::google::protobuf::int64 m_llmoney() const;
  inline void set_m_llmoney(::google::protobuf::int64 value);
  
  // required string m_sMsg = 5;
  inline bool has_m_smsg() const;
  inline void clear_m_smsg();
  static const int kMSMsgFieldNumber = 5;
  inline const ::std::string& m_smsg() const;
  inline void set_m_smsg(const ::std::string& value);
  inline void set_m_smsg(const char* value);
  inline void set_m_smsg(const char* value, size_t size);
  inline ::std::string* mutable_m_smsg();
  inline ::std::string* release_m_smsg();
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_GameEndSystemMsg)
 private:
  inline void set_has_m_ltype();
  inline void clear_has_m_ltype();
  inline void set_has_m_lusn();
  inline void clear_has_m_lusn();
  inline void set_has_m_bgiveup();
  inline void clear_has_m_bgiveup();
  inline void set_has_m_llmoney();
  inline void clear_has_m_llmoney();
  inline void set_has_m_smsg();
  inline void clear_has_m_smsg();
  
  ::google::protobuf::int32 m_ltype_;
  ::google::protobuf::int32 m_lusn_;
  ::google::protobuf::int64 m_llmoney_;
  ::std::string* m_smsg_;
  ::google::protobuf::int32 m_bgiveup_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_GameEndSystemMsg* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_ChangeAvatarNotify : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_ChangeAvatarNotify();
  virtual ~PKMsgSC_ChangeAvatarNotify();
  
  PKMsgSC_ChangeAvatarNotify(const PKMsgSC_ChangeAvatarNotify& from);
  
  inline PKMsgSC_ChangeAvatarNotify& operator=(const PKMsgSC_ChangeAvatarNotify& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_ChangeAvatarNotify& default_instance();
  
  void Swap(PKMsgSC_ChangeAvatarNotify* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_ChangeAvatarNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_ChangeAvatarNotify& from);
  void MergeFrom(const PKMsgSC_ChangeAvatarNotify& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lUSN = 1;
  inline bool has_m_lusn() const;
  inline void clear_m_lusn();
  static const int kMLUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lusn() const;
  inline void set_m_lusn(::google::protobuf::int32 value);
  
  // required int32 m_nIndex = 2;
  inline bool has_m_nindex() const;
  inline void clear_m_nindex();
  static const int kMNIndexFieldNumber = 2;
  inline ::google::protobuf::int32 m_nindex() const;
  inline void set_m_nindex(::google::protobuf::int32 value);
  
  // required .PKUserInfo m_uinfo = 3;
  inline bool has_m_uinfo() const;
  inline void clear_m_uinfo();
  static const int kMUinfoFieldNumber = 3;
  inline const ::PKUserInfo& m_uinfo() const;
  inline ::PKUserInfo* mutable_m_uinfo();
  inline ::PKUserInfo* release_m_uinfo();
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_ChangeAvatarNotify)
 private:
  inline void set_has_m_lusn();
  inline void clear_has_m_lusn();
  inline void set_has_m_nindex();
  inline void clear_has_m_nindex();
  inline void set_has_m_uinfo();
  inline void clear_has_m_uinfo();
  
  ::google::protobuf::int32 m_lusn_;
  ::google::protobuf::int32 m_nindex_;
  ::PKUserInfo* m_uinfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_ChangeAvatarNotify* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_AbuseAns : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_AbuseAns();
  virtual ~PKMsgSC_AbuseAns();
  
  PKMsgSC_AbuseAns(const PKMsgSC_AbuseAns& from);
  
  inline PKMsgSC_AbuseAns& operator=(const PKMsgSC_AbuseAns& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_AbuseAns& default_instance();
  
  void Swap(PKMsgSC_AbuseAns* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_AbuseAns* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_AbuseAns& from);
  void MergeFrom(const PKMsgSC_AbuseAns& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_AbuseAns)
 private:
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_AbuseAns* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_SoundTypeAns : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_SoundTypeAns();
  virtual ~PKMsgSC_SoundTypeAns();
  
  PKMsgSC_SoundTypeAns(const PKMsgSC_SoundTypeAns& from);
  
  inline PKMsgSC_SoundTypeAns& operator=(const PKMsgSC_SoundTypeAns& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_SoundTypeAns& default_instance();
  
  void Swap(PKMsgSC_SoundTypeAns* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_SoundTypeAns* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_SoundTypeAns& from);
  void MergeFrom(const PKMsgSC_SoundTypeAns& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lUSN = 1;
  inline bool has_m_lusn() const;
  inline void clear_m_lusn();
  static const int kMLUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lusn() const;
  inline void set_m_lusn(::google::protobuf::int32 value);
  
  // required int32 m_nIndex = 2;
  inline bool has_m_nindex() const;
  inline void clear_m_nindex();
  static const int kMNIndexFieldNumber = 2;
  inline ::google::protobuf::int32 m_nindex() const;
  inline void set_m_nindex(::google::protobuf::int32 value);
  
  // required sint32 m_lSoundType = 3;
  inline bool has_m_lsoundtype() const;
  inline void clear_m_lsoundtype();
  static const int kMLSoundTypeFieldNumber = 3;
  inline ::google::protobuf::int32 m_lsoundtype() const;
  inline void set_m_lsoundtype(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_SoundTypeAns)
 private:
  inline void set_has_m_lusn();
  inline void clear_has_m_lusn();
  inline void set_has_m_nindex();
  inline void clear_has_m_nindex();
  inline void set_has_m_lsoundtype();
  inline void clear_has_m_lsoundtype();
  
  ::google::protobuf::int32 m_lusn_;
  ::google::protobuf::int32 m_nindex_;
  ::google::protobuf::int32 m_lsoundtype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_SoundTypeAns* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_FMoney : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_FMoney();
  virtual ~PKMsgSC_FMoney();
  
  PKMsgSC_FMoney(const PKMsgSC_FMoney& from);
  
  inline PKMsgSC_FMoney& operator=(const PKMsgSC_FMoney& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_FMoney& default_instance();
  
  void Swap(PKMsgSC_FMoney* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_FMoney* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_FMoney& from);
  void MergeFrom(const PKMsgSC_FMoney& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string m_sFMoney = 1;
  inline bool has_m_sfmoney() const;
  inline void clear_m_sfmoney();
  static const int kMSFMoneyFieldNumber = 1;
  inline const ::std::string& m_sfmoney() const;
  inline void set_m_sfmoney(const ::std::string& value);
  inline void set_m_sfmoney(const char* value);
  inline void set_m_sfmoney(const char* value, size_t size);
  inline ::std::string* mutable_m_sfmoney();
  inline ::std::string* release_m_sfmoney();
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_FMoney)
 private:
  inline void set_has_m_sfmoney();
  inline void clear_has_m_sfmoney();
  
  ::std::string* m_sfmoney_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_FMoney* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_ItemNotify : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_ItemNotify();
  virtual ~PKMsgSC_ItemNotify();
  
  PKMsgSC_ItemNotify(const PKMsgSC_ItemNotify& from);
  
  inline PKMsgSC_ItemNotify& operator=(const PKMsgSC_ItemNotify& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_ItemNotify& default_instance();
  
  void Swap(PKMsgSC_ItemNotify* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_ItemNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_ItemNotify& from);
  void MergeFrom(const PKMsgSC_ItemNotify& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lLimitTotalCnt = 1;
  inline bool has_m_llimittotalcnt() const;
  inline void clear_m_llimittotalcnt();
  static const int kMLLimitTotalCntFieldNumber = 1;
  inline ::google::protobuf::int32 m_llimittotalcnt() const;
  inline void set_m_llimittotalcnt(::google::protobuf::int32 value);
  
  // required sint32 m_lLimitTodayCnt = 2;
  inline bool has_m_llimittodaycnt() const;
  inline void clear_m_llimittodaycnt();
  static const int kMLLimitTodayCntFieldNumber = 2;
  inline ::google::protobuf::int32 m_llimittodaycnt() const;
  inline void set_m_llimittodaycnt(::google::protobuf::int32 value);
  
  // required sint32 m_bInfinitySpeedItem = 3;
  inline bool has_m_binfinityspeeditem() const;
  inline void clear_m_binfinityspeeditem();
  static const int kMBInfinitySpeedItemFieldNumber = 3;
  inline ::google::protobuf::int32 m_binfinityspeeditem() const;
  inline void set_m_binfinityspeeditem(::google::protobuf::int32 value);
  
  // required sint64 m_llSpeedToTime = 4;
  inline bool has_m_llspeedtotime() const;
  inline void clear_m_llspeedtotime();
  static const int kMLlSpeedToTimeFieldNumber = 4;
  inline ::google::protobuf::int64 m_llspeedtotime() const;
  inline void set_m_llspeedtotime(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_ItemNotify)
 private:
  inline void set_has_m_llimittotalcnt();
  inline void clear_has_m_llimittotalcnt();
  inline void set_has_m_llimittodaycnt();
  inline void clear_has_m_llimittodaycnt();
  inline void set_has_m_binfinityspeeditem();
  inline void clear_has_m_binfinityspeeditem();
  inline void set_has_m_llspeedtotime();
  inline void clear_has_m_llspeedtotime();
  
  ::google::protobuf::int32 m_llimittotalcnt_;
  ::google::protobuf::int32 m_llimittodaycnt_;
  ::google::protobuf::int64 m_llspeedtotime_;
  ::google::protobuf::int32 m_binfinityspeeditem_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_ItemNotify* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_DisconnectMoneyNotify : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_DisconnectMoneyNotify();
  virtual ~PKMsgSC_DisconnectMoneyNotify();
  
  PKMsgSC_DisconnectMoneyNotify(const PKMsgSC_DisconnectMoneyNotify& from);
  
  inline PKMsgSC_DisconnectMoneyNotify& operator=(const PKMsgSC_DisconnectMoneyNotify& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_DisconnectMoneyNotify& default_instance();
  
  void Swap(PKMsgSC_DisconnectMoneyNotify* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_DisconnectMoneyNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_DisconnectMoneyNotify& from);
  void MergeFrom(const PKMsgSC_DisconnectMoneyNotify& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string m_sNickName = 1;
  inline bool has_m_snickname() const;
  inline void clear_m_snickname();
  static const int kMSNickNameFieldNumber = 1;
  inline const ::std::string& m_snickname() const;
  inline void set_m_snickname(const ::std::string& value);
  inline void set_m_snickname(const char* value);
  inline void set_m_snickname(const char* value, size_t size);
  inline ::std::string* mutable_m_snickname();
  inline ::std::string* release_m_snickname();
  
  // required sint64 m_llDisconnectMoney = 2;
  inline bool has_m_lldisconnectmoney() const;
  inline void clear_m_lldisconnectmoney();
  static const int kMLlDisconnectMoneyFieldNumber = 2;
  inline ::google::protobuf::int64 m_lldisconnectmoney() const;
  inline void set_m_lldisconnectmoney(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_DisconnectMoneyNotify)
 private:
  inline void set_has_m_snickname();
  inline void clear_has_m_snickname();
  inline void set_has_m_lldisconnectmoney();
  inline void clear_has_m_lldisconnectmoney();
  
  ::std::string* m_snickname_;
  ::google::protobuf::int64 m_lldisconnectmoney_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_DisconnectMoneyNotify* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_ExitNtf : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_ExitNtf();
  virtual ~PKMsgSC_ExitNtf();
  
  PKMsgSC_ExitNtf(const PKMsgSC_ExitNtf& from);
  
  inline PKMsgSC_ExitNtf& operator=(const PKMsgSC_ExitNtf& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_ExitNtf& default_instance();
  
  void Swap(PKMsgSC_ExitNtf* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_ExitNtf* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_ExitNtf& from);
  void MergeFrom(const PKMsgSC_ExitNtf& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lUSN = 1;
  inline bool has_m_lusn() const;
  inline void clear_m_lusn();
  static const int kMLUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lusn() const;
  inline void set_m_lusn(::google::protobuf::int32 value);
  
  // required int32 m_nIndex = 2;
  inline bool has_m_nindex() const;
  inline void clear_m_nindex();
  static const int kMNIndexFieldNumber = 2;
  inline ::google::protobuf::int32 m_nindex() const;
  inline void set_m_nindex(::google::protobuf::int32 value);
  
  // required sint32 m_lExit = 3;
  inline bool has_m_lexit() const;
  inline void clear_m_lexit();
  static const int kMLExitFieldNumber = 3;
  inline ::google::protobuf::int32 m_lexit() const;
  inline void set_m_lexit(::google::protobuf::int32 value);
  
  // required sint32 m_bExit = 4;
  inline bool has_m_bexit() const;
  inline void clear_m_bexit();
  static const int kMBExitFieldNumber = 4;
  inline ::google::protobuf::int32 m_bexit() const;
  inline void set_m_bexit(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_ExitNtf)
 private:
  inline void set_has_m_lusn();
  inline void clear_has_m_lusn();
  inline void set_has_m_nindex();
  inline void clear_has_m_nindex();
  inline void set_has_m_lexit();
  inline void clear_has_m_lexit();
  inline void set_has_m_bexit();
  inline void clear_has_m_bexit();
  
  ::google::protobuf::int32 m_lusn_;
  ::google::protobuf::int32 m_nindex_;
  ::google::protobuf::int32 m_lexit_;
  ::google::protobuf::int32 m_bexit_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_ExitNtf* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_RematchOKAns : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_RematchOKAns();
  virtual ~PKMsgSC_RematchOKAns();
  
  PKMsgSC_RematchOKAns(const PKMsgSC_RematchOKAns& from);
  
  inline PKMsgSC_RematchOKAns& operator=(const PKMsgSC_RematchOKAns& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_RematchOKAns& default_instance();
  
  void Swap(PKMsgSC_RematchOKAns* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_RematchOKAns* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_RematchOKAns& from);
  void MergeFrom(const PKMsgSC_RematchOKAns& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lUSN = 1;
  inline bool has_m_lusn() const;
  inline void clear_m_lusn();
  static const int kMLUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lusn() const;
  inline void set_m_lusn(::google::protobuf::int32 value);
  
  // required sint64 m_llPoolMoney = 2;
  inline bool has_m_llpoolmoney() const;
  inline void clear_m_llpoolmoney();
  static const int kMLlPoolMoneyFieldNumber = 2;
  inline ::google::protobuf::int64 m_llpoolmoney() const;
  inline void set_m_llpoolmoney(::google::protobuf::int64 value);
  
  // required .PKMoney m_money = 3;
  inline bool has_m_money() const;
  inline void clear_m_money();
  static const int kMMoneyFieldNumber = 3;
  inline const ::PKMoney& m_money() const;
  inline ::PKMoney* mutable_m_money();
  inline ::PKMoney* release_m_money();
  
  // required sint32 m_bRematchOK = 4;
  inline bool has_m_brematchok() const;
  inline void clear_m_brematchok();
  static const int kMBRematchOKFieldNumber = 4;
  inline ::google::protobuf::int32 m_brematchok() const;
  inline void set_m_brematchok(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_RematchOKAns)
 private:
  inline void set_has_m_lusn();
  inline void clear_has_m_lusn();
  inline void set_has_m_llpoolmoney();
  inline void clear_has_m_llpoolmoney();
  inline void set_has_m_money();
  inline void clear_has_m_money();
  inline void set_has_m_brematchok();
  inline void clear_has_m_brematchok();
  
  ::google::protobuf::int64 m_llpoolmoney_;
  ::google::protobuf::int32 m_lusn_;
  ::google::protobuf::int32 m_brematchok_;
  ::PKMoney* m_money_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_RematchOKAns* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_RuleNotify : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_RuleNotify();
  virtual ~PKMsgSC_RuleNotify();
  
  PKMsgSC_RuleNotify(const PKMsgSC_RuleNotify& from);
  
  inline PKMsgSC_RuleNotify& operator=(const PKMsgSC_RuleNotify& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_RuleNotify& default_instance();
  
  void Swap(PKMsgSC_RuleNotify* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_RuleNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_RuleNotify& from);
  void MergeFrom(const PKMsgSC_RuleNotify& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 m_nRuleIdx = 1;
  inline bool has_m_nruleidx() const;
  inline void clear_m_nruleidx();
  static const int kMNRuleIdxFieldNumber = 1;
  inline ::google::protobuf::int32 m_nruleidx() const;
  inline void set_m_nruleidx(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_RuleNotify)
 private:
  inline void set_has_m_nruleidx();
  inline void clear_has_m_nruleidx();
  
  ::google::protobuf::int32 m_nruleidx_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_RuleNotify* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_AllowEntryWaitingUser : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_AllowEntryWaitingUser();
  virtual ~PKMsgSC_AllowEntryWaitingUser();
  
  PKMsgSC_AllowEntryWaitingUser(const PKMsgSC_AllowEntryWaitingUser& from);
  
  inline PKMsgSC_AllowEntryWaitingUser& operator=(const PKMsgSC_AllowEntryWaitingUser& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_AllowEntryWaitingUser& default_instance();
  
  void Swap(PKMsgSC_AllowEntryWaitingUser* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_AllowEntryWaitingUser* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_AllowEntryWaitingUser& from);
  void MergeFrom(const PKMsgSC_AllowEntryWaitingUser& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_AllowEntryWaitingUser)
 private:
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_AllowEntryWaitingUser* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_AllWaitingUserDataNtf : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_AllWaitingUserDataNtf();
  virtual ~PKMsgSC_AllWaitingUserDataNtf();
  
  PKMsgSC_AllWaitingUserDataNtf(const PKMsgSC_AllWaitingUserDataNtf& from);
  
  inline PKMsgSC_AllWaitingUserDataNtf& operator=(const PKMsgSC_AllWaitingUserDataNtf& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_AllWaitingUserDataNtf& default_instance();
  
  void Swap(PKMsgSC_AllWaitingUserDataNtf* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_AllWaitingUserDataNtf* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_AllWaitingUserDataNtf& from);
  void MergeFrom(const PKMsgSC_AllWaitingUserDataNtf& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_bSendWaitingUser = 1;
  inline bool has_m_bsendwaitinguser() const;
  inline void clear_m_bsendwaitinguser();
  static const int kMBSendWaitingUserFieldNumber = 1;
  inline ::google::protobuf::int32 m_bsendwaitinguser() const;
  inline void set_m_bsendwaitinguser(::google::protobuf::int32 value);
  
  // repeated .PKWAITINGUSERDATA m_WaitingUserData = 2;
  inline int m_waitinguserdata_size() const;
  inline void clear_m_waitinguserdata();
  static const int kMWaitingUserDataFieldNumber = 2;
  inline const ::PKWAITINGUSERDATA& m_waitinguserdata(int index) const;
  inline ::PKWAITINGUSERDATA* mutable_m_waitinguserdata(int index);
  inline ::PKWAITINGUSERDATA* add_m_waitinguserdata();
  inline const ::google::protobuf::RepeatedPtrField< ::PKWAITINGUSERDATA >&
      m_waitinguserdata() const;
  inline ::google::protobuf::RepeatedPtrField< ::PKWAITINGUSERDATA >*
      mutable_m_waitinguserdata();
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_AllWaitingUserDataNtf)
 private:
  inline void set_has_m_bsendwaitinguser();
  inline void clear_has_m_bsendwaitinguser();
  
  ::google::protobuf::RepeatedPtrField< ::PKWAITINGUSERDATA > m_waitinguserdata_;
  ::google::protobuf::int32 m_bsendwaitinguser_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_AllWaitingUserDataNtf* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_UserDataChangeNtf : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_UserDataChangeNtf();
  virtual ~PKMsgSC_UserDataChangeNtf();
  
  PKMsgSC_UserDataChangeNtf(const PKMsgSC_UserDataChangeNtf& from);
  
  inline PKMsgSC_UserDataChangeNtf& operator=(const PKMsgSC_UserDataChangeNtf& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_UserDataChangeNtf& default_instance();
  
  void Swap(PKMsgSC_UserDataChangeNtf* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_UserDataChangeNtf* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_UserDataChangeNtf& from);
  void MergeFrom(const PKMsgSC_UserDataChangeNtf& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .PKRCUserData m_userData = 1;
  inline bool has_m_userdata() const;
  inline void clear_m_userdata();
  static const int kMUserDataFieldNumber = 1;
  inline const ::PKRCUserData& m_userdata() const;
  inline ::PKRCUserData* mutable_m_userdata();
  inline ::PKRCUserData* release_m_userdata();
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_UserDataChangeNtf)
 private:
  inline void set_has_m_userdata();
  inline void clear_has_m_userdata();
  
  ::PKRCUserData* m_userdata_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_UserDataChangeNtf* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_RefillMoneyNtf : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_RefillMoneyNtf();
  virtual ~PKMsgSC_RefillMoneyNtf();
  
  PKMsgSC_RefillMoneyNtf(const PKMsgSC_RefillMoneyNtf& from);
  
  inline PKMsgSC_RefillMoneyNtf& operator=(const PKMsgSC_RefillMoneyNtf& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_RefillMoneyNtf& default_instance();
  
  void Swap(PKMsgSC_RefillMoneyNtf* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_RefillMoneyNtf* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_RefillMoneyNtf& from);
  void MergeFrom(const PKMsgSC_RefillMoneyNtf& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lUSN = 1;
  inline bool has_m_lusn() const;
  inline void clear_m_lusn();
  static const int kMLUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lusn() const;
  inline void set_m_lusn(::google::protobuf::int32 value);
  
  // required int32 m_nRefillCnt = 2;
  inline bool has_m_nrefillcnt() const;
  inline void clear_m_nrefillcnt();
  static const int kMNRefillCntFieldNumber = 2;
  inline ::google::protobuf::int32 m_nrefillcnt() const;
  inline void set_m_nrefillcnt(::google::protobuf::int32 value);
  
  // required sint64 m_llRefillMoney = 3;
  inline bool has_m_llrefillmoney() const;
  inline void clear_m_llrefillmoney();
  static const int kMLlRefillMoneyFieldNumber = 3;
  inline ::google::protobuf::int64 m_llrefillmoney() const;
  inline void set_m_llrefillmoney(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_RefillMoneyNtf)
 private:
  inline void set_has_m_lusn();
  inline void clear_has_m_lusn();
  inline void set_has_m_nrefillcnt();
  inline void clear_has_m_nrefillcnt();
  inline void set_has_m_llrefillmoney();
  inline void clear_has_m_llrefillmoney();
  
  ::google::protobuf::int32 m_lusn_;
  ::google::protobuf::int32 m_nrefillcnt_;
  ::google::protobuf::int64 m_llrefillmoney_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_RefillMoneyNtf* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_JackpotMoneyNtf : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_JackpotMoneyNtf();
  virtual ~PKMsgSC_JackpotMoneyNtf();
  
  PKMsgSC_JackpotMoneyNtf(const PKMsgSC_JackpotMoneyNtf& from);
  
  inline PKMsgSC_JackpotMoneyNtf& operator=(const PKMsgSC_JackpotMoneyNtf& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_JackpotMoneyNtf& default_instance();
  
  void Swap(PKMsgSC_JackpotMoneyNtf* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_JackpotMoneyNtf* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_JackpotMoneyNtf& from);
  void MergeFrom(const PKMsgSC_JackpotMoneyNtf& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lUSN = 1;
  inline bool has_m_lusn() const;
  inline void clear_m_lusn();
  static const int kMLUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lusn() const;
  inline void set_m_lusn(::google::protobuf::int32 value);
  
  // required sint64 m_llJackpotMoney = 2;
  inline bool has_m_lljackpotmoney() const;
  inline void clear_m_lljackpotmoney();
  static const int kMLlJackpotMoneyFieldNumber = 2;
  inline ::google::protobuf::int64 m_lljackpotmoney() const;
  inline void set_m_lljackpotmoney(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_JackpotMoneyNtf)
 private:
  inline void set_has_m_lusn();
  inline void clear_has_m_lusn();
  inline void set_has_m_lljackpotmoney();
  inline void clear_has_m_lljackpotmoney();
  
  ::google::protobuf::int64 m_lljackpotmoney_;
  ::google::protobuf::int32 m_lusn_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_JackpotMoneyNtf* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_GuardianAngelMoney : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_GuardianAngelMoney();
  virtual ~PKMsgSC_GuardianAngelMoney();
  
  PKMsgSC_GuardianAngelMoney(const PKMsgSC_GuardianAngelMoney& from);
  
  inline PKMsgSC_GuardianAngelMoney& operator=(const PKMsgSC_GuardianAngelMoney& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_GuardianAngelMoney& default_instance();
  
  void Swap(PKMsgSC_GuardianAngelMoney* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_GuardianAngelMoney* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_GuardianAngelMoney& from);
  void MergeFrom(const PKMsgSC_GuardianAngelMoney& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lUSN = 1;
  inline bool has_m_lusn() const;
  inline void clear_m_lusn();
  static const int kMLUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lusn() const;
  inline void set_m_lusn(::google::protobuf::int32 value);
  
  // required int32 m_nGuardianAngelCnt = 2;
  inline bool has_m_nguardianangelcnt() const;
  inline void clear_m_nguardianangelcnt();
  static const int kMNGuardianAngelCntFieldNumber = 2;
  inline ::google::protobuf::int32 m_nguardianangelcnt() const;
  inline void set_m_nguardianangelcnt(::google::protobuf::int32 value);
  
  // required sint64 m_llAngelMoney = 3;
  inline bool has_m_llangelmoney() const;
  inline void clear_m_llangelmoney();
  static const int kMLlAngelMoneyFieldNumber = 3;
  inline ::google::protobuf::int64 m_llangelmoney() const;
  inline void set_m_llangelmoney(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_GuardianAngelMoney)
 private:
  inline void set_has_m_lusn();
  inline void clear_has_m_lusn();
  inline void set_has_m_nguardianangelcnt();
  inline void clear_has_m_nguardianangelcnt();
  inline void set_has_m_llangelmoney();
  inline void clear_has_m_llangelmoney();
  
  ::google::protobuf::int32 m_lusn_;
  ::google::protobuf::int32 m_nguardianangelcnt_;
  ::google::protobuf::int64 m_llangelmoney_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_GuardianAngelMoney* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_GameMasterCallNtf : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_GameMasterCallNtf();
  virtual ~PKMsgSC_GameMasterCallNtf();
  
  PKMsgSC_GameMasterCallNtf(const PKMsgSC_GameMasterCallNtf& from);
  
  inline PKMsgSC_GameMasterCallNtf& operator=(const PKMsgSC_GameMasterCallNtf& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_GameMasterCallNtf& default_instance();
  
  void Swap(PKMsgSC_GameMasterCallNtf* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_GameMasterCallNtf* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_GameMasterCallNtf& from);
  void MergeFrom(const PKMsgSC_GameMasterCallNtf& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 m_lGMCall_USN = 1;
  inline bool has_m_lgmcall_usn() const;
  inline void clear_m_lgmcall_usn();
  static const int kMLGMCallUSNFieldNumber = 1;
  inline ::google::protobuf::int32 m_lgmcall_usn() const;
  inline void set_m_lgmcall_usn(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_GameMasterCallNtf)
 private:
  inline void set_has_m_lgmcall_usn();
  inline void clear_has_m_lgmcall_usn();
  
  ::google::protobuf::int32 m_lgmcall_usn_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_GameMasterCallNtf* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_ObserverCnt : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_ObserverCnt();
  virtual ~PKMsgSC_ObserverCnt();
  
  PKMsgSC_ObserverCnt(const PKMsgSC_ObserverCnt& from);
  
  inline PKMsgSC_ObserverCnt& operator=(const PKMsgSC_ObserverCnt& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_ObserverCnt& default_instance();
  
  void Swap(PKMsgSC_ObserverCnt* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_ObserverCnt* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_ObserverCnt& from);
  void MergeFrom(const PKMsgSC_ObserverCnt& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 m_nObserverCnt = 1;
  inline bool has_m_nobservercnt() const;
  inline void clear_m_nobservercnt();
  static const int kMNObserverCntFieldNumber = 1;
  inline ::google::protobuf::int32 m_nobservercnt() const;
  inline void set_m_nobservercnt(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_ObserverCnt)
 private:
  inline void set_has_m_nobservercnt();
  inline void clear_has_m_nobservercnt();
  
  ::google::protobuf::int32 m_nobservercnt_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_ObserverCnt* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_Bonus : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_Bonus();
  virtual ~PKMsgSC_Bonus();
  
  PKMsgSC_Bonus(const PKMsgSC_Bonus& from);
  
  inline PKMsgSC_Bonus& operator=(const PKMsgSC_Bonus& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_Bonus& default_instance();
  
  void Swap(PKMsgSC_Bonus* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_Bonus* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_Bonus& from);
  void MergeFrom(const PKMsgSC_Bonus& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint64 m_llBonus = 1;
  inline bool has_m_llbonus() const;
  inline void clear_m_llbonus();
  static const int kMLlBonusFieldNumber = 1;
  inline ::google::protobuf::int64 m_llbonus() const;
  inline void set_m_llbonus(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_Bonus)
 private:
  inline void set_has_m_llbonus();
  inline void clear_has_m_llbonus();
  
  ::google::protobuf::int64 m_llbonus_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_Bonus* default_instance_;
};
// -------------------------------------------------------------------

class PKMsgSC_PoliceNotify : public ::google::protobuf::MessageLite {
 public:
  PKMsgSC_PoliceNotify();
  virtual ~PKMsgSC_PoliceNotify();
  
  PKMsgSC_PoliceNotify(const PKMsgSC_PoliceNotify& from);
  
  inline PKMsgSC_PoliceNotify& operator=(const PKMsgSC_PoliceNotify& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const PKMsgSC_PoliceNotify& default_instance();
  
  void Swap(PKMsgSC_PoliceNotify* other);
  
  // implements Message ----------------------------------------------
  
  PKMsgSC_PoliceNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PKMsgSC_PoliceNotify& from);
  void MergeFrom(const PKMsgSC_PoliceNotify& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string m_policeMsg = 1;
  inline bool has_m_policemsg() const;
  inline void clear_m_policemsg();
  static const int kMPoliceMsgFieldNumber = 1;
  inline const ::std::string& m_policemsg() const;
  inline void set_m_policemsg(const ::std::string& value);
  inline void set_m_policemsg(const char* value);
  inline void set_m_policemsg(const char* value, size_t size);
  inline ::std::string* mutable_m_policemsg();
  inline ::std::string* release_m_policemsg();
  
  // @@protoc_insertion_point(class_scope:PKMsgSC_PoliceNotify)
 private:
  inline void set_has_m_policemsg();
  inline void clear_has_m_policemsg();
  
  ::std::string* m_policemsg_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static PKMsgSC_PoliceNotify* default_instance_;
};
// ===================================================================


// ===================================================================

// GameUserInfo

// required .GameInfo gameInfo = 1;
inline bool GameUserInfo::has_gameinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameUserInfo::set_has_gameinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameUserInfo::clear_has_gameinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameUserInfo::clear_gameinfo() {
  if (gameinfo_ != NULL) gameinfo_->::GameInfo::Clear();
  clear_has_gameinfo();
}
inline const ::GameInfo& GameUserInfo::gameinfo() const {
  return gameinfo_ != NULL ? *gameinfo_ : *default_instance_->gameinfo_;
}
inline ::GameInfo* GameUserInfo::mutable_gameinfo() {
  set_has_gameinfo();
  if (gameinfo_ == NULL) gameinfo_ = new ::GameInfo;
  return gameinfo_;
}
inline ::GameInfo* GameUserInfo::release_gameinfo() {
  clear_has_gameinfo();
  ::GameInfo* temp = gameinfo_;
  gameinfo_ = NULL;
  return temp;
}

// required .MemberInfo memberInfo = 2;
inline bool GameUserInfo::has_memberinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameUserInfo::set_has_memberinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameUserInfo::clear_has_memberinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameUserInfo::clear_memberinfo() {
  if (memberinfo_ != NULL) memberinfo_->::MemberInfo::Clear();
  clear_has_memberinfo();
}
inline const ::MemberInfo& GameUserInfo::memberinfo() const {
  return memberinfo_ != NULL ? *memberinfo_ : *default_instance_->memberinfo_;
}
inline ::MemberInfo* GameUserInfo::mutable_memberinfo() {
  set_has_memberinfo();
  if (memberinfo_ == NULL) memberinfo_ = new ::MemberInfo;
  return memberinfo_;
}
inline ::MemberInfo* GameUserInfo::release_memberinfo() {
  clear_has_memberinfo();
  ::MemberInfo* temp = memberinfo_;
  memberinfo_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// GameRoomInfo

// required int32 roomID = 1;
inline bool GameRoomInfo::has_roomid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameRoomInfo::set_has_roomid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameRoomInfo::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameRoomInfo::clear_roomid() {
  roomid_ = 0;
  clear_has_roomid();
}
inline ::google::protobuf::int32 GameRoomInfo::roomid() const {
  return roomid_;
}
inline void GameRoomInfo::set_roomid(::google::protobuf::int32 value) {
  set_has_roomid();
  roomid_ = value;
}

// required int32 pointMoney = 2;
inline bool GameRoomInfo::has_pointmoney() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameRoomInfo::set_has_pointmoney() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameRoomInfo::clear_has_pointmoney() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameRoomInfo::clear_pointmoney() {
  pointmoney_ = 0;
  clear_has_pointmoney();
}
inline ::google::protobuf::int32 GameRoomInfo::pointmoney() const {
  return pointmoney_;
}
inline void GameRoomInfo::set_pointmoney(::google::protobuf::int32 value) {
  set_has_pointmoney();
  pointmoney_ = value;
}

// repeated .GameUserInfo gameUserInfo = 3;
inline int GameRoomInfo::gameuserinfo_size() const {
  return gameuserinfo_.size();
}
inline void GameRoomInfo::clear_gameuserinfo() {
  gameuserinfo_.Clear();
}
inline const ::GameUserInfo& GameRoomInfo::gameuserinfo(int index) const {
  return gameuserinfo_.Get(index);
}
inline ::GameUserInfo* GameRoomInfo::mutable_gameuserinfo(int index) {
  return gameuserinfo_.Mutable(index);
}
inline ::GameUserInfo* GameRoomInfo::add_gameuserinfo() {
  return gameuserinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::GameUserInfo >&
GameRoomInfo::gameuserinfo() const {
  return gameuserinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::GameUserInfo >*
GameRoomInfo::mutable_gameuserinfo() {
  return &gameuserinfo_;
}

// optional bool enablestart = 4;
inline bool GameRoomInfo::has_enablestart() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameRoomInfo::set_has_enablestart() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameRoomInfo::clear_has_enablestart() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameRoomInfo::clear_enablestart() {
  enablestart_ = false;
  clear_has_enablestart();
}
inline bool GameRoomInfo::enablestart() const {
  return enablestart_;
}
inline void GameRoomInfo::set_enablestart(bool value) {
  set_has_enablestart();
  enablestart_ = value;
}

// -------------------------------------------------------------------

// GameInfo

// required int32 gameID = 1;
inline bool GameInfo::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameInfo::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameInfo::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameInfo::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GameInfo::gameid() const {
  return gameid_;
}
inline void GameInfo::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GameInfo::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameInfo::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameInfo::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameInfo::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GameInfo::gameindex() const {
  return gameindex_;
}
inline void GameInfo::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// required string level = 3;
inline bool GameInfo::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameInfo::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameInfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameInfo::clear_level() {
  if (level_ != &::google::protobuf::internal::kEmptyString) {
    level_->clear();
  }
  clear_has_level();
}
inline const ::std::string& GameInfo::level() const {
  return *level_;
}
inline void GameInfo::set_level(const ::std::string& value) {
  set_has_level();
  if (level_ == &::google::protobuf::internal::kEmptyString) {
    level_ = new ::std::string;
  }
  level_->assign(value);
}
inline void GameInfo::set_level(const char* value) {
  set_has_level();
  if (level_ == &::google::protobuf::internal::kEmptyString) {
    level_ = new ::std::string;
  }
  level_->assign(value);
}
inline void GameInfo::set_level(const char* value, size_t size) {
  set_has_level();
  if (level_ == &::google::protobuf::internal::kEmptyString) {
    level_ = new ::std::string;
  }
  level_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameInfo::mutable_level() {
  set_has_level();
  if (level_ == &::google::protobuf::internal::kEmptyString) {
    level_ = new ::std::string;
  }
  return level_;
}
inline ::std::string* GameInfo::release_level() {
  clear_has_level();
  if (level_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = level_;
    level_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string money = 4;
inline bool GameInfo::has_money() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameInfo::set_has_money() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameInfo::clear_has_money() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameInfo::clear_money() {
  if (money_ != &::google::protobuf::internal::kEmptyString) {
    money_->clear();
  }
  clear_has_money();
}
inline const ::std::string& GameInfo::money() const {
  return *money_;
}
inline void GameInfo::set_money(const ::std::string& value) {
  set_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    money_ = new ::std::string;
  }
  money_->assign(value);
}
inline void GameInfo::set_money(const char* value) {
  set_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    money_ = new ::std::string;
  }
  money_->assign(value);
}
inline void GameInfo::set_money(const char* value, size_t size) {
  set_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    money_ = new ::std::string;
  }
  money_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameInfo::mutable_money() {
  set_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    money_ = new ::std::string;
  }
  return money_;
}
inline ::std::string* GameInfo::release_money() {
  clear_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = money_;
    money_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 winCnt = 5;
inline bool GameInfo::has_wincnt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameInfo::set_has_wincnt() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameInfo::clear_has_wincnt() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameInfo::clear_wincnt() {
  wincnt_ = 0;
  clear_has_wincnt();
}
inline ::google::protobuf::int32 GameInfo::wincnt() const {
  return wincnt_;
}
inline void GameInfo::set_wincnt(::google::protobuf::int32 value) {
  set_has_wincnt();
  wincnt_ = value;
}

// required int32 loseCnt = 6;
inline bool GameInfo::has_losecnt() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GameInfo::set_has_losecnt() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GameInfo::clear_has_losecnt() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GameInfo::clear_losecnt() {
  losecnt_ = 0;
  clear_has_losecnt();
}
inline ::google::protobuf::int32 GameInfo::losecnt() const {
  return losecnt_;
}
inline void GameInfo::set_losecnt(::google::protobuf::int32 value) {
  set_has_losecnt();
  losecnt_ = value;
}

// required int32 allInCnt = 7;
inline bool GameInfo::has_allincnt() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GameInfo::set_has_allincnt() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GameInfo::clear_has_allincnt() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GameInfo::clear_allincnt() {
  allincnt_ = 0;
  clear_has_allincnt();
}
inline ::google::protobuf::int32 GameInfo::allincnt() const {
  return allincnt_;
}
inline void GameInfo::set_allincnt(::google::protobuf::int32 value) {
  set_has_allincnt();
  allincnt_ = value;
}

// -------------------------------------------------------------------

// MemberInfo

// required int32 gameID = 1;
inline bool MemberInfo::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MemberInfo::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MemberInfo::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MemberInfo::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 MemberInfo::gameid() const {
  return gameid_;
}
inline void MemberInfo::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required string avatarUrl = 2;
inline bool MemberInfo::has_avatarurl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MemberInfo::set_has_avatarurl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MemberInfo::clear_has_avatarurl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MemberInfo::clear_avatarurl() {
  if (avatarurl_ != &::google::protobuf::internal::kEmptyString) {
    avatarurl_->clear();
  }
  clear_has_avatarurl();
}
inline const ::std::string& MemberInfo::avatarurl() const {
  return *avatarurl_;
}
inline void MemberInfo::set_avatarurl(const ::std::string& value) {
  set_has_avatarurl();
  if (avatarurl_ == &::google::protobuf::internal::kEmptyString) {
    avatarurl_ = new ::std::string;
  }
  avatarurl_->assign(value);
}
inline void MemberInfo::set_avatarurl(const char* value) {
  set_has_avatarurl();
  if (avatarurl_ == &::google::protobuf::internal::kEmptyString) {
    avatarurl_ = new ::std::string;
  }
  avatarurl_->assign(value);
}
inline void MemberInfo::set_avatarurl(const char* value, size_t size) {
  set_has_avatarurl();
  if (avatarurl_ == &::google::protobuf::internal::kEmptyString) {
    avatarurl_ = new ::std::string;
  }
  avatarurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MemberInfo::mutable_avatarurl() {
  set_has_avatarurl();
  if (avatarurl_ == &::google::protobuf::internal::kEmptyString) {
    avatarurl_ = new ::std::string;
  }
  return avatarurl_;
}
inline ::std::string* MemberInfo::release_avatarurl() {
  clear_has_avatarurl();
  if (avatarurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = avatarurl_;
    avatarurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string nickName = 3;
inline bool MemberInfo::has_nickname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MemberInfo::set_has_nickname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MemberInfo::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MemberInfo::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& MemberInfo::nickname() const {
  return *nickname_;
}
inline void MemberInfo::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void MemberInfo::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void MemberInfo::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MemberInfo::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* MemberInfo::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// s_req_game_test_packet

// required int32 test_int = 2;
inline bool s_req_game_test_packet::has_test_int() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_req_game_test_packet::set_has_test_int() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_req_game_test_packet::clear_has_test_int() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_req_game_test_packet::clear_test_int() {
  test_int_ = 0;
  clear_has_test_int();
}
inline ::google::protobuf::int32 s_req_game_test_packet::test_int() const {
  return test_int_;
}
inline void s_req_game_test_packet::set_test_int(::google::protobuf::int32 value) {
  set_has_test_int();
  test_int_ = value;
}

// required string test_string = 3;
inline bool s_req_game_test_packet::has_test_string() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void s_req_game_test_packet::set_has_test_string() {
  _has_bits_[0] |= 0x00000002u;
}
inline void s_req_game_test_packet::clear_has_test_string() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void s_req_game_test_packet::clear_test_string() {
  if (test_string_ != &::google::protobuf::internal::kEmptyString) {
    test_string_->clear();
  }
  clear_has_test_string();
}
inline const ::std::string& s_req_game_test_packet::test_string() const {
  return *test_string_;
}
inline void s_req_game_test_packet::set_test_string(const ::std::string& value) {
  set_has_test_string();
  if (test_string_ == &::google::protobuf::internal::kEmptyString) {
    test_string_ = new ::std::string;
  }
  test_string_->assign(value);
}
inline void s_req_game_test_packet::set_test_string(const char* value) {
  set_has_test_string();
  if (test_string_ == &::google::protobuf::internal::kEmptyString) {
    test_string_ = new ::std::string;
  }
  test_string_->assign(value);
}
inline void s_req_game_test_packet::set_test_string(const char* value, size_t size) {
  set_has_test_string();
  if (test_string_ == &::google::protobuf::internal::kEmptyString) {
    test_string_ = new ::std::string;
  }
  test_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* s_req_game_test_packet::mutable_test_string() {
  set_has_test_string();
  if (test_string_ == &::google::protobuf::internal::kEmptyString) {
    test_string_ = new ::std::string;
  }
  return test_string_;
}
inline ::std::string* s_req_game_test_packet::release_test_string() {
  clear_has_test_string();
  if (test_string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = test_string_;
    test_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// s_req_send_cmd

// required int32 cmd_type = 2;
inline bool s_req_send_cmd::has_cmd_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_req_send_cmd::set_has_cmd_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_req_send_cmd::clear_has_cmd_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_req_send_cmd::clear_cmd_type() {
  cmd_type_ = 0;
  clear_has_cmd_type();
}
inline ::google::protobuf::int32 s_req_send_cmd::cmd_type() const {
  return cmd_type_;
}
inline void s_req_send_cmd::set_cmd_type(::google::protobuf::int32 value) {
  set_has_cmd_type();
  cmd_type_ = value;
}

// required string cmd = 3;
inline bool s_req_send_cmd::has_cmd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void s_req_send_cmd::set_has_cmd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void s_req_send_cmd::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void s_req_send_cmd::clear_cmd() {
  if (cmd_ != &::google::protobuf::internal::kEmptyString) {
    cmd_->clear();
  }
  clear_has_cmd();
}
inline const ::std::string& s_req_send_cmd::cmd() const {
  return *cmd_;
}
inline void s_req_send_cmd::set_cmd(const ::std::string& value) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(value);
}
inline void s_req_send_cmd::set_cmd(const char* value) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(value);
}
inline void s_req_send_cmd::set_cmd(const char* value, size_t size) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* s_req_send_cmd::mutable_cmd() {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  return cmd_;
}
inline ::std::string* s_req_send_cmd::release_cmd() {
  clear_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cmd_;
    cmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// s_req_join_room

// required .GameInfo gameinfo = 1;
inline bool s_req_join_room::has_gameinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_req_join_room::set_has_gameinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_req_join_room::clear_has_gameinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_req_join_room::clear_gameinfo() {
  if (gameinfo_ != NULL) gameinfo_->::GameInfo::Clear();
  clear_has_gameinfo();
}
inline const ::GameInfo& s_req_join_room::gameinfo() const {
  return gameinfo_ != NULL ? *gameinfo_ : *default_instance_->gameinfo_;
}
inline ::GameInfo* s_req_join_room::mutable_gameinfo() {
  set_has_gameinfo();
  if (gameinfo_ == NULL) gameinfo_ = new ::GameInfo;
  return gameinfo_;
}
inline ::GameInfo* s_req_join_room::release_gameinfo() {
  clear_has_gameinfo();
  ::GameInfo* temp = gameinfo_;
  gameinfo_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// s_req_send_start

// optional int32 gameid = 1;
inline bool s_req_send_start::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_req_send_start::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_req_send_start::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_req_send_start::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 s_req_send_start::gameid() const {
  return gameid_;
}
inline void s_req_send_start::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// -------------------------------------------------------------------

// s_req_send_select_card

// required sint32 m_lCardIdx = 1;
inline bool s_req_send_select_card::has_m_lcardidx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_req_send_select_card::set_has_m_lcardidx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_req_send_select_card::clear_has_m_lcardidx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_req_send_select_card::clear_m_lcardidx() {
  m_lcardidx_ = 0;
  clear_has_m_lcardidx();
}
inline ::google::protobuf::int32 s_req_send_select_card::m_lcardidx() const {
  return m_lcardidx_;
}
inline void s_req_send_select_card::set_m_lcardidx(::google::protobuf::int32 value) {
  set_has_m_lcardidx();
  m_lcardidx_ = value;
}

// -------------------------------------------------------------------

// s_req_betting

// required sint32 gameid = 1;
inline bool s_req_betting::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_req_betting::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_req_betting::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_req_betting::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 s_req_betting::gameid() const {
  return gameid_;
}
inline void s_req_betting::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required sint32 m_lBetType = 2;
inline bool s_req_betting::has_m_lbettype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void s_req_betting::set_has_m_lbettype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void s_req_betting::clear_has_m_lbettype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void s_req_betting::clear_m_lbettype() {
  m_lbettype_ = 0;
  clear_has_m_lbettype();
}
inline ::google::protobuf::int32 s_req_betting::m_lbettype() const {
  return m_lbettype_;
}
inline void s_req_betting::set_m_lbettype(::google::protobuf::int32 value) {
  set_has_m_lbettype();
  m_lbettype_ = value;
}

// -------------------------------------------------------------------

// s_req_ping

// optional int32 usn = 1;
inline bool s_req_ping::has_usn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_req_ping::set_has_usn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_req_ping::clear_has_usn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_req_ping::clear_usn() {
  usn_ = 0;
  clear_has_usn();
}
inline ::google::protobuf::int32 s_req_ping::usn() const {
  return usn_;
}
inline void s_req_ping::set_usn(::google::protobuf::int32 value) {
  set_has_usn();
  usn_ = value;
}

// -------------------------------------------------------------------

// s_req_entry

// required int32 m_nVersion = 1;
inline bool s_req_entry::has_m_nversion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_req_entry::set_has_m_nversion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_req_entry::clear_has_m_nversion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_req_entry::clear_m_nversion() {
  m_nversion_ = 0;
  clear_has_m_nversion();
}
inline ::google::protobuf::int32 s_req_entry::m_nversion() const {
  return m_nversion_;
}
inline void s_req_entry::set_m_nversion(::google::protobuf::int32 value) {
  set_has_m_nversion();
  m_nversion_ = value;
}

// optional sint32 m_bWelcomeSound = 2;
inline bool s_req_entry::has_m_bwelcomesound() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void s_req_entry::set_has_m_bwelcomesound() {
  _has_bits_[0] |= 0x00000002u;
}
inline void s_req_entry::clear_has_m_bwelcomesound() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void s_req_entry::clear_m_bwelcomesound() {
  m_bwelcomesound_ = 0;
  clear_has_m_bwelcomesound();
}
inline ::google::protobuf::int32 s_req_entry::m_bwelcomesound() const {
  return m_bwelcomesound_;
}
inline void s_req_entry::set_m_bwelcomesound(::google::protobuf::int32 value) {
  set_has_m_bwelcomesound();
  m_bwelcomesound_ = value;
}

// required sint32 m_lSoundType = 3;
inline bool s_req_entry::has_m_lsoundtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void s_req_entry::set_has_m_lsoundtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void s_req_entry::clear_has_m_lsoundtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void s_req_entry::clear_m_lsoundtype() {
  m_lsoundtype_ = 0;
  clear_has_m_lsoundtype();
}
inline ::google::protobuf::int32 s_req_entry::m_lsoundtype() const {
  return m_lsoundtype_;
}
inline void s_req_entry::set_m_lsoundtype(::google::protobuf::int32 value) {
  set_has_m_lsoundtype();
  m_lsoundtype_ = value;
}

// required string m_sNickName = 4;
inline bool s_req_entry::has_m_snickname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void s_req_entry::set_has_m_snickname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void s_req_entry::clear_has_m_snickname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void s_req_entry::clear_m_snickname() {
  if (m_snickname_ != &::google::protobuf::internal::kEmptyString) {
    m_snickname_->clear();
  }
  clear_has_m_snickname();
}
inline const ::std::string& s_req_entry::m_snickname() const {
  return *m_snickname_;
}
inline void s_req_entry::set_m_snickname(const ::std::string& value) {
  set_has_m_snickname();
  if (m_snickname_ == &::google::protobuf::internal::kEmptyString) {
    m_snickname_ = new ::std::string;
  }
  m_snickname_->assign(value);
}
inline void s_req_entry::set_m_snickname(const char* value) {
  set_has_m_snickname();
  if (m_snickname_ == &::google::protobuf::internal::kEmptyString) {
    m_snickname_ = new ::std::string;
  }
  m_snickname_->assign(value);
}
inline void s_req_entry::set_m_snickname(const char* value, size_t size) {
  set_has_m_snickname();
  if (m_snickname_ == &::google::protobuf::internal::kEmptyString) {
    m_snickname_ = new ::std::string;
  }
  m_snickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* s_req_entry::mutable_m_snickname() {
  set_has_m_snickname();
  if (m_snickname_ == &::google::protobuf::internal::kEmptyString) {
    m_snickname_ = new ::std::string;
  }
  return m_snickname_;
}
inline ::std::string* s_req_entry::release_m_snickname() {
  clear_has_m_snickname();
  if (m_snickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_snickname_;
    m_snickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string m_sAvt = 5;
inline bool s_req_entry::has_m_savt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void s_req_entry::set_has_m_savt() {
  _has_bits_[0] |= 0x00000010u;
}
inline void s_req_entry::clear_has_m_savt() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void s_req_entry::clear_m_savt() {
  if (m_savt_ != &::google::protobuf::internal::kEmptyString) {
    m_savt_->clear();
  }
  clear_has_m_savt();
}
inline const ::std::string& s_req_entry::m_savt() const {
  return *m_savt_;
}
inline void s_req_entry::set_m_savt(const ::std::string& value) {
  set_has_m_savt();
  if (m_savt_ == &::google::protobuf::internal::kEmptyString) {
    m_savt_ = new ::std::string;
  }
  m_savt_->assign(value);
}
inline void s_req_entry::set_m_savt(const char* value) {
  set_has_m_savt();
  if (m_savt_ == &::google::protobuf::internal::kEmptyString) {
    m_savt_ = new ::std::string;
  }
  m_savt_->assign(value);
}
inline void s_req_entry::set_m_savt(const char* value, size_t size) {
  set_has_m_savt();
  if (m_savt_ == &::google::protobuf::internal::kEmptyString) {
    m_savt_ = new ::std::string;
  }
  m_savt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* s_req_entry::mutable_m_savt() {
  set_has_m_savt();
  if (m_savt_ == &::google::protobuf::internal::kEmptyString) {
    m_savt_ = new ::std::string;
  }
  return m_savt_;
}
inline ::std::string* s_req_entry::release_m_savt() {
  clear_has_m_savt();
  if (m_savt_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_savt_;
    m_savt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required sint32 m_lCLevel = 6;
inline bool s_req_entry::has_m_lclevel() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void s_req_entry::set_has_m_lclevel() {
  _has_bits_[0] |= 0x00000020u;
}
inline void s_req_entry::clear_has_m_lclevel() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void s_req_entry::clear_m_lclevel() {
  m_lclevel_ = 0;
  clear_has_m_lclevel();
}
inline ::google::protobuf::int32 s_req_entry::m_lclevel() const {
  return m_lclevel_;
}
inline void s_req_entry::set_m_lclevel(::google::protobuf::int32 value) {
  set_has_m_lclevel();
  m_lclevel_ = value;
}

// required sint32 m_lSex = 7;
inline bool s_req_entry::has_m_lsex() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void s_req_entry::set_has_m_lsex() {
  _has_bits_[0] |= 0x00000040u;
}
inline void s_req_entry::clear_has_m_lsex() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void s_req_entry::clear_m_lsex() {
  m_lsex_ = 0;
  clear_has_m_lsex();
}
inline ::google::protobuf::int32 s_req_entry::m_lsex() const {
  return m_lsex_;
}
inline void s_req_entry::set_m_lsex(::google::protobuf::int32 value) {
  set_has_m_lsex();
  m_lsex_ = value;
}

// required int32 gameid = 8;
inline bool s_req_entry::has_gameid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void s_req_entry::set_has_gameid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void s_req_entry::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void s_req_entry::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 s_req_entry::gameid() const {
  return gameid_;
}
inline void s_req_entry::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// -------------------------------------------------------------------

// s_req_continue

// required sint32 m_lExit = 1;
inline bool s_req_continue::has_m_lexit() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_req_continue::set_has_m_lexit() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_req_continue::clear_has_m_lexit() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_req_continue::clear_m_lexit() {
  m_lexit_ = 0;
  clear_has_m_lexit();
}
inline ::google::protobuf::int32 s_req_continue::m_lexit() const {
  return m_lexit_;
}
inline void s_req_continue::set_m_lexit(::google::protobuf::int32 value) {
  set_has_m_lexit();
  m_lexit_ = value;
}

// -------------------------------------------------------------------

// s_req_ruleset

// required int32 m_nRuleIdx = 1;
inline bool s_req_ruleset::has_m_nruleidx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_req_ruleset::set_has_m_nruleidx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_req_ruleset::clear_has_m_nruleidx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_req_ruleset::clear_m_nruleidx() {
  m_nruleidx_ = 0;
  clear_has_m_nruleidx();
}
inline ::google::protobuf::int32 s_req_ruleset::m_nruleidx() const {
  return m_nruleidx_;
}
inline void s_req_ruleset::set_m_nruleidx(::google::protobuf::int32 value) {
  set_has_m_nruleidx();
  m_nruleidx_ = value;
}

// -------------------------------------------------------------------

// s_req_jokboset

// required sint32 m_lKey1 = 1;
inline bool s_req_jokboset::has_m_lkey1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_req_jokboset::set_has_m_lkey1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_req_jokboset::clear_has_m_lkey1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_req_jokboset::clear_m_lkey1() {
  m_lkey1_ = 0;
  clear_has_m_lkey1();
}
inline ::google::protobuf::int32 s_req_jokboset::m_lkey1() const {
  return m_lkey1_;
}
inline void s_req_jokboset::set_m_lkey1(::google::protobuf::int32 value) {
  set_has_m_lkey1();
  m_lkey1_ = value;
}

// required sint32 m_lKey2 = 2;
inline bool s_req_jokboset::has_m_lkey2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void s_req_jokboset::set_has_m_lkey2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void s_req_jokboset::clear_has_m_lkey2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void s_req_jokboset::clear_m_lkey2() {
  m_lkey2_ = 0;
  clear_has_m_lkey2();
}
inline ::google::protobuf::int32 s_req_jokboset::m_lkey2() const {
  return m_lkey2_;
}
inline void s_req_jokboset::set_m_lkey2(::google::protobuf::int32 value) {
  set_has_m_lkey2();
  m_lkey2_ = value;
}

// required sint32 m_lKey3 = 3;
inline bool s_req_jokboset::has_m_lkey3() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void s_req_jokboset::set_has_m_lkey3() {
  _has_bits_[0] |= 0x00000004u;
}
inline void s_req_jokboset::clear_has_m_lkey3() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void s_req_jokboset::clear_m_lkey3() {
  m_lkey3_ = 0;
  clear_has_m_lkey3();
}
inline ::google::protobuf::int32 s_req_jokboset::m_lkey3() const {
  return m_lkey3_;
}
inline void s_req_jokboset::set_m_lkey3(::google::protobuf::int32 value) {
  set_has_m_lkey3();
  m_lkey3_ = value;
}

// required sint32 m_lKey4 = 4;
inline bool s_req_jokboset::has_m_lkey4() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void s_req_jokboset::set_has_m_lkey4() {
  _has_bits_[0] |= 0x00000008u;
}
inline void s_req_jokboset::clear_has_m_lkey4() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void s_req_jokboset::clear_m_lkey4() {
  m_lkey4_ = 0;
  clear_has_m_lkey4();
}
inline ::google::protobuf::int32 s_req_jokboset::m_lkey4() const {
  return m_lkey4_;
}
inline void s_req_jokboset::set_m_lkey4(::google::protobuf::int32 value) {
  set_has_m_lkey4();
  m_lkey4_ = value;
}

// required sint32 m_lKey5 = 5;
inline bool s_req_jokboset::has_m_lkey5() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void s_req_jokboset::set_has_m_lkey5() {
  _has_bits_[0] |= 0x00000010u;
}
inline void s_req_jokboset::clear_has_m_lkey5() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void s_req_jokboset::clear_m_lkey5() {
  m_lkey5_ = 0;
  clear_has_m_lkey5();
}
inline ::google::protobuf::int32 s_req_jokboset::m_lkey5() const {
  return m_lkey5_;
}
inline void s_req_jokboset::set_m_lkey5(::google::protobuf::int32 value) {
  set_has_m_lkey5();
  m_lkey5_ = value;
}

// -------------------------------------------------------------------

// s_req_ack

// required int32 m_nTagID = 1;
inline bool s_req_ack::has_m_ntagid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_req_ack::set_has_m_ntagid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_req_ack::clear_has_m_ntagid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_req_ack::clear_m_ntagid() {
  m_ntagid_ = 0;
  clear_has_m_ntagid();
}
inline ::google::protobuf::int32 s_req_ack::m_ntagid() const {
  return m_ntagid_;
}
inline void s_req_ack::set_m_ntagid(::google::protobuf::int32 value) {
  set_has_m_ntagid();
  m_ntagid_ = value;
}

// -------------------------------------------------------------------

// s_req_choiceremovecard

// required sint32 m_lUSN = 1;
inline bool s_req_choiceremovecard::has_m_lusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_req_choiceremovecard::set_has_m_lusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_req_choiceremovecard::clear_has_m_lusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_req_choiceremovecard::clear_m_lusn() {
  m_lusn_ = 0;
  clear_has_m_lusn();
}
inline ::google::protobuf::int32 s_req_choiceremovecard::m_lusn() const {
  return m_lusn_;
}
inline void s_req_choiceremovecard::set_m_lusn(::google::protobuf::int32 value) {
  set_has_m_lusn();
  m_lusn_ = value;
}

// required int32 m_nRemoveCardIndex = 2;
inline bool s_req_choiceremovecard::has_m_nremovecardindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void s_req_choiceremovecard::set_has_m_nremovecardindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void s_req_choiceremovecard::clear_has_m_nremovecardindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void s_req_choiceremovecard::clear_m_nremovecardindex() {
  m_nremovecardindex_ = 0;
  clear_has_m_nremovecardindex();
}
inline ::google::protobuf::int32 s_req_choiceremovecard::m_nremovecardindex() const {
  return m_nremovecardindex_;
}
inline void s_req_choiceremovecard::set_m_nremovecardindex(::google::protobuf::int32 value) {
  set_has_m_nremovecardindex();
  m_nremovecardindex_ = value;
}

// -------------------------------------------------------------------

// s_req_purge

// required sint32 m_lType = 1;
inline bool s_req_purge::has_m_ltype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_req_purge::set_has_m_ltype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_req_purge::clear_has_m_ltype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_req_purge::clear_m_ltype() {
  m_ltype_ = 0;
  clear_has_m_ltype();
}
inline ::google::protobuf::int32 s_req_purge::m_ltype() const {
  return m_ltype_;
}
inline void s_req_purge::set_m_ltype(::google::protobuf::int32 value) {
  set_has_m_ltype();
  m_ltype_ = value;
}

// required sint32 m_lPurgeUSN = 2;
inline bool s_req_purge::has_m_lpurgeusn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void s_req_purge::set_has_m_lpurgeusn() {
  _has_bits_[0] |= 0x00000002u;
}
inline void s_req_purge::clear_has_m_lpurgeusn() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void s_req_purge::clear_m_lpurgeusn() {
  m_lpurgeusn_ = 0;
  clear_has_m_lpurgeusn();
}
inline ::google::protobuf::int32 s_req_purge::m_lpurgeusn() const {
  return m_lpurgeusn_;
}
inline void s_req_purge::set_m_lpurgeusn(::google::protobuf::int32 value) {
  set_has_m_lpurgeusn();
  m_lpurgeusn_ = value;
}

// -------------------------------------------------------------------

// s_req_exitque

// required sint32 m_lExit = 1;
inline bool s_req_exitque::has_m_lexit() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_req_exitque::set_has_m_lexit() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_req_exitque::clear_has_m_lexit() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_req_exitque::clear_m_lexit() {
  m_lexit_ = 0;
  clear_has_m_lexit();
}
inline ::google::protobuf::int32 s_req_exitque::m_lexit() const {
  return m_lexit_;
}
inline void s_req_exitque::set_m_lexit(::google::protobuf::int32 value) {
  set_has_m_lexit();
  m_lexit_ = value;
}

// required sint32 m_bAction = 2;
inline bool s_req_exitque::has_m_baction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void s_req_exitque::set_has_m_baction() {
  _has_bits_[0] |= 0x00000002u;
}
inline void s_req_exitque::clear_has_m_baction() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void s_req_exitque::clear_m_baction() {
  m_baction_ = 0;
  clear_has_m_baction();
}
inline ::google::protobuf::int32 s_req_exitque::m_baction() const {
  return m_baction_;
}
inline void s_req_exitque::set_m_baction(::google::protobuf::int32 value) {
  set_has_m_baction();
  m_baction_ = value;
}

// -------------------------------------------------------------------

// s_req_soundtype

// required sint32 m_lSoundType = 1;
inline bool s_req_soundtype::has_m_lsoundtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_req_soundtype::set_has_m_lsoundtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_req_soundtype::clear_has_m_lsoundtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_req_soundtype::clear_m_lsoundtype() {
  m_lsoundtype_ = 0;
  clear_has_m_lsoundtype();
}
inline ::google::protobuf::int32 s_req_soundtype::m_lsoundtype() const {
  return m_lsoundtype_;
}
inline void s_req_soundtype::set_m_lsoundtype(::google::protobuf::int32 value) {
  set_has_m_lsoundtype();
  m_lsoundtype_ = value;
}

// -------------------------------------------------------------------

// s_req_abuse

// required sint32 m_lType = 1;
inline bool s_req_abuse::has_m_ltype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_req_abuse::set_has_m_ltype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_req_abuse::clear_has_m_ltype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_req_abuse::clear_m_ltype() {
  m_ltype_ = 0;
  clear_has_m_ltype();
}
inline ::google::protobuf::int32 s_req_abuse::m_ltype() const {
  return m_ltype_;
}
inline void s_req_abuse::set_m_ltype(::google::protobuf::int32 value) {
  set_has_m_ltype();
  m_ltype_ = value;
}

// required string m_sDay = 2;
inline bool s_req_abuse::has_m_sday() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void s_req_abuse::set_has_m_sday() {
  _has_bits_[0] |= 0x00000002u;
}
inline void s_req_abuse::clear_has_m_sday() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void s_req_abuse::clear_m_sday() {
  if (m_sday_ != &::google::protobuf::internal::kEmptyString) {
    m_sday_->clear();
  }
  clear_has_m_sday();
}
inline const ::std::string& s_req_abuse::m_sday() const {
  return *m_sday_;
}
inline void s_req_abuse::set_m_sday(const ::std::string& value) {
  set_has_m_sday();
  if (m_sday_ == &::google::protobuf::internal::kEmptyString) {
    m_sday_ = new ::std::string;
  }
  m_sday_->assign(value);
}
inline void s_req_abuse::set_m_sday(const char* value) {
  set_has_m_sday();
  if (m_sday_ == &::google::protobuf::internal::kEmptyString) {
    m_sday_ = new ::std::string;
  }
  m_sday_->assign(value);
}
inline void s_req_abuse::set_m_sday(const char* value, size_t size) {
  set_has_m_sday();
  if (m_sday_ == &::google::protobuf::internal::kEmptyString) {
    m_sday_ = new ::std::string;
  }
  m_sday_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* s_req_abuse::mutable_m_sday() {
  set_has_m_sday();
  if (m_sday_ == &::google::protobuf::internal::kEmptyString) {
    m_sday_ = new ::std::string;
  }
  return m_sday_;
}
inline ::std::string* s_req_abuse::release_m_sday() {
  clear_has_m_sday();
  if (m_sday_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_sday_;
    m_sday_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// s_req_observe

// -------------------------------------------------------------------

// GLReqGameProtocol

// required .GLReqGameProtocol.Type type = 1;
inline bool GLReqGameProtocol::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLReqGameProtocol::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLReqGameProtocol::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLReqGameProtocol::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::GLReqGameProtocol_Type GLReqGameProtocol::type() const {
  return static_cast< ::GLReqGameProtocol_Type >(type_);
}
inline void GLReqGameProtocol::set_type(::GLReqGameProtocol_Type value) {
  GOOGLE_DCHECK(::GLReqGameProtocol_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .s_req_game_test_packet m_req_game_test_packet = 2;
inline bool GLReqGameProtocol::has_m_req_game_test_packet() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLReqGameProtocol::set_has_m_req_game_test_packet() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLReqGameProtocol::clear_has_m_req_game_test_packet() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLReqGameProtocol::clear_m_req_game_test_packet() {
  if (m_req_game_test_packet_ != NULL) m_req_game_test_packet_->::s_req_game_test_packet::Clear();
  clear_has_m_req_game_test_packet();
}
inline const ::s_req_game_test_packet& GLReqGameProtocol::m_req_game_test_packet() const {
  return m_req_game_test_packet_ != NULL ? *m_req_game_test_packet_ : *default_instance_->m_req_game_test_packet_;
}
inline ::s_req_game_test_packet* GLReqGameProtocol::mutable_m_req_game_test_packet() {
  set_has_m_req_game_test_packet();
  if (m_req_game_test_packet_ == NULL) m_req_game_test_packet_ = new ::s_req_game_test_packet;
  return m_req_game_test_packet_;
}
inline ::s_req_game_test_packet* GLReqGameProtocol::release_m_req_game_test_packet() {
  clear_has_m_req_game_test_packet();
  ::s_req_game_test_packet* temp = m_req_game_test_packet_;
  m_req_game_test_packet_ = NULL;
  return temp;
}

// optional .s_req_send_cmd m_req_send_cmd = 3;
inline bool GLReqGameProtocol::has_m_req_send_cmd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GLReqGameProtocol::set_has_m_req_send_cmd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GLReqGameProtocol::clear_has_m_req_send_cmd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GLReqGameProtocol::clear_m_req_send_cmd() {
  if (m_req_send_cmd_ != NULL) m_req_send_cmd_->::s_req_send_cmd::Clear();
  clear_has_m_req_send_cmd();
}
inline const ::s_req_send_cmd& GLReqGameProtocol::m_req_send_cmd() const {
  return m_req_send_cmd_ != NULL ? *m_req_send_cmd_ : *default_instance_->m_req_send_cmd_;
}
inline ::s_req_send_cmd* GLReqGameProtocol::mutable_m_req_send_cmd() {
  set_has_m_req_send_cmd();
  if (m_req_send_cmd_ == NULL) m_req_send_cmd_ = new ::s_req_send_cmd;
  return m_req_send_cmd_;
}
inline ::s_req_send_cmd* GLReqGameProtocol::release_m_req_send_cmd() {
  clear_has_m_req_send_cmd();
  ::s_req_send_cmd* temp = m_req_send_cmd_;
  m_req_send_cmd_ = NULL;
  return temp;
}

// optional .s_req_join_room m_req_join_room = 4;
inline bool GLReqGameProtocol::has_m_req_join_room() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GLReqGameProtocol::set_has_m_req_join_room() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GLReqGameProtocol::clear_has_m_req_join_room() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GLReqGameProtocol::clear_m_req_join_room() {
  if (m_req_join_room_ != NULL) m_req_join_room_->::s_req_join_room::Clear();
  clear_has_m_req_join_room();
}
inline const ::s_req_join_room& GLReqGameProtocol::m_req_join_room() const {
  return m_req_join_room_ != NULL ? *m_req_join_room_ : *default_instance_->m_req_join_room_;
}
inline ::s_req_join_room* GLReqGameProtocol::mutable_m_req_join_room() {
  set_has_m_req_join_room();
  if (m_req_join_room_ == NULL) m_req_join_room_ = new ::s_req_join_room;
  return m_req_join_room_;
}
inline ::s_req_join_room* GLReqGameProtocol::release_m_req_join_room() {
  clear_has_m_req_join_room();
  ::s_req_join_room* temp = m_req_join_room_;
  m_req_join_room_ = NULL;
  return temp;
}

// optional .s_req_send_start m_req_send_start = 5;
inline bool GLReqGameProtocol::has_m_req_send_start() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GLReqGameProtocol::set_has_m_req_send_start() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GLReqGameProtocol::clear_has_m_req_send_start() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GLReqGameProtocol::clear_m_req_send_start() {
  if (m_req_send_start_ != NULL) m_req_send_start_->::s_req_send_start::Clear();
  clear_has_m_req_send_start();
}
inline const ::s_req_send_start& GLReqGameProtocol::m_req_send_start() const {
  return m_req_send_start_ != NULL ? *m_req_send_start_ : *default_instance_->m_req_send_start_;
}
inline ::s_req_send_start* GLReqGameProtocol::mutable_m_req_send_start() {
  set_has_m_req_send_start();
  if (m_req_send_start_ == NULL) m_req_send_start_ = new ::s_req_send_start;
  return m_req_send_start_;
}
inline ::s_req_send_start* GLReqGameProtocol::release_m_req_send_start() {
  clear_has_m_req_send_start();
  ::s_req_send_start* temp = m_req_send_start_;
  m_req_send_start_ = NULL;
  return temp;
}

// optional .s_req_send_select_card m_req_send_select_card = 6;
inline bool GLReqGameProtocol::has_m_req_send_select_card() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GLReqGameProtocol::set_has_m_req_send_select_card() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GLReqGameProtocol::clear_has_m_req_send_select_card() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GLReqGameProtocol::clear_m_req_send_select_card() {
  if (m_req_send_select_card_ != NULL) m_req_send_select_card_->::s_req_send_select_card::Clear();
  clear_has_m_req_send_select_card();
}
inline const ::s_req_send_select_card& GLReqGameProtocol::m_req_send_select_card() const {
  return m_req_send_select_card_ != NULL ? *m_req_send_select_card_ : *default_instance_->m_req_send_select_card_;
}
inline ::s_req_send_select_card* GLReqGameProtocol::mutable_m_req_send_select_card() {
  set_has_m_req_send_select_card();
  if (m_req_send_select_card_ == NULL) m_req_send_select_card_ = new ::s_req_send_select_card;
  return m_req_send_select_card_;
}
inline ::s_req_send_select_card* GLReqGameProtocol::release_m_req_send_select_card() {
  clear_has_m_req_send_select_card();
  ::s_req_send_select_card* temp = m_req_send_select_card_;
  m_req_send_select_card_ = NULL;
  return temp;
}

// optional .s_req_betting m_req_betting = 7;
inline bool GLReqGameProtocol::has_m_req_betting() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GLReqGameProtocol::set_has_m_req_betting() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GLReqGameProtocol::clear_has_m_req_betting() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GLReqGameProtocol::clear_m_req_betting() {
  if (m_req_betting_ != NULL) m_req_betting_->::s_req_betting::Clear();
  clear_has_m_req_betting();
}
inline const ::s_req_betting& GLReqGameProtocol::m_req_betting() const {
  return m_req_betting_ != NULL ? *m_req_betting_ : *default_instance_->m_req_betting_;
}
inline ::s_req_betting* GLReqGameProtocol::mutable_m_req_betting() {
  set_has_m_req_betting();
  if (m_req_betting_ == NULL) m_req_betting_ = new ::s_req_betting;
  return m_req_betting_;
}
inline ::s_req_betting* GLReqGameProtocol::release_m_req_betting() {
  clear_has_m_req_betting();
  ::s_req_betting* temp = m_req_betting_;
  m_req_betting_ = NULL;
  return temp;
}

// optional .s_req_ping m_req_ping = 8;
inline bool GLReqGameProtocol::has_m_req_ping() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GLReqGameProtocol::set_has_m_req_ping() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GLReqGameProtocol::clear_has_m_req_ping() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GLReqGameProtocol::clear_m_req_ping() {
  if (m_req_ping_ != NULL) m_req_ping_->::s_req_ping::Clear();
  clear_has_m_req_ping();
}
inline const ::s_req_ping& GLReqGameProtocol::m_req_ping() const {
  return m_req_ping_ != NULL ? *m_req_ping_ : *default_instance_->m_req_ping_;
}
inline ::s_req_ping* GLReqGameProtocol::mutable_m_req_ping() {
  set_has_m_req_ping();
  if (m_req_ping_ == NULL) m_req_ping_ = new ::s_req_ping;
  return m_req_ping_;
}
inline ::s_req_ping* GLReqGameProtocol::release_m_req_ping() {
  clear_has_m_req_ping();
  ::s_req_ping* temp = m_req_ping_;
  m_req_ping_ = NULL;
  return temp;
}

// optional .s_req_entry m_req_entry = 9;
inline bool GLReqGameProtocol::has_m_req_entry() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GLReqGameProtocol::set_has_m_req_entry() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GLReqGameProtocol::clear_has_m_req_entry() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GLReqGameProtocol::clear_m_req_entry() {
  if (m_req_entry_ != NULL) m_req_entry_->::s_req_entry::Clear();
  clear_has_m_req_entry();
}
inline const ::s_req_entry& GLReqGameProtocol::m_req_entry() const {
  return m_req_entry_ != NULL ? *m_req_entry_ : *default_instance_->m_req_entry_;
}
inline ::s_req_entry* GLReqGameProtocol::mutable_m_req_entry() {
  set_has_m_req_entry();
  if (m_req_entry_ == NULL) m_req_entry_ = new ::s_req_entry;
  return m_req_entry_;
}
inline ::s_req_entry* GLReqGameProtocol::release_m_req_entry() {
  clear_has_m_req_entry();
  ::s_req_entry* temp = m_req_entry_;
  m_req_entry_ = NULL;
  return temp;
}

// optional .s_req_continue m_req_continue = 10;
inline bool GLReqGameProtocol::has_m_req_continue() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GLReqGameProtocol::set_has_m_req_continue() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GLReqGameProtocol::clear_has_m_req_continue() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GLReqGameProtocol::clear_m_req_continue() {
  if (m_req_continue_ != NULL) m_req_continue_->::s_req_continue::Clear();
  clear_has_m_req_continue();
}
inline const ::s_req_continue& GLReqGameProtocol::m_req_continue() const {
  return m_req_continue_ != NULL ? *m_req_continue_ : *default_instance_->m_req_continue_;
}
inline ::s_req_continue* GLReqGameProtocol::mutable_m_req_continue() {
  set_has_m_req_continue();
  if (m_req_continue_ == NULL) m_req_continue_ = new ::s_req_continue;
  return m_req_continue_;
}
inline ::s_req_continue* GLReqGameProtocol::release_m_req_continue() {
  clear_has_m_req_continue();
  ::s_req_continue* temp = m_req_continue_;
  m_req_continue_ = NULL;
  return temp;
}

// optional .s_req_ruleset m_req_ruleset = 11;
inline bool GLReqGameProtocol::has_m_req_ruleset() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GLReqGameProtocol::set_has_m_req_ruleset() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GLReqGameProtocol::clear_has_m_req_ruleset() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GLReqGameProtocol::clear_m_req_ruleset() {
  if (m_req_ruleset_ != NULL) m_req_ruleset_->::s_req_ruleset::Clear();
  clear_has_m_req_ruleset();
}
inline const ::s_req_ruleset& GLReqGameProtocol::m_req_ruleset() const {
  return m_req_ruleset_ != NULL ? *m_req_ruleset_ : *default_instance_->m_req_ruleset_;
}
inline ::s_req_ruleset* GLReqGameProtocol::mutable_m_req_ruleset() {
  set_has_m_req_ruleset();
  if (m_req_ruleset_ == NULL) m_req_ruleset_ = new ::s_req_ruleset;
  return m_req_ruleset_;
}
inline ::s_req_ruleset* GLReqGameProtocol::release_m_req_ruleset() {
  clear_has_m_req_ruleset();
  ::s_req_ruleset* temp = m_req_ruleset_;
  m_req_ruleset_ = NULL;
  return temp;
}

// optional .s_req_jokboset m_req_jokboset = 12;
inline bool GLReqGameProtocol::has_m_req_jokboset() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GLReqGameProtocol::set_has_m_req_jokboset() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GLReqGameProtocol::clear_has_m_req_jokboset() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GLReqGameProtocol::clear_m_req_jokboset() {
  if (m_req_jokboset_ != NULL) m_req_jokboset_->::s_req_jokboset::Clear();
  clear_has_m_req_jokboset();
}
inline const ::s_req_jokboset& GLReqGameProtocol::m_req_jokboset() const {
  return m_req_jokboset_ != NULL ? *m_req_jokboset_ : *default_instance_->m_req_jokboset_;
}
inline ::s_req_jokboset* GLReqGameProtocol::mutable_m_req_jokboset() {
  set_has_m_req_jokboset();
  if (m_req_jokboset_ == NULL) m_req_jokboset_ = new ::s_req_jokboset;
  return m_req_jokboset_;
}
inline ::s_req_jokboset* GLReqGameProtocol::release_m_req_jokboset() {
  clear_has_m_req_jokboset();
  ::s_req_jokboset* temp = m_req_jokboset_;
  m_req_jokboset_ = NULL;
  return temp;
}

// optional .s_req_ack m_req_ack = 13;
inline bool GLReqGameProtocol::has_m_req_ack() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GLReqGameProtocol::set_has_m_req_ack() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GLReqGameProtocol::clear_has_m_req_ack() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GLReqGameProtocol::clear_m_req_ack() {
  if (m_req_ack_ != NULL) m_req_ack_->::s_req_ack::Clear();
  clear_has_m_req_ack();
}
inline const ::s_req_ack& GLReqGameProtocol::m_req_ack() const {
  return m_req_ack_ != NULL ? *m_req_ack_ : *default_instance_->m_req_ack_;
}
inline ::s_req_ack* GLReqGameProtocol::mutable_m_req_ack() {
  set_has_m_req_ack();
  if (m_req_ack_ == NULL) m_req_ack_ = new ::s_req_ack;
  return m_req_ack_;
}
inline ::s_req_ack* GLReqGameProtocol::release_m_req_ack() {
  clear_has_m_req_ack();
  ::s_req_ack* temp = m_req_ack_;
  m_req_ack_ = NULL;
  return temp;
}

// optional .s_req_choiceremovecard m_req_choiceremovecard = 14;
inline bool GLReqGameProtocol::has_m_req_choiceremovecard() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void GLReqGameProtocol::set_has_m_req_choiceremovecard() {
  _has_bits_[0] |= 0x00002000u;
}
inline void GLReqGameProtocol::clear_has_m_req_choiceremovecard() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void GLReqGameProtocol::clear_m_req_choiceremovecard() {
  if (m_req_choiceremovecard_ != NULL) m_req_choiceremovecard_->::s_req_choiceremovecard::Clear();
  clear_has_m_req_choiceremovecard();
}
inline const ::s_req_choiceremovecard& GLReqGameProtocol::m_req_choiceremovecard() const {
  return m_req_choiceremovecard_ != NULL ? *m_req_choiceremovecard_ : *default_instance_->m_req_choiceremovecard_;
}
inline ::s_req_choiceremovecard* GLReqGameProtocol::mutable_m_req_choiceremovecard() {
  set_has_m_req_choiceremovecard();
  if (m_req_choiceremovecard_ == NULL) m_req_choiceremovecard_ = new ::s_req_choiceremovecard;
  return m_req_choiceremovecard_;
}
inline ::s_req_choiceremovecard* GLReqGameProtocol::release_m_req_choiceremovecard() {
  clear_has_m_req_choiceremovecard();
  ::s_req_choiceremovecard* temp = m_req_choiceremovecard_;
  m_req_choiceremovecard_ = NULL;
  return temp;
}

// optional .s_req_purge m_req_purge = 15;
inline bool GLReqGameProtocol::has_m_req_purge() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void GLReqGameProtocol::set_has_m_req_purge() {
  _has_bits_[0] |= 0x00004000u;
}
inline void GLReqGameProtocol::clear_has_m_req_purge() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void GLReqGameProtocol::clear_m_req_purge() {
  if (m_req_purge_ != NULL) m_req_purge_->::s_req_purge::Clear();
  clear_has_m_req_purge();
}
inline const ::s_req_purge& GLReqGameProtocol::m_req_purge() const {
  return m_req_purge_ != NULL ? *m_req_purge_ : *default_instance_->m_req_purge_;
}
inline ::s_req_purge* GLReqGameProtocol::mutable_m_req_purge() {
  set_has_m_req_purge();
  if (m_req_purge_ == NULL) m_req_purge_ = new ::s_req_purge;
  return m_req_purge_;
}
inline ::s_req_purge* GLReqGameProtocol::release_m_req_purge() {
  clear_has_m_req_purge();
  ::s_req_purge* temp = m_req_purge_;
  m_req_purge_ = NULL;
  return temp;
}

// optional .s_req_exitque m_req_exitque = 16;
inline bool GLReqGameProtocol::has_m_req_exitque() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void GLReqGameProtocol::set_has_m_req_exitque() {
  _has_bits_[0] |= 0x00008000u;
}
inline void GLReqGameProtocol::clear_has_m_req_exitque() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void GLReqGameProtocol::clear_m_req_exitque() {
  if (m_req_exitque_ != NULL) m_req_exitque_->::s_req_exitque::Clear();
  clear_has_m_req_exitque();
}
inline const ::s_req_exitque& GLReqGameProtocol::m_req_exitque() const {
  return m_req_exitque_ != NULL ? *m_req_exitque_ : *default_instance_->m_req_exitque_;
}
inline ::s_req_exitque* GLReqGameProtocol::mutable_m_req_exitque() {
  set_has_m_req_exitque();
  if (m_req_exitque_ == NULL) m_req_exitque_ = new ::s_req_exitque;
  return m_req_exitque_;
}
inline ::s_req_exitque* GLReqGameProtocol::release_m_req_exitque() {
  clear_has_m_req_exitque();
  ::s_req_exitque* temp = m_req_exitque_;
  m_req_exitque_ = NULL;
  return temp;
}

// optional .s_req_soundtype m_req_soundtype = 17;
inline bool GLReqGameProtocol::has_m_req_soundtype() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void GLReqGameProtocol::set_has_m_req_soundtype() {
  _has_bits_[0] |= 0x00010000u;
}
inline void GLReqGameProtocol::clear_has_m_req_soundtype() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void GLReqGameProtocol::clear_m_req_soundtype() {
  if (m_req_soundtype_ != NULL) m_req_soundtype_->::s_req_soundtype::Clear();
  clear_has_m_req_soundtype();
}
inline const ::s_req_soundtype& GLReqGameProtocol::m_req_soundtype() const {
  return m_req_soundtype_ != NULL ? *m_req_soundtype_ : *default_instance_->m_req_soundtype_;
}
inline ::s_req_soundtype* GLReqGameProtocol::mutable_m_req_soundtype() {
  set_has_m_req_soundtype();
  if (m_req_soundtype_ == NULL) m_req_soundtype_ = new ::s_req_soundtype;
  return m_req_soundtype_;
}
inline ::s_req_soundtype* GLReqGameProtocol::release_m_req_soundtype() {
  clear_has_m_req_soundtype();
  ::s_req_soundtype* temp = m_req_soundtype_;
  m_req_soundtype_ = NULL;
  return temp;
}

// optional .s_req_abuse m_req_abuse = 18;
inline bool GLReqGameProtocol::has_m_req_abuse() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void GLReqGameProtocol::set_has_m_req_abuse() {
  _has_bits_[0] |= 0x00020000u;
}
inline void GLReqGameProtocol::clear_has_m_req_abuse() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void GLReqGameProtocol::clear_m_req_abuse() {
  if (m_req_abuse_ != NULL) m_req_abuse_->::s_req_abuse::Clear();
  clear_has_m_req_abuse();
}
inline const ::s_req_abuse& GLReqGameProtocol::m_req_abuse() const {
  return m_req_abuse_ != NULL ? *m_req_abuse_ : *default_instance_->m_req_abuse_;
}
inline ::s_req_abuse* GLReqGameProtocol::mutable_m_req_abuse() {
  set_has_m_req_abuse();
  if (m_req_abuse_ == NULL) m_req_abuse_ = new ::s_req_abuse;
  return m_req_abuse_;
}
inline ::s_req_abuse* GLReqGameProtocol::release_m_req_abuse() {
  clear_has_m_req_abuse();
  ::s_req_abuse* temp = m_req_abuse_;
  m_req_abuse_ = NULL;
  return temp;
}

// optional .s_req_observe m_req_observe = 19;
inline bool GLReqGameProtocol::has_m_req_observe() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void GLReqGameProtocol::set_has_m_req_observe() {
  _has_bits_[0] |= 0x00040000u;
}
inline void GLReqGameProtocol::clear_has_m_req_observe() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void GLReqGameProtocol::clear_m_req_observe() {
  if (m_req_observe_ != NULL) m_req_observe_->::s_req_observe::Clear();
  clear_has_m_req_observe();
}
inline const ::s_req_observe& GLReqGameProtocol::m_req_observe() const {
  return m_req_observe_ != NULL ? *m_req_observe_ : *default_instance_->m_req_observe_;
}
inline ::s_req_observe* GLReqGameProtocol::mutable_m_req_observe() {
  set_has_m_req_observe();
  if (m_req_observe_ == NULL) m_req_observe_ = new ::s_req_observe;
  return m_req_observe_;
}
inline ::s_req_observe* GLReqGameProtocol::release_m_req_observe() {
  clear_has_m_req_observe();
  ::s_req_observe* temp = m_req_observe_;
  m_req_observe_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// s_ans_game_test_packet

// required int32 test_int = 2;
inline bool s_ans_game_test_packet::has_test_int() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_ans_game_test_packet::set_has_test_int() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_ans_game_test_packet::clear_has_test_int() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_ans_game_test_packet::clear_test_int() {
  test_int_ = 0;
  clear_has_test_int();
}
inline ::google::protobuf::int32 s_ans_game_test_packet::test_int() const {
  return test_int_;
}
inline void s_ans_game_test_packet::set_test_int(::google::protobuf::int32 value) {
  set_has_test_int();
  test_int_ = value;
}

// required string test_string = 3;
inline bool s_ans_game_test_packet::has_test_string() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void s_ans_game_test_packet::set_has_test_string() {
  _has_bits_[0] |= 0x00000002u;
}
inline void s_ans_game_test_packet::clear_has_test_string() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void s_ans_game_test_packet::clear_test_string() {
  if (test_string_ != &::google::protobuf::internal::kEmptyString) {
    test_string_->clear();
  }
  clear_has_test_string();
}
inline const ::std::string& s_ans_game_test_packet::test_string() const {
  return *test_string_;
}
inline void s_ans_game_test_packet::set_test_string(const ::std::string& value) {
  set_has_test_string();
  if (test_string_ == &::google::protobuf::internal::kEmptyString) {
    test_string_ = new ::std::string;
  }
  test_string_->assign(value);
}
inline void s_ans_game_test_packet::set_test_string(const char* value) {
  set_has_test_string();
  if (test_string_ == &::google::protobuf::internal::kEmptyString) {
    test_string_ = new ::std::string;
  }
  test_string_->assign(value);
}
inline void s_ans_game_test_packet::set_test_string(const char* value, size_t size) {
  set_has_test_string();
  if (test_string_ == &::google::protobuf::internal::kEmptyString) {
    test_string_ = new ::std::string;
  }
  test_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* s_ans_game_test_packet::mutable_test_string() {
  set_has_test_string();
  if (test_string_ == &::google::protobuf::internal::kEmptyString) {
    test_string_ = new ::std::string;
  }
  return test_string_;
}
inline ::std::string* s_ans_game_test_packet::release_test_string() {
  clear_has_test_string();
  if (test_string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = test_string_;
    test_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// s_ans_join_room

// required .GameRoomInfo gameroominfo = 1;
inline bool s_ans_join_room::has_gameroominfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_ans_join_room::set_has_gameroominfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_ans_join_room::clear_has_gameroominfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_ans_join_room::clear_gameroominfo() {
  if (gameroominfo_ != NULL) gameroominfo_->::GameRoomInfo::Clear();
  clear_has_gameroominfo();
}
inline const ::GameRoomInfo& s_ans_join_room::gameroominfo() const {
  return gameroominfo_ != NULL ? *gameroominfo_ : *default_instance_->gameroominfo_;
}
inline ::GameRoomInfo* s_ans_join_room::mutable_gameroominfo() {
  set_has_gameroominfo();
  if (gameroominfo_ == NULL) gameroominfo_ = new ::GameRoomInfo;
  return gameroominfo_;
}
inline ::GameRoomInfo* s_ans_join_room::release_gameroominfo() {
  clear_has_gameroominfo();
  ::GameRoomInfo* temp = gameroominfo_;
  gameroominfo_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// s_ans_deal_card

// required sint32 m_lBossUSN = 1;
inline bool s_ans_deal_card::has_m_lbossusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_ans_deal_card::set_has_m_lbossusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_ans_deal_card::clear_has_m_lbossusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_ans_deal_card::clear_m_lbossusn() {
  m_lbossusn_ = 0;
  clear_has_m_lbossusn();
}
inline ::google::protobuf::int32 s_ans_deal_card::m_lbossusn() const {
  return m_lbossusn_;
}
inline void s_ans_deal_card::set_m_lbossusn(::google::protobuf::int32 value) {
  set_has_m_lbossusn();
  m_lbossusn_ = value;
}

// required int32 m_nType = 2;
inline bool s_ans_deal_card::has_m_ntype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void s_ans_deal_card::set_has_m_ntype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void s_ans_deal_card::clear_has_m_ntype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void s_ans_deal_card::clear_m_ntype() {
  m_ntype_ = 0;
  clear_has_m_ntype();
}
inline ::google::protobuf::int32 s_ans_deal_card::m_ntype() const {
  return m_ntype_;
}
inline void s_ans_deal_card::set_m_ntype(::google::protobuf::int32 value) {
  set_has_m_ntype();
  m_ntype_ = value;
}

// required sint32 m_lCardsDealt = 3;
inline bool s_ans_deal_card::has_m_lcardsdealt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void s_ans_deal_card::set_has_m_lcardsdealt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void s_ans_deal_card::clear_has_m_lcardsdealt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void s_ans_deal_card::clear_m_lcardsdealt() {
  m_lcardsdealt_ = 0;
  clear_has_m_lcardsdealt();
}
inline ::google::protobuf::int32 s_ans_deal_card::m_lcardsdealt() const {
  return m_lcardsdealt_;
}
inline void s_ans_deal_card::set_m_lcardsdealt(::google::protobuf::int32 value) {
  set_has_m_lcardsdealt();
  m_lcardsdealt_ = value;
}

// repeated .PKOneCard m_vtOneCard = 4;
inline int s_ans_deal_card::m_vtonecard_size() const {
  return m_vtonecard_.size();
}
inline void s_ans_deal_card::clear_m_vtonecard() {
  m_vtonecard_.Clear();
}
inline const ::PKOneCard& s_ans_deal_card::m_vtonecard(int index) const {
  return m_vtonecard_.Get(index);
}
inline ::PKOneCard* s_ans_deal_card::mutable_m_vtonecard(int index) {
  return m_vtonecard_.Mutable(index);
}
inline ::PKOneCard* s_ans_deal_card::add_m_vtonecard() {
  return m_vtonecard_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PKOneCard >&
s_ans_deal_card::m_vtonecard() const {
  return m_vtonecard_;
}
inline ::google::protobuf::RepeatedPtrField< ::PKOneCard >*
s_ans_deal_card::mutable_m_vtonecard() {
  return &m_vtonecard_;
}

// -------------------------------------------------------------------

// s_ans_deal_cards

// required sint32 m_lBossUSN = 1;
inline bool s_ans_deal_cards::has_m_lbossusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_ans_deal_cards::set_has_m_lbossusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_ans_deal_cards::clear_has_m_lbossusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_ans_deal_cards::clear_m_lbossusn() {
  m_lbossusn_ = 0;
  clear_has_m_lbossusn();
}
inline ::google::protobuf::int32 s_ans_deal_cards::m_lbossusn() const {
  return m_lbossusn_;
}
inline void s_ans_deal_cards::set_m_lbossusn(::google::protobuf::int32 value) {
  set_has_m_lbossusn();
  m_lbossusn_ = value;
}

// required sint32 m_lState = 2;
inline bool s_ans_deal_cards::has_m_lstate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void s_ans_deal_cards::set_has_m_lstate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void s_ans_deal_cards::clear_has_m_lstate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void s_ans_deal_cards::clear_m_lstate() {
  m_lstate_ = 0;
  clear_has_m_lstate();
}
inline ::google::protobuf::int32 s_ans_deal_cards::m_lstate() const {
  return m_lstate_;
}
inline void s_ans_deal_cards::set_m_lstate(::google::protobuf::int32 value) {
  set_has_m_lstate();
  m_lstate_ = value;
}

// required int32 m_nType = 3;
inline bool s_ans_deal_cards::has_m_ntype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void s_ans_deal_cards::set_has_m_ntype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void s_ans_deal_cards::clear_has_m_ntype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void s_ans_deal_cards::clear_m_ntype() {
  m_ntype_ = 0;
  clear_has_m_ntype();
}
inline ::google::protobuf::int32 s_ans_deal_cards::m_ntype() const {
  return m_ntype_;
}
inline void s_ans_deal_cards::set_m_ntype(::google::protobuf::int32 value) {
  set_has_m_ntype();
  m_ntype_ = value;
}

// repeated .PKCards m_tblCard = 4;
inline int s_ans_deal_cards::m_tblcard_size() const {
  return m_tblcard_.size();
}
inline void s_ans_deal_cards::clear_m_tblcard() {
  m_tblcard_.Clear();
}
inline const ::PKCards& s_ans_deal_cards::m_tblcard(int index) const {
  return m_tblcard_.Get(index);
}
inline ::PKCards* s_ans_deal_cards::mutable_m_tblcard(int index) {
  return m_tblcard_.Mutable(index);
}
inline ::PKCards* s_ans_deal_cards::add_m_tblcard() {
  return m_tblcard_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PKCards >&
s_ans_deal_cards::m_tblcard() const {
  return m_tblcard_;
}
inline ::google::protobuf::RepeatedPtrField< ::PKCards >*
s_ans_deal_cards::mutable_m_tblcard() {
  return &m_tblcard_;
}

// repeated .PKMoney m_tblMoney = 5;
inline int s_ans_deal_cards::m_tblmoney_size() const {
  return m_tblmoney_.size();
}
inline void s_ans_deal_cards::clear_m_tblmoney() {
  m_tblmoney_.Clear();
}
inline const ::PKMoney& s_ans_deal_cards::m_tblmoney(int index) const {
  return m_tblmoney_.Get(index);
}
inline ::PKMoney* s_ans_deal_cards::mutable_m_tblmoney(int index) {
  return m_tblmoney_.Mutable(index);
}
inline ::PKMoney* s_ans_deal_cards::add_m_tblmoney() {
  return m_tblmoney_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PKMoney >&
s_ans_deal_cards::m_tblmoney() const {
  return m_tblmoney_;
}
inline ::google::protobuf::RepeatedPtrField< ::PKMoney >*
s_ans_deal_cards::mutable_m_tblmoney() {
  return &m_tblmoney_;
}

// required sint64 m_llPoolMoney = 6;
inline bool s_ans_deal_cards::has_m_llpoolmoney() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void s_ans_deal_cards::set_has_m_llpoolmoney() {
  _has_bits_[0] |= 0x00000020u;
}
inline void s_ans_deal_cards::clear_has_m_llpoolmoney() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void s_ans_deal_cards::clear_m_llpoolmoney() {
  m_llpoolmoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_llpoolmoney();
}
inline ::google::protobuf::int64 s_ans_deal_cards::m_llpoolmoney() const {
  return m_llpoolmoney_;
}
inline void s_ans_deal_cards::set_m_llpoolmoney(::google::protobuf::int64 value) {
  set_has_m_llpoolmoney();
  m_llpoolmoney_ = value;
}

// -------------------------------------------------------------------

// s_ans_send_ante

// required sint64 m_llAnteMoney = 1;
inline bool s_ans_send_ante::has_m_llantemoney() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_ans_send_ante::set_has_m_llantemoney() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_ans_send_ante::clear_has_m_llantemoney() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_ans_send_ante::clear_m_llantemoney() {
  m_llantemoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_llantemoney();
}
inline ::google::protobuf::int64 s_ans_send_ante::m_llantemoney() const {
  return m_llantemoney_;
}
inline void s_ans_send_ante::set_m_llantemoney(::google::protobuf::int64 value) {
  set_has_m_llantemoney();
  m_llantemoney_ = value;
}

// -------------------------------------------------------------------

// s_ans_select_card

// required sint32 m_lUSN = 1;
inline bool s_ans_select_card::has_m_lusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_ans_select_card::set_has_m_lusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_ans_select_card::clear_has_m_lusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_ans_select_card::clear_m_lusn() {
  m_lusn_ = 0;
  clear_has_m_lusn();
}
inline ::google::protobuf::int32 s_ans_select_card::m_lusn() const {
  return m_lusn_;
}
inline void s_ans_select_card::set_m_lusn(::google::protobuf::int32 value) {
  set_has_m_lusn();
  m_lusn_ = value;
}

// required int32 m_nSelect = 2;
inline bool s_ans_select_card::has_m_nselect() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void s_ans_select_card::set_has_m_nselect() {
  _has_bits_[0] |= 0x00000002u;
}
inline void s_ans_select_card::clear_has_m_nselect() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void s_ans_select_card::clear_m_nselect() {
  m_nselect_ = 0;
  clear_has_m_nselect();
}
inline ::google::protobuf::int32 s_ans_select_card::m_nselect() const {
  return m_nselect_;
}
inline void s_ans_select_card::set_m_nselect(::google::protobuf::int32 value) {
  set_has_m_nselect();
  m_nselect_ = value;
}

// required sint32 m_lCardIndex = 3;
inline bool s_ans_select_card::has_m_lcardindex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void s_ans_select_card::set_has_m_lcardindex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void s_ans_select_card::clear_has_m_lcardindex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void s_ans_select_card::clear_m_lcardindex() {
  m_lcardindex_ = 0;
  clear_has_m_lcardindex();
}
inline ::google::protobuf::int32 s_ans_select_card::m_lcardindex() const {
  return m_lcardindex_;
}
inline void s_ans_select_card::set_m_lcardindex(::google::protobuf::int32 value) {
  set_has_m_lcardindex();
  m_lcardindex_ = value;
}

// required sint32 m_lChoiceType = 4;
inline bool s_ans_select_card::has_m_lchoicetype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void s_ans_select_card::set_has_m_lchoicetype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void s_ans_select_card::clear_has_m_lchoicetype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void s_ans_select_card::clear_m_lchoicetype() {
  m_lchoicetype_ = 0;
  clear_has_m_lchoicetype();
}
inline ::google::protobuf::int32 s_ans_select_card::m_lchoicetype() const {
  return m_lchoicetype_;
}
inline void s_ans_select_card::set_m_lchoicetype(::google::protobuf::int32 value) {
  set_has_m_lchoicetype();
  m_lchoicetype_ = value;
}

// -------------------------------------------------------------------

// s_ans_opencard

// required sint32 m_lState = 1;
inline bool s_ans_opencard::has_m_lstate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_ans_opencard::set_has_m_lstate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_ans_opencard::clear_has_m_lstate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_ans_opencard::clear_m_lstate() {
  m_lstate_ = 0;
  clear_has_m_lstate();
}
inline ::google::protobuf::int32 s_ans_opencard::m_lstate() const {
  return m_lstate_;
}
inline void s_ans_opencard::set_m_lstate(::google::protobuf::int32 value) {
  set_has_m_lstate();
  m_lstate_ = value;
}

// repeated .PKCards m_tblCard = 2;
inline int s_ans_opencard::m_tblcard_size() const {
  return m_tblcard_.size();
}
inline void s_ans_opencard::clear_m_tblcard() {
  m_tblcard_.Clear();
}
inline const ::PKCards& s_ans_opencard::m_tblcard(int index) const {
  return m_tblcard_.Get(index);
}
inline ::PKCards* s_ans_opencard::mutable_m_tblcard(int index) {
  return m_tblcard_.Mutable(index);
}
inline ::PKCards* s_ans_opencard::add_m_tblcard() {
  return m_tblcard_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PKCards >&
s_ans_opencard::m_tblcard() const {
  return m_tblcard_;
}
inline ::google::protobuf::RepeatedPtrField< ::PKCards >*
s_ans_opencard::mutable_m_tblcard() {
  return &m_tblcard_;
}

// repeated sint32 m_vtState = 3;
inline int s_ans_opencard::m_vtstate_size() const {
  return m_vtstate_.size();
}
inline void s_ans_opencard::clear_m_vtstate() {
  m_vtstate_.Clear();
}
inline ::google::protobuf::int32 s_ans_opencard::m_vtstate(int index) const {
  return m_vtstate_.Get(index);
}
inline void s_ans_opencard::set_m_vtstate(int index, ::google::protobuf::int32 value) {
  m_vtstate_.Set(index, value);
}
inline void s_ans_opencard::add_m_vtstate(::google::protobuf::int32 value) {
  m_vtstate_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
s_ans_opencard::m_vtstate() const {
  return m_vtstate_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
s_ans_opencard::mutable_m_vtstate() {
  return &m_vtstate_;
}

// -------------------------------------------------------------------

// s_ans_boss

// required sint32 m_lBossUSN = 1;
inline bool s_ans_boss::has_m_lbossusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_ans_boss::set_has_m_lbossusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_ans_boss::clear_has_m_lbossusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_ans_boss::clear_m_lbossusn() {
  m_lbossusn_ = 0;
  clear_has_m_lbossusn();
}
inline ::google::protobuf::int32 s_ans_boss::m_lbossusn() const {
  return m_lbossusn_;
}
inline void s_ans_boss::set_m_lbossusn(::google::protobuf::int32 value) {
  set_has_m_lbossusn();
  m_lbossusn_ = value;
}

// required int32 m_nBossRank = 2;
inline bool s_ans_boss::has_m_nbossrank() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void s_ans_boss::set_has_m_nbossrank() {
  _has_bits_[0] |= 0x00000002u;
}
inline void s_ans_boss::clear_has_m_nbossrank() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void s_ans_boss::clear_m_nbossrank() {
  m_nbossrank_ = 0;
  clear_has_m_nbossrank();
}
inline ::google::protobuf::int32 s_ans_boss::m_nbossrank() const {
  return m_nbossrank_;
}
inline void s_ans_boss::set_m_nbossrank(::google::protobuf::int32 value) {
  set_has_m_nbossrank();
  m_nbossrank_ = value;
}

// -------------------------------------------------------------------

// s_ans_deal_hiddencard

// required sint32 m_lBossUSN = 1;
inline bool s_ans_deal_hiddencard::has_m_lbossusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_ans_deal_hiddencard::set_has_m_lbossusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_ans_deal_hiddencard::clear_has_m_lbossusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_ans_deal_hiddencard::clear_m_lbossusn() {
  m_lbossusn_ = 0;
  clear_has_m_lbossusn();
}
inline ::google::protobuf::int32 s_ans_deal_hiddencard::m_lbossusn() const {
  return m_lbossusn_;
}
inline void s_ans_deal_hiddencard::set_m_lbossusn(::google::protobuf::int32 value) {
  set_has_m_lbossusn();
  m_lbossusn_ = value;
}

// required sint32 m_lCardsDealt = 2;
inline bool s_ans_deal_hiddencard::has_m_lcardsdealt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void s_ans_deal_hiddencard::set_has_m_lcardsdealt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void s_ans_deal_hiddencard::clear_has_m_lcardsdealt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void s_ans_deal_hiddencard::clear_m_lcardsdealt() {
  m_lcardsdealt_ = 0;
  clear_has_m_lcardsdealt();
}
inline ::google::protobuf::int32 s_ans_deal_hiddencard::m_lcardsdealt() const {
  return m_lcardsdealt_;
}
inline void s_ans_deal_hiddencard::set_m_lcardsdealt(::google::protobuf::int32 value) {
  set_has_m_lcardsdealt();
  m_lcardsdealt_ = value;
}

// repeated .PKOneCard m_vtOneCard = 3;
inline int s_ans_deal_hiddencard::m_vtonecard_size() const {
  return m_vtonecard_.size();
}
inline void s_ans_deal_hiddencard::clear_m_vtonecard() {
  m_vtonecard_.Clear();
}
inline const ::PKOneCard& s_ans_deal_hiddencard::m_vtonecard(int index) const {
  return m_vtonecard_.Get(index);
}
inline ::PKOneCard* s_ans_deal_hiddencard::mutable_m_vtonecard(int index) {
  return m_vtonecard_.Mutable(index);
}
inline ::PKOneCard* s_ans_deal_hiddencard::add_m_vtonecard() {
  return m_vtonecard_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PKOneCard >&
s_ans_deal_hiddencard::m_vtonecard() const {
  return m_vtonecard_;
}
inline ::google::protobuf::RepeatedPtrField< ::PKOneCard >*
s_ans_deal_hiddencard::mutable_m_vtonecard() {
  return &m_vtonecard_;
}

// -------------------------------------------------------------------

// s_ans_betting

// required int32 m_lUSN = 1;
inline bool s_ans_betting::has_m_lusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_ans_betting::set_has_m_lusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_ans_betting::clear_has_m_lusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_ans_betting::clear_m_lusn() {
  m_lusn_ = 0;
  clear_has_m_lusn();
}
inline ::google::protobuf::int32 s_ans_betting::m_lusn() const {
  return m_lusn_;
}
inline void s_ans_betting::set_m_lusn(::google::protobuf::int32 value) {
  set_has_m_lusn();
  m_lusn_ = value;
}

// required int32 m_BetType = 2;
inline bool s_ans_betting::has_m_bettype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void s_ans_betting::set_has_m_bettype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void s_ans_betting::clear_has_m_bettype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void s_ans_betting::clear_m_bettype() {
  m_bettype_ = 0;
  clear_has_m_bettype();
}
inline ::google::protobuf::int32 s_ans_betting::m_bettype() const {
  return m_bettype_;
}
inline void s_ans_betting::set_m_bettype(::google::protobuf::int32 value) {
  set_has_m_bettype();
  m_bettype_ = value;
}

// -------------------------------------------------------------------

// s_ans_pong

// optional int32 error_code = 1;
inline bool s_ans_pong::has_error_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_ans_pong::set_has_error_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_ans_pong::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_ans_pong::clear_error_code() {
  error_code_ = 0;
  clear_has_error_code();
}
inline ::google::protobuf::int32 s_ans_pong::error_code() const {
  return error_code_;
}
inline void s_ans_pong::set_error_code(::google::protobuf::int32 value) {
  set_has_error_code();
  error_code_ = value;
}

// -------------------------------------------------------------------

// s_ans_entry

// required sint32 m_lUSN = 1;
inline bool s_ans_entry::has_m_lusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_ans_entry::set_has_m_lusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_ans_entry::clear_has_m_lusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_ans_entry::clear_m_lusn() {
  m_lusn_ = 0;
  clear_has_m_lusn();
}
inline ::google::protobuf::int32 s_ans_entry::m_lusn() const {
  return m_lusn_;
}
inline void s_ans_entry::set_m_lusn(::google::protobuf::int32 value) {
  set_has_m_lusn();
  m_lusn_ = value;
}

// required int32 m_nIndex = 2;
inline bool s_ans_entry::has_m_nindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void s_ans_entry::set_has_m_nindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void s_ans_entry::clear_has_m_nindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void s_ans_entry::clear_m_nindex() {
  m_nindex_ = 0;
  clear_has_m_nindex();
}
inline ::google::protobuf::int32 s_ans_entry::m_nindex() const {
  return m_nindex_;
}
inline void s_ans_entry::set_m_nindex(::google::protobuf::int32 value) {
  set_has_m_nindex();
  m_nindex_ = value;
}

// required sint32 m_lOwnerUSN = 3;
inline bool s_ans_entry::has_m_lownerusn() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void s_ans_entry::set_has_m_lownerusn() {
  _has_bits_[0] |= 0x00000004u;
}
inline void s_ans_entry::clear_has_m_lownerusn() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void s_ans_entry::clear_m_lownerusn() {
  m_lownerusn_ = 0;
  clear_has_m_lownerusn();
}
inline ::google::protobuf::int32 s_ans_entry::m_lownerusn() const {
  return m_lownerusn_;
}
inline void s_ans_entry::set_m_lownerusn(::google::protobuf::int32 value) {
  set_has_m_lownerusn();
  m_lownerusn_ = value;
}

// repeated .PKUserInfo m_tblUI = 4;
inline int s_ans_entry::m_tblui_size() const {
  return m_tblui_.size();
}
inline void s_ans_entry::clear_m_tblui() {
  m_tblui_.Clear();
}
inline const ::PKUserInfo& s_ans_entry::m_tblui(int index) const {
  return m_tblui_.Get(index);
}
inline ::PKUserInfo* s_ans_entry::mutable_m_tblui(int index) {
  return m_tblui_.Mutable(index);
}
inline ::PKUserInfo* s_ans_entry::add_m_tblui() {
  return m_tblui_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PKUserInfo >&
s_ans_entry::m_tblui() const {
  return m_tblui_;
}
inline ::google::protobuf::RepeatedPtrField< ::PKUserInfo >*
s_ans_entry::mutable_m_tblui() {
  return &m_tblui_;
}

// repeated .PKMoney m_tblMoney = 5;
inline int s_ans_entry::m_tblmoney_size() const {
  return m_tblmoney_.size();
}
inline void s_ans_entry::clear_m_tblmoney() {
  m_tblmoney_.Clear();
}
inline const ::PKMoney& s_ans_entry::m_tblmoney(int index) const {
  return m_tblmoney_.Get(index);
}
inline ::PKMoney* s_ans_entry::mutable_m_tblmoney(int index) {
  return m_tblmoney_.Mutable(index);
}
inline ::PKMoney* s_ans_entry::add_m_tblmoney() {
  return m_tblmoney_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PKMoney >&
s_ans_entry::m_tblmoney() const {
  return m_tblmoney_;
}
inline ::google::protobuf::RepeatedPtrField< ::PKMoney >*
s_ans_entry::mutable_m_tblmoney() {
  return &m_tblmoney_;
}

// required sint32 m_bWelcomeSound = 6;
inline bool s_ans_entry::has_m_bwelcomesound() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void s_ans_entry::set_has_m_bwelcomesound() {
  _has_bits_[0] |= 0x00000020u;
}
inline void s_ans_entry::clear_has_m_bwelcomesound() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void s_ans_entry::clear_m_bwelcomesound() {
  m_bwelcomesound_ = 0;
  clear_has_m_bwelcomesound();
}
inline ::google::protobuf::int32 s_ans_entry::m_bwelcomesound() const {
  return m_bwelcomesound_;
}
inline void s_ans_entry::set_m_bwelcomesound(::google::protobuf::int32 value) {
  set_has_m_bwelcomesound();
  m_bwelcomesound_ = value;
}

// required sint32 m_lObserveCnt = 7;
inline bool s_ans_entry::has_m_lobservecnt() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void s_ans_entry::set_has_m_lobservecnt() {
  _has_bits_[0] |= 0x00000040u;
}
inline void s_ans_entry::clear_has_m_lobservecnt() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void s_ans_entry::clear_m_lobservecnt() {
  m_lobservecnt_ = 0;
  clear_has_m_lobservecnt();
}
inline ::google::protobuf::int32 s_ans_entry::m_lobservecnt() const {
  return m_lobservecnt_;
}
inline void s_ans_entry::set_m_lobservecnt(::google::protobuf::int32 value) {
  set_has_m_lobservecnt();
  m_lobservecnt_ = value;
}

// -------------------------------------------------------------------

// s_betting_msg

// required int32 m_lUSN = 1;
inline bool s_betting_msg::has_m_lusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_betting_msg::set_has_m_lusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_betting_msg::clear_has_m_lusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_betting_msg::clear_m_lusn() {
  m_lusn_ = 0;
  clear_has_m_lusn();
}
inline ::google::protobuf::int32 s_betting_msg::m_lusn() const {
  return m_lusn_;
}
inline void s_betting_msg::set_m_lusn(::google::protobuf::int32 value) {
  set_has_m_lusn();
  m_lusn_ = value;
}

// required int32 m_nIndex = 2;
inline bool s_betting_msg::has_m_nindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void s_betting_msg::set_has_m_nindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void s_betting_msg::clear_has_m_nindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void s_betting_msg::clear_m_nindex() {
  m_nindex_ = 0;
  clear_has_m_nindex();
}
inline ::google::protobuf::int32 s_betting_msg::m_nindex() const {
  return m_nindex_;
}
inline void s_betting_msg::set_m_nindex(::google::protobuf::int32 value) {
  set_has_m_nindex();
  m_nindex_ = value;
}

// required int32 m_BetType = 3;
inline bool s_betting_msg::has_m_bettype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void s_betting_msg::set_has_m_bettype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void s_betting_msg::clear_has_m_bettype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void s_betting_msg::clear_m_bettype() {
  m_bettype_ = 0;
  clear_has_m_bettype();
}
inline ::google::protobuf::int32 s_betting_msg::m_bettype() const {
  return m_bettype_;
}
inline void s_betting_msg::set_m_bettype(::google::protobuf::int32 value) {
  set_has_m_bettype();
  m_bettype_ = value;
}

// required int32 m_bBettingMoney = 4;
inline bool s_betting_msg::has_m_bbettingmoney() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void s_betting_msg::set_has_m_bbettingmoney() {
  _has_bits_[0] |= 0x00000008u;
}
inline void s_betting_msg::clear_has_m_bbettingmoney() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void s_betting_msg::clear_m_bbettingmoney() {
  m_bbettingmoney_ = 0;
  clear_has_m_bbettingmoney();
}
inline ::google::protobuf::int32 s_betting_msg::m_bbettingmoney() const {
  return m_bbettingmoney_;
}
inline void s_betting_msg::set_m_bbettingmoney(::google::protobuf::int32 value) {
  set_has_m_bbettingmoney();
  m_bbettingmoney_ = value;
}

// required int32 m_bMoneyLack = 5;
inline bool s_betting_msg::has_m_bmoneylack() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void s_betting_msg::set_has_m_bmoneylack() {
  _has_bits_[0] |= 0x00000010u;
}
inline void s_betting_msg::clear_has_m_bmoneylack() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void s_betting_msg::clear_m_bmoneylack() {
  m_bmoneylack_ = 0;
  clear_has_m_bmoneylack();
}
inline ::google::protobuf::int32 s_betting_msg::m_bmoneylack() const {
  return m_bmoneylack_;
}
inline void s_betting_msg::set_m_bmoneylack(::google::protobuf::int32 value) {
  set_has_m_bmoneylack();
  m_bmoneylack_ = value;
}

// required int32 m_bCallMoneyZero = 6;
inline bool s_betting_msg::has_m_bcallmoneyzero() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void s_betting_msg::set_has_m_bcallmoneyzero() {
  _has_bits_[0] |= 0x00000020u;
}
inline void s_betting_msg::clear_has_m_bcallmoneyzero() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void s_betting_msg::clear_m_bcallmoneyzero() {
  m_bcallmoneyzero_ = 0;
  clear_has_m_bcallmoneyzero();
}
inline ::google::protobuf::int32 s_betting_msg::m_bcallmoneyzero() const {
  return m_bcallmoneyzero_;
}
inline void s_betting_msg::set_m_bcallmoneyzero(::google::protobuf::int32 value) {
  set_has_m_bcallmoneyzero();
  m_bcallmoneyzero_ = value;
}

// required int64 m_llCallMoney = 7;
inline bool s_betting_msg::has_m_llcallmoney() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void s_betting_msg::set_has_m_llcallmoney() {
  _has_bits_[0] |= 0x00000040u;
}
inline void s_betting_msg::clear_has_m_llcallmoney() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void s_betting_msg::clear_m_llcallmoney() {
  m_llcallmoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_llcallmoney();
}
inline ::google::protobuf::int64 s_betting_msg::m_llcallmoney() const {
  return m_llcallmoney_;
}
inline void s_betting_msg::set_m_llcallmoney(::google::protobuf::int64 value) {
  set_has_m_llcallmoney();
  m_llcallmoney_ = value;
}

// required int64 m_llRaiseMoney = 8;
inline bool s_betting_msg::has_m_llraisemoney() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void s_betting_msg::set_has_m_llraisemoney() {
  _has_bits_[0] |= 0x00000080u;
}
inline void s_betting_msg::clear_has_m_llraisemoney() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void s_betting_msg::clear_m_llraisemoney() {
  m_llraisemoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_llraisemoney();
}
inline ::google::protobuf::int64 s_betting_msg::m_llraisemoney() const {
  return m_llraisemoney_;
}
inline void s_betting_msg::set_m_llraisemoney(::google::protobuf::int64 value) {
  set_has_m_llraisemoney();
  m_llraisemoney_ = value;
}

// required int64 m_llSideMoney = 9;
inline bool s_betting_msg::has_m_llsidemoney() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void s_betting_msg::set_has_m_llsidemoney() {
  _has_bits_[0] |= 0x00000100u;
}
inline void s_betting_msg::clear_has_m_llsidemoney() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void s_betting_msg::clear_m_llsidemoney() {
  m_llsidemoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_llsidemoney();
}
inline ::google::protobuf::int64 s_betting_msg::m_llsidemoney() const {
  return m_llsidemoney_;
}
inline void s_betting_msg::set_m_llsidemoney(::google::protobuf::int64 value) {
  set_has_m_llsidemoney();
  m_llsidemoney_ = value;
}

// required int32 m_lBetTurn = 10;
inline bool s_betting_msg::has_m_lbetturn() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void s_betting_msg::set_has_m_lbetturn() {
  _has_bits_[0] |= 0x00000200u;
}
inline void s_betting_msg::clear_has_m_lbetturn() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void s_betting_msg::clear_m_lbetturn() {
  m_lbetturn_ = 0;
  clear_has_m_lbetturn();
}
inline ::google::protobuf::int32 s_betting_msg::m_lbetturn() const {
  return m_lbetturn_;
}
inline void s_betting_msg::set_m_lbetturn(::google::protobuf::int32 value) {
  set_has_m_lbetturn();
  m_lbetturn_ = value;
}

// required .PKMoney m_money = 11;
inline bool s_betting_msg::has_m_money() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void s_betting_msg::set_has_m_money() {
  _has_bits_[0] |= 0x00000400u;
}
inline void s_betting_msg::clear_has_m_money() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void s_betting_msg::clear_m_money() {
  if (m_money_ != NULL) m_money_->::PKMoney::Clear();
  clear_has_m_money();
}
inline const ::PKMoney& s_betting_msg::m_money() const {
  return m_money_ != NULL ? *m_money_ : *default_instance_->m_money_;
}
inline ::PKMoney* s_betting_msg::mutable_m_money() {
  set_has_m_money();
  if (m_money_ == NULL) m_money_ = new ::PKMoney;
  return m_money_;
}
inline ::PKMoney* s_betting_msg::release_m_money() {
  clear_has_m_money();
  ::PKMoney* temp = m_money_;
  m_money_ = NULL;
  return temp;
}

// repeated int64 m_vtCallMoney = 12;
inline int s_betting_msg::m_vtcallmoney_size() const {
  return m_vtcallmoney_.size();
}
inline void s_betting_msg::clear_m_vtcallmoney() {
  m_vtcallmoney_.Clear();
}
inline ::google::protobuf::int64 s_betting_msg::m_vtcallmoney(int index) const {
  return m_vtcallmoney_.Get(index);
}
inline void s_betting_msg::set_m_vtcallmoney(int index, ::google::protobuf::int64 value) {
  m_vtcallmoney_.Set(index, value);
}
inline void s_betting_msg::add_m_vtcallmoney(::google::protobuf::int64 value) {
  m_vtcallmoney_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
s_betting_msg::m_vtcallmoney() const {
  return m_vtcallmoney_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
s_betting_msg::mutable_m_vtcallmoney() {
  return &m_vtcallmoney_;
}

// required int64 m_llPoolMoney = 13;
inline bool s_betting_msg::has_m_llpoolmoney() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void s_betting_msg::set_has_m_llpoolmoney() {
  _has_bits_[0] |= 0x00001000u;
}
inline void s_betting_msg::clear_has_m_llpoolmoney() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void s_betting_msg::clear_m_llpoolmoney() {
  m_llpoolmoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_llpoolmoney();
}
inline ::google::protobuf::int64 s_betting_msg::m_llpoolmoney() const {
  return m_llpoolmoney_;
}
inline void s_betting_msg::set_m_llpoolmoney(::google::protobuf::int64 value) {
  set_has_m_llpoolmoney();
  m_llpoolmoney_ = value;
}

// -------------------------------------------------------------------

// s_finished

// required sint32 m_lState = 1;
inline bool s_finished::has_m_lstate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_finished::set_has_m_lstate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_finished::clear_has_m_lstate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_finished::clear_m_lstate() {
  m_lstate_ = 0;
  clear_has_m_lstate();
}
inline ::google::protobuf::int32 s_finished::m_lstate() const {
  return m_lstate_;
}
inline void s_finished::set_m_lstate(::google::protobuf::int32 value) {
  set_has_m_lstate();
  m_lstate_ = value;
}

// required sint32 m_bGiveUp = 2;
inline bool s_finished::has_m_bgiveup() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void s_finished::set_has_m_bgiveup() {
  _has_bits_[0] |= 0x00000002u;
}
inline void s_finished::clear_has_m_bgiveup() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void s_finished::clear_m_bgiveup() {
  m_bgiveup_ = 0;
  clear_has_m_bgiveup();
}
inline ::google::protobuf::int32 s_finished::m_bgiveup() const {
  return m_bgiveup_;
}
inline void s_finished::set_m_bgiveup(::google::protobuf::int32 value) {
  set_has_m_bgiveup();
  m_bgiveup_ = value;
}

// required sint32 m_lRank = 3;
inline bool s_finished::has_m_lrank() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void s_finished::set_has_m_lrank() {
  _has_bits_[0] |= 0x00000004u;
}
inline void s_finished::clear_has_m_lrank() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void s_finished::clear_m_lrank() {
  m_lrank_ = 0;
  clear_has_m_lrank();
}
inline ::google::protobuf::int32 s_finished::m_lrank() const {
  return m_lrank_;
}
inline void s_finished::set_m_lrank(::google::protobuf::int32 value) {
  set_has_m_lrank();
  m_lrank_ = value;
}

// required sint32 m_lBossUSN = 4;
inline bool s_finished::has_m_lbossusn() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void s_finished::set_has_m_lbossusn() {
  _has_bits_[0] |= 0x00000008u;
}
inline void s_finished::clear_has_m_lbossusn() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void s_finished::clear_m_lbossusn() {
  m_lbossusn_ = 0;
  clear_has_m_lbossusn();
}
inline ::google::protobuf::int32 s_finished::m_lbossusn() const {
  return m_lbossusn_;
}
inline void s_finished::set_m_lbossusn(::google::protobuf::int32 value) {
  set_has_m_lbossusn();
  m_lbossusn_ = value;
}

// required sint64 m_llGiveMoney = 5;
inline bool s_finished::has_m_llgivemoney() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void s_finished::set_has_m_llgivemoney() {
  _has_bits_[0] |= 0x00000010u;
}
inline void s_finished::clear_has_m_llgivemoney() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void s_finished::clear_m_llgivemoney() {
  m_llgivemoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_llgivemoney();
}
inline ::google::protobuf::int64 s_finished::m_llgivemoney() const {
  return m_llgivemoney_;
}
inline void s_finished::set_m_llgivemoney(::google::protobuf::int64 value) {
  set_has_m_llgivemoney();
  m_llgivemoney_ = value;
}

// repeated int32 m_vtWin = 6;
inline int s_finished::m_vtwin_size() const {
  return m_vtwin_.size();
}
inline void s_finished::clear_m_vtwin() {
  m_vtwin_.Clear();
}
inline ::google::protobuf::int32 s_finished::m_vtwin(int index) const {
  return m_vtwin_.Get(index);
}
inline void s_finished::set_m_vtwin(int index, ::google::protobuf::int32 value) {
  m_vtwin_.Set(index, value);
}
inline void s_finished::add_m_vtwin(::google::protobuf::int32 value) {
  m_vtwin_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
s_finished::m_vtwin() const {
  return m_vtwin_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
s_finished::mutable_m_vtwin() {
  return &m_vtwin_;
}

// repeated int32 m_vtResult = 7;
inline int s_finished::m_vtresult_size() const {
  return m_vtresult_.size();
}
inline void s_finished::clear_m_vtresult() {
  m_vtresult_.Clear();
}
inline ::google::protobuf::int32 s_finished::m_vtresult(int index) const {
  return m_vtresult_.Get(index);
}
inline void s_finished::set_m_vtresult(int index, ::google::protobuf::int32 value) {
  m_vtresult_.Set(index, value);
}
inline void s_finished::add_m_vtresult(::google::protobuf::int32 value) {
  m_vtresult_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
s_finished::m_vtresult() const {
  return m_vtresult_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
s_finished::mutable_m_vtresult() {
  return &m_vtresult_;
}

// repeated sint64 m_vtGiveMoney = 8;
inline int s_finished::m_vtgivemoney_size() const {
  return m_vtgivemoney_.size();
}
inline void s_finished::clear_m_vtgivemoney() {
  m_vtgivemoney_.Clear();
}
inline ::google::protobuf::int64 s_finished::m_vtgivemoney(int index) const {
  return m_vtgivemoney_.Get(index);
}
inline void s_finished::set_m_vtgivemoney(int index, ::google::protobuf::int64 value) {
  m_vtgivemoney_.Set(index, value);
}
inline void s_finished::add_m_vtgivemoney(::google::protobuf::int64 value) {
  m_vtgivemoney_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
s_finished::m_vtgivemoney() const {
  return m_vtgivemoney_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
s_finished::mutable_m_vtgivemoney() {
  return &m_vtgivemoney_;
}

// repeated .PKCards m_tblCard = 9;
inline int s_finished::m_tblcard_size() const {
  return m_tblcard_.size();
}
inline void s_finished::clear_m_tblcard() {
  m_tblcard_.Clear();
}
inline const ::PKCards& s_finished::m_tblcard(int index) const {
  return m_tblcard_.Get(index);
}
inline ::PKCards* s_finished::mutable_m_tblcard(int index) {
  return m_tblcard_.Mutable(index);
}
inline ::PKCards* s_finished::add_m_tblcard() {
  return m_tblcard_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PKCards >&
s_finished::m_tblcard() const {
  return m_tblcard_;
}
inline ::google::protobuf::RepeatedPtrField< ::PKCards >*
s_finished::mutable_m_tblcard() {
  return &m_tblcard_;
}

// repeated .PKMoney m_tblMoney = 10;
inline int s_finished::m_tblmoney_size() const {
  return m_tblmoney_.size();
}
inline void s_finished::clear_m_tblmoney() {
  m_tblmoney_.Clear();
}
inline const ::PKMoney& s_finished::m_tblmoney(int index) const {
  return m_tblmoney_.Get(index);
}
inline ::PKMoney* s_finished::mutable_m_tblmoney(int index) {
  return m_tblmoney_.Mutable(index);
}
inline ::PKMoney* s_finished::add_m_tblmoney() {
  return m_tblmoney_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PKMoney >&
s_finished::m_tblmoney() const {
  return m_tblmoney_;
}
inline ::google::protobuf::RepeatedPtrField< ::PKMoney >*
s_finished::mutable_m_tblmoney() {
  return &m_tblmoney_;
}

// required sint64 m_llPoolMoney = 11;
inline bool s_finished::has_m_llpoolmoney() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void s_finished::set_has_m_llpoolmoney() {
  _has_bits_[0] |= 0x00000400u;
}
inline void s_finished::clear_has_m_llpoolmoney() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void s_finished::clear_m_llpoolmoney() {
  m_llpoolmoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_llpoolmoney();
}
inline ::google::protobuf::int64 s_finished::m_llpoolmoney() const {
  return m_llpoolmoney_;
}
inline void s_finished::set_m_llpoolmoney(::google::protobuf::int64 value) {
  set_has_m_llpoolmoney();
  m_llpoolmoney_ = value;
}

// repeated .UserMoney m_vtUserMoney = 12;
inline int s_finished::m_vtusermoney_size() const {
  return m_vtusermoney_.size();
}
inline void s_finished::clear_m_vtusermoney() {
  m_vtusermoney_.Clear();
}
inline const ::UserMoney& s_finished::m_vtusermoney(int index) const {
  return m_vtusermoney_.Get(index);
}
inline ::UserMoney* s_finished::mutable_m_vtusermoney(int index) {
  return m_vtusermoney_.Mutable(index);
}
inline ::UserMoney* s_finished::add_m_vtusermoney() {
  return m_vtusermoney_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::UserMoney >&
s_finished::m_vtusermoney() const {
  return m_vtusermoney_;
}
inline ::google::protobuf::RepeatedPtrField< ::UserMoney >*
s_finished::mutable_m_vtusermoney() {
  return &m_vtusermoney_;
}

// required sint32 m_lResultIdx = 13;
inline bool s_finished::has_m_lresultidx() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void s_finished::set_has_m_lresultidx() {
  _has_bits_[0] |= 0x00001000u;
}
inline void s_finished::clear_has_m_lresultidx() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void s_finished::clear_m_lresultidx() {
  m_lresultidx_ = 0;
  clear_has_m_lresultidx();
}
inline ::google::protobuf::int32 s_finished::m_lresultidx() const {
  return m_lresultidx_;
}
inline void s_finished::set_m_lresultidx(::google::protobuf::int32 value) {
  set_has_m_lresultidx();
  m_lresultidx_ = value;
}

// required sint64 m_llJackpot = 14;
inline bool s_finished::has_m_lljackpot() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void s_finished::set_has_m_lljackpot() {
  _has_bits_[0] |= 0x00002000u;
}
inline void s_finished::clear_has_m_lljackpot() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void s_finished::clear_m_lljackpot() {
  m_lljackpot_ = GOOGLE_LONGLONG(0);
  clear_has_m_lljackpot();
}
inline ::google::protobuf::int64 s_finished::m_lljackpot() const {
  return m_lljackpot_;
}
inline void s_finished::set_m_lljackpot(::google::protobuf::int64 value) {
  set_has_m_lljackpot();
  m_lljackpot_ = value;
}

// -------------------------------------------------------------------

// s_jackpotmoneyntf

// required sint32 m_lUSN = 1;
inline bool s_jackpotmoneyntf::has_m_lusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_jackpotmoneyntf::set_has_m_lusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_jackpotmoneyntf::clear_has_m_lusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_jackpotmoneyntf::clear_m_lusn() {
  m_lusn_ = 0;
  clear_has_m_lusn();
}
inline ::google::protobuf::int32 s_jackpotmoneyntf::m_lusn() const {
  return m_lusn_;
}
inline void s_jackpotmoneyntf::set_m_lusn(::google::protobuf::int32 value) {
  set_has_m_lusn();
  m_lusn_ = value;
}

// required sint64 m_llJackpotMoney = 2;
inline bool s_jackpotmoneyntf::has_m_lljackpotmoney() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void s_jackpotmoneyntf::set_has_m_lljackpotmoney() {
  _has_bits_[0] |= 0x00000002u;
}
inline void s_jackpotmoneyntf::clear_has_m_lljackpotmoney() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void s_jackpotmoneyntf::clear_m_lljackpotmoney() {
  m_lljackpotmoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_lljackpotmoney();
}
inline ::google::protobuf::int64 s_jackpotmoneyntf::m_lljackpotmoney() const {
  return m_lljackpotmoney_;
}
inline void s_jackpotmoneyntf::set_m_lljackpotmoney(::google::protobuf::int64 value) {
  set_has_m_lljackpotmoney();
  m_lljackpotmoney_ = value;
}

// -------------------------------------------------------------------

// s_ans_continue

// required sint32 m_lUSN = 1;
inline bool s_ans_continue::has_m_lusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_ans_continue::set_has_m_lusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_ans_continue::clear_has_m_lusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_ans_continue::clear_m_lusn() {
  m_lusn_ = 0;
  clear_has_m_lusn();
}
inline ::google::protobuf::int32 s_ans_continue::m_lusn() const {
  return m_lusn_;
}
inline void s_ans_continue::set_m_lusn(::google::protobuf::int32 value) {
  set_has_m_lusn();
  m_lusn_ = value;
}

// -------------------------------------------------------------------

// s_ans_ruleset

// required int32 m_nRuleIdx = 1;
inline bool s_ans_ruleset::has_m_nruleidx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_ans_ruleset::set_has_m_nruleidx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_ans_ruleset::clear_has_m_nruleidx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_ans_ruleset::clear_m_nruleidx() {
  m_nruleidx_ = 0;
  clear_has_m_nruleidx();
}
inline ::google::protobuf::int32 s_ans_ruleset::m_nruleidx() const {
  return m_nruleidx_;
}
inline void s_ans_ruleset::set_m_nruleidx(::google::protobuf::int32 value) {
  set_has_m_nruleidx();
  m_nruleidx_ = value;
}

// -------------------------------------------------------------------

// s_ans_start

// required sint32 m_lState = 1;
inline bool s_ans_start::has_m_lstate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_ans_start::set_has_m_lstate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_ans_start::clear_has_m_lstate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_ans_start::clear_m_lstate() {
  m_lstate_ = 0;
  clear_has_m_lstate();
}
inline ::google::protobuf::int32 s_ans_start::m_lstate() const {
  return m_lstate_;
}
inline void s_ans_start::set_m_lstate(::google::protobuf::int32 value) {
  set_has_m_lstate();
  m_lstate_ = value;
}

// repeated sint32 m_vtState = 2;
inline int s_ans_start::m_vtstate_size() const {
  return m_vtstate_.size();
}
inline void s_ans_start::clear_m_vtstate() {
  m_vtstate_.Clear();
}
inline ::google::protobuf::int32 s_ans_start::m_vtstate(int index) const {
  return m_vtstate_.Get(index);
}
inline void s_ans_start::set_m_vtstate(int index, ::google::protobuf::int32 value) {
  m_vtstate_.Set(index, value);
}
inline void s_ans_start::add_m_vtstate(::google::protobuf::int32 value) {
  m_vtstate_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
s_ans_start::m_vtstate() const {
  return m_vtstate_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
s_ans_start::mutable_m_vtstate() {
  return &m_vtstate_;
}

// required sint64 m_llSystemTime = 3;
inline bool s_ans_start::has_m_llsystemtime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void s_ans_start::set_has_m_llsystemtime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void s_ans_start::clear_has_m_llsystemtime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void s_ans_start::clear_m_llsystemtime() {
  m_llsystemtime_ = GOOGLE_LONGLONG(0);
  clear_has_m_llsystemtime();
}
inline ::google::protobuf::int64 s_ans_start::m_llsystemtime() const {
  return m_llsystemtime_;
}
inline void s_ans_start::set_m_llsystemtime(::google::protobuf::int64 value) {
  set_has_m_llsystemtime();
  m_llsystemtime_ = value;
}

// -------------------------------------------------------------------

// s_carddata

// required int32 m_nDealCnt = 1;
inline bool s_carddata::has_m_ndealcnt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_carddata::set_has_m_ndealcnt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_carddata::clear_has_m_ndealcnt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_carddata::clear_m_ndealcnt() {
  m_ndealcnt_ = 0;
  clear_has_m_ndealcnt();
}
inline ::google::protobuf::int32 s_carddata::m_ndealcnt() const {
  return m_ndealcnt_;
}
inline void s_carddata::set_m_ndealcnt(::google::protobuf::int32 value) {
  set_has_m_ndealcnt();
  m_ndealcnt_ = value;
}

// required sint32 m_lCardsDealt = 2;
inline bool s_carddata::has_m_lcardsdealt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void s_carddata::set_has_m_lcardsdealt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void s_carddata::clear_has_m_lcardsdealt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void s_carddata::clear_m_lcardsdealt() {
  m_lcardsdealt_ = 0;
  clear_has_m_lcardsdealt();
}
inline ::google::protobuf::int32 s_carddata::m_lcardsdealt() const {
  return m_lcardsdealt_;
}
inline void s_carddata::set_m_lcardsdealt(::google::protobuf::int32 value) {
  set_has_m_lcardsdealt();
  m_lcardsdealt_ = value;
}

// repeated .PKCards m_tblCard = 3;
inline int s_carddata::m_tblcard_size() const {
  return m_tblcard_.size();
}
inline void s_carddata::clear_m_tblcard() {
  m_tblcard_.Clear();
}
inline const ::PKCards& s_carddata::m_tblcard(int index) const {
  return m_tblcard_.Get(index);
}
inline ::PKCards* s_carddata::mutable_m_tblcard(int index) {
  return m_tblcard_.Mutable(index);
}
inline ::PKCards* s_carddata::add_m_tblcard() {
  return m_tblcard_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PKCards >&
s_carddata::m_tblcard() const {
  return m_tblcard_;
}
inline ::google::protobuf::RepeatedPtrField< ::PKCards >*
s_carddata::mutable_m_tblcard() {
  return &m_tblcard_;
}

// repeated .PKMoney m_tblMoney = 4;
inline int s_carddata::m_tblmoney_size() const {
  return m_tblmoney_.size();
}
inline void s_carddata::clear_m_tblmoney() {
  m_tblmoney_.Clear();
}
inline const ::PKMoney& s_carddata::m_tblmoney(int index) const {
  return m_tblmoney_.Get(index);
}
inline ::PKMoney* s_carddata::mutable_m_tblmoney(int index) {
  return m_tblmoney_.Mutable(index);
}
inline ::PKMoney* s_carddata::add_m_tblmoney() {
  return m_tblmoney_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PKMoney >&
s_carddata::m_tblmoney() const {
  return m_tblmoney_;
}
inline ::google::protobuf::RepeatedPtrField< ::PKMoney >*
s_carddata::mutable_m_tblmoney() {
  return &m_tblmoney_;
}

// required sint64 m_llPoolMoney = 5;
inline bool s_carddata::has_m_llpoolmoney() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void s_carddata::set_has_m_llpoolmoney() {
  _has_bits_[0] |= 0x00000010u;
}
inline void s_carddata::clear_has_m_llpoolmoney() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void s_carddata::clear_m_llpoolmoney() {
  m_llpoolmoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_llpoolmoney();
}
inline ::google::protobuf::int64 s_carddata::m_llpoolmoney() const {
  return m_llpoolmoney_;
}
inline void s_carddata::set_m_llpoolmoney(::google::protobuf::int64 value) {
  set_has_m_llpoolmoney();
  m_llpoolmoney_ = value;
}

// -------------------------------------------------------------------

// s_entryreject

// required sint32 m_lType = 1;
inline bool s_entryreject::has_m_ltype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_entryreject::set_has_m_ltype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_entryreject::clear_has_m_ltype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_entryreject::clear_m_ltype() {
  m_ltype_ = 0;
  clear_has_m_ltype();
}
inline ::google::protobuf::int32 s_entryreject::m_ltype() const {
  return m_ltype_;
}
inline void s_entryreject::set_m_ltype(::google::protobuf::int32 value) {
  set_has_m_ltype();
  m_ltype_ = value;
}

// required sint64 m_llCMoney = 2;
inline bool s_entryreject::has_m_llcmoney() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void s_entryreject::set_has_m_llcmoney() {
  _has_bits_[0] |= 0x00000002u;
}
inline void s_entryreject::clear_has_m_llcmoney() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void s_entryreject::clear_m_llcmoney() {
  m_llcmoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_llcmoney();
}
inline ::google::protobuf::int64 s_entryreject::m_llcmoney() const {
  return m_llcmoney_;
}
inline void s_entryreject::set_m_llcmoney(::google::protobuf::int64 value) {
  set_has_m_llcmoney();
  m_llcmoney_ = value;
}

// -------------------------------------------------------------------

// s_nostart

// -------------------------------------------------------------------

// s_newgame

// repeated .PKWinLoseInfo m_vtWinLoseInfo = 1;
inline int s_newgame::m_vtwinloseinfo_size() const {
  return m_vtwinloseinfo_.size();
}
inline void s_newgame::clear_m_vtwinloseinfo() {
  m_vtwinloseinfo_.Clear();
}
inline const ::PKWinLoseInfo& s_newgame::m_vtwinloseinfo(int index) const {
  return m_vtwinloseinfo_.Get(index);
}
inline ::PKWinLoseInfo* s_newgame::mutable_m_vtwinloseinfo(int index) {
  return m_vtwinloseinfo_.Mutable(index);
}
inline ::PKWinLoseInfo* s_newgame::add_m_vtwinloseinfo() {
  return m_vtwinloseinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PKWinLoseInfo >&
s_newgame::m_vtwinloseinfo() const {
  return m_vtwinloseinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::PKWinLoseInfo >*
s_newgame::mutable_m_vtwinloseinfo() {
  return &m_vtwinloseinfo_;
}

// -------------------------------------------------------------------

// s_ans_purge

// -------------------------------------------------------------------

// s_purgeinfo

// repeated .PKVecUSN m_vtPurgeUSN = 1;
inline int s_purgeinfo::m_vtpurgeusn_size() const {
  return m_vtpurgeusn_.size();
}
inline void s_purgeinfo::clear_m_vtpurgeusn() {
  m_vtpurgeusn_.Clear();
}
inline const ::PKVecUSN& s_purgeinfo::m_vtpurgeusn(int index) const {
  return m_vtpurgeusn_.Get(index);
}
inline ::PKVecUSN* s_purgeinfo::mutable_m_vtpurgeusn(int index) {
  return m_vtpurgeusn_.Mutable(index);
}
inline ::PKVecUSN* s_purgeinfo::add_m_vtpurgeusn() {
  return m_vtpurgeusn_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PKVecUSN >&
s_purgeinfo::m_vtpurgeusn() const {
  return m_vtpurgeusn_;
}
inline ::google::protobuf::RepeatedPtrField< ::PKVecUSN >*
s_purgeinfo::mutable_m_vtpurgeusn() {
  return &m_vtpurgeusn_;
}

// required int32 m_nCount = 2;
inline bool s_purgeinfo::has_m_ncount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void s_purgeinfo::set_has_m_ncount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void s_purgeinfo::clear_has_m_ncount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void s_purgeinfo::clear_m_ncount() {
  m_ncount_ = 0;
  clear_has_m_ncount();
}
inline ::google::protobuf::int32 s_purgeinfo::m_ncount() const {
  return m_ncount_;
}
inline void s_purgeinfo::set_m_ncount(::google::protobuf::int32 value) {
  set_has_m_ncount();
  m_ncount_ = value;
}

// -------------------------------------------------------------------

// s_systemmsg

// required sint32 m_lType = 1;
inline bool s_systemmsg::has_m_ltype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_systemmsg::set_has_m_ltype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_systemmsg::clear_has_m_ltype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_systemmsg::clear_m_ltype() {
  m_ltype_ = 0;
  clear_has_m_ltype();
}
inline ::google::protobuf::int32 s_systemmsg::m_ltype() const {
  return m_ltype_;
}
inline void s_systemmsg::set_m_ltype(::google::protobuf::int32 value) {
  set_has_m_ltype();
  m_ltype_ = value;
}

// -------------------------------------------------------------------

// s_exitntf

// required sint32 m_lUSN = 1;
inline bool s_exitntf::has_m_lusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_exitntf::set_has_m_lusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_exitntf::clear_has_m_lusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_exitntf::clear_m_lusn() {
  m_lusn_ = 0;
  clear_has_m_lusn();
}
inline ::google::protobuf::int32 s_exitntf::m_lusn() const {
  return m_lusn_;
}
inline void s_exitntf::set_m_lusn(::google::protobuf::int32 value) {
  set_has_m_lusn();
  m_lusn_ = value;
}

// required int32 m_nIndex = 2;
inline bool s_exitntf::has_m_nindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void s_exitntf::set_has_m_nindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void s_exitntf::clear_has_m_nindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void s_exitntf::clear_m_nindex() {
  m_nindex_ = 0;
  clear_has_m_nindex();
}
inline ::google::protobuf::int32 s_exitntf::m_nindex() const {
  return m_nindex_;
}
inline void s_exitntf::set_m_nindex(::google::protobuf::int32 value) {
  set_has_m_nindex();
  m_nindex_ = value;
}

// required sint32 m_lExit = 3;
inline bool s_exitntf::has_m_lexit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void s_exitntf::set_has_m_lexit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void s_exitntf::clear_has_m_lexit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void s_exitntf::clear_m_lexit() {
  m_lexit_ = 0;
  clear_has_m_lexit();
}
inline ::google::protobuf::int32 s_exitntf::m_lexit() const {
  return m_lexit_;
}
inline void s_exitntf::set_m_lexit(::google::protobuf::int32 value) {
  set_has_m_lexit();
  m_lexit_ = value;
}

// required sint32 m_bExit = 4;
inline bool s_exitntf::has_m_bexit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void s_exitntf::set_has_m_bexit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void s_exitntf::clear_has_m_bexit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void s_exitntf::clear_m_bexit() {
  m_bexit_ = 0;
  clear_has_m_bexit();
}
inline ::google::protobuf::int32 s_exitntf::m_bexit() const {
  return m_bexit_;
}
inline void s_exitntf::set_m_bexit(::google::protobuf::int32 value) {
  set_has_m_bexit();
  m_bexit_ = value;
}

// -------------------------------------------------------------------

// s_refillmoneyntf

// required sint32 m_lUSN = 1;
inline bool s_refillmoneyntf::has_m_lusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_refillmoneyntf::set_has_m_lusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_refillmoneyntf::clear_has_m_lusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_refillmoneyntf::clear_m_lusn() {
  m_lusn_ = 0;
  clear_has_m_lusn();
}
inline ::google::protobuf::int32 s_refillmoneyntf::m_lusn() const {
  return m_lusn_;
}
inline void s_refillmoneyntf::set_m_lusn(::google::protobuf::int32 value) {
  set_has_m_lusn();
  m_lusn_ = value;
}

// required int32 m_nRefillCnt = 2;
inline bool s_refillmoneyntf::has_m_nrefillcnt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void s_refillmoneyntf::set_has_m_nrefillcnt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void s_refillmoneyntf::clear_has_m_nrefillcnt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void s_refillmoneyntf::clear_m_nrefillcnt() {
  m_nrefillcnt_ = 0;
  clear_has_m_nrefillcnt();
}
inline ::google::protobuf::int32 s_refillmoneyntf::m_nrefillcnt() const {
  return m_nrefillcnt_;
}
inline void s_refillmoneyntf::set_m_nrefillcnt(::google::protobuf::int32 value) {
  set_has_m_nrefillcnt();
  m_nrefillcnt_ = value;
}

// required sint64 m_llRefillMoney = 3;
inline bool s_refillmoneyntf::has_m_llrefillmoney() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void s_refillmoneyntf::set_has_m_llrefillmoney() {
  _has_bits_[0] |= 0x00000004u;
}
inline void s_refillmoneyntf::clear_has_m_llrefillmoney() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void s_refillmoneyntf::clear_m_llrefillmoney() {
  m_llrefillmoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_llrefillmoney();
}
inline ::google::protobuf::int64 s_refillmoneyntf::m_llrefillmoney() const {
  return m_llrefillmoney_;
}
inline void s_refillmoneyntf::set_m_llrefillmoney(::google::protobuf::int64 value) {
  set_has_m_llrefillmoney();
  m_llrefillmoney_ = value;
}

// -------------------------------------------------------------------

// s_bonus

// required sint64 m_llBonus = 1;
inline bool s_bonus::has_m_llbonus() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_bonus::set_has_m_llbonus() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_bonus::clear_has_m_llbonus() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_bonus::clear_m_llbonus() {
  m_llbonus_ = GOOGLE_LONGLONG(0);
  clear_has_m_llbonus();
}
inline ::google::protobuf::int64 s_bonus::m_llbonus() const {
  return m_llbonus_;
}
inline void s_bonus::set_m_llbonus(::google::protobuf::int64 value) {
  set_has_m_llbonus();
  m_llbonus_ = value;
}

// -------------------------------------------------------------------

// s_userjoinerr

// required sint32 m_lUSN = 1;
inline bool s_userjoinerr::has_m_lusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_userjoinerr::set_has_m_lusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_userjoinerr::clear_has_m_lusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_userjoinerr::clear_m_lusn() {
  m_lusn_ = 0;
  clear_has_m_lusn();
}
inline ::google::protobuf::int32 s_userjoinerr::m_lusn() const {
  return m_lusn_;
}
inline void s_userjoinerr::set_m_lusn(::google::protobuf::int32 value) {
  set_has_m_lusn();
  m_lusn_ = value;
}

// required sint32 m_lErrorCode = 2;
inline bool s_userjoinerr::has_m_lerrorcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void s_userjoinerr::set_has_m_lerrorcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void s_userjoinerr::clear_has_m_lerrorcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void s_userjoinerr::clear_m_lerrorcode() {
  m_lerrorcode_ = 0;
  clear_has_m_lerrorcode();
}
inline ::google::protobuf::int32 s_userjoinerr::m_lerrorcode() const {
  return m_lerrorcode_;
}
inline void s_userjoinerr::set_m_lerrorcode(::google::protobuf::int32 value) {
  set_has_m_lerrorcode();
  m_lerrorcode_ = value;
}

// -------------------------------------------------------------------

// s_userdisconnect

// required sint32 m_lUSN = 1;
inline bool s_userdisconnect::has_m_lusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_userdisconnect::set_has_m_lusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_userdisconnect::clear_has_m_lusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_userdisconnect::clear_m_lusn() {
  m_lusn_ = 0;
  clear_has_m_lusn();
}
inline ::google::protobuf::int32 s_userdisconnect::m_lusn() const {
  return m_lusn_;
}
inline void s_userdisconnect::set_m_lusn(::google::protobuf::int32 value) {
  set_has_m_lusn();
  m_lusn_ = value;
}

// required .PKUserInfo m_uinfo = 2;
inline bool s_userdisconnect::has_m_uinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void s_userdisconnect::set_has_m_uinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void s_userdisconnect::clear_has_m_uinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void s_userdisconnect::clear_m_uinfo() {
  if (m_uinfo_ != NULL) m_uinfo_->::PKUserInfo::Clear();
  clear_has_m_uinfo();
}
inline const ::PKUserInfo& s_userdisconnect::m_uinfo() const {
  return m_uinfo_ != NULL ? *m_uinfo_ : *default_instance_->m_uinfo_;
}
inline ::PKUserInfo* s_userdisconnect::mutable_m_uinfo() {
  set_has_m_uinfo();
  if (m_uinfo_ == NULL) m_uinfo_ = new ::PKUserInfo;
  return m_uinfo_;
}
inline ::PKUserInfo* s_userdisconnect::release_m_uinfo() {
  clear_has_m_uinfo();
  ::PKUserInfo* temp = m_uinfo_;
  m_uinfo_ = NULL;
  return temp;
}

// required sint32 m_lState = 3;
inline bool s_userdisconnect::has_m_lstate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void s_userdisconnect::set_has_m_lstate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void s_userdisconnect::clear_has_m_lstate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void s_userdisconnect::clear_m_lstate() {
  m_lstate_ = 0;
  clear_has_m_lstate();
}
inline ::google::protobuf::int32 s_userdisconnect::m_lstate() const {
  return m_lstate_;
}
inline void s_userdisconnect::set_m_lstate(::google::protobuf::int32 value) {
  set_has_m_lstate();
  m_lstate_ = value;
}

// required sint32 m_lOwnerUSN = 4;
inline bool s_userdisconnect::has_m_lownerusn() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void s_userdisconnect::set_has_m_lownerusn() {
  _has_bits_[0] |= 0x00000008u;
}
inline void s_userdisconnect::clear_has_m_lownerusn() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void s_userdisconnect::clear_m_lownerusn() {
  m_lownerusn_ = 0;
  clear_has_m_lownerusn();
}
inline ::google::protobuf::int32 s_userdisconnect::m_lownerusn() const {
  return m_lownerusn_;
}
inline void s_userdisconnect::set_m_lownerusn(::google::protobuf::int32 value) {
  set_has_m_lownerusn();
  m_lownerusn_ = value;
}

// -------------------------------------------------------------------

// s_soundtypeans

// required sint32 m_lUSN = 1;
inline bool s_soundtypeans::has_m_lusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_soundtypeans::set_has_m_lusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_soundtypeans::clear_has_m_lusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_soundtypeans::clear_m_lusn() {
  m_lusn_ = 0;
  clear_has_m_lusn();
}
inline ::google::protobuf::int32 s_soundtypeans::m_lusn() const {
  return m_lusn_;
}
inline void s_soundtypeans::set_m_lusn(::google::protobuf::int32 value) {
  set_has_m_lusn();
  m_lusn_ = value;
}

// required int32 m_nIndex = 2;
inline bool s_soundtypeans::has_m_nindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void s_soundtypeans::set_has_m_nindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void s_soundtypeans::clear_has_m_nindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void s_soundtypeans::clear_m_nindex() {
  m_nindex_ = 0;
  clear_has_m_nindex();
}
inline ::google::protobuf::int32 s_soundtypeans::m_nindex() const {
  return m_nindex_;
}
inline void s_soundtypeans::set_m_nindex(::google::protobuf::int32 value) {
  set_has_m_nindex();
  m_nindex_ = value;
}

// required sint32 m_lSoundType = 3;
inline bool s_soundtypeans::has_m_lsoundtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void s_soundtypeans::set_has_m_lsoundtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void s_soundtypeans::clear_has_m_lsoundtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void s_soundtypeans::clear_m_lsoundtype() {
  m_lsoundtype_ = 0;
  clear_has_m_lsoundtype();
}
inline ::google::protobuf::int32 s_soundtypeans::m_lsoundtype() const {
  return m_lsoundtype_;
}
inline void s_soundtypeans::set_m_lsoundtype(::google::protobuf::int32 value) {
  set_has_m_lsoundtype();
  m_lsoundtype_ = value;
}

// -------------------------------------------------------------------

// s_userjoinans

// required sint32 m_lState = 1;
inline bool s_userjoinans::has_m_lstate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_userjoinans::set_has_m_lstate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_userjoinans::clear_has_m_lstate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_userjoinans::clear_m_lstate() {
  m_lstate_ = 0;
  clear_has_m_lstate();
}
inline ::google::protobuf::int32 s_userjoinans::m_lstate() const {
  return m_lstate_;
}
inline void s_userjoinans::set_m_lstate(::google::protobuf::int32 value) {
  set_has_m_lstate();
  m_lstate_ = value;
}

// required int32 m_nEnter = 2;
inline bool s_userjoinans::has_m_nenter() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void s_userjoinans::set_has_m_nenter() {
  _has_bits_[0] |= 0x00000002u;
}
inline void s_userjoinans::clear_has_m_nenter() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void s_userjoinans::clear_m_nenter() {
  m_nenter_ = 0;
  clear_has_m_nenter();
}
inline ::google::protobuf::int32 s_userjoinans::m_nenter() const {
  return m_nenter_;
}
inline void s_userjoinans::set_m_nenter(::google::protobuf::int32 value) {
  set_has_m_nenter();
  m_nenter_ = value;
}

// required int32 m_nSet = 3;
inline bool s_userjoinans::has_m_nset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void s_userjoinans::set_has_m_nset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void s_userjoinans::clear_has_m_nset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void s_userjoinans::clear_m_nset() {
  m_nset_ = 0;
  clear_has_m_nset();
}
inline ::google::protobuf::int32 s_userjoinans::m_nset() const {
  return m_nset_;
}
inline void s_userjoinans::set_m_nset(::google::protobuf::int32 value) {
  set_has_m_nset();
  m_nset_ = value;
}

// required int32 m_lChannel_idx = 4;
inline bool s_userjoinans::has_m_lchannel_idx() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void s_userjoinans::set_has_m_lchannel_idx() {
  _has_bits_[0] |= 0x00000008u;
}
inline void s_userjoinans::clear_has_m_lchannel_idx() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void s_userjoinans::clear_m_lchannel_idx() {
  m_lchannel_idx_ = 0;
  clear_has_m_lchannel_idx();
}
inline ::google::protobuf::int32 s_userjoinans::m_lchannel_idx() const {
  return m_lchannel_idx_;
}
inline void s_userjoinans::set_m_lchannel_idx(::google::protobuf::int32 value) {
  set_has_m_lchannel_idx();
  m_lchannel_idx_ = value;
}

// required sint32 m_lOwnerUSN = 5;
inline bool s_userjoinans::has_m_lownerusn() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void s_userjoinans::set_has_m_lownerusn() {
  _has_bits_[0] |= 0x00000010u;
}
inline void s_userjoinans::clear_has_m_lownerusn() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void s_userjoinans::clear_m_lownerusn() {
  m_lownerusn_ = 0;
  clear_has_m_lownerusn();
}
inline ::google::protobuf::int32 s_userjoinans::m_lownerusn() const {
  return m_lownerusn_;
}
inline void s_userjoinans::set_m_lownerusn(::google::protobuf::int32 value) {
  set_has_m_lownerusn();
  m_lownerusn_ = value;
}

// required sint32 m_lBossUSN = 6;
inline bool s_userjoinans::has_m_lbossusn() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void s_userjoinans::set_has_m_lbossusn() {
  _has_bits_[0] |= 0x00000020u;
}
inline void s_userjoinans::clear_has_m_lbossusn() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void s_userjoinans::clear_m_lbossusn() {
  m_lbossusn_ = 0;
  clear_has_m_lbossusn();
}
inline ::google::protobuf::int32 s_userjoinans::m_lbossusn() const {
  return m_lbossusn_;
}
inline void s_userjoinans::set_m_lbossusn(::google::protobuf::int32 value) {
  set_has_m_lbossusn();
  m_lbossusn_ = value;
}

// required int32 m_nRoomPurgeCnt = 7;
inline bool s_userjoinans::has_m_nroompurgecnt() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void s_userjoinans::set_has_m_nroompurgecnt() {
  _has_bits_[0] |= 0x00000040u;
}
inline void s_userjoinans::clear_has_m_nroompurgecnt() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void s_userjoinans::clear_m_nroompurgecnt() {
  m_nroompurgecnt_ = 0;
  clear_has_m_nroompurgecnt();
}
inline ::google::protobuf::int32 s_userjoinans::m_nroompurgecnt() const {
  return m_nroompurgecnt_;
}
inline void s_userjoinans::set_m_nroompurgecnt(::google::protobuf::int32 value) {
  set_has_m_nroompurgecnt();
  m_nroompurgecnt_ = value;
}

// required .PKOption m_option = 8;
inline bool s_userjoinans::has_m_option() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void s_userjoinans::set_has_m_option() {
  _has_bits_[0] |= 0x00000080u;
}
inline void s_userjoinans::clear_has_m_option() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void s_userjoinans::clear_m_option() {
  if (m_option_ != NULL) m_option_->::PKOption::Clear();
  clear_has_m_option();
}
inline const ::PKOption& s_userjoinans::m_option() const {
  return m_option_ != NULL ? *m_option_ : *default_instance_->m_option_;
}
inline ::PKOption* s_userjoinans::mutable_m_option() {
  set_has_m_option();
  if (m_option_ == NULL) m_option_ = new ::PKOption;
  return m_option_;
}
inline ::PKOption* s_userjoinans::release_m_option() {
  clear_has_m_option();
  ::PKOption* temp = m_option_;
  m_option_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// s_startreq

// -------------------------------------------------------------------

// s_ans_abuse

// -------------------------------------------------------------------

// s_continue_msg

// repeated .PKWinLoseInfo m_vtWinLoseInfo = 1;
inline int s_continue_msg::m_vtwinloseinfo_size() const {
  return m_vtwinloseinfo_.size();
}
inline void s_continue_msg::clear_m_vtwinloseinfo() {
  m_vtwinloseinfo_.Clear();
}
inline const ::PKWinLoseInfo& s_continue_msg::m_vtwinloseinfo(int index) const {
  return m_vtwinloseinfo_.Get(index);
}
inline ::PKWinLoseInfo* s_continue_msg::mutable_m_vtwinloseinfo(int index) {
  return m_vtwinloseinfo_.Mutable(index);
}
inline ::PKWinLoseInfo* s_continue_msg::add_m_vtwinloseinfo() {
  return m_vtwinloseinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PKWinLoseInfo >&
s_continue_msg::m_vtwinloseinfo() const {
  return m_vtwinloseinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::PKWinLoseInfo >*
s_continue_msg::mutable_m_vtwinloseinfo() {
  return &m_vtwinloseinfo_;
}

// -------------------------------------------------------------------

// s_ans_observe

// required sint32 m_lUSN = 1;
inline bool s_ans_observe::has_m_lusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_ans_observe::set_has_m_lusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_ans_observe::clear_has_m_lusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_ans_observe::clear_m_lusn() {
  m_lusn_ = 0;
  clear_has_m_lusn();
}
inline ::google::protobuf::int32 s_ans_observe::m_lusn() const {
  return m_lusn_;
}
inline void s_ans_observe::set_m_lusn(::google::protobuf::int32 value) {
  set_has_m_lusn();
  m_lusn_ = value;
}

// required int32 m_nIndex = 2;
inline bool s_ans_observe::has_m_nindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void s_ans_observe::set_has_m_nindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void s_ans_observe::clear_has_m_nindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void s_ans_observe::clear_m_nindex() {
  m_nindex_ = 0;
  clear_has_m_nindex();
}
inline ::google::protobuf::int32 s_ans_observe::m_nindex() const {
  return m_nindex_;
}
inline void s_ans_observe::set_m_nindex(::google::protobuf::int32 value) {
  set_has_m_nindex();
  m_nindex_ = value;
}

// required sint32 m_lOwnerUSN = 3;
inline bool s_ans_observe::has_m_lownerusn() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void s_ans_observe::set_has_m_lownerusn() {
  _has_bits_[0] |= 0x00000004u;
}
inline void s_ans_observe::clear_has_m_lownerusn() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void s_ans_observe::clear_m_lownerusn() {
  m_lownerusn_ = 0;
  clear_has_m_lownerusn();
}
inline ::google::protobuf::int32 s_ans_observe::m_lownerusn() const {
  return m_lownerusn_;
}
inline void s_ans_observe::set_m_lownerusn(::google::protobuf::int32 value) {
  set_has_m_lownerusn();
  m_lownerusn_ = value;
}

// required .PKUserInfo m_uinfo = 4;
inline bool s_ans_observe::has_m_uinfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void s_ans_observe::set_has_m_uinfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void s_ans_observe::clear_has_m_uinfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void s_ans_observe::clear_m_uinfo() {
  if (m_uinfo_ != NULL) m_uinfo_->::PKUserInfo::Clear();
  clear_has_m_uinfo();
}
inline const ::PKUserInfo& s_ans_observe::m_uinfo() const {
  return m_uinfo_ != NULL ? *m_uinfo_ : *default_instance_->m_uinfo_;
}
inline ::PKUserInfo* s_ans_observe::mutable_m_uinfo() {
  set_has_m_uinfo();
  if (m_uinfo_ == NULL) m_uinfo_ = new ::PKUserInfo;
  return m_uinfo_;
}
inline ::PKUserInfo* s_ans_observe::release_m_uinfo() {
  clear_has_m_uinfo();
  ::PKUserInfo* temp = m_uinfo_;
  m_uinfo_ = NULL;
  return temp;
}

// required .PKMoney m_money = 5;
inline bool s_ans_observe::has_m_money() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void s_ans_observe::set_has_m_money() {
  _has_bits_[0] |= 0x00000010u;
}
inline void s_ans_observe::clear_has_m_money() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void s_ans_observe::clear_m_money() {
  if (m_money_ != NULL) m_money_->::PKMoney::Clear();
  clear_has_m_money();
}
inline const ::PKMoney& s_ans_observe::m_money() const {
  return m_money_ != NULL ? *m_money_ : *default_instance_->m_money_;
}
inline ::PKMoney* s_ans_observe::mutable_m_money() {
  set_has_m_money();
  if (m_money_ == NULL) m_money_ = new ::PKMoney;
  return m_money_;
}
inline ::PKMoney* s_ans_observe::release_m_money() {
  clear_has_m_money();
  ::PKMoney* temp = m_money_;
  m_money_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// s_observercnt

// required int32 m_nObserverCnt = 1;
inline bool s_observercnt::has_m_nobservercnt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_observercnt::set_has_m_nobservercnt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_observercnt::clear_has_m_nobservercnt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_observercnt::clear_m_nobservercnt() {
  m_nobservercnt_ = 0;
  clear_has_m_nobservercnt();
}
inline ::google::protobuf::int32 s_observercnt::m_nobservercnt() const {
  return m_nobservercnt_;
}
inline void s_observercnt::set_m_nobservercnt(::google::protobuf::int32 value) {
  set_has_m_nobservercnt();
  m_nobservercnt_ = value;
}

// -------------------------------------------------------------------

// GLAnsGameProtocol

// required .GLAnsGameProtocol.Type type = 1;
inline bool GLAnsGameProtocol::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameProtocol::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameProtocol::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameProtocol::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::GLAnsGameProtocol_Type GLAnsGameProtocol::type() const {
  return static_cast< ::GLAnsGameProtocol_Type >(type_);
}
inline void GLAnsGameProtocol::set_type(::GLAnsGameProtocol_Type value) {
  GOOGLE_DCHECK(::GLAnsGameProtocol_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .s_ans_game_test_packet m_ans_game_test_packet = 2;
inline bool GLAnsGameProtocol::has_m_ans_game_test_packet() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameProtocol::set_has_m_ans_game_test_packet() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameProtocol::clear_has_m_ans_game_test_packet() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameProtocol::clear_m_ans_game_test_packet() {
  if (m_ans_game_test_packet_ != NULL) m_ans_game_test_packet_->::s_ans_game_test_packet::Clear();
  clear_has_m_ans_game_test_packet();
}
inline const ::s_ans_game_test_packet& GLAnsGameProtocol::m_ans_game_test_packet() const {
  return m_ans_game_test_packet_ != NULL ? *m_ans_game_test_packet_ : *default_instance_->m_ans_game_test_packet_;
}
inline ::s_ans_game_test_packet* GLAnsGameProtocol::mutable_m_ans_game_test_packet() {
  set_has_m_ans_game_test_packet();
  if (m_ans_game_test_packet_ == NULL) m_ans_game_test_packet_ = new ::s_ans_game_test_packet;
  return m_ans_game_test_packet_;
}
inline ::s_ans_game_test_packet* GLAnsGameProtocol::release_m_ans_game_test_packet() {
  clear_has_m_ans_game_test_packet();
  ::s_ans_game_test_packet* temp = m_ans_game_test_packet_;
  m_ans_game_test_packet_ = NULL;
  return temp;
}

// optional .s_ans_join_room m_ans_join_room = 3;
inline bool GLAnsGameProtocol::has_m_ans_join_room() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GLAnsGameProtocol::set_has_m_ans_join_room() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GLAnsGameProtocol::clear_has_m_ans_join_room() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GLAnsGameProtocol::clear_m_ans_join_room() {
  if (m_ans_join_room_ != NULL) m_ans_join_room_->::s_ans_join_room::Clear();
  clear_has_m_ans_join_room();
}
inline const ::s_ans_join_room& GLAnsGameProtocol::m_ans_join_room() const {
  return m_ans_join_room_ != NULL ? *m_ans_join_room_ : *default_instance_->m_ans_join_room_;
}
inline ::s_ans_join_room* GLAnsGameProtocol::mutable_m_ans_join_room() {
  set_has_m_ans_join_room();
  if (m_ans_join_room_ == NULL) m_ans_join_room_ = new ::s_ans_join_room;
  return m_ans_join_room_;
}
inline ::s_ans_join_room* GLAnsGameProtocol::release_m_ans_join_room() {
  clear_has_m_ans_join_room();
  ::s_ans_join_room* temp = m_ans_join_room_;
  m_ans_join_room_ = NULL;
  return temp;
}

// optional .s_ans_deal_card m_ans_deal_card = 4;
inline bool GLAnsGameProtocol::has_m_ans_deal_card() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GLAnsGameProtocol::set_has_m_ans_deal_card() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GLAnsGameProtocol::clear_has_m_ans_deal_card() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GLAnsGameProtocol::clear_m_ans_deal_card() {
  if (m_ans_deal_card_ != NULL) m_ans_deal_card_->::s_ans_deal_card::Clear();
  clear_has_m_ans_deal_card();
}
inline const ::s_ans_deal_card& GLAnsGameProtocol::m_ans_deal_card() const {
  return m_ans_deal_card_ != NULL ? *m_ans_deal_card_ : *default_instance_->m_ans_deal_card_;
}
inline ::s_ans_deal_card* GLAnsGameProtocol::mutable_m_ans_deal_card() {
  set_has_m_ans_deal_card();
  if (m_ans_deal_card_ == NULL) m_ans_deal_card_ = new ::s_ans_deal_card;
  return m_ans_deal_card_;
}
inline ::s_ans_deal_card* GLAnsGameProtocol::release_m_ans_deal_card() {
  clear_has_m_ans_deal_card();
  ::s_ans_deal_card* temp = m_ans_deal_card_;
  m_ans_deal_card_ = NULL;
  return temp;
}

// optional .s_ans_send_ante m_ans_send_ante = 5;
inline bool GLAnsGameProtocol::has_m_ans_send_ante() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GLAnsGameProtocol::set_has_m_ans_send_ante() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GLAnsGameProtocol::clear_has_m_ans_send_ante() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GLAnsGameProtocol::clear_m_ans_send_ante() {
  if (m_ans_send_ante_ != NULL) m_ans_send_ante_->::s_ans_send_ante::Clear();
  clear_has_m_ans_send_ante();
}
inline const ::s_ans_send_ante& GLAnsGameProtocol::m_ans_send_ante() const {
  return m_ans_send_ante_ != NULL ? *m_ans_send_ante_ : *default_instance_->m_ans_send_ante_;
}
inline ::s_ans_send_ante* GLAnsGameProtocol::mutable_m_ans_send_ante() {
  set_has_m_ans_send_ante();
  if (m_ans_send_ante_ == NULL) m_ans_send_ante_ = new ::s_ans_send_ante;
  return m_ans_send_ante_;
}
inline ::s_ans_send_ante* GLAnsGameProtocol::release_m_ans_send_ante() {
  clear_has_m_ans_send_ante();
  ::s_ans_send_ante* temp = m_ans_send_ante_;
  m_ans_send_ante_ = NULL;
  return temp;
}

// optional .s_ans_select_card m_ans_select_card = 6;
inline bool GLAnsGameProtocol::has_m_ans_select_card() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GLAnsGameProtocol::set_has_m_ans_select_card() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GLAnsGameProtocol::clear_has_m_ans_select_card() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GLAnsGameProtocol::clear_m_ans_select_card() {
  if (m_ans_select_card_ != NULL) m_ans_select_card_->::s_ans_select_card::Clear();
  clear_has_m_ans_select_card();
}
inline const ::s_ans_select_card& GLAnsGameProtocol::m_ans_select_card() const {
  return m_ans_select_card_ != NULL ? *m_ans_select_card_ : *default_instance_->m_ans_select_card_;
}
inline ::s_ans_select_card* GLAnsGameProtocol::mutable_m_ans_select_card() {
  set_has_m_ans_select_card();
  if (m_ans_select_card_ == NULL) m_ans_select_card_ = new ::s_ans_select_card;
  return m_ans_select_card_;
}
inline ::s_ans_select_card* GLAnsGameProtocol::release_m_ans_select_card() {
  clear_has_m_ans_select_card();
  ::s_ans_select_card* temp = m_ans_select_card_;
  m_ans_select_card_ = NULL;
  return temp;
}

// optional .s_ans_opencard m_ans_opencard = 7;
inline bool GLAnsGameProtocol::has_m_ans_opencard() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GLAnsGameProtocol::set_has_m_ans_opencard() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GLAnsGameProtocol::clear_has_m_ans_opencard() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GLAnsGameProtocol::clear_m_ans_opencard() {
  if (m_ans_opencard_ != NULL) m_ans_opencard_->::s_ans_opencard::Clear();
  clear_has_m_ans_opencard();
}
inline const ::s_ans_opencard& GLAnsGameProtocol::m_ans_opencard() const {
  return m_ans_opencard_ != NULL ? *m_ans_opencard_ : *default_instance_->m_ans_opencard_;
}
inline ::s_ans_opencard* GLAnsGameProtocol::mutable_m_ans_opencard() {
  set_has_m_ans_opencard();
  if (m_ans_opencard_ == NULL) m_ans_opencard_ = new ::s_ans_opencard;
  return m_ans_opencard_;
}
inline ::s_ans_opencard* GLAnsGameProtocol::release_m_ans_opencard() {
  clear_has_m_ans_opencard();
  ::s_ans_opencard* temp = m_ans_opencard_;
  m_ans_opencard_ = NULL;
  return temp;
}

// optional .s_ans_boss m_ans_boss = 8;
inline bool GLAnsGameProtocol::has_m_ans_boss() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GLAnsGameProtocol::set_has_m_ans_boss() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GLAnsGameProtocol::clear_has_m_ans_boss() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GLAnsGameProtocol::clear_m_ans_boss() {
  if (m_ans_boss_ != NULL) m_ans_boss_->::s_ans_boss::Clear();
  clear_has_m_ans_boss();
}
inline const ::s_ans_boss& GLAnsGameProtocol::m_ans_boss() const {
  return m_ans_boss_ != NULL ? *m_ans_boss_ : *default_instance_->m_ans_boss_;
}
inline ::s_ans_boss* GLAnsGameProtocol::mutable_m_ans_boss() {
  set_has_m_ans_boss();
  if (m_ans_boss_ == NULL) m_ans_boss_ = new ::s_ans_boss;
  return m_ans_boss_;
}
inline ::s_ans_boss* GLAnsGameProtocol::release_m_ans_boss() {
  clear_has_m_ans_boss();
  ::s_ans_boss* temp = m_ans_boss_;
  m_ans_boss_ = NULL;
  return temp;
}

// optional .s_ans_deal_hiddencard m_ans_deal_hiddencard = 9;
inline bool GLAnsGameProtocol::has_m_ans_deal_hiddencard() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GLAnsGameProtocol::set_has_m_ans_deal_hiddencard() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GLAnsGameProtocol::clear_has_m_ans_deal_hiddencard() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GLAnsGameProtocol::clear_m_ans_deal_hiddencard() {
  if (m_ans_deal_hiddencard_ != NULL) m_ans_deal_hiddencard_->::s_ans_deal_hiddencard::Clear();
  clear_has_m_ans_deal_hiddencard();
}
inline const ::s_ans_deal_hiddencard& GLAnsGameProtocol::m_ans_deal_hiddencard() const {
  return m_ans_deal_hiddencard_ != NULL ? *m_ans_deal_hiddencard_ : *default_instance_->m_ans_deal_hiddencard_;
}
inline ::s_ans_deal_hiddencard* GLAnsGameProtocol::mutable_m_ans_deal_hiddencard() {
  set_has_m_ans_deal_hiddencard();
  if (m_ans_deal_hiddencard_ == NULL) m_ans_deal_hiddencard_ = new ::s_ans_deal_hiddencard;
  return m_ans_deal_hiddencard_;
}
inline ::s_ans_deal_hiddencard* GLAnsGameProtocol::release_m_ans_deal_hiddencard() {
  clear_has_m_ans_deal_hiddencard();
  ::s_ans_deal_hiddencard* temp = m_ans_deal_hiddencard_;
  m_ans_deal_hiddencard_ = NULL;
  return temp;
}

// optional .s_ans_betting m_ans_betting = 10;
inline bool GLAnsGameProtocol::has_m_ans_betting() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GLAnsGameProtocol::set_has_m_ans_betting() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GLAnsGameProtocol::clear_has_m_ans_betting() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GLAnsGameProtocol::clear_m_ans_betting() {
  if (m_ans_betting_ != NULL) m_ans_betting_->::s_ans_betting::Clear();
  clear_has_m_ans_betting();
}
inline const ::s_ans_betting& GLAnsGameProtocol::m_ans_betting() const {
  return m_ans_betting_ != NULL ? *m_ans_betting_ : *default_instance_->m_ans_betting_;
}
inline ::s_ans_betting* GLAnsGameProtocol::mutable_m_ans_betting() {
  set_has_m_ans_betting();
  if (m_ans_betting_ == NULL) m_ans_betting_ = new ::s_ans_betting;
  return m_ans_betting_;
}
inline ::s_ans_betting* GLAnsGameProtocol::release_m_ans_betting() {
  clear_has_m_ans_betting();
  ::s_ans_betting* temp = m_ans_betting_;
  m_ans_betting_ = NULL;
  return temp;
}

// optional .s_ans_pong m_ans_pong = 11;
inline bool GLAnsGameProtocol::has_m_ans_pong() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GLAnsGameProtocol::set_has_m_ans_pong() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GLAnsGameProtocol::clear_has_m_ans_pong() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GLAnsGameProtocol::clear_m_ans_pong() {
  if (m_ans_pong_ != NULL) m_ans_pong_->::s_ans_pong::Clear();
  clear_has_m_ans_pong();
}
inline const ::s_ans_pong& GLAnsGameProtocol::m_ans_pong() const {
  return m_ans_pong_ != NULL ? *m_ans_pong_ : *default_instance_->m_ans_pong_;
}
inline ::s_ans_pong* GLAnsGameProtocol::mutable_m_ans_pong() {
  set_has_m_ans_pong();
  if (m_ans_pong_ == NULL) m_ans_pong_ = new ::s_ans_pong;
  return m_ans_pong_;
}
inline ::s_ans_pong* GLAnsGameProtocol::release_m_ans_pong() {
  clear_has_m_ans_pong();
  ::s_ans_pong* temp = m_ans_pong_;
  m_ans_pong_ = NULL;
  return temp;
}

// optional .s_ans_entry m_ans_entry = 12;
inline bool GLAnsGameProtocol::has_m_ans_entry() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GLAnsGameProtocol::set_has_m_ans_entry() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GLAnsGameProtocol::clear_has_m_ans_entry() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GLAnsGameProtocol::clear_m_ans_entry() {
  if (m_ans_entry_ != NULL) m_ans_entry_->::s_ans_entry::Clear();
  clear_has_m_ans_entry();
}
inline const ::s_ans_entry& GLAnsGameProtocol::m_ans_entry() const {
  return m_ans_entry_ != NULL ? *m_ans_entry_ : *default_instance_->m_ans_entry_;
}
inline ::s_ans_entry* GLAnsGameProtocol::mutable_m_ans_entry() {
  set_has_m_ans_entry();
  if (m_ans_entry_ == NULL) m_ans_entry_ = new ::s_ans_entry;
  return m_ans_entry_;
}
inline ::s_ans_entry* GLAnsGameProtocol::release_m_ans_entry() {
  clear_has_m_ans_entry();
  ::s_ans_entry* temp = m_ans_entry_;
  m_ans_entry_ = NULL;
  return temp;
}

// optional .s_ans_deal_cards m_ans_deal_cards = 13;
inline bool GLAnsGameProtocol::has_m_ans_deal_cards() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GLAnsGameProtocol::set_has_m_ans_deal_cards() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GLAnsGameProtocol::clear_has_m_ans_deal_cards() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GLAnsGameProtocol::clear_m_ans_deal_cards() {
  if (m_ans_deal_cards_ != NULL) m_ans_deal_cards_->::s_ans_deal_cards::Clear();
  clear_has_m_ans_deal_cards();
}
inline const ::s_ans_deal_cards& GLAnsGameProtocol::m_ans_deal_cards() const {
  return m_ans_deal_cards_ != NULL ? *m_ans_deal_cards_ : *default_instance_->m_ans_deal_cards_;
}
inline ::s_ans_deal_cards* GLAnsGameProtocol::mutable_m_ans_deal_cards() {
  set_has_m_ans_deal_cards();
  if (m_ans_deal_cards_ == NULL) m_ans_deal_cards_ = new ::s_ans_deal_cards;
  return m_ans_deal_cards_;
}
inline ::s_ans_deal_cards* GLAnsGameProtocol::release_m_ans_deal_cards() {
  clear_has_m_ans_deal_cards();
  ::s_ans_deal_cards* temp = m_ans_deal_cards_;
  m_ans_deal_cards_ = NULL;
  return temp;
}

// optional .s_betting_msg m_betting_msg = 14;
inline bool GLAnsGameProtocol::has_m_betting_msg() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void GLAnsGameProtocol::set_has_m_betting_msg() {
  _has_bits_[0] |= 0x00002000u;
}
inline void GLAnsGameProtocol::clear_has_m_betting_msg() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void GLAnsGameProtocol::clear_m_betting_msg() {
  if (m_betting_msg_ != NULL) m_betting_msg_->::s_betting_msg::Clear();
  clear_has_m_betting_msg();
}
inline const ::s_betting_msg& GLAnsGameProtocol::m_betting_msg() const {
  return m_betting_msg_ != NULL ? *m_betting_msg_ : *default_instance_->m_betting_msg_;
}
inline ::s_betting_msg* GLAnsGameProtocol::mutable_m_betting_msg() {
  set_has_m_betting_msg();
  if (m_betting_msg_ == NULL) m_betting_msg_ = new ::s_betting_msg;
  return m_betting_msg_;
}
inline ::s_betting_msg* GLAnsGameProtocol::release_m_betting_msg() {
  clear_has_m_betting_msg();
  ::s_betting_msg* temp = m_betting_msg_;
  m_betting_msg_ = NULL;
  return temp;
}

// optional .s_finished m_finished = 15;
inline bool GLAnsGameProtocol::has_m_finished() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void GLAnsGameProtocol::set_has_m_finished() {
  _has_bits_[0] |= 0x00004000u;
}
inline void GLAnsGameProtocol::clear_has_m_finished() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void GLAnsGameProtocol::clear_m_finished() {
  if (m_finished_ != NULL) m_finished_->::s_finished::Clear();
  clear_has_m_finished();
}
inline const ::s_finished& GLAnsGameProtocol::m_finished() const {
  return m_finished_ != NULL ? *m_finished_ : *default_instance_->m_finished_;
}
inline ::s_finished* GLAnsGameProtocol::mutable_m_finished() {
  set_has_m_finished();
  if (m_finished_ == NULL) m_finished_ = new ::s_finished;
  return m_finished_;
}
inline ::s_finished* GLAnsGameProtocol::release_m_finished() {
  clear_has_m_finished();
  ::s_finished* temp = m_finished_;
  m_finished_ = NULL;
  return temp;
}

// optional .s_jackpotmoneyntf m_jackpotmoneyntf = 16;
inline bool GLAnsGameProtocol::has_m_jackpotmoneyntf() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void GLAnsGameProtocol::set_has_m_jackpotmoneyntf() {
  _has_bits_[0] |= 0x00008000u;
}
inline void GLAnsGameProtocol::clear_has_m_jackpotmoneyntf() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void GLAnsGameProtocol::clear_m_jackpotmoneyntf() {
  if (m_jackpotmoneyntf_ != NULL) m_jackpotmoneyntf_->::s_jackpotmoneyntf::Clear();
  clear_has_m_jackpotmoneyntf();
}
inline const ::s_jackpotmoneyntf& GLAnsGameProtocol::m_jackpotmoneyntf() const {
  return m_jackpotmoneyntf_ != NULL ? *m_jackpotmoneyntf_ : *default_instance_->m_jackpotmoneyntf_;
}
inline ::s_jackpotmoneyntf* GLAnsGameProtocol::mutable_m_jackpotmoneyntf() {
  set_has_m_jackpotmoneyntf();
  if (m_jackpotmoneyntf_ == NULL) m_jackpotmoneyntf_ = new ::s_jackpotmoneyntf;
  return m_jackpotmoneyntf_;
}
inline ::s_jackpotmoneyntf* GLAnsGameProtocol::release_m_jackpotmoneyntf() {
  clear_has_m_jackpotmoneyntf();
  ::s_jackpotmoneyntf* temp = m_jackpotmoneyntf_;
  m_jackpotmoneyntf_ = NULL;
  return temp;
}

// optional .s_ans_continue m_ans_continue = 17;
inline bool GLAnsGameProtocol::has_m_ans_continue() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void GLAnsGameProtocol::set_has_m_ans_continue() {
  _has_bits_[0] |= 0x00010000u;
}
inline void GLAnsGameProtocol::clear_has_m_ans_continue() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void GLAnsGameProtocol::clear_m_ans_continue() {
  if (m_ans_continue_ != NULL) m_ans_continue_->::s_ans_continue::Clear();
  clear_has_m_ans_continue();
}
inline const ::s_ans_continue& GLAnsGameProtocol::m_ans_continue() const {
  return m_ans_continue_ != NULL ? *m_ans_continue_ : *default_instance_->m_ans_continue_;
}
inline ::s_ans_continue* GLAnsGameProtocol::mutable_m_ans_continue() {
  set_has_m_ans_continue();
  if (m_ans_continue_ == NULL) m_ans_continue_ = new ::s_ans_continue;
  return m_ans_continue_;
}
inline ::s_ans_continue* GLAnsGameProtocol::release_m_ans_continue() {
  clear_has_m_ans_continue();
  ::s_ans_continue* temp = m_ans_continue_;
  m_ans_continue_ = NULL;
  return temp;
}

// optional .s_ans_ruleset m_ans_ruleset = 18;
inline bool GLAnsGameProtocol::has_m_ans_ruleset() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void GLAnsGameProtocol::set_has_m_ans_ruleset() {
  _has_bits_[0] |= 0x00020000u;
}
inline void GLAnsGameProtocol::clear_has_m_ans_ruleset() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void GLAnsGameProtocol::clear_m_ans_ruleset() {
  if (m_ans_ruleset_ != NULL) m_ans_ruleset_->::s_ans_ruleset::Clear();
  clear_has_m_ans_ruleset();
}
inline const ::s_ans_ruleset& GLAnsGameProtocol::m_ans_ruleset() const {
  return m_ans_ruleset_ != NULL ? *m_ans_ruleset_ : *default_instance_->m_ans_ruleset_;
}
inline ::s_ans_ruleset* GLAnsGameProtocol::mutable_m_ans_ruleset() {
  set_has_m_ans_ruleset();
  if (m_ans_ruleset_ == NULL) m_ans_ruleset_ = new ::s_ans_ruleset;
  return m_ans_ruleset_;
}
inline ::s_ans_ruleset* GLAnsGameProtocol::release_m_ans_ruleset() {
  clear_has_m_ans_ruleset();
  ::s_ans_ruleset* temp = m_ans_ruleset_;
  m_ans_ruleset_ = NULL;
  return temp;
}

// optional .s_ans_start m_ans_start = 19;
inline bool GLAnsGameProtocol::has_m_ans_start() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void GLAnsGameProtocol::set_has_m_ans_start() {
  _has_bits_[0] |= 0x00040000u;
}
inline void GLAnsGameProtocol::clear_has_m_ans_start() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void GLAnsGameProtocol::clear_m_ans_start() {
  if (m_ans_start_ != NULL) m_ans_start_->::s_ans_start::Clear();
  clear_has_m_ans_start();
}
inline const ::s_ans_start& GLAnsGameProtocol::m_ans_start() const {
  return m_ans_start_ != NULL ? *m_ans_start_ : *default_instance_->m_ans_start_;
}
inline ::s_ans_start* GLAnsGameProtocol::mutable_m_ans_start() {
  set_has_m_ans_start();
  if (m_ans_start_ == NULL) m_ans_start_ = new ::s_ans_start;
  return m_ans_start_;
}
inline ::s_ans_start* GLAnsGameProtocol::release_m_ans_start() {
  clear_has_m_ans_start();
  ::s_ans_start* temp = m_ans_start_;
  m_ans_start_ = NULL;
  return temp;
}

// optional .s_carddata m_carddata = 20;
inline bool GLAnsGameProtocol::has_m_carddata() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void GLAnsGameProtocol::set_has_m_carddata() {
  _has_bits_[0] |= 0x00080000u;
}
inline void GLAnsGameProtocol::clear_has_m_carddata() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void GLAnsGameProtocol::clear_m_carddata() {
  if (m_carddata_ != NULL) m_carddata_->::s_carddata::Clear();
  clear_has_m_carddata();
}
inline const ::s_carddata& GLAnsGameProtocol::m_carddata() const {
  return m_carddata_ != NULL ? *m_carddata_ : *default_instance_->m_carddata_;
}
inline ::s_carddata* GLAnsGameProtocol::mutable_m_carddata() {
  set_has_m_carddata();
  if (m_carddata_ == NULL) m_carddata_ = new ::s_carddata;
  return m_carddata_;
}
inline ::s_carddata* GLAnsGameProtocol::release_m_carddata() {
  clear_has_m_carddata();
  ::s_carddata* temp = m_carddata_;
  m_carddata_ = NULL;
  return temp;
}

// optional .s_entryreject m_entryreject = 21;
inline bool GLAnsGameProtocol::has_m_entryreject() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void GLAnsGameProtocol::set_has_m_entryreject() {
  _has_bits_[0] |= 0x00100000u;
}
inline void GLAnsGameProtocol::clear_has_m_entryreject() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void GLAnsGameProtocol::clear_m_entryreject() {
  if (m_entryreject_ != NULL) m_entryreject_->::s_entryreject::Clear();
  clear_has_m_entryreject();
}
inline const ::s_entryreject& GLAnsGameProtocol::m_entryreject() const {
  return m_entryreject_ != NULL ? *m_entryreject_ : *default_instance_->m_entryreject_;
}
inline ::s_entryreject* GLAnsGameProtocol::mutable_m_entryreject() {
  set_has_m_entryreject();
  if (m_entryreject_ == NULL) m_entryreject_ = new ::s_entryreject;
  return m_entryreject_;
}
inline ::s_entryreject* GLAnsGameProtocol::release_m_entryreject() {
  clear_has_m_entryreject();
  ::s_entryreject* temp = m_entryreject_;
  m_entryreject_ = NULL;
  return temp;
}

// optional .s_nostart m_nostart = 22;
inline bool GLAnsGameProtocol::has_m_nostart() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void GLAnsGameProtocol::set_has_m_nostart() {
  _has_bits_[0] |= 0x00200000u;
}
inline void GLAnsGameProtocol::clear_has_m_nostart() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void GLAnsGameProtocol::clear_m_nostart() {
  if (m_nostart_ != NULL) m_nostart_->::s_nostart::Clear();
  clear_has_m_nostart();
}
inline const ::s_nostart& GLAnsGameProtocol::m_nostart() const {
  return m_nostart_ != NULL ? *m_nostart_ : *default_instance_->m_nostart_;
}
inline ::s_nostart* GLAnsGameProtocol::mutable_m_nostart() {
  set_has_m_nostart();
  if (m_nostart_ == NULL) m_nostart_ = new ::s_nostart;
  return m_nostart_;
}
inline ::s_nostart* GLAnsGameProtocol::release_m_nostart() {
  clear_has_m_nostart();
  ::s_nostart* temp = m_nostart_;
  m_nostart_ = NULL;
  return temp;
}

// optional .s_newgame m_newgame = 23;
inline bool GLAnsGameProtocol::has_m_newgame() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void GLAnsGameProtocol::set_has_m_newgame() {
  _has_bits_[0] |= 0x00400000u;
}
inline void GLAnsGameProtocol::clear_has_m_newgame() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void GLAnsGameProtocol::clear_m_newgame() {
  if (m_newgame_ != NULL) m_newgame_->::s_newgame::Clear();
  clear_has_m_newgame();
}
inline const ::s_newgame& GLAnsGameProtocol::m_newgame() const {
  return m_newgame_ != NULL ? *m_newgame_ : *default_instance_->m_newgame_;
}
inline ::s_newgame* GLAnsGameProtocol::mutable_m_newgame() {
  set_has_m_newgame();
  if (m_newgame_ == NULL) m_newgame_ = new ::s_newgame;
  return m_newgame_;
}
inline ::s_newgame* GLAnsGameProtocol::release_m_newgame() {
  clear_has_m_newgame();
  ::s_newgame* temp = m_newgame_;
  m_newgame_ = NULL;
  return temp;
}

// optional .s_ans_purge m_ans_purge = 24;
inline bool GLAnsGameProtocol::has_m_ans_purge() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void GLAnsGameProtocol::set_has_m_ans_purge() {
  _has_bits_[0] |= 0x00800000u;
}
inline void GLAnsGameProtocol::clear_has_m_ans_purge() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void GLAnsGameProtocol::clear_m_ans_purge() {
  if (m_ans_purge_ != NULL) m_ans_purge_->::s_ans_purge::Clear();
  clear_has_m_ans_purge();
}
inline const ::s_ans_purge& GLAnsGameProtocol::m_ans_purge() const {
  return m_ans_purge_ != NULL ? *m_ans_purge_ : *default_instance_->m_ans_purge_;
}
inline ::s_ans_purge* GLAnsGameProtocol::mutable_m_ans_purge() {
  set_has_m_ans_purge();
  if (m_ans_purge_ == NULL) m_ans_purge_ = new ::s_ans_purge;
  return m_ans_purge_;
}
inline ::s_ans_purge* GLAnsGameProtocol::release_m_ans_purge() {
  clear_has_m_ans_purge();
  ::s_ans_purge* temp = m_ans_purge_;
  m_ans_purge_ = NULL;
  return temp;
}

// optional .s_purgeinfo m_purgeinfo = 25;
inline bool GLAnsGameProtocol::has_m_purgeinfo() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void GLAnsGameProtocol::set_has_m_purgeinfo() {
  _has_bits_[0] |= 0x01000000u;
}
inline void GLAnsGameProtocol::clear_has_m_purgeinfo() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void GLAnsGameProtocol::clear_m_purgeinfo() {
  if (m_purgeinfo_ != NULL) m_purgeinfo_->::s_purgeinfo::Clear();
  clear_has_m_purgeinfo();
}
inline const ::s_purgeinfo& GLAnsGameProtocol::m_purgeinfo() const {
  return m_purgeinfo_ != NULL ? *m_purgeinfo_ : *default_instance_->m_purgeinfo_;
}
inline ::s_purgeinfo* GLAnsGameProtocol::mutable_m_purgeinfo() {
  set_has_m_purgeinfo();
  if (m_purgeinfo_ == NULL) m_purgeinfo_ = new ::s_purgeinfo;
  return m_purgeinfo_;
}
inline ::s_purgeinfo* GLAnsGameProtocol::release_m_purgeinfo() {
  clear_has_m_purgeinfo();
  ::s_purgeinfo* temp = m_purgeinfo_;
  m_purgeinfo_ = NULL;
  return temp;
}

// optional .s_exitntf m_exitntf = 26;
inline bool GLAnsGameProtocol::has_m_exitntf() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void GLAnsGameProtocol::set_has_m_exitntf() {
  _has_bits_[0] |= 0x02000000u;
}
inline void GLAnsGameProtocol::clear_has_m_exitntf() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void GLAnsGameProtocol::clear_m_exitntf() {
  if (m_exitntf_ != NULL) m_exitntf_->::s_exitntf::Clear();
  clear_has_m_exitntf();
}
inline const ::s_exitntf& GLAnsGameProtocol::m_exitntf() const {
  return m_exitntf_ != NULL ? *m_exitntf_ : *default_instance_->m_exitntf_;
}
inline ::s_exitntf* GLAnsGameProtocol::mutable_m_exitntf() {
  set_has_m_exitntf();
  if (m_exitntf_ == NULL) m_exitntf_ = new ::s_exitntf;
  return m_exitntf_;
}
inline ::s_exitntf* GLAnsGameProtocol::release_m_exitntf() {
  clear_has_m_exitntf();
  ::s_exitntf* temp = m_exitntf_;
  m_exitntf_ = NULL;
  return temp;
}

// optional .s_refillmoneyntf m_refillmoneyntf = 27;
inline bool GLAnsGameProtocol::has_m_refillmoneyntf() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void GLAnsGameProtocol::set_has_m_refillmoneyntf() {
  _has_bits_[0] |= 0x04000000u;
}
inline void GLAnsGameProtocol::clear_has_m_refillmoneyntf() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void GLAnsGameProtocol::clear_m_refillmoneyntf() {
  if (m_refillmoneyntf_ != NULL) m_refillmoneyntf_->::s_refillmoneyntf::Clear();
  clear_has_m_refillmoneyntf();
}
inline const ::s_refillmoneyntf& GLAnsGameProtocol::m_refillmoneyntf() const {
  return m_refillmoneyntf_ != NULL ? *m_refillmoneyntf_ : *default_instance_->m_refillmoneyntf_;
}
inline ::s_refillmoneyntf* GLAnsGameProtocol::mutable_m_refillmoneyntf() {
  set_has_m_refillmoneyntf();
  if (m_refillmoneyntf_ == NULL) m_refillmoneyntf_ = new ::s_refillmoneyntf;
  return m_refillmoneyntf_;
}
inline ::s_refillmoneyntf* GLAnsGameProtocol::release_m_refillmoneyntf() {
  clear_has_m_refillmoneyntf();
  ::s_refillmoneyntf* temp = m_refillmoneyntf_;
  m_refillmoneyntf_ = NULL;
  return temp;
}

// optional .s_bonus m_bonus = 28;
inline bool GLAnsGameProtocol::has_m_bonus() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void GLAnsGameProtocol::set_has_m_bonus() {
  _has_bits_[0] |= 0x08000000u;
}
inline void GLAnsGameProtocol::clear_has_m_bonus() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void GLAnsGameProtocol::clear_m_bonus() {
  if (m_bonus_ != NULL) m_bonus_->::s_bonus::Clear();
  clear_has_m_bonus();
}
inline const ::s_bonus& GLAnsGameProtocol::m_bonus() const {
  return m_bonus_ != NULL ? *m_bonus_ : *default_instance_->m_bonus_;
}
inline ::s_bonus* GLAnsGameProtocol::mutable_m_bonus() {
  set_has_m_bonus();
  if (m_bonus_ == NULL) m_bonus_ = new ::s_bonus;
  return m_bonus_;
}
inline ::s_bonus* GLAnsGameProtocol::release_m_bonus() {
  clear_has_m_bonus();
  ::s_bonus* temp = m_bonus_;
  m_bonus_ = NULL;
  return temp;
}

// optional .s_systemmsg m_systemmsg = 29;
inline bool GLAnsGameProtocol::has_m_systemmsg() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void GLAnsGameProtocol::set_has_m_systemmsg() {
  _has_bits_[0] |= 0x10000000u;
}
inline void GLAnsGameProtocol::clear_has_m_systemmsg() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void GLAnsGameProtocol::clear_m_systemmsg() {
  if (m_systemmsg_ != NULL) m_systemmsg_->::s_systemmsg::Clear();
  clear_has_m_systemmsg();
}
inline const ::s_systemmsg& GLAnsGameProtocol::m_systemmsg() const {
  return m_systemmsg_ != NULL ? *m_systemmsg_ : *default_instance_->m_systemmsg_;
}
inline ::s_systemmsg* GLAnsGameProtocol::mutable_m_systemmsg() {
  set_has_m_systemmsg();
  if (m_systemmsg_ == NULL) m_systemmsg_ = new ::s_systemmsg;
  return m_systemmsg_;
}
inline ::s_systemmsg* GLAnsGameProtocol::release_m_systemmsg() {
  clear_has_m_systemmsg();
  ::s_systemmsg* temp = m_systemmsg_;
  m_systemmsg_ = NULL;
  return temp;
}

// optional .s_userjoinerr m_userjoinerr = 30;
inline bool GLAnsGameProtocol::has_m_userjoinerr() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void GLAnsGameProtocol::set_has_m_userjoinerr() {
  _has_bits_[0] |= 0x20000000u;
}
inline void GLAnsGameProtocol::clear_has_m_userjoinerr() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void GLAnsGameProtocol::clear_m_userjoinerr() {
  if (m_userjoinerr_ != NULL) m_userjoinerr_->::s_userjoinerr::Clear();
  clear_has_m_userjoinerr();
}
inline const ::s_userjoinerr& GLAnsGameProtocol::m_userjoinerr() const {
  return m_userjoinerr_ != NULL ? *m_userjoinerr_ : *default_instance_->m_userjoinerr_;
}
inline ::s_userjoinerr* GLAnsGameProtocol::mutable_m_userjoinerr() {
  set_has_m_userjoinerr();
  if (m_userjoinerr_ == NULL) m_userjoinerr_ = new ::s_userjoinerr;
  return m_userjoinerr_;
}
inline ::s_userjoinerr* GLAnsGameProtocol::release_m_userjoinerr() {
  clear_has_m_userjoinerr();
  ::s_userjoinerr* temp = m_userjoinerr_;
  m_userjoinerr_ = NULL;
  return temp;
}

// optional .s_userdisconnect m_userdisconnect = 31;
inline bool GLAnsGameProtocol::has_m_userdisconnect() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void GLAnsGameProtocol::set_has_m_userdisconnect() {
  _has_bits_[0] |= 0x40000000u;
}
inline void GLAnsGameProtocol::clear_has_m_userdisconnect() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void GLAnsGameProtocol::clear_m_userdisconnect() {
  if (m_userdisconnect_ != NULL) m_userdisconnect_->::s_userdisconnect::Clear();
  clear_has_m_userdisconnect();
}
inline const ::s_userdisconnect& GLAnsGameProtocol::m_userdisconnect() const {
  return m_userdisconnect_ != NULL ? *m_userdisconnect_ : *default_instance_->m_userdisconnect_;
}
inline ::s_userdisconnect* GLAnsGameProtocol::mutable_m_userdisconnect() {
  set_has_m_userdisconnect();
  if (m_userdisconnect_ == NULL) m_userdisconnect_ = new ::s_userdisconnect;
  return m_userdisconnect_;
}
inline ::s_userdisconnect* GLAnsGameProtocol::release_m_userdisconnect() {
  clear_has_m_userdisconnect();
  ::s_userdisconnect* temp = m_userdisconnect_;
  m_userdisconnect_ = NULL;
  return temp;
}

// optional .s_soundtypeans m_soundtypeans = 32;
inline bool GLAnsGameProtocol::has_m_soundtypeans() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void GLAnsGameProtocol::set_has_m_soundtypeans() {
  _has_bits_[0] |= 0x80000000u;
}
inline void GLAnsGameProtocol::clear_has_m_soundtypeans() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void GLAnsGameProtocol::clear_m_soundtypeans() {
  if (m_soundtypeans_ != NULL) m_soundtypeans_->::s_soundtypeans::Clear();
  clear_has_m_soundtypeans();
}
inline const ::s_soundtypeans& GLAnsGameProtocol::m_soundtypeans() const {
  return m_soundtypeans_ != NULL ? *m_soundtypeans_ : *default_instance_->m_soundtypeans_;
}
inline ::s_soundtypeans* GLAnsGameProtocol::mutable_m_soundtypeans() {
  set_has_m_soundtypeans();
  if (m_soundtypeans_ == NULL) m_soundtypeans_ = new ::s_soundtypeans;
  return m_soundtypeans_;
}
inline ::s_soundtypeans* GLAnsGameProtocol::release_m_soundtypeans() {
  clear_has_m_soundtypeans();
  ::s_soundtypeans* temp = m_soundtypeans_;
  m_soundtypeans_ = NULL;
  return temp;
}

// optional .s_userjoinans m_userjoinans = 33;
inline bool GLAnsGameProtocol::has_m_userjoinans() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void GLAnsGameProtocol::set_has_m_userjoinans() {
  _has_bits_[1] |= 0x00000001u;
}
inline void GLAnsGameProtocol::clear_has_m_userjoinans() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void GLAnsGameProtocol::clear_m_userjoinans() {
  if (m_userjoinans_ != NULL) m_userjoinans_->::s_userjoinans::Clear();
  clear_has_m_userjoinans();
}
inline const ::s_userjoinans& GLAnsGameProtocol::m_userjoinans() const {
  return m_userjoinans_ != NULL ? *m_userjoinans_ : *default_instance_->m_userjoinans_;
}
inline ::s_userjoinans* GLAnsGameProtocol::mutable_m_userjoinans() {
  set_has_m_userjoinans();
  if (m_userjoinans_ == NULL) m_userjoinans_ = new ::s_userjoinans;
  return m_userjoinans_;
}
inline ::s_userjoinans* GLAnsGameProtocol::release_m_userjoinans() {
  clear_has_m_userjoinans();
  ::s_userjoinans* temp = m_userjoinans_;
  m_userjoinans_ = NULL;
  return temp;
}

// optional .s_startreq m_startreq = 34;
inline bool GLAnsGameProtocol::has_m_startreq() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void GLAnsGameProtocol::set_has_m_startreq() {
  _has_bits_[1] |= 0x00000002u;
}
inline void GLAnsGameProtocol::clear_has_m_startreq() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void GLAnsGameProtocol::clear_m_startreq() {
  if (m_startreq_ != NULL) m_startreq_->::s_startreq::Clear();
  clear_has_m_startreq();
}
inline const ::s_startreq& GLAnsGameProtocol::m_startreq() const {
  return m_startreq_ != NULL ? *m_startreq_ : *default_instance_->m_startreq_;
}
inline ::s_startreq* GLAnsGameProtocol::mutable_m_startreq() {
  set_has_m_startreq();
  if (m_startreq_ == NULL) m_startreq_ = new ::s_startreq;
  return m_startreq_;
}
inline ::s_startreq* GLAnsGameProtocol::release_m_startreq() {
  clear_has_m_startreq();
  ::s_startreq* temp = m_startreq_;
  m_startreq_ = NULL;
  return temp;
}

// optional .s_ans_abuse m_ans_abuse = 35;
inline bool GLAnsGameProtocol::has_m_ans_abuse() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void GLAnsGameProtocol::set_has_m_ans_abuse() {
  _has_bits_[1] |= 0x00000004u;
}
inline void GLAnsGameProtocol::clear_has_m_ans_abuse() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void GLAnsGameProtocol::clear_m_ans_abuse() {
  if (m_ans_abuse_ != NULL) m_ans_abuse_->::s_ans_abuse::Clear();
  clear_has_m_ans_abuse();
}
inline const ::s_ans_abuse& GLAnsGameProtocol::m_ans_abuse() const {
  return m_ans_abuse_ != NULL ? *m_ans_abuse_ : *default_instance_->m_ans_abuse_;
}
inline ::s_ans_abuse* GLAnsGameProtocol::mutable_m_ans_abuse() {
  set_has_m_ans_abuse();
  if (m_ans_abuse_ == NULL) m_ans_abuse_ = new ::s_ans_abuse;
  return m_ans_abuse_;
}
inline ::s_ans_abuse* GLAnsGameProtocol::release_m_ans_abuse() {
  clear_has_m_ans_abuse();
  ::s_ans_abuse* temp = m_ans_abuse_;
  m_ans_abuse_ = NULL;
  return temp;
}

// optional .s_continue_msg m_continue_msg = 36;
inline bool GLAnsGameProtocol::has_m_continue_msg() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void GLAnsGameProtocol::set_has_m_continue_msg() {
  _has_bits_[1] |= 0x00000008u;
}
inline void GLAnsGameProtocol::clear_has_m_continue_msg() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void GLAnsGameProtocol::clear_m_continue_msg() {
  if (m_continue_msg_ != NULL) m_continue_msg_->::s_continue_msg::Clear();
  clear_has_m_continue_msg();
}
inline const ::s_continue_msg& GLAnsGameProtocol::m_continue_msg() const {
  return m_continue_msg_ != NULL ? *m_continue_msg_ : *default_instance_->m_continue_msg_;
}
inline ::s_continue_msg* GLAnsGameProtocol::mutable_m_continue_msg() {
  set_has_m_continue_msg();
  if (m_continue_msg_ == NULL) m_continue_msg_ = new ::s_continue_msg;
  return m_continue_msg_;
}
inline ::s_continue_msg* GLAnsGameProtocol::release_m_continue_msg() {
  clear_has_m_continue_msg();
  ::s_continue_msg* temp = m_continue_msg_;
  m_continue_msg_ = NULL;
  return temp;
}

// optional .s_ans_observe m_ans_observe = 37;
inline bool GLAnsGameProtocol::has_m_ans_observe() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void GLAnsGameProtocol::set_has_m_ans_observe() {
  _has_bits_[1] |= 0x00000010u;
}
inline void GLAnsGameProtocol::clear_has_m_ans_observe() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void GLAnsGameProtocol::clear_m_ans_observe() {
  if (m_ans_observe_ != NULL) m_ans_observe_->::s_ans_observe::Clear();
  clear_has_m_ans_observe();
}
inline const ::s_ans_observe& GLAnsGameProtocol::m_ans_observe() const {
  return m_ans_observe_ != NULL ? *m_ans_observe_ : *default_instance_->m_ans_observe_;
}
inline ::s_ans_observe* GLAnsGameProtocol::mutable_m_ans_observe() {
  set_has_m_ans_observe();
  if (m_ans_observe_ == NULL) m_ans_observe_ = new ::s_ans_observe;
  return m_ans_observe_;
}
inline ::s_ans_observe* GLAnsGameProtocol::release_m_ans_observe() {
  clear_has_m_ans_observe();
  ::s_ans_observe* temp = m_ans_observe_;
  m_ans_observe_ = NULL;
  return temp;
}

// optional .s_observercnt m_observercnt = 38;
inline bool GLAnsGameProtocol::has_m_observercnt() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void GLAnsGameProtocol::set_has_m_observercnt() {
  _has_bits_[1] |= 0x00000020u;
}
inline void GLAnsGameProtocol::clear_has_m_observercnt() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void GLAnsGameProtocol::clear_m_observercnt() {
  if (m_observercnt_ != NULL) m_observercnt_->::s_observercnt::Clear();
  clear_has_m_observercnt();
}
inline const ::s_observercnt& GLAnsGameProtocol::m_observercnt() const {
  return m_observercnt_ != NULL ? *m_observercnt_ : *default_instance_->m_observercnt_;
}
inline ::s_observercnt* GLAnsGameProtocol::mutable_m_observercnt() {
  set_has_m_observercnt();
  if (m_observercnt_ == NULL) m_observercnt_ = new ::s_observercnt;
  return m_observercnt_;
}
inline ::s_observercnt* GLAnsGameProtocol::release_m_observercnt() {
  clear_has_m_observercnt();
  ::s_observercnt* temp = m_observercnt_;
  m_observercnt_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// PKCards

// repeated int32 m_vtCards = 1;
inline int PKCards::m_vtcards_size() const {
  return m_vtcards_.size();
}
inline void PKCards::clear_m_vtcards() {
  m_vtcards_.Clear();
}
inline ::google::protobuf::int32 PKCards::m_vtcards(int index) const {
  return m_vtcards_.Get(index);
}
inline void PKCards::set_m_vtcards(int index, ::google::protobuf::int32 value) {
  m_vtcards_.Set(index, value);
}
inline void PKCards::add_m_vtcards(::google::protobuf::int32 value) {
  m_vtcards_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PKCards::m_vtcards() const {
  return m_vtcards_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PKCards::mutable_m_vtcards() {
  return &m_vtcards_;
}

// required int32 m_lResultIdx = 2;
inline bool PKCards::has_m_lresultidx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKCards::set_has_m_lresultidx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKCards::clear_has_m_lresultidx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKCards::clear_m_lresultidx() {
  m_lresultidx_ = 0;
  clear_has_m_lresultidx();
}
inline ::google::protobuf::int32 PKCards::m_lresultidx() const {
  return m_lresultidx_;
}
inline void PKCards::set_m_lresultidx(::google::protobuf::int32 value) {
  set_has_m_lresultidx();
  m_lresultidx_ = value;
}

// repeated .PKVecUSN m_vUserUSN = 3;
inline int PKCards::m_vuserusn_size() const {
  return m_vuserusn_.size();
}
inline void PKCards::clear_m_vuserusn() {
  m_vuserusn_.Clear();
}
inline const ::PKVecUSN& PKCards::m_vuserusn(int index) const {
  return m_vuserusn_.Get(index);
}
inline ::PKVecUSN* PKCards::mutable_m_vuserusn(int index) {
  return m_vuserusn_.Mutable(index);
}
inline ::PKVecUSN* PKCards::add_m_vuserusn() {
  return m_vuserusn_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PKVecUSN >&
PKCards::m_vuserusn() const {
  return m_vuserusn_;
}
inline ::google::protobuf::RepeatedPtrField< ::PKVecUSN >*
PKCards::mutable_m_vuserusn() {
  return &m_vuserusn_;
}

// -------------------------------------------------------------------

// PKMoney

// required sint64 m_llCMoney = 1;
inline bool PKMoney::has_m_llcmoney() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMoney::set_has_m_llcmoney() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMoney::clear_has_m_llcmoney() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMoney::clear_m_llcmoney() {
  m_llcmoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_llcmoney();
}
inline ::google::protobuf::int64 PKMoney::m_llcmoney() const {
  return m_llcmoney_;
}
inline void PKMoney::set_m_llcmoney(::google::protobuf::int64 value) {
  set_has_m_llcmoney();
  m_llcmoney_ = value;
}

// required sint64 m_llCallMoney = 2;
inline bool PKMoney::has_m_llcallmoney() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKMoney::set_has_m_llcallmoney() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKMoney::clear_has_m_llcallmoney() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKMoney::clear_m_llcallmoney() {
  m_llcallmoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_llcallmoney();
}
inline ::google::protobuf::int64 PKMoney::m_llcallmoney() const {
  return m_llcallmoney_;
}
inline void PKMoney::set_m_llcallmoney(::google::protobuf::int64 value) {
  set_has_m_llcallmoney();
  m_llcallmoney_ = value;
}

// required sint64 m_llSideMoney = 3;
inline bool PKMoney::has_m_llsidemoney() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PKMoney::set_has_m_llsidemoney() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PKMoney::clear_has_m_llsidemoney() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PKMoney::clear_m_llsidemoney() {
  m_llsidemoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_llsidemoney();
}
inline ::google::protobuf::int64 PKMoney::m_llsidemoney() const {
  return m_llsidemoney_;
}
inline void PKMoney::set_m_llsidemoney(::google::protobuf::int64 value) {
  set_has_m_llsidemoney();
  m_llsidemoney_ = value;
}

// required sint64 m_llCallHabMoney = 4;
inline bool PKMoney::has_m_llcallhabmoney() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PKMoney::set_has_m_llcallhabmoney() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PKMoney::clear_has_m_llcallhabmoney() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PKMoney::clear_m_llcallhabmoney() {
  m_llcallhabmoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_llcallhabmoney();
}
inline ::google::protobuf::int64 PKMoney::m_llcallhabmoney() const {
  return m_llcallhabmoney_;
}
inline void PKMoney::set_m_llcallhabmoney(::google::protobuf::int64 value) {
  set_has_m_llcallhabmoney();
  m_llcallhabmoney_ = value;
}

// required sint64 m_llTakeMoney = 5;
inline bool PKMoney::has_m_lltakemoney() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PKMoney::set_has_m_lltakemoney() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PKMoney::clear_has_m_lltakemoney() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PKMoney::clear_m_lltakemoney() {
  m_lltakemoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_lltakemoney();
}
inline ::google::protobuf::int64 PKMoney::m_lltakemoney() const {
  return m_lltakemoney_;
}
inline void PKMoney::set_m_lltakemoney(::google::protobuf::int64 value) {
  set_has_m_lltakemoney();
  m_lltakemoney_ = value;
}

// required sint64 m_llJackpotMoney = 6;
inline bool PKMoney::has_m_lljackpotmoney() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PKMoney::set_has_m_lljackpotmoney() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PKMoney::clear_has_m_lljackpotmoney() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PKMoney::clear_m_lljackpotmoney() {
  m_lljackpotmoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_lljackpotmoney();
}
inline ::google::protobuf::int64 PKMoney::m_lljackpotmoney() const {
  return m_lljackpotmoney_;
}
inline void PKMoney::set_m_lljackpotmoney(::google::protobuf::int64 value) {
  set_has_m_lljackpotmoney();
  m_lljackpotmoney_ = value;
}

// required sint32 m_lBetState = 7;
inline bool PKMoney::has_m_lbetstate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PKMoney::set_has_m_lbetstate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PKMoney::clear_has_m_lbetstate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PKMoney::clear_m_lbetstate() {
  m_lbetstate_ = 0;
  clear_has_m_lbetstate();
}
inline ::google::protobuf::int32 PKMoney::m_lbetstate() const {
  return m_lbetstate_;
}
inline void PKMoney::set_m_lbetstate(::google::protobuf::int32 value) {
  set_has_m_lbetstate();
  m_lbetstate_ = value;
}

// required sint32 m_lBetReceive = 8;
inline bool PKMoney::has_m_lbetreceive() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PKMoney::set_has_m_lbetreceive() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PKMoney::clear_has_m_lbetreceive() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PKMoney::clear_m_lbetreceive() {
  m_lbetreceive_ = 0;
  clear_has_m_lbetreceive();
}
inline ::google::protobuf::int32 PKMoney::m_lbetreceive() const {
  return m_lbetreceive_;
}
inline void PKMoney::set_m_lbetreceive(::google::protobuf::int32 value) {
  set_has_m_lbetreceive();
  m_lbetreceive_ = value;
}

// required sint32 m_lBetCount = 9;
inline bool PKMoney::has_m_lbetcount() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PKMoney::set_has_m_lbetcount() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PKMoney::clear_has_m_lbetcount() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PKMoney::clear_m_lbetcount() {
  m_lbetcount_ = 0;
  clear_has_m_lbetcount();
}
inline ::google::protobuf::int32 PKMoney::m_lbetcount() const {
  return m_lbetcount_;
}
inline void PKMoney::set_m_lbetcount(::google::protobuf::int32 value) {
  set_has_m_lbetcount();
  m_lbetcount_ = value;
}

// required sint32 m_lResultIdx = 10;
inline bool PKMoney::has_m_lresultidx() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PKMoney::set_has_m_lresultidx() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PKMoney::clear_has_m_lresultidx() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PKMoney::clear_m_lresultidx() {
  m_lresultidx_ = 0;
  clear_has_m_lresultidx();
}
inline ::google::protobuf::int32 PKMoney::m_lresultidx() const {
  return m_lresultidx_;
}
inline void PKMoney::set_m_lresultidx(::google::protobuf::int32 value) {
  set_has_m_lresultidx();
  m_lresultidx_ = value;
}

// required string m_sMoneyMsg = 11;
inline bool PKMoney::has_m_smoneymsg() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PKMoney::set_has_m_smoneymsg() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PKMoney::clear_has_m_smoneymsg() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PKMoney::clear_m_smoneymsg() {
  if (m_smoneymsg_ != &::google::protobuf::internal::kEmptyString) {
    m_smoneymsg_->clear();
  }
  clear_has_m_smoneymsg();
}
inline const ::std::string& PKMoney::m_smoneymsg() const {
  return *m_smoneymsg_;
}
inline void PKMoney::set_m_smoneymsg(const ::std::string& value) {
  set_has_m_smoneymsg();
  if (m_smoneymsg_ == &::google::protobuf::internal::kEmptyString) {
    m_smoneymsg_ = new ::std::string;
  }
  m_smoneymsg_->assign(value);
}
inline void PKMoney::set_m_smoneymsg(const char* value) {
  set_has_m_smoneymsg();
  if (m_smoneymsg_ == &::google::protobuf::internal::kEmptyString) {
    m_smoneymsg_ = new ::std::string;
  }
  m_smoneymsg_->assign(value);
}
inline void PKMoney::set_m_smoneymsg(const char* value, size_t size) {
  set_has_m_smoneymsg();
  if (m_smoneymsg_ == &::google::protobuf::internal::kEmptyString) {
    m_smoneymsg_ = new ::std::string;
  }
  m_smoneymsg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PKMoney::mutable_m_smoneymsg() {
  set_has_m_smoneymsg();
  if (m_smoneymsg_ == &::google::protobuf::internal::kEmptyString) {
    m_smoneymsg_ = new ::std::string;
  }
  return m_smoneymsg_;
}
inline ::std::string* PKMoney::release_m_smoneymsg() {
  clear_has_m_smoneymsg();
  if (m_smoneymsg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_smoneymsg_;
    m_smoneymsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// UserMoney

// required sint32 m_lUSN = 1;
inline bool UserMoney::has_m_lusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserMoney::set_has_m_lusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserMoney::clear_has_m_lusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserMoney::clear_m_lusn() {
  m_lusn_ = 0;
  clear_has_m_lusn();
}
inline ::google::protobuf::int32 UserMoney::m_lusn() const {
  return m_lusn_;
}
inline void UserMoney::set_m_lusn(::google::protobuf::int32 value) {
  set_has_m_lusn();
  m_lusn_ = value;
}

// required sint32 m_lState = 2;
inline bool UserMoney::has_m_lstate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserMoney::set_has_m_lstate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserMoney::clear_has_m_lstate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserMoney::clear_m_lstate() {
  m_lstate_ = 0;
  clear_has_m_lstate();
}
inline ::google::protobuf::int32 UserMoney::m_lstate() const {
  return m_lstate_;
}
inline void UserMoney::set_m_lstate(::google::protobuf::int32 value) {
  set_has_m_lstate();
  m_lstate_ = value;
}

// required sint64 m_llMoney = 3;
inline bool UserMoney::has_m_llmoney() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserMoney::set_has_m_llmoney() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserMoney::clear_has_m_llmoney() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserMoney::clear_m_llmoney() {
  m_llmoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_llmoney();
}
inline ::google::protobuf::int64 UserMoney::m_llmoney() const {
  return m_llmoney_;
}
inline void UserMoney::set_m_llmoney(::google::protobuf::int64 value) {
  set_has_m_llmoney();
  m_llmoney_ = value;
}

// required sint64 m_llCallHabMoney = 4;
inline bool UserMoney::has_m_llcallhabmoney() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserMoney::set_has_m_llcallhabmoney() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserMoney::clear_has_m_llcallhabmoney() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserMoney::clear_m_llcallhabmoney() {
  m_llcallhabmoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_llcallhabmoney();
}
inline ::google::protobuf::int64 UserMoney::m_llcallhabmoney() const {
  return m_llcallhabmoney_;
}
inline void UserMoney::set_m_llcallhabmoney(::google::protobuf::int64 value) {
  set_has_m_llcallhabmoney();
  m_llcallhabmoney_ = value;
}

// required sint64 m_llTakeMoney = 5;
inline bool UserMoney::has_m_lltakemoney() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserMoney::set_has_m_lltakemoney() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserMoney::clear_has_m_lltakemoney() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserMoney::clear_m_lltakemoney() {
  m_lltakemoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_lltakemoney();
}
inline ::google::protobuf::int64 UserMoney::m_lltakemoney() const {
  return m_lltakemoney_;
}
inline void UserMoney::set_m_lltakemoney(::google::protobuf::int64 value) {
  set_has_m_lltakemoney();
  m_lltakemoney_ = value;
}

// required sint64 m_llDealMoney = 6;
inline bool UserMoney::has_m_lldealmoney() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserMoney::set_has_m_lldealmoney() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserMoney::clear_has_m_lldealmoney() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserMoney::clear_m_lldealmoney() {
  m_lldealmoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_lldealmoney();
}
inline ::google::protobuf::int64 UserMoney::m_lldealmoney() const {
  return m_lldealmoney_;
}
inline void UserMoney::set_m_lldealmoney(::google::protobuf::int64 value) {
  set_has_m_lldealmoney();
  m_lldealmoney_ = value;
}

// required string m_sNickName = 7;
inline bool UserMoney::has_m_snickname() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserMoney::set_has_m_snickname() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserMoney::clear_has_m_snickname() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserMoney::clear_m_snickname() {
  if (m_snickname_ != &::google::protobuf::internal::kEmptyString) {
    m_snickname_->clear();
  }
  clear_has_m_snickname();
}
inline const ::std::string& UserMoney::m_snickname() const {
  return *m_snickname_;
}
inline void UserMoney::set_m_snickname(const ::std::string& value) {
  set_has_m_snickname();
  if (m_snickname_ == &::google::protobuf::internal::kEmptyString) {
    m_snickname_ = new ::std::string;
  }
  m_snickname_->assign(value);
}
inline void UserMoney::set_m_snickname(const char* value) {
  set_has_m_snickname();
  if (m_snickname_ == &::google::protobuf::internal::kEmptyString) {
    m_snickname_ = new ::std::string;
  }
  m_snickname_->assign(value);
}
inline void UserMoney::set_m_snickname(const char* value, size_t size) {
  set_has_m_snickname();
  if (m_snickname_ == &::google::protobuf::internal::kEmptyString) {
    m_snickname_ = new ::std::string;
  }
  m_snickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserMoney::mutable_m_snickname() {
  set_has_m_snickname();
  if (m_snickname_ == &::google::protobuf::internal::kEmptyString) {
    m_snickname_ = new ::std::string;
  }
  return m_snickname_;
}
inline ::std::string* UserMoney::release_m_snickname() {
  clear_has_m_snickname();
  if (m_snickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_snickname_;
    m_snickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string m_sDealerTax = 8;
inline bool UserMoney::has_m_sdealertax() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserMoney::set_has_m_sdealertax() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserMoney::clear_has_m_sdealertax() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserMoney::clear_m_sdealertax() {
  if (m_sdealertax_ != &::google::protobuf::internal::kEmptyString) {
    m_sdealertax_->clear();
  }
  clear_has_m_sdealertax();
}
inline const ::std::string& UserMoney::m_sdealertax() const {
  return *m_sdealertax_;
}
inline void UserMoney::set_m_sdealertax(const ::std::string& value) {
  set_has_m_sdealertax();
  if (m_sdealertax_ == &::google::protobuf::internal::kEmptyString) {
    m_sdealertax_ = new ::std::string;
  }
  m_sdealertax_->assign(value);
}
inline void UserMoney::set_m_sdealertax(const char* value) {
  set_has_m_sdealertax();
  if (m_sdealertax_ == &::google::protobuf::internal::kEmptyString) {
    m_sdealertax_ = new ::std::string;
  }
  m_sdealertax_->assign(value);
}
inline void UserMoney::set_m_sdealertax(const char* value, size_t size) {
  set_has_m_sdealertax();
  if (m_sdealertax_ == &::google::protobuf::internal::kEmptyString) {
    m_sdealertax_ = new ::std::string;
  }
  m_sdealertax_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserMoney::mutable_m_sdealertax() {
  set_has_m_sdealertax();
  if (m_sdealertax_ == &::google::protobuf::internal::kEmptyString) {
    m_sdealertax_ = new ::std::string;
  }
  return m_sdealertax_;
}
inline ::std::string* UserMoney::release_m_sdealertax() {
  clear_has_m_sdealertax();
  if (m_sdealertax_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_sdealertax_;
    m_sdealertax_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// PKCWinLose

// required sint32 m_lWin = 1;
inline bool PKCWinLose::has_m_lwin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKCWinLose::set_has_m_lwin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKCWinLose::clear_has_m_lwin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKCWinLose::clear_m_lwin() {
  m_lwin_ = 0;
  clear_has_m_lwin();
}
inline ::google::protobuf::int32 PKCWinLose::m_lwin() const {
  return m_lwin_;
}
inline void PKCWinLose::set_m_lwin(::google::protobuf::int32 value) {
  set_has_m_lwin();
  m_lwin_ = value;
}

// required sint32 m_lLose = 2;
inline bool PKCWinLose::has_m_llose() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKCWinLose::set_has_m_llose() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKCWinLose::clear_has_m_llose() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKCWinLose::clear_m_llose() {
  m_llose_ = 0;
  clear_has_m_llose();
}
inline ::google::protobuf::int32 PKCWinLose::m_llose() const {
  return m_llose_;
}
inline void PKCWinLose::set_m_llose(::google::protobuf::int32 value) {
  set_has_m_llose();
  m_llose_ = value;
}

// required sint32 m_lContinue = 3;
inline bool PKCWinLose::has_m_lcontinue() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PKCWinLose::set_has_m_lcontinue() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PKCWinLose::clear_has_m_lcontinue() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PKCWinLose::clear_m_lcontinue() {
  m_lcontinue_ = 0;
  clear_has_m_lcontinue();
}
inline ::google::protobuf::int32 PKCWinLose::m_lcontinue() const {
  return m_lcontinue_;
}
inline void PKCWinLose::set_m_lcontinue(::google::protobuf::int32 value) {
  set_has_m_lcontinue();
  m_lcontinue_ = value;
}

// -------------------------------------------------------------------

// PKUserInfo

// required sint32 m_lUSN = 1;
inline bool PKUserInfo::has_m_lusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKUserInfo::set_has_m_lusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKUserInfo::clear_has_m_lusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKUserInfo::clear_m_lusn() {
  m_lusn_ = 0;
  clear_has_m_lusn();
}
inline ::google::protobuf::int32 PKUserInfo::m_lusn() const {
  return m_lusn_;
}
inline void PKUserInfo::set_m_lusn(::google::protobuf::int32 value) {
  set_has_m_lusn();
  m_lusn_ = value;
}

// required sint32 m_nIndex = 2;
inline bool PKUserInfo::has_m_nindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKUserInfo::set_has_m_nindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKUserInfo::clear_has_m_nindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKUserInfo::clear_m_nindex() {
  m_nindex_ = 0;
  clear_has_m_nindex();
}
inline ::google::protobuf::int32 PKUserInfo::m_nindex() const {
  return m_nindex_;
}
inline void PKUserInfo::set_m_nindex(::google::protobuf::int32 value) {
  set_has_m_nindex();
  m_nindex_ = value;
}

// required string m_sNickName = 3;
inline bool PKUserInfo::has_m_snickname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PKUserInfo::set_has_m_snickname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PKUserInfo::clear_has_m_snickname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PKUserInfo::clear_m_snickname() {
  if (m_snickname_ != &::google::protobuf::internal::kEmptyString) {
    m_snickname_->clear();
  }
  clear_has_m_snickname();
}
inline const ::std::string& PKUserInfo::m_snickname() const {
  return *m_snickname_;
}
inline void PKUserInfo::set_m_snickname(const ::std::string& value) {
  set_has_m_snickname();
  if (m_snickname_ == &::google::protobuf::internal::kEmptyString) {
    m_snickname_ = new ::std::string;
  }
  m_snickname_->assign(value);
}
inline void PKUserInfo::set_m_snickname(const char* value) {
  set_has_m_snickname();
  if (m_snickname_ == &::google::protobuf::internal::kEmptyString) {
    m_snickname_ = new ::std::string;
  }
  m_snickname_->assign(value);
}
inline void PKUserInfo::set_m_snickname(const char* value, size_t size) {
  set_has_m_snickname();
  if (m_snickname_ == &::google::protobuf::internal::kEmptyString) {
    m_snickname_ = new ::std::string;
  }
  m_snickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PKUserInfo::mutable_m_snickname() {
  set_has_m_snickname();
  if (m_snickname_ == &::google::protobuf::internal::kEmptyString) {
    m_snickname_ = new ::std::string;
  }
  return m_snickname_;
}
inline ::std::string* PKUserInfo::release_m_snickname() {
  clear_has_m_snickname();
  if (m_snickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_snickname_;
    m_snickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string m_sID = 4;
inline bool PKUserInfo::has_m_sid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PKUserInfo::set_has_m_sid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PKUserInfo::clear_has_m_sid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PKUserInfo::clear_m_sid() {
  if (m_sid_ != &::google::protobuf::internal::kEmptyString) {
    m_sid_->clear();
  }
  clear_has_m_sid();
}
inline const ::std::string& PKUserInfo::m_sid() const {
  return *m_sid_;
}
inline void PKUserInfo::set_m_sid(const ::std::string& value) {
  set_has_m_sid();
  if (m_sid_ == &::google::protobuf::internal::kEmptyString) {
    m_sid_ = new ::std::string;
  }
  m_sid_->assign(value);
}
inline void PKUserInfo::set_m_sid(const char* value) {
  set_has_m_sid();
  if (m_sid_ == &::google::protobuf::internal::kEmptyString) {
    m_sid_ = new ::std::string;
  }
  m_sid_->assign(value);
}
inline void PKUserInfo::set_m_sid(const char* value, size_t size) {
  set_has_m_sid();
  if (m_sid_ == &::google::protobuf::internal::kEmptyString) {
    m_sid_ = new ::std::string;
  }
  m_sid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PKUserInfo::mutable_m_sid() {
  set_has_m_sid();
  if (m_sid_ == &::google::protobuf::internal::kEmptyString) {
    m_sid_ = new ::std::string;
  }
  return m_sid_;
}
inline ::std::string* PKUserInfo::release_m_sid() {
  clear_has_m_sid();
  if (m_sid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_sid_;
    m_sid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required sint32 m_lCLevel = 5;
inline bool PKUserInfo::has_m_lclevel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PKUserInfo::set_has_m_lclevel() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PKUserInfo::clear_has_m_lclevel() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PKUserInfo::clear_m_lclevel() {
  m_lclevel_ = 0;
  clear_has_m_lclevel();
}
inline ::google::protobuf::int32 PKUserInfo::m_lclevel() const {
  return m_lclevel_;
}
inline void PKUserInfo::set_m_lclevel(::google::protobuf::int32 value) {
  set_has_m_lclevel();
  m_lclevel_ = value;
}

// required sint32 m_lSoundType = 6;
inline bool PKUserInfo::has_m_lsoundtype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PKUserInfo::set_has_m_lsoundtype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PKUserInfo::clear_has_m_lsoundtype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PKUserInfo::clear_m_lsoundtype() {
  m_lsoundtype_ = 0;
  clear_has_m_lsoundtype();
}
inline ::google::protobuf::int32 PKUserInfo::m_lsoundtype() const {
  return m_lsoundtype_;
}
inline void PKUserInfo::set_m_lsoundtype(::google::protobuf::int32 value) {
  set_has_m_lsoundtype();
  m_lsoundtype_ = value;
}

// required string m_sAvt = 7;
inline bool PKUserInfo::has_m_savt() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PKUserInfo::set_has_m_savt() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PKUserInfo::clear_has_m_savt() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PKUserInfo::clear_m_savt() {
  if (m_savt_ != &::google::protobuf::internal::kEmptyString) {
    m_savt_->clear();
  }
  clear_has_m_savt();
}
inline const ::std::string& PKUserInfo::m_savt() const {
  return *m_savt_;
}
inline void PKUserInfo::set_m_savt(const ::std::string& value) {
  set_has_m_savt();
  if (m_savt_ == &::google::protobuf::internal::kEmptyString) {
    m_savt_ = new ::std::string;
  }
  m_savt_->assign(value);
}
inline void PKUserInfo::set_m_savt(const char* value) {
  set_has_m_savt();
  if (m_savt_ == &::google::protobuf::internal::kEmptyString) {
    m_savt_ = new ::std::string;
  }
  m_savt_->assign(value);
}
inline void PKUserInfo::set_m_savt(const char* value, size_t size) {
  set_has_m_savt();
  if (m_savt_ == &::google::protobuf::internal::kEmptyString) {
    m_savt_ = new ::std::string;
  }
  m_savt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PKUserInfo::mutable_m_savt() {
  set_has_m_savt();
  if (m_savt_ == &::google::protobuf::internal::kEmptyString) {
    m_savt_ = new ::std::string;
  }
  return m_savt_;
}
inline ::std::string* PKUserInfo::release_m_savt() {
  clear_has_m_savt();
  if (m_savt_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_savt_;
    m_savt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required sint32 m_lUserState = 8;
inline bool PKUserInfo::has_m_luserstate() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PKUserInfo::set_has_m_luserstate() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PKUserInfo::clear_has_m_luserstate() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PKUserInfo::clear_m_luserstate() {
  m_luserstate_ = 0;
  clear_has_m_luserstate();
}
inline ::google::protobuf::int32 PKUserInfo::m_luserstate() const {
  return m_luserstate_;
}
inline void PKUserInfo::set_m_luserstate(::google::protobuf::int32 value) {
  set_has_m_luserstate();
  m_luserstate_ = value;
}

// required .PKCWinLose m_cWinLose = 9;
inline bool PKUserInfo::has_m_cwinlose() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PKUserInfo::set_has_m_cwinlose() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PKUserInfo::clear_has_m_cwinlose() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PKUserInfo::clear_m_cwinlose() {
  if (m_cwinlose_ != NULL) m_cwinlose_->::PKCWinLose::Clear();
  clear_has_m_cwinlose();
}
inline const ::PKCWinLose& PKUserInfo::m_cwinlose() const {
  return m_cwinlose_ != NULL ? *m_cwinlose_ : *default_instance_->m_cwinlose_;
}
inline ::PKCWinLose* PKUserInfo::mutable_m_cwinlose() {
  set_has_m_cwinlose();
  if (m_cwinlose_ == NULL) m_cwinlose_ = new ::PKCWinLose;
  return m_cwinlose_;
}
inline ::PKCWinLose* PKUserInfo::release_m_cwinlose() {
  clear_has_m_cwinlose();
  ::PKCWinLose* temp = m_cwinlose_;
  m_cwinlose_ = NULL;
  return temp;
}

// required .PKCWinLose m_cWinLose_Today = 10;
inline bool PKUserInfo::has_m_cwinlose_today() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PKUserInfo::set_has_m_cwinlose_today() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PKUserInfo::clear_has_m_cwinlose_today() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PKUserInfo::clear_m_cwinlose_today() {
  if (m_cwinlose_today_ != NULL) m_cwinlose_today_->::PKCWinLose::Clear();
  clear_has_m_cwinlose_today();
}
inline const ::PKCWinLose& PKUserInfo::m_cwinlose_today() const {
  return m_cwinlose_today_ != NULL ? *m_cwinlose_today_ : *default_instance_->m_cwinlose_today_;
}
inline ::PKCWinLose* PKUserInfo::mutable_m_cwinlose_today() {
  set_has_m_cwinlose_today();
  if (m_cwinlose_today_ == NULL) m_cwinlose_today_ = new ::PKCWinLose;
  return m_cwinlose_today_;
}
inline ::PKCWinLose* PKUserInfo::release_m_cwinlose_today() {
  clear_has_m_cwinlose_today();
  ::PKCWinLose* temp = m_cwinlose_today_;
  m_cwinlose_today_ = NULL;
  return temp;
}

// required .PKCWinLose m_cWinLose_Room = 11;
inline bool PKUserInfo::has_m_cwinlose_room() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PKUserInfo::set_has_m_cwinlose_room() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PKUserInfo::clear_has_m_cwinlose_room() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PKUserInfo::clear_m_cwinlose_room() {
  if (m_cwinlose_room_ != NULL) m_cwinlose_room_->::PKCWinLose::Clear();
  clear_has_m_cwinlose_room();
}
inline const ::PKCWinLose& PKUserInfo::m_cwinlose_room() const {
  return m_cwinlose_room_ != NULL ? *m_cwinlose_room_ : *default_instance_->m_cwinlose_room_;
}
inline ::PKCWinLose* PKUserInfo::mutable_m_cwinlose_room() {
  set_has_m_cwinlose_room();
  if (m_cwinlose_room_ == NULL) m_cwinlose_room_ = new ::PKCWinLose;
  return m_cwinlose_room_;
}
inline ::PKCWinLose* PKUserInfo::release_m_cwinlose_room() {
  clear_has_m_cwinlose_room();
  ::PKCWinLose* temp = m_cwinlose_room_;
  m_cwinlose_room_ = NULL;
  return temp;
}

// required sint64 m_llCMoney = 12;
inline bool PKUserInfo::has_m_llcmoney() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PKUserInfo::set_has_m_llcmoney() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PKUserInfo::clear_has_m_llcmoney() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PKUserInfo::clear_m_llcmoney() {
  m_llcmoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_llcmoney();
}
inline ::google::protobuf::int64 PKUserInfo::m_llcmoney() const {
  return m_llcmoney_;
}
inline void PKUserInfo::set_m_llcmoney(::google::protobuf::int64 value) {
  set_has_m_llcmoney();
  m_llcmoney_ = value;
}

// required sint64 m_llFMoney = 13;
inline bool PKUserInfo::has_m_llfmoney() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PKUserInfo::set_has_m_llfmoney() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PKUserInfo::clear_has_m_llfmoney() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PKUserInfo::clear_m_llfmoney() {
  m_llfmoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_llfmoney();
}
inline ::google::protobuf::int64 PKUserInfo::m_llfmoney() const {
  return m_llfmoney_;
}
inline void PKUserInfo::set_m_llfmoney(::google::protobuf::int64 value) {
  set_has_m_llfmoney();
  m_llfmoney_ = value;
}

// required sint32 m_lExit = 14;
inline bool PKUserInfo::has_m_lexit() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PKUserInfo::set_has_m_lexit() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PKUserInfo::clear_has_m_lexit() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PKUserInfo::clear_m_lexit() {
  m_lexit_ = 0;
  clear_has_m_lexit();
}
inline ::google::protobuf::int32 PKUserInfo::m_lexit() const {
  return m_lexit_;
}
inline void PKUserInfo::set_m_lexit(::google::protobuf::int32 value) {
  set_has_m_lexit();
  m_lexit_ = value;
}

// required sint32 m_nItemType = 15;
inline bool PKUserInfo::has_m_nitemtype() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void PKUserInfo::set_has_m_nitemtype() {
  _has_bits_[0] |= 0x00004000u;
}
inline void PKUserInfo::clear_has_m_nitemtype() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void PKUserInfo::clear_m_nitemtype() {
  m_nitemtype_ = 0;
  clear_has_m_nitemtype();
}
inline ::google::protobuf::int32 PKUserInfo::m_nitemtype() const {
  return m_nitemtype_;
}
inline void PKUserInfo::set_m_nitemtype(::google::protobuf::int32 value) {
  set_has_m_nitemtype();
  m_nitemtype_ = value;
}

// required sint32 m_lAck = 16;
inline bool PKUserInfo::has_m_lack() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void PKUserInfo::set_has_m_lack() {
  _has_bits_[0] |= 0x00008000u;
}
inline void PKUserInfo::clear_has_m_lack() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void PKUserInfo::clear_m_lack() {
  m_lack_ = 0;
  clear_has_m_lack();
}
inline ::google::protobuf::int32 PKUserInfo::m_lack() const {
  return m_lack_;
}
inline void PKUserInfo::set_m_lack(::google::protobuf::int32 value) {
  set_has_m_lack();
  m_lack_ = value;
}

// required sint32 m_lJackpot = 17;
inline bool PKUserInfo::has_m_ljackpot() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void PKUserInfo::set_has_m_ljackpot() {
  _has_bits_[0] |= 0x00010000u;
}
inline void PKUserInfo::clear_has_m_ljackpot() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void PKUserInfo::clear_m_ljackpot() {
  m_ljackpot_ = 0;
  clear_has_m_ljackpot();
}
inline ::google::protobuf::int32 PKUserInfo::m_ljackpot() const {
  return m_ljackpot_;
}
inline void PKUserInfo::set_m_ljackpot(::google::protobuf::int32 value) {
  set_has_m_ljackpot();
  m_ljackpot_ = value;
}

// required sint32 m_lDieCardsDealt = 18;
inline bool PKUserInfo::has_m_ldiecardsdealt() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void PKUserInfo::set_has_m_ldiecardsdealt() {
  _has_bits_[0] |= 0x00020000u;
}
inline void PKUserInfo::clear_has_m_ldiecardsdealt() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void PKUserInfo::clear_m_ldiecardsdealt() {
  m_ldiecardsdealt_ = 0;
  clear_has_m_ldiecardsdealt();
}
inline ::google::protobuf::int32 PKUserInfo::m_ldiecardsdealt() const {
  return m_ldiecardsdealt_;
}
inline void PKUserInfo::set_m_ldiecardsdealt(::google::protobuf::int32 value) {
  set_has_m_ldiecardsdealt();
  m_ldiecardsdealt_ = value;
}

// -------------------------------------------------------------------

// PKOneCard

// required int32 m_nIndex = 1;
inline bool PKOneCard::has_m_nindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKOneCard::set_has_m_nindex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKOneCard::clear_has_m_nindex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKOneCard::clear_m_nindex() {
  m_nindex_ = 0;
  clear_has_m_nindex();
}
inline ::google::protobuf::int32 PKOneCard::m_nindex() const {
  return m_nindex_;
}
inline void PKOneCard::set_m_nindex(::google::protobuf::int32 value) {
  set_has_m_nindex();
  m_nindex_ = value;
}

// required int32 m_lCardIndex = 2;
inline bool PKOneCard::has_m_lcardindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKOneCard::set_has_m_lcardindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKOneCard::clear_has_m_lcardindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKOneCard::clear_m_lcardindex() {
  m_lcardindex_ = 0;
  clear_has_m_lcardindex();
}
inline ::google::protobuf::int32 PKOneCard::m_lcardindex() const {
  return m_lcardindex_;
}
inline void PKOneCard::set_m_lcardindex(::google::protobuf::int32 value) {
  set_has_m_lcardindex();
  m_lcardindex_ = value;
}

// -------------------------------------------------------------------

// PKVecMoney

// required sint64 VecMoney = 1;
inline bool PKVecMoney::has_vecmoney() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKVecMoney::set_has_vecmoney() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKVecMoney::clear_has_vecmoney() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKVecMoney::clear_vecmoney() {
  vecmoney_ = GOOGLE_LONGLONG(0);
  clear_has_vecmoney();
}
inline ::google::protobuf::int64 PKVecMoney::vecmoney() const {
  return vecmoney_;
}
inline void PKVecMoney::set_vecmoney(::google::protobuf::int64 value) {
  set_has_vecmoney();
  vecmoney_ = value;
}

// -------------------------------------------------------------------

// PKWinLoseInfo

// required sint64 m_llCMoney = 1;
inline bool PKWinLoseInfo::has_m_llcmoney() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKWinLoseInfo::set_has_m_llcmoney() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKWinLoseInfo::clear_has_m_llcmoney() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKWinLoseInfo::clear_m_llcmoney() {
  m_llcmoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_llcmoney();
}
inline ::google::protobuf::int64 PKWinLoseInfo::m_llcmoney() const {
  return m_llcmoney_;
}
inline void PKWinLoseInfo::set_m_llcmoney(::google::protobuf::int64 value) {
  set_has_m_llcmoney();
  m_llcmoney_ = value;
}

// required sint32 m_lWin = 2;
inline bool PKWinLoseInfo::has_m_lwin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKWinLoseInfo::set_has_m_lwin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKWinLoseInfo::clear_has_m_lwin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKWinLoseInfo::clear_m_lwin() {
  m_lwin_ = 0;
  clear_has_m_lwin();
}
inline ::google::protobuf::int32 PKWinLoseInfo::m_lwin() const {
  return m_lwin_;
}
inline void PKWinLoseInfo::set_m_lwin(::google::protobuf::int32 value) {
  set_has_m_lwin();
  m_lwin_ = value;
}

// required sint32 m_lLose = 3;
inline bool PKWinLoseInfo::has_m_llose() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PKWinLoseInfo::set_has_m_llose() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PKWinLoseInfo::clear_has_m_llose() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PKWinLoseInfo::clear_m_llose() {
  m_llose_ = 0;
  clear_has_m_llose();
}
inline ::google::protobuf::int32 PKWinLoseInfo::m_llose() const {
  return m_llose_;
}
inline void PKWinLoseInfo::set_m_llose(::google::protobuf::int32 value) {
  set_has_m_llose();
  m_llose_ = value;
}

// required sint32 m_lReserved = 4;
inline bool PKWinLoseInfo::has_m_lreserved() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PKWinLoseInfo::set_has_m_lreserved() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PKWinLoseInfo::clear_has_m_lreserved() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PKWinLoseInfo::clear_m_lreserved() {
  m_lreserved_ = 0;
  clear_has_m_lreserved();
}
inline ::google::protobuf::int32 PKWinLoseInfo::m_lreserved() const {
  return m_lreserved_;
}
inline void PKWinLoseInfo::set_m_lreserved(::google::protobuf::int32 value) {
  set_has_m_lreserved();
  m_lreserved_ = value;
}

// -------------------------------------------------------------------

// PKVecUSN

// required int64 USN = 1;
inline bool PKVecUSN::has_usn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKVecUSN::set_has_usn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKVecUSN::clear_has_usn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKVecUSN::clear_usn() {
  usn_ = GOOGLE_LONGLONG(0);
  clear_has_usn();
}
inline ::google::protobuf::int64 PKVecUSN::usn() const {
  return usn_;
}
inline void PKVecUSN::set_usn(::google::protobuf::int64 value) {
  set_has_usn();
  usn_ = value;
}

// -------------------------------------------------------------------

// PKWAITINGUSERDATA

// required int32 m_lUSN = 1;
inline bool PKWAITINGUSERDATA::has_m_lusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKWAITINGUSERDATA::set_has_m_lusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKWAITINGUSERDATA::clear_has_m_lusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKWAITINGUSERDATA::clear_m_lusn() {
  m_lusn_ = 0;
  clear_has_m_lusn();
}
inline ::google::protobuf::int32 PKWAITINGUSERDATA::m_lusn() const {
  return m_lusn_;
}
inline void PKWAITINGUSERDATA::set_m_lusn(::google::protobuf::int32 value) {
  set_has_m_lusn();
  m_lusn_ = value;
}

// required int32 m_lTicketNum = 2;
inline bool PKWAITINGUSERDATA::has_m_lticketnum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKWAITINGUSERDATA::set_has_m_lticketnum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKWAITINGUSERDATA::clear_has_m_lticketnum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKWAITINGUSERDATA::clear_m_lticketnum() {
  m_lticketnum_ = 0;
  clear_has_m_lticketnum();
}
inline ::google::protobuf::int32 PKWAITINGUSERDATA::m_lticketnum() const {
  return m_lticketnum_;
}
inline void PKWAITINGUSERDATA::set_m_lticketnum(::google::protobuf::int32 value) {
  set_has_m_lticketnum();
  m_lticketnum_ = value;
}

// required int32 m_lBackColor = 3;
inline bool PKWAITINGUSERDATA::has_m_lbackcolor() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PKWAITINGUSERDATA::set_has_m_lbackcolor() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PKWAITINGUSERDATA::clear_has_m_lbackcolor() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PKWAITINGUSERDATA::clear_m_lbackcolor() {
  m_lbackcolor_ = 0;
  clear_has_m_lbackcolor();
}
inline ::google::protobuf::int32 PKWAITINGUSERDATA::m_lbackcolor() const {
  return m_lbackcolor_;
}
inline void PKWAITINGUSERDATA::set_m_lbackcolor(::google::protobuf::int32 value) {
  set_has_m_lbackcolor();
  m_lbackcolor_ = value;
}

// required int32 m_bCallWeb = 4;
inline bool PKWAITINGUSERDATA::has_m_bcallweb() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PKWAITINGUSERDATA::set_has_m_bcallweb() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PKWAITINGUSERDATA::clear_has_m_bcallweb() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PKWAITINGUSERDATA::clear_m_bcallweb() {
  m_bcallweb_ = 0;
  clear_has_m_bcallweb();
}
inline ::google::protobuf::int32 PKWAITINGUSERDATA::m_bcallweb() const {
  return m_bcallweb_;
}
inline void PKWAITINGUSERDATA::set_m_bcallweb(::google::protobuf::int32 value) {
  set_has_m_bcallweb();
  m_bcallweb_ = value;
}

// -------------------------------------------------------------------

// CRefill

// required int64 m_llTime = 1;
inline bool CRefill::has_m_lltime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CRefill::set_has_m_lltime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CRefill::clear_has_m_lltime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CRefill::clear_m_lltime() {
  m_lltime_ = GOOGLE_LONGLONG(0);
  clear_has_m_lltime();
}
inline ::google::protobuf::int64 CRefill::m_lltime() const {
  return m_lltime_;
}
inline void CRefill::set_m_lltime(::google::protobuf::int64 value) {
  set_has_m_lltime();
  m_lltime_ = value;
}

// required int32 m_nCnt = 2;
inline bool CRefill::has_m_ncnt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CRefill::set_has_m_ncnt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CRefill::clear_has_m_ncnt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CRefill::clear_m_ncnt() {
  m_ncnt_ = 0;
  clear_has_m_ncnt();
}
inline ::google::protobuf::int32 CRefill::m_ncnt() const {
  return m_ncnt_;
}
inline void CRefill::set_m_ncnt(::google::protobuf::int32 value) {
  set_has_m_ncnt();
  m_ncnt_ = value;
}

// required int32 m_lPLevel = 3;
inline bool CRefill::has_m_lplevel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CRefill::set_has_m_lplevel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CRefill::clear_has_m_lplevel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CRefill::clear_m_lplevel() {
  m_lplevel_ = 0;
  clear_has_m_lplevel();
}
inline ::google::protobuf::int32 CRefill::m_lplevel() const {
  return m_lplevel_;
}
inline void CRefill::set_m_lplevel(::google::protobuf::int32 value) {
  set_has_m_lplevel();
  m_lplevel_ = value;
}

// -------------------------------------------------------------------

// PKItemList

// repeated .PKItem m_lstItem = 1;
inline int PKItemList::m_lstitem_size() const {
  return m_lstitem_.size();
}
inline void PKItemList::clear_m_lstitem() {
  m_lstitem_.Clear();
}
inline const ::PKItem& PKItemList::m_lstitem(int index) const {
  return m_lstitem_.Get(index);
}
inline ::PKItem* PKItemList::mutable_m_lstitem(int index) {
  return m_lstitem_.Mutable(index);
}
inline ::PKItem* PKItemList::add_m_lstitem() {
  return m_lstitem_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PKItem >&
PKItemList::m_lstitem() const {
  return m_lstitem_;
}
inline ::google::protobuf::RepeatedPtrField< ::PKItem >*
PKItemList::mutable_m_lstitem() {
  return &m_lstitem_;
}

// -------------------------------------------------------------------

// PKItem

// required int32 m_lFucnsrl = 1;
inline bool PKItem::has_m_lfucnsrl() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKItem::set_has_m_lfucnsrl() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKItem::clear_has_m_lfucnsrl() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKItem::clear_m_lfucnsrl() {
  m_lfucnsrl_ = 0;
  clear_has_m_lfucnsrl();
}
inline ::google::protobuf::int32 PKItem::m_lfucnsrl() const {
  return m_lfucnsrl_;
}
inline void PKItem::set_m_lfucnsrl(::google::protobuf::int32 value) {
  set_has_m_lfucnsrl();
  m_lfucnsrl_ = value;
}

// required int64 m_llStartTime = 2;
inline bool PKItem::has_m_llstarttime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKItem::set_has_m_llstarttime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKItem::clear_has_m_llstarttime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKItem::clear_m_llstarttime() {
  m_llstarttime_ = GOOGLE_LONGLONG(0);
  clear_has_m_llstarttime();
}
inline ::google::protobuf::int64 PKItem::m_llstarttime() const {
  return m_llstarttime_;
}
inline void PKItem::set_m_llstarttime(::google::protobuf::int64 value) {
  set_has_m_llstarttime();
  m_llstarttime_ = value;
}

// required int64 m_llEndTime = 3;
inline bool PKItem::has_m_llendtime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PKItem::set_has_m_llendtime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PKItem::clear_has_m_llendtime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PKItem::clear_m_llendtime() {
  m_llendtime_ = GOOGLE_LONGLONG(0);
  clear_has_m_llendtime();
}
inline ::google::protobuf::int64 PKItem::m_llendtime() const {
  return m_llendtime_;
}
inline void PKItem::set_m_llendtime(::google::protobuf::int64 value) {
  set_has_m_llendtime();
  m_llendtime_ = value;
}

// required int64 m_llCount = 4;
inline bool PKItem::has_m_llcount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PKItem::set_has_m_llcount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PKItem::clear_has_m_llcount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PKItem::clear_m_llcount() {
  m_llcount_ = GOOGLE_LONGLONG(0);
  clear_has_m_llcount();
}
inline ::google::protobuf::int64 PKItem::m_llcount() const {
  return m_llcount_;
}
inline void PKItem::set_m_llcount(::google::protobuf::int64 value) {
  set_has_m_llcount();
  m_llcount_ = value;
}

// -------------------------------------------------------------------

// PKRCUserData

// -------------------------------------------------------------------

// PKOption

// required string m_sRoomTitle = 1;
inline bool PKOption::has_m_sroomtitle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKOption::set_has_m_sroomtitle() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKOption::clear_has_m_sroomtitle() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKOption::clear_m_sroomtitle() {
  if (m_sroomtitle_ != &::google::protobuf::internal::kEmptyString) {
    m_sroomtitle_->clear();
  }
  clear_has_m_sroomtitle();
}
inline const ::std::string& PKOption::m_sroomtitle() const {
  return *m_sroomtitle_;
}
inline void PKOption::set_m_sroomtitle(const ::std::string& value) {
  set_has_m_sroomtitle();
  if (m_sroomtitle_ == &::google::protobuf::internal::kEmptyString) {
    m_sroomtitle_ = new ::std::string;
  }
  m_sroomtitle_->assign(value);
}
inline void PKOption::set_m_sroomtitle(const char* value) {
  set_has_m_sroomtitle();
  if (m_sroomtitle_ == &::google::protobuf::internal::kEmptyString) {
    m_sroomtitle_ = new ::std::string;
  }
  m_sroomtitle_->assign(value);
}
inline void PKOption::set_m_sroomtitle(const char* value, size_t size) {
  set_has_m_sroomtitle();
  if (m_sroomtitle_ == &::google::protobuf::internal::kEmptyString) {
    m_sroomtitle_ = new ::std::string;
  }
  m_sroomtitle_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PKOption::mutable_m_sroomtitle() {
  set_has_m_sroomtitle();
  if (m_sroomtitle_ == &::google::protobuf::internal::kEmptyString) {
    m_sroomtitle_ = new ::std::string;
  }
  return m_sroomtitle_;
}
inline ::std::string* PKOption::release_m_sroomtitle() {
  clear_has_m_sroomtitle();
  if (m_sroomtitle_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_sroomtitle_;
    m_sroomtitle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string m_sPassword = 2;
inline bool PKOption::has_m_spassword() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKOption::set_has_m_spassword() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKOption::clear_has_m_spassword() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKOption::clear_m_spassword() {
  if (m_spassword_ != &::google::protobuf::internal::kEmptyString) {
    m_spassword_->clear();
  }
  clear_has_m_spassword();
}
inline const ::std::string& PKOption::m_spassword() const {
  return *m_spassword_;
}
inline void PKOption::set_m_spassword(const ::std::string& value) {
  set_has_m_spassword();
  if (m_spassword_ == &::google::protobuf::internal::kEmptyString) {
    m_spassword_ = new ::std::string;
  }
  m_spassword_->assign(value);
}
inline void PKOption::set_m_spassword(const char* value) {
  set_has_m_spassword();
  if (m_spassword_ == &::google::protobuf::internal::kEmptyString) {
    m_spassword_ = new ::std::string;
  }
  m_spassword_->assign(value);
}
inline void PKOption::set_m_spassword(const char* value, size_t size) {
  set_has_m_spassword();
  if (m_spassword_ == &::google::protobuf::internal::kEmptyString) {
    m_spassword_ = new ::std::string;
  }
  m_spassword_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PKOption::mutable_m_spassword() {
  set_has_m_spassword();
  if (m_spassword_ == &::google::protobuf::internal::kEmptyString) {
    m_spassword_ = new ::std::string;
  }
  return m_spassword_;
}
inline ::std::string* PKOption::release_m_spassword() {
  clear_has_m_spassword();
  if (m_spassword_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_spassword_;
    m_spassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 m_lMaxUserCnt = 3;
inline bool PKOption::has_m_lmaxusercnt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PKOption::set_has_m_lmaxusercnt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PKOption::clear_has_m_lmaxusercnt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PKOption::clear_m_lmaxusercnt() {
  m_lmaxusercnt_ = 0;
  clear_has_m_lmaxusercnt();
}
inline ::google::protobuf::int32 PKOption::m_lmaxusercnt() const {
  return m_lmaxusercnt_;
}
inline void PKOption::set_m_lmaxusercnt(::google::protobuf::int32 value) {
  set_has_m_lmaxusercnt();
  m_lmaxusercnt_ = value;
}

// required int32 m_lMaxPlayerUserCnt = 4;
inline bool PKOption::has_m_lmaxplayerusercnt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PKOption::set_has_m_lmaxplayerusercnt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PKOption::clear_has_m_lmaxplayerusercnt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PKOption::clear_m_lmaxplayerusercnt() {
  m_lmaxplayerusercnt_ = 0;
  clear_has_m_lmaxplayerusercnt();
}
inline ::google::protobuf::int32 PKOption::m_lmaxplayerusercnt() const {
  return m_lmaxplayerusercnt_;
}
inline void PKOption::set_m_lmaxplayerusercnt(::google::protobuf::int32 value) {
  set_has_m_lmaxplayerusercnt();
  m_lmaxplayerusercnt_ = value;
}

// required int32 m_lMaxPlayerCardCnt = 5;
inline bool PKOption::has_m_lmaxplayercardcnt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PKOption::set_has_m_lmaxplayercardcnt() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PKOption::clear_has_m_lmaxplayercardcnt() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PKOption::clear_m_lmaxplayercardcnt() {
  m_lmaxplayercardcnt_ = 0;
  clear_has_m_lmaxplayercardcnt();
}
inline ::google::protobuf::int32 PKOption::m_lmaxplayercardcnt() const {
  return m_lmaxplayercardcnt_;
}
inline void PKOption::set_m_lmaxplayercardcnt(::google::protobuf::int32 value) {
  set_has_m_lmaxplayercardcnt();
  m_lmaxplayercardcnt_ = value;
}

// required int32 m_lChoiceMode = 6;
inline bool PKOption::has_m_lchoicemode() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PKOption::set_has_m_lchoicemode() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PKOption::clear_has_m_lchoicemode() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PKOption::clear_m_lchoicemode() {
  m_lchoicemode_ = 0;
  clear_has_m_lchoicemode();
}
inline ::google::protobuf::int32 PKOption::m_lchoicemode() const {
  return m_lchoicemode_;
}
inline void PKOption::set_m_lchoicemode(::google::protobuf::int32 value) {
  set_has_m_lchoicemode();
  m_lchoicemode_ = value;
}

// required int32 m_lRoomType = 7;
inline bool PKOption::has_m_lroomtype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PKOption::set_has_m_lroomtype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PKOption::clear_has_m_lroomtype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PKOption::clear_m_lroomtype() {
  m_lroomtype_ = 0;
  clear_has_m_lroomtype();
}
inline ::google::protobuf::int32 PKOption::m_lroomtype() const {
  return m_lroomtype_;
}
inline void PKOption::set_m_lroomtype(::google::protobuf::int32 value) {
  set_has_m_lroomtype();
  m_lroomtype_ = value;
}

// required int32 m_lBetRule = 8;
inline bool PKOption::has_m_lbetrule() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PKOption::set_has_m_lbetrule() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PKOption::clear_has_m_lbetrule() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PKOption::clear_m_lbetrule() {
  m_lbetrule_ = 0;
  clear_has_m_lbetrule();
}
inline ::google::protobuf::int32 PKOption::m_lbetrule() const {
  return m_lbetrule_;
}
inline void PKOption::set_m_lbetrule(::google::protobuf::int32 value) {
  set_has_m_lbetrule();
  m_lbetrule_ = value;
}

// required int32 m_lBetType = 9;
inline bool PKOption::has_m_lbettype() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PKOption::set_has_m_lbettype() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PKOption::clear_has_m_lbettype() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PKOption::clear_m_lbettype() {
  m_lbettype_ = 0;
  clear_has_m_lbettype();
}
inline ::google::protobuf::int32 PKOption::m_lbettype() const {
  return m_lbettype_;
}
inline void PKOption::set_m_lbettype(::google::protobuf::int32 value) {
  set_has_m_lbettype();
  m_lbettype_ = value;
}

// required int32 m_lAddRule = 10;
inline bool PKOption::has_m_laddrule() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PKOption::set_has_m_laddrule() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PKOption::clear_has_m_laddrule() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PKOption::clear_m_laddrule() {
  m_laddrule_ = 0;
  clear_has_m_laddrule();
}
inline ::google::protobuf::int32 PKOption::m_laddrule() const {
  return m_laddrule_;
}
inline void PKOption::set_m_laddrule(::google::protobuf::int32 value) {
  set_has_m_laddrule();
  m_laddrule_ = value;
}

// required int32 m_lRematchJoin = 11;
inline bool PKOption::has_m_lrematchjoin() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PKOption::set_has_m_lrematchjoin() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PKOption::clear_has_m_lrematchjoin() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PKOption::clear_m_lrematchjoin() {
  m_lrematchjoin_ = 0;
  clear_has_m_lrematchjoin();
}
inline ::google::protobuf::int32 PKOption::m_lrematchjoin() const {
  return m_lrematchjoin_;
}
inline void PKOption::set_m_lrematchjoin(::google::protobuf::int32 value) {
  set_has_m_lrematchjoin();
  m_lrematchjoin_ = value;
}

// required int32 m_lLimitMoney = 12;
inline bool PKOption::has_m_llimitmoney() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PKOption::set_has_m_llimitmoney() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PKOption::clear_has_m_llimitmoney() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PKOption::clear_m_llimitmoney() {
  m_llimitmoney_ = 0;
  clear_has_m_llimitmoney();
}
inline ::google::protobuf::int32 PKOption::m_llimitmoney() const {
  return m_llimitmoney_;
}
inline void PKOption::set_m_llimitmoney(::google::protobuf::int32 value) {
  set_has_m_llimitmoney();
  m_llimitmoney_ = value;
}

// required sint64 m_llGameAnteMoney = 13;
inline bool PKOption::has_m_llgameantemoney() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PKOption::set_has_m_llgameantemoney() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PKOption::clear_has_m_llgameantemoney() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PKOption::clear_m_llgameantemoney() {
  m_llgameantemoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_llgameantemoney();
}
inline ::google::protobuf::int64 PKOption::m_llgameantemoney() const {
  return m_llgameantemoney_;
}
inline void PKOption::set_m_llgameantemoney(::google::protobuf::int64 value) {
  set_has_m_llgameantemoney();
  m_llgameantemoney_ = value;
}

// required int32 m_bEcho = 14;
inline bool PKOption::has_m_becho() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PKOption::set_has_m_becho() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PKOption::clear_has_m_becho() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PKOption::clear_m_becho() {
  m_becho_ = 0;
  clear_has_m_becho();
}
inline ::google::protobuf::int32 PKOption::m_becho() const {
  return m_becho_;
}
inline void PKOption::set_m_becho(::google::protobuf::int32 value) {
  set_has_m_becho();
  m_becho_ = value;
}

// required int32 m_lMakeUSN = 15;
inline bool PKOption::has_m_lmakeusn() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void PKOption::set_has_m_lmakeusn() {
  _has_bits_[0] |= 0x00004000u;
}
inline void PKOption::clear_has_m_lmakeusn() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void PKOption::clear_m_lmakeusn() {
  m_lmakeusn_ = 0;
  clear_has_m_lmakeusn();
}
inline ::google::protobuf::int32 PKOption::m_lmakeusn() const {
  return m_lmakeusn_;
}
inline void PKOption::set_m_lmakeusn(::google::protobuf::int32 value) {
  set_has_m_lmakeusn();
  m_lmakeusn_ = value;
}

// required int32 m_lCategory = 16;
inline bool PKOption::has_m_lcategory() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void PKOption::set_has_m_lcategory() {
  _has_bits_[0] |= 0x00008000u;
}
inline void PKOption::clear_has_m_lcategory() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void PKOption::clear_m_lcategory() {
  m_lcategory_ = 0;
  clear_has_m_lcategory();
}
inline ::google::protobuf::int32 PKOption::m_lcategory() const {
  return m_lcategory_;
}
inline void PKOption::set_m_lcategory(::google::protobuf::int32 value) {
  set_has_m_lcategory();
  m_lcategory_ = value;
}

// required int32 m_lChannelID = 17;
inline bool PKOption::has_m_lchannelid() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void PKOption::set_has_m_lchannelid() {
  _has_bits_[0] |= 0x00010000u;
}
inline void PKOption::clear_has_m_lchannelid() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void PKOption::clear_m_lchannelid() {
  m_lchannelid_ = 0;
  clear_has_m_lchannelid();
}
inline ::google::protobuf::int32 PKOption::m_lchannelid() const {
  return m_lchannelid_;
}
inline void PKOption::set_m_lchannelid(::google::protobuf::int32 value) {
  set_has_m_lchannelid();
  m_lchannelid_ = value;
}

// required sint64 m_llAnteMoney = 18;
inline bool PKOption::has_m_llantemoney() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void PKOption::set_has_m_llantemoney() {
  _has_bits_[0] |= 0x00020000u;
}
inline void PKOption::clear_has_m_llantemoney() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void PKOption::clear_m_llantemoney() {
  m_llantemoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_llantemoney();
}
inline ::google::protobuf::int64 PKOption::m_llantemoney() const {
  return m_llantemoney_;
}
inline void PKOption::set_m_llantemoney(::google::protobuf::int64 value) {
  set_has_m_llantemoney();
  m_llantemoney_ = value;
}

// -------------------------------------------------------------------

// PKRCUser

// required int32 m_lUSN = 1;
inline bool PKRCUser::has_m_lusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKRCUser::set_has_m_lusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKRCUser::clear_has_m_lusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKRCUser::clear_m_lusn() {
  m_lusn_ = 0;
  clear_has_m_lusn();
}
inline ::google::protobuf::int32 PKRCUser::m_lusn() const {
  return m_lusn_;
}
inline void PKRCUser::set_m_lusn(::google::protobuf::int32 value) {
  set_has_m_lusn();
  m_lusn_ = value;
}

// required int32 m_lJumin = 2;
inline bool PKRCUser::has_m_ljumin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKRCUser::set_has_m_ljumin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKRCUser::clear_has_m_ljumin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKRCUser::clear_m_ljumin() {
  m_ljumin_ = 0;
  clear_has_m_ljumin();
}
inline ::google::protobuf::int32 PKRCUser::m_ljumin() const {
  return m_ljumin_;
}
inline void PKRCUser::set_m_ljumin(::google::protobuf::int32 value) {
  set_has_m_ljumin();
  m_ljumin_ = value;
}

// required int32 m_lFirstUSN = 3;
inline bool PKRCUser::has_m_lfirstusn() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PKRCUser::set_has_m_lfirstusn() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PKRCUser::clear_has_m_lfirstusn() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PKRCUser::clear_m_lfirstusn() {
  m_lfirstusn_ = 0;
  clear_has_m_lfirstusn();
}
inline ::google::protobuf::int32 PKRCUser::m_lfirstusn() const {
  return m_lfirstusn_;
}
inline void PKRCUser::set_m_lfirstusn(::google::protobuf::int32 value) {
  set_has_m_lfirstusn();
  m_lfirstusn_ = value;
}

// required int32 m_lAgeIndex = 4;
inline bool PKRCUser::has_m_lageindex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PKRCUser::set_has_m_lageindex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PKRCUser::clear_has_m_lageindex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PKRCUser::clear_m_lageindex() {
  m_lageindex_ = 0;
  clear_has_m_lageindex();
}
inline ::google::protobuf::int32 PKRCUser::m_lageindex() const {
  return m_lageindex_;
}
inline void PKRCUser::set_m_lageindex(::google::protobuf::int32 value) {
  set_has_m_lageindex();
  m_lageindex_ = value;
}

// required int32 m_lJobIndex = 5;
inline bool PKRCUser::has_m_ljobindex() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PKRCUser::set_has_m_ljobindex() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PKRCUser::clear_has_m_ljobindex() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PKRCUser::clear_m_ljobindex() {
  m_ljobindex_ = 0;
  clear_has_m_ljobindex();
}
inline ::google::protobuf::int32 PKRCUser::m_ljobindex() const {
  return m_ljobindex_;
}
inline void PKRCUser::set_m_ljobindex(::google::protobuf::int32 value) {
  set_has_m_ljobindex();
  m_ljobindex_ = value;
}

// required int32 m_lRegionIndex = 6;
inline bool PKRCUser::has_m_lregionindex() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PKRCUser::set_has_m_lregionindex() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PKRCUser::clear_has_m_lregionindex() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PKRCUser::clear_m_lregionindex() {
  m_lregionindex_ = 0;
  clear_has_m_lregionindex();
}
inline ::google::protobuf::int32 PKRCUser::m_lregionindex() const {
  return m_lregionindex_;
}
inline void PKRCUser::set_m_lregionindex(::google::protobuf::int32 value) {
  set_has_m_lregionindex();
  m_lregionindex_ = value;
}

// required int32 m_lGuildIndex = 7;
inline bool PKRCUser::has_m_lguildindex() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PKRCUser::set_has_m_lguildindex() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PKRCUser::clear_has_m_lguildindex() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PKRCUser::clear_m_lguildindex() {
  m_lguildindex_ = 0;
  clear_has_m_lguildindex();
}
inline ::google::protobuf::int32 PKRCUser::m_lguildindex() const {
  return m_lguildindex_;
}
inline void PKRCUser::set_m_lguildindex(::google::protobuf::int32 value) {
  set_has_m_lguildindex();
  m_lguildindex_ = value;
}

// required int32 m_lMemberIndex = 8;
inline bool PKRCUser::has_m_lmemberindex() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PKRCUser::set_has_m_lmemberindex() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PKRCUser::clear_has_m_lmemberindex() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PKRCUser::clear_m_lmemberindex() {
  m_lmemberindex_ = 0;
  clear_has_m_lmemberindex();
}
inline ::google::protobuf::int32 PKRCUser::m_lmemberindex() const {
  return m_lmemberindex_;
}
inline void PKRCUser::set_m_lmemberindex(::google::protobuf::int32 value) {
  set_has_m_lmemberindex();
  m_lmemberindex_ = value;
}

// required int32 m_lClientIP = 9;
inline bool PKRCUser::has_m_lclientip() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PKRCUser::set_has_m_lclientip() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PKRCUser::clear_has_m_lclientip() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PKRCUser::clear_m_lclientip() {
  m_lclientip_ = 0;
  clear_has_m_lclientip();
}
inline ::google::protobuf::int32 PKRCUser::m_lclientip() const {
  return m_lclientip_;
}
inline void PKRCUser::set_m_lclientip(::google::protobuf::int32 value) {
  set_has_m_lclientip();
  m_lclientip_ = value;
}

// required int32 m_lGatewayIP = 10;
inline bool PKRCUser::has_m_lgatewayip() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PKRCUser::set_has_m_lgatewayip() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PKRCUser::clear_has_m_lgatewayip() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PKRCUser::clear_m_lgatewayip() {
  m_lgatewayip_ = 0;
  clear_has_m_lgatewayip();
}
inline ::google::protobuf::int32 PKRCUser::m_lgatewayip() const {
  return m_lgatewayip_;
}
inline void PKRCUser::set_m_lgatewayip(::google::protobuf::int32 value) {
  set_has_m_lgatewayip();
  m_lgatewayip_ = value;
}

// required int32 m_lMacAddress = 11;
inline bool PKRCUser::has_m_lmacaddress() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PKRCUser::set_has_m_lmacaddress() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PKRCUser::clear_has_m_lmacaddress() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PKRCUser::clear_m_lmacaddress() {
  m_lmacaddress_ = 0;
  clear_has_m_lmacaddress();
}
inline ::google::protobuf::int32 PKRCUser::m_lmacaddress() const {
  return m_lmacaddress_;
}
inline void PKRCUser::set_m_lmacaddress(::google::protobuf::int32 value) {
  set_has_m_lmacaddress();
  m_lmacaddress_ = value;
}

// required string m_sMobileInfo = 12;
inline bool PKRCUser::has_m_smobileinfo() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PKRCUser::set_has_m_smobileinfo() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PKRCUser::clear_has_m_smobileinfo() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PKRCUser::clear_m_smobileinfo() {
  if (m_smobileinfo_ != &::google::protobuf::internal::kEmptyString) {
    m_smobileinfo_->clear();
  }
  clear_has_m_smobileinfo();
}
inline const ::std::string& PKRCUser::m_smobileinfo() const {
  return *m_smobileinfo_;
}
inline void PKRCUser::set_m_smobileinfo(const ::std::string& value) {
  set_has_m_smobileinfo();
  if (m_smobileinfo_ == &::google::protobuf::internal::kEmptyString) {
    m_smobileinfo_ = new ::std::string;
  }
  m_smobileinfo_->assign(value);
}
inline void PKRCUser::set_m_smobileinfo(const char* value) {
  set_has_m_smobileinfo();
  if (m_smobileinfo_ == &::google::protobuf::internal::kEmptyString) {
    m_smobileinfo_ = new ::std::string;
  }
  m_smobileinfo_->assign(value);
}
inline void PKRCUser::set_m_smobileinfo(const char* value, size_t size) {
  set_has_m_smobileinfo();
  if (m_smobileinfo_ == &::google::protobuf::internal::kEmptyString) {
    m_smobileinfo_ = new ::std::string;
  }
  m_smobileinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PKRCUser::mutable_m_smobileinfo() {
  set_has_m_smobileinfo();
  if (m_smobileinfo_ == &::google::protobuf::internal::kEmptyString) {
    m_smobileinfo_ = new ::std::string;
  }
  return m_smobileinfo_;
}
inline ::std::string* PKRCUser::release_m_smobileinfo() {
  clear_has_m_smobileinfo();
  if (m_smobileinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_smobileinfo_;
    m_smobileinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string m_sAuthKey = 13;
inline bool PKRCUser::has_m_sauthkey() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PKRCUser::set_has_m_sauthkey() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PKRCUser::clear_has_m_sauthkey() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PKRCUser::clear_m_sauthkey() {
  if (m_sauthkey_ != &::google::protobuf::internal::kEmptyString) {
    m_sauthkey_->clear();
  }
  clear_has_m_sauthkey();
}
inline const ::std::string& PKRCUser::m_sauthkey() const {
  return *m_sauthkey_;
}
inline void PKRCUser::set_m_sauthkey(const ::std::string& value) {
  set_has_m_sauthkey();
  if (m_sauthkey_ == &::google::protobuf::internal::kEmptyString) {
    m_sauthkey_ = new ::std::string;
  }
  m_sauthkey_->assign(value);
}
inline void PKRCUser::set_m_sauthkey(const char* value) {
  set_has_m_sauthkey();
  if (m_sauthkey_ == &::google::protobuf::internal::kEmptyString) {
    m_sauthkey_ = new ::std::string;
  }
  m_sauthkey_->assign(value);
}
inline void PKRCUser::set_m_sauthkey(const char* value, size_t size) {
  set_has_m_sauthkey();
  if (m_sauthkey_ == &::google::protobuf::internal::kEmptyString) {
    m_sauthkey_ = new ::std::string;
  }
  m_sauthkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PKRCUser::mutable_m_sauthkey() {
  set_has_m_sauthkey();
  if (m_sauthkey_ == &::google::protobuf::internal::kEmptyString) {
    m_sauthkey_ = new ::std::string;
  }
  return m_sauthkey_;
}
inline ::std::string* PKRCUser::release_m_sauthkey() {
  clear_has_m_sauthkey();
  if (m_sauthkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_sauthkey_;
    m_sauthkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string m_sUserGameData = 14;
inline bool PKRCUser::has_m_susergamedata() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PKRCUser::set_has_m_susergamedata() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PKRCUser::clear_has_m_susergamedata() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PKRCUser::clear_m_susergamedata() {
  if (m_susergamedata_ != &::google::protobuf::internal::kEmptyString) {
    m_susergamedata_->clear();
  }
  clear_has_m_susergamedata();
}
inline const ::std::string& PKRCUser::m_susergamedata() const {
  return *m_susergamedata_;
}
inline void PKRCUser::set_m_susergamedata(const ::std::string& value) {
  set_has_m_susergamedata();
  if (m_susergamedata_ == &::google::protobuf::internal::kEmptyString) {
    m_susergamedata_ = new ::std::string;
  }
  m_susergamedata_->assign(value);
}
inline void PKRCUser::set_m_susergamedata(const char* value) {
  set_has_m_susergamedata();
  if (m_susergamedata_ == &::google::protobuf::internal::kEmptyString) {
    m_susergamedata_ = new ::std::string;
  }
  m_susergamedata_->assign(value);
}
inline void PKRCUser::set_m_susergamedata(const char* value, size_t size) {
  set_has_m_susergamedata();
  if (m_susergamedata_ == &::google::protobuf::internal::kEmptyString) {
    m_susergamedata_ = new ::std::string;
  }
  m_susergamedata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PKRCUser::mutable_m_susergamedata() {
  set_has_m_susergamedata();
  if (m_susergamedata_ == &::google::protobuf::internal::kEmptyString) {
    m_susergamedata_ = new ::std::string;
  }
  return m_susergamedata_;
}
inline ::std::string* PKRCUser::release_m_susergamedata() {
  clear_has_m_susergamedata();
  if (m_susergamedata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_susergamedata_;
    m_susergamedata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 m_nIndex = 15;
inline bool PKRCUser::has_m_nindex() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void PKRCUser::set_has_m_nindex() {
  _has_bits_[0] |= 0x00004000u;
}
inline void PKRCUser::clear_has_m_nindex() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void PKRCUser::clear_m_nindex() {
  m_nindex_ = 0;
  clear_has_m_nindex();
}
inline ::google::protobuf::int32 PKRCUser::m_nindex() const {
  return m_nindex_;
}
inline void PKRCUser::set_m_nindex(::google::protobuf::int32 value) {
  set_has_m_nindex();
  m_nindex_ = value;
}

// required string m_sNickName = 16;
inline bool PKRCUser::has_m_snickname() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void PKRCUser::set_has_m_snickname() {
  _has_bits_[0] |= 0x00008000u;
}
inline void PKRCUser::clear_has_m_snickname() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void PKRCUser::clear_m_snickname() {
  if (m_snickname_ != &::google::protobuf::internal::kEmptyString) {
    m_snickname_->clear();
  }
  clear_has_m_snickname();
}
inline const ::std::string& PKRCUser::m_snickname() const {
  return *m_snickname_;
}
inline void PKRCUser::set_m_snickname(const ::std::string& value) {
  set_has_m_snickname();
  if (m_snickname_ == &::google::protobuf::internal::kEmptyString) {
    m_snickname_ = new ::std::string;
  }
  m_snickname_->assign(value);
}
inline void PKRCUser::set_m_snickname(const char* value) {
  set_has_m_snickname();
  if (m_snickname_ == &::google::protobuf::internal::kEmptyString) {
    m_snickname_ = new ::std::string;
  }
  m_snickname_->assign(value);
}
inline void PKRCUser::set_m_snickname(const char* value, size_t size) {
  set_has_m_snickname();
  if (m_snickname_ == &::google::protobuf::internal::kEmptyString) {
    m_snickname_ = new ::std::string;
  }
  m_snickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PKRCUser::mutable_m_snickname() {
  set_has_m_snickname();
  if (m_snickname_ == &::google::protobuf::internal::kEmptyString) {
    m_snickname_ = new ::std::string;
  }
  return m_snickname_;
}
inline ::std::string* PKRCUser::release_m_snickname() {
  clear_has_m_snickname();
  if (m_snickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_snickname_;
    m_snickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string m_sUserID = 17;
inline bool PKRCUser::has_m_suserid() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void PKRCUser::set_has_m_suserid() {
  _has_bits_[0] |= 0x00010000u;
}
inline void PKRCUser::clear_has_m_suserid() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void PKRCUser::clear_m_suserid() {
  if (m_suserid_ != &::google::protobuf::internal::kEmptyString) {
    m_suserid_->clear();
  }
  clear_has_m_suserid();
}
inline const ::std::string& PKRCUser::m_suserid() const {
  return *m_suserid_;
}
inline void PKRCUser::set_m_suserid(const ::std::string& value) {
  set_has_m_suserid();
  if (m_suserid_ == &::google::protobuf::internal::kEmptyString) {
    m_suserid_ = new ::std::string;
  }
  m_suserid_->assign(value);
}
inline void PKRCUser::set_m_suserid(const char* value) {
  set_has_m_suserid();
  if (m_suserid_ == &::google::protobuf::internal::kEmptyString) {
    m_suserid_ = new ::std::string;
  }
  m_suserid_->assign(value);
}
inline void PKRCUser::set_m_suserid(const char* value, size_t size) {
  set_has_m_suserid();
  if (m_suserid_ == &::google::protobuf::internal::kEmptyString) {
    m_suserid_ = new ::std::string;
  }
  m_suserid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PKRCUser::mutable_m_suserid() {
  set_has_m_suserid();
  if (m_suserid_ == &::google::protobuf::internal::kEmptyString) {
    m_suserid_ = new ::std::string;
  }
  return m_suserid_;
}
inline ::std::string* PKRCUser::release_m_suserid() {
  clear_has_m_suserid();
  if (m_suserid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_suserid_;
    m_suserid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string m_sAvt = 18;
inline bool PKRCUser::has_m_savt() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void PKRCUser::set_has_m_savt() {
  _has_bits_[0] |= 0x00020000u;
}
inline void PKRCUser::clear_has_m_savt() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void PKRCUser::clear_m_savt() {
  if (m_savt_ != &::google::protobuf::internal::kEmptyString) {
    m_savt_->clear();
  }
  clear_has_m_savt();
}
inline const ::std::string& PKRCUser::m_savt() const {
  return *m_savt_;
}
inline void PKRCUser::set_m_savt(const ::std::string& value) {
  set_has_m_savt();
  if (m_savt_ == &::google::protobuf::internal::kEmptyString) {
    m_savt_ = new ::std::string;
  }
  m_savt_->assign(value);
}
inline void PKRCUser::set_m_savt(const char* value) {
  set_has_m_savt();
  if (m_savt_ == &::google::protobuf::internal::kEmptyString) {
    m_savt_ = new ::std::string;
  }
  m_savt_->assign(value);
}
inline void PKRCUser::set_m_savt(const char* value, size_t size) {
  set_has_m_savt();
  if (m_savt_ == &::google::protobuf::internal::kEmptyString) {
    m_savt_ = new ::std::string;
  }
  m_savt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PKRCUser::mutable_m_savt() {
  set_has_m_savt();
  if (m_savt_ == &::google::protobuf::internal::kEmptyString) {
    m_savt_ = new ::std::string;
  }
  return m_savt_;
}
inline ::std::string* PKRCUser::release_m_savt() {
  clear_has_m_savt();
  if (m_savt_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_savt_;
    m_savt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 m_lCLevel = 19;
inline bool PKRCUser::has_m_lclevel() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void PKRCUser::set_has_m_lclevel() {
  _has_bits_[0] |= 0x00040000u;
}
inline void PKRCUser::clear_has_m_lclevel() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void PKRCUser::clear_m_lclevel() {
  m_lclevel_ = 0;
  clear_has_m_lclevel();
}
inline ::google::protobuf::int32 PKRCUser::m_lclevel() const {
  return m_lclevel_;
}
inline void PKRCUser::set_m_lclevel(::google::protobuf::int32 value) {
  set_has_m_lclevel();
  m_lclevel_ = value;
}

// required int32 m_lSex = 20;
inline bool PKRCUser::has_m_lsex() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void PKRCUser::set_has_m_lsex() {
  _has_bits_[0] |= 0x00080000u;
}
inline void PKRCUser::clear_has_m_lsex() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void PKRCUser::clear_m_lsex() {
  m_lsex_ = 0;
  clear_has_m_lsex();
}
inline ::google::protobuf::int32 PKRCUser::m_lsex() const {
  return m_lsex_;
}
inline void PKRCUser::set_m_lsex(::google::protobuf::int32 value) {
  set_has_m_lsex();
  m_lsex_ = value;
}

// required int64 m_llCMoney = 21;
inline bool PKRCUser::has_m_llcmoney() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void PKRCUser::set_has_m_llcmoney() {
  _has_bits_[0] |= 0x00100000u;
}
inline void PKRCUser::clear_has_m_llcmoney() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void PKRCUser::clear_m_llcmoney() {
  m_llcmoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_llcmoney();
}
inline ::google::protobuf::int64 PKRCUser::m_llcmoney() const {
  return m_llcmoney_;
}
inline void PKRCUser::set_m_llcmoney(::google::protobuf::int64 value) {
  set_has_m_llcmoney();
  m_llcmoney_ = value;
}

// required int64 m_llFMoney = 22;
inline bool PKRCUser::has_m_llfmoney() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void PKRCUser::set_has_m_llfmoney() {
  _has_bits_[0] |= 0x00200000u;
}
inline void PKRCUser::clear_has_m_llfmoney() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void PKRCUser::clear_m_llfmoney() {
  m_llfmoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_llfmoney();
}
inline ::google::protobuf::int64 PKRCUser::m_llfmoney() const {
  return m_llfmoney_;
}
inline void PKRCUser::set_m_llfmoney(::google::protobuf::int64 value) {
  set_has_m_llfmoney();
  m_llfmoney_ = value;
}

// required int64 m_llSafeMoney = 23;
inline bool PKRCUser::has_m_llsafemoney() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void PKRCUser::set_has_m_llsafemoney() {
  _has_bits_[0] |= 0x00400000u;
}
inline void PKRCUser::clear_has_m_llsafemoney() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void PKRCUser::clear_m_llsafemoney() {
  m_llsafemoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_llsafemoney();
}
inline ::google::protobuf::int64 PKRCUser::m_llsafemoney() const {
  return m_llsafemoney_;
}
inline void PKRCUser::set_m_llsafemoney(::google::protobuf::int64 value) {
  set_has_m_llsafemoney();
  m_llsafemoney_ = value;
}

// required int64 m_llPlastAllinDate = 24;
inline bool PKRCUser::has_m_llplastallindate() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void PKRCUser::set_has_m_llplastallindate() {
  _has_bits_[0] |= 0x00800000u;
}
inline void PKRCUser::clear_has_m_llplastallindate() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void PKRCUser::clear_m_llplastallindate() {
  m_llplastallindate_ = GOOGLE_LONGLONG(0);
  clear_has_m_llplastallindate();
}
inline ::google::protobuf::int64 PKRCUser::m_llplastallindate() const {
  return m_llplastallindate_;
}
inline void PKRCUser::set_m_llplastallindate(::google::protobuf::int64 value) {
  set_has_m_llplastallindate();
  m_llplastallindate_ = value;
}

// required int64 m_llPlastLogonDay = 25;
inline bool PKRCUser::has_m_llplastlogonday() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void PKRCUser::set_has_m_llplastlogonday() {
  _has_bits_[0] |= 0x01000000u;
}
inline void PKRCUser::clear_has_m_llplastlogonday() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void PKRCUser::clear_m_llplastlogonday() {
  m_llplastlogonday_ = GOOGLE_LONGLONG(0);
  clear_has_m_llplastlogonday();
}
inline ::google::protobuf::int64 PKRCUser::m_llplastlogonday() const {
  return m_llplastlogonday_;
}
inline void PKRCUser::set_m_llplastlogonday(::google::protobuf::int64 value) {
  set_has_m_llplastlogonday();
  m_llplastlogonday_ = value;
}

// required int32 m_lMTodayPlayCount = 26;
inline bool PKRCUser::has_m_lmtodayplaycount() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void PKRCUser::set_has_m_lmtodayplaycount() {
  _has_bits_[0] |= 0x02000000u;
}
inline void PKRCUser::clear_has_m_lmtodayplaycount() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void PKRCUser::clear_m_lmtodayplaycount() {
  m_lmtodayplaycount_ = 0;
  clear_has_m_lmtodayplaycount();
}
inline ::google::protobuf::int32 PKRCUser::m_lmtodayplaycount() const {
  return m_lmtodayplaycount_;
}
inline void PKRCUser::set_m_lmtodayplaycount(::google::protobuf::int32 value) {
  set_has_m_lmtodayplaycount();
  m_lmtodayplaycount_ = value;
}

// required int32 m_lMTodayPlayTime = 27;
inline bool PKRCUser::has_m_lmtodayplaytime() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void PKRCUser::set_has_m_lmtodayplaytime() {
  _has_bits_[0] |= 0x04000000u;
}
inline void PKRCUser::clear_has_m_lmtodayplaytime() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void PKRCUser::clear_m_lmtodayplaytime() {
  m_lmtodayplaytime_ = 0;
  clear_has_m_lmtodayplaytime();
}
inline ::google::protobuf::int32 PKRCUser::m_lmtodayplaytime() const {
  return m_lmtodayplaytime_;
}
inline void PKRCUser::set_m_lmtodayplaytime(::google::protobuf::int32 value) {
  set_has_m_lmtodayplaytime();
  m_lmtodayplaytime_ = value;
}

// required int32 m_lPTotalPlayCount = 28;
inline bool PKRCUser::has_m_lptotalplaycount() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void PKRCUser::set_has_m_lptotalplaycount() {
  _has_bits_[0] |= 0x08000000u;
}
inline void PKRCUser::clear_has_m_lptotalplaycount() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void PKRCUser::clear_m_lptotalplaycount() {
  m_lptotalplaycount_ = 0;
  clear_has_m_lptotalplaycount();
}
inline ::google::protobuf::int32 PKRCUser::m_lptotalplaycount() const {
  return m_lptotalplaycount_;
}
inline void PKRCUser::set_m_lptotalplaycount(::google::protobuf::int32 value) {
  set_has_m_lptotalplaycount();
  m_lptotalplaycount_ = value;
}

// required .CRefill m_cRefill = 29;
inline bool PKRCUser::has_m_crefill() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void PKRCUser::set_has_m_crefill() {
  _has_bits_[0] |= 0x10000000u;
}
inline void PKRCUser::clear_has_m_crefill() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void PKRCUser::clear_m_crefill() {
  if (m_crefill_ != NULL) m_crefill_->::CRefill::Clear();
  clear_has_m_crefill();
}
inline const ::CRefill& PKRCUser::m_crefill() const {
  return m_crefill_ != NULL ? *m_crefill_ : *default_instance_->m_crefill_;
}
inline ::CRefill* PKRCUser::mutable_m_crefill() {
  set_has_m_crefill();
  if (m_crefill_ == NULL) m_crefill_ = new ::CRefill;
  return m_crefill_;
}
inline ::CRefill* PKRCUser::release_m_crefill() {
  clear_has_m_crefill();
  ::CRefill* temp = m_crefill_;
  m_crefill_ = NULL;
  return temp;
}

// required int64 m_llPExtMoney = 30;
inline bool PKRCUser::has_m_llpextmoney() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void PKRCUser::set_has_m_llpextmoney() {
  _has_bits_[0] |= 0x20000000u;
}
inline void PKRCUser::clear_has_m_llpextmoney() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void PKRCUser::clear_m_llpextmoney() {
  m_llpextmoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_llpextmoney();
}
inline ::google::protobuf::int64 PKRCUser::m_llpextmoney() const {
  return m_llpextmoney_;
}
inline void PKRCUser::set_m_llpextmoney(::google::protobuf::int64 value) {
  set_has_m_llpextmoney();
  m_llpextmoney_ = value;
}

// required int64 m_llPExtendDate = 31;
inline bool PKRCUser::has_m_llpextenddate() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void PKRCUser::set_has_m_llpextenddate() {
  _has_bits_[0] |= 0x40000000u;
}
inline void PKRCUser::clear_has_m_llpextenddate() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void PKRCUser::clear_m_llpextenddate() {
  m_llpextenddate_ = GOOGLE_LONGLONG(0);
  clear_has_m_llpextenddate();
}
inline ::google::protobuf::int64 PKRCUser::m_llpextenddate() const {
  return m_llpextenddate_;
}
inline void PKRCUser::set_m_llpextenddate(::google::protobuf::int64 value) {
  set_has_m_llpextenddate();
  m_llpextenddate_ = value;
}

// required int64 m_llPBonusDate = 32;
inline bool PKRCUser::has_m_llpbonusdate() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void PKRCUser::set_has_m_llpbonusdate() {
  _has_bits_[0] |= 0x80000000u;
}
inline void PKRCUser::clear_has_m_llpbonusdate() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void PKRCUser::clear_m_llpbonusdate() {
  m_llpbonusdate_ = GOOGLE_LONGLONG(0);
  clear_has_m_llpbonusdate();
}
inline ::google::protobuf::int64 PKRCUser::m_llpbonusdate() const {
  return m_llpbonusdate_;
}
inline void PKRCUser::set_m_llpbonusdate(::google::protobuf::int64 value) {
  set_has_m_llpbonusdate();
  m_llpbonusdate_ = value;
}

// required int32 m_lMMonthPlayCount = 33;
inline bool PKRCUser::has_m_lmmonthplaycount() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void PKRCUser::set_has_m_lmmonthplaycount() {
  _has_bits_[1] |= 0x00000001u;
}
inline void PKRCUser::clear_has_m_lmmonthplaycount() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void PKRCUser::clear_m_lmmonthplaycount() {
  m_lmmonthplaycount_ = 0;
  clear_has_m_lmmonthplaycount();
}
inline ::google::protobuf::int32 PKRCUser::m_lmmonthplaycount() const {
  return m_lmmonthplaycount_;
}
inline void PKRCUser::set_m_lmmonthplaycount(::google::protobuf::int32 value) {
  set_has_m_lmmonthplaycount();
  m_lmmonthplaycount_ = value;
}

// required int32 m_lMMonthPlayTime = 34;
inline bool PKRCUser::has_m_lmmonthplaytime() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void PKRCUser::set_has_m_lmmonthplaytime() {
  _has_bits_[1] |= 0x00000002u;
}
inline void PKRCUser::clear_has_m_lmmonthplaytime() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void PKRCUser::clear_m_lmmonthplaytime() {
  m_lmmonthplaytime_ = 0;
  clear_has_m_lmmonthplaytime();
}
inline ::google::protobuf::int32 PKRCUser::m_lmmonthplaytime() const {
  return m_lmmonthplaytime_;
}
inline void PKRCUser::set_m_lmmonthplaytime(::google::protobuf::int32 value) {
  set_has_m_lmmonthplaytime();
  m_lmmonthplaytime_ = value;
}

// required .PKCWinLose m_cWinLose = 35;
inline bool PKRCUser::has_m_cwinlose() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void PKRCUser::set_has_m_cwinlose() {
  _has_bits_[1] |= 0x00000004u;
}
inline void PKRCUser::clear_has_m_cwinlose() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void PKRCUser::clear_m_cwinlose() {
  if (m_cwinlose_ != NULL) m_cwinlose_->::PKCWinLose::Clear();
  clear_has_m_cwinlose();
}
inline const ::PKCWinLose& PKRCUser::m_cwinlose() const {
  return m_cwinlose_ != NULL ? *m_cwinlose_ : *default_instance_->m_cwinlose_;
}
inline ::PKCWinLose* PKRCUser::mutable_m_cwinlose() {
  set_has_m_cwinlose();
  if (m_cwinlose_ == NULL) m_cwinlose_ = new ::PKCWinLose;
  return m_cwinlose_;
}
inline ::PKCWinLose* PKRCUser::release_m_cwinlose() {
  clear_has_m_cwinlose();
  ::PKCWinLose* temp = m_cwinlose_;
  m_cwinlose_ = NULL;
  return temp;
}

// required int32 m_lGDisCnt = 36;
inline bool PKRCUser::has_m_lgdiscnt() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void PKRCUser::set_has_m_lgdiscnt() {
  _has_bits_[1] |= 0x00000008u;
}
inline void PKRCUser::clear_has_m_lgdiscnt() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void PKRCUser::clear_m_lgdiscnt() {
  m_lgdiscnt_ = 0;
  clear_has_m_lgdiscnt();
}
inline ::google::protobuf::int32 PKRCUser::m_lgdiscnt() const {
  return m_lgdiscnt_;
}
inline void PKRCUser::set_m_lgdiscnt(::google::protobuf::int32 value) {
  set_has_m_lgdiscnt();
  m_lgdiscnt_ = value;
}

// required int64 m_llGlastLogonDay = 37;
inline bool PKRCUser::has_m_llglastlogonday() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void PKRCUser::set_has_m_llglastlogonday() {
  _has_bits_[1] |= 0x00000010u;
}
inline void PKRCUser::clear_has_m_llglastlogonday() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void PKRCUser::clear_m_llglastlogonday() {
  m_llglastlogonday_ = GOOGLE_LONGLONG(0);
  clear_has_m_llglastlogonday();
}
inline ::google::protobuf::int64 PKRCUser::m_llglastlogonday() const {
  return m_llglastlogonday_;
}
inline void PKRCUser::set_m_llglastlogonday(::google::protobuf::int64 value) {
  set_has_m_llglastlogonday();
  m_llglastlogonday_ = value;
}

// required int64 m_llGRegDate = 38;
inline bool PKRCUser::has_m_llgregdate() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void PKRCUser::set_has_m_llgregdate() {
  _has_bits_[1] |= 0x00000020u;
}
inline void PKRCUser::clear_has_m_llgregdate() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void PKRCUser::clear_m_llgregdate() {
  m_llgregdate_ = GOOGLE_LONGLONG(0);
  clear_has_m_llgregdate();
}
inline ::google::protobuf::int64 PKRCUser::m_llgregdate() const {
  return m_llgregdate_;
}
inline void PKRCUser::set_m_llgregdate(::google::protobuf::int64 value) {
  set_has_m_llgregdate();
  m_llgregdate_ = value;
}

// required int64 m_llGFirstPlayDate = 39;
inline bool PKRCUser::has_m_llgfirstplaydate() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void PKRCUser::set_has_m_llgfirstplaydate() {
  _has_bits_[1] |= 0x00000040u;
}
inline void PKRCUser::clear_has_m_llgfirstplaydate() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void PKRCUser::clear_m_llgfirstplaydate() {
  m_llgfirstplaydate_ = GOOGLE_LONGLONG(0);
  clear_has_m_llgfirstplaydate();
}
inline ::google::protobuf::int64 PKRCUser::m_llgfirstplaydate() const {
  return m_llgfirstplaydate_;
}
inline void PKRCUser::set_m_llgfirstplaydate(::google::protobuf::int64 value) {
  set_has_m_llgfirstplaydate();
  m_llgfirstplaydate_ = value;
}

// required int32 m_lGTodayPlayCount = 40;
inline bool PKRCUser::has_m_lgtodayplaycount() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void PKRCUser::set_has_m_lgtodayplaycount() {
  _has_bits_[1] |= 0x00000080u;
}
inline void PKRCUser::clear_has_m_lgtodayplaycount() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void PKRCUser::clear_m_lgtodayplaycount() {
  m_lgtodayplaycount_ = 0;
  clear_has_m_lgtodayplaycount();
}
inline ::google::protobuf::int32 PKRCUser::m_lgtodayplaycount() const {
  return m_lgtodayplaycount_;
}
inline void PKRCUser::set_m_lgtodayplaycount(::google::protobuf::int32 value) {
  set_has_m_lgtodayplaycount();
  m_lgtodayplaycount_ = value;
}

// required int32 m_lGTodayPlayTime = 41;
inline bool PKRCUser::has_m_lgtodayplaytime() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void PKRCUser::set_has_m_lgtodayplaytime() {
  _has_bits_[1] |= 0x00000100u;
}
inline void PKRCUser::clear_has_m_lgtodayplaytime() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void PKRCUser::clear_m_lgtodayplaytime() {
  m_lgtodayplaytime_ = 0;
  clear_has_m_lgtodayplaytime();
}
inline ::google::protobuf::int32 PKRCUser::m_lgtodayplaytime() const {
  return m_lgtodayplaytime_;
}
inline void PKRCUser::set_m_lgtodayplaytime(::google::protobuf::int32 value) {
  set_has_m_lgtodayplaytime();
  m_lgtodayplaytime_ = value;
}

// required int32 m_lGTotalPlayCount = 42;
inline bool PKRCUser::has_m_lgtotalplaycount() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void PKRCUser::set_has_m_lgtotalplaycount() {
  _has_bits_[1] |= 0x00000200u;
}
inline void PKRCUser::clear_has_m_lgtotalplaycount() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void PKRCUser::clear_m_lgtotalplaycount() {
  m_lgtotalplaycount_ = 0;
  clear_has_m_lgtotalplaycount();
}
inline ::google::protobuf::int32 PKRCUser::m_lgtotalplaycount() const {
  return m_lgtotalplaycount_;
}
inline void PKRCUser::set_m_lgtotalplaycount(::google::protobuf::int32 value) {
  set_has_m_lgtotalplaycount();
  m_lgtotalplaycount_ = value;
}

// required int32 m_lGTotalPlayTime = 43;
inline bool PKRCUser::has_m_lgtotalplaytime() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void PKRCUser::set_has_m_lgtotalplaytime() {
  _has_bits_[1] |= 0x00000400u;
}
inline void PKRCUser::clear_has_m_lgtotalplaytime() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void PKRCUser::clear_m_lgtotalplaytime() {
  m_lgtotalplaytime_ = 0;
  clear_has_m_lgtotalplaytime();
}
inline ::google::protobuf::int32 PKRCUser::m_lgtotalplaytime() const {
  return m_lgtotalplaytime_;
}
inline void PKRCUser::set_m_lgtotalplaytime(::google::protobuf::int32 value) {
  set_has_m_lgtotalplaytime();
  m_lgtotalplaytime_ = value;
}

// required int32 m_lGAllinCnt = 44;
inline bool PKRCUser::has_m_lgallincnt() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void PKRCUser::set_has_m_lgallincnt() {
  _has_bits_[1] |= 0x00000800u;
}
inline void PKRCUser::clear_has_m_lgallincnt() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void PKRCUser::clear_m_lgallincnt() {
  m_lgallincnt_ = 0;
  clear_has_m_lgallincnt();
}
inline ::google::protobuf::int32 PKRCUser::m_lgallincnt() const {
  return m_lgallincnt_;
}
inline void PKRCUser::set_m_lgallincnt(::google::protobuf::int32 value) {
  set_has_m_lgallincnt();
  m_lgallincnt_ = value;
}

// required int32 m_lGAllinOut = 45;
inline bool PKRCUser::has_m_lgallinout() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void PKRCUser::set_has_m_lgallinout() {
  _has_bits_[1] |= 0x00001000u;
}
inline void PKRCUser::clear_has_m_lgallinout() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void PKRCUser::clear_m_lgallinout() {
  m_lgallinout_ = 0;
  clear_has_m_lgallinout();
}
inline ::google::protobuf::int32 PKRCUser::m_lgallinout() const {
  return m_lgallinout_;
}
inline void PKRCUser::set_m_lgallinout(::google::protobuf::int32 value) {
  set_has_m_lgallinout();
  m_lgallinout_ = value;
}

// required int64 m_llGLastAllinDate = 46;
inline bool PKRCUser::has_m_llglastallindate() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void PKRCUser::set_has_m_llglastallindate() {
  _has_bits_[1] |= 0x00002000u;
}
inline void PKRCUser::clear_has_m_llglastallindate() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void PKRCUser::clear_m_llglastallindate() {
  m_llglastallindate_ = GOOGLE_LONGLONG(0);
  clear_has_m_llglastallindate();
}
inline ::google::protobuf::int64 PKRCUser::m_llglastallindate() const {
  return m_llglastallindate_;
}
inline void PKRCUser::set_m_llglastallindate(::google::protobuf::int64 value) {
  set_has_m_llglastallindate();
  m_llglastallindate_ = value;
}

// required .PKCWinLose m_cWinLose_Today = 47;
inline bool PKRCUser::has_m_cwinlose_today() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void PKRCUser::set_has_m_cwinlose_today() {
  _has_bits_[1] |= 0x00004000u;
}
inline void PKRCUser::clear_has_m_cwinlose_today() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void PKRCUser::clear_m_cwinlose_today() {
  if (m_cwinlose_today_ != NULL) m_cwinlose_today_->::PKCWinLose::Clear();
  clear_has_m_cwinlose_today();
}
inline const ::PKCWinLose& PKRCUser::m_cwinlose_today() const {
  return m_cwinlose_today_ != NULL ? *m_cwinlose_today_ : *default_instance_->m_cwinlose_today_;
}
inline ::PKCWinLose* PKRCUser::mutable_m_cwinlose_today() {
  set_has_m_cwinlose_today();
  if (m_cwinlose_today_ == NULL) m_cwinlose_today_ = new ::PKCWinLose;
  return m_cwinlose_today_;
}
inline ::PKCWinLose* PKRCUser::release_m_cwinlose_today() {
  clear_has_m_cwinlose_today();
  ::PKCWinLose* temp = m_cwinlose_today_;
  m_cwinlose_today_ = NULL;
  return temp;
}

// required int64 m_llGTodayMoney = 48;
inline bool PKRCUser::has_m_llgtodaymoney() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void PKRCUser::set_has_m_llgtodaymoney() {
  _has_bits_[1] |= 0x00008000u;
}
inline void PKRCUser::clear_has_m_llgtodaymoney() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void PKRCUser::clear_m_llgtodaymoney() {
  m_llgtodaymoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_llgtodaymoney();
}
inline ::google::protobuf::int64 PKRCUser::m_llgtodaymoney() const {
  return m_llgtodaymoney_;
}
inline void PKRCUser::set_m_llgtodaymoney(::google::protobuf::int64 value) {
  set_has_m_llgtodaymoney();
  m_llgtodaymoney_ = value;
}

// required int32 m_lFourCardCnt = 49;
inline bool PKRCUser::has_m_lfourcardcnt() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void PKRCUser::set_has_m_lfourcardcnt() {
  _has_bits_[1] |= 0x00010000u;
}
inline void PKRCUser::clear_has_m_lfourcardcnt() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void PKRCUser::clear_m_lfourcardcnt() {
  m_lfourcardcnt_ = 0;
  clear_has_m_lfourcardcnt();
}
inline ::google::protobuf::int32 PKRCUser::m_lfourcardcnt() const {
  return m_lfourcardcnt_;
}
inline void PKRCUser::set_m_lfourcardcnt(::google::protobuf::int32 value) {
  set_has_m_lfourcardcnt();
  m_lfourcardcnt_ = value;
}

// required int32 m_lStraightFlushCnt = 50;
inline bool PKRCUser::has_m_lstraightflushcnt() const {
  return (_has_bits_[1] & 0x00020000u) != 0;
}
inline void PKRCUser::set_has_m_lstraightflushcnt() {
  _has_bits_[1] |= 0x00020000u;
}
inline void PKRCUser::clear_has_m_lstraightflushcnt() {
  _has_bits_[1] &= ~0x00020000u;
}
inline void PKRCUser::clear_m_lstraightflushcnt() {
  m_lstraightflushcnt_ = 0;
  clear_has_m_lstraightflushcnt();
}
inline ::google::protobuf::int32 PKRCUser::m_lstraightflushcnt() const {
  return m_lstraightflushcnt_;
}
inline void PKRCUser::set_m_lstraightflushcnt(::google::protobuf::int32 value) {
  set_has_m_lstraightflushcnt();
  m_lstraightflushcnt_ = value;
}

// required int32 m_lRoyalStraightFlushCnt = 51;
inline bool PKRCUser::has_m_lroyalstraightflushcnt() const {
  return (_has_bits_[1] & 0x00040000u) != 0;
}
inline void PKRCUser::set_has_m_lroyalstraightflushcnt() {
  _has_bits_[1] |= 0x00040000u;
}
inline void PKRCUser::clear_has_m_lroyalstraightflushcnt() {
  _has_bits_[1] &= ~0x00040000u;
}
inline void PKRCUser::clear_m_lroyalstraightflushcnt() {
  m_lroyalstraightflushcnt_ = 0;
  clear_has_m_lroyalstraightflushcnt();
}
inline ::google::protobuf::int32 PKRCUser::m_lroyalstraightflushcnt() const {
  return m_lroyalstraightflushcnt_;
}
inline void PKRCUser::set_m_lroyalstraightflushcnt(::google::protobuf::int32 value) {
  set_has_m_lroyalstraightflushcnt();
  m_lroyalstraightflushcnt_ = value;
}

// required int32 m_nReserve01 = 52;
inline bool PKRCUser::has_m_nreserve01() const {
  return (_has_bits_[1] & 0x00080000u) != 0;
}
inline void PKRCUser::set_has_m_nreserve01() {
  _has_bits_[1] |= 0x00080000u;
}
inline void PKRCUser::clear_has_m_nreserve01() {
  _has_bits_[1] &= ~0x00080000u;
}
inline void PKRCUser::clear_m_nreserve01() {
  m_nreserve01_ = 0;
  clear_has_m_nreserve01();
}
inline ::google::protobuf::int32 PKRCUser::m_nreserve01() const {
  return m_nreserve01_;
}
inline void PKRCUser::set_m_nreserve01(::google::protobuf::int32 value) {
  set_has_m_nreserve01();
  m_nreserve01_ = value;
}

// required int32 m_nReserve02 = 53;
inline bool PKRCUser::has_m_nreserve02() const {
  return (_has_bits_[1] & 0x00100000u) != 0;
}
inline void PKRCUser::set_has_m_nreserve02() {
  _has_bits_[1] |= 0x00100000u;
}
inline void PKRCUser::clear_has_m_nreserve02() {
  _has_bits_[1] &= ~0x00100000u;
}
inline void PKRCUser::clear_m_nreserve02() {
  m_nreserve02_ = 0;
  clear_has_m_nreserve02();
}
inline ::google::protobuf::int32 PKRCUser::m_nreserve02() const {
  return m_nreserve02_;
}
inline void PKRCUser::set_m_nreserve02(::google::protobuf::int32 value) {
  set_has_m_nreserve02();
  m_nreserve02_ = value;
}

// required .PKItemList m_ItemList = 54;
inline bool PKRCUser::has_m_itemlist() const {
  return (_has_bits_[1] & 0x00200000u) != 0;
}
inline void PKRCUser::set_has_m_itemlist() {
  _has_bits_[1] |= 0x00200000u;
}
inline void PKRCUser::clear_has_m_itemlist() {
  _has_bits_[1] &= ~0x00200000u;
}
inline void PKRCUser::clear_m_itemlist() {
  if (m_itemlist_ != NULL) m_itemlist_->::PKItemList::Clear();
  clear_has_m_itemlist();
}
inline const ::PKItemList& PKRCUser::m_itemlist() const {
  return m_itemlist_ != NULL ? *m_itemlist_ : *default_instance_->m_itemlist_;
}
inline ::PKItemList* PKRCUser::mutable_m_itemlist() {
  set_has_m_itemlist();
  if (m_itemlist_ == NULL) m_itemlist_ = new ::PKItemList;
  return m_itemlist_;
}
inline ::PKItemList* PKRCUser::release_m_itemlist() {
  clear_has_m_itemlist();
  ::PKItemList* temp = m_itemlist_;
  m_itemlist_ = NULL;
  return temp;
}

// required int64 m_llJoinDate = 55;
inline bool PKRCUser::has_m_lljoindate() const {
  return (_has_bits_[1] & 0x00400000u) != 0;
}
inline void PKRCUser::set_has_m_lljoindate() {
  _has_bits_[1] |= 0x00400000u;
}
inline void PKRCUser::clear_has_m_lljoindate() {
  _has_bits_[1] &= ~0x00400000u;
}
inline void PKRCUser::clear_m_lljoindate() {
  m_lljoindate_ = GOOGLE_LONGLONG(0);
  clear_has_m_lljoindate();
}
inline ::google::protobuf::int64 PKRCUser::m_lljoindate() const {
  return m_lljoindate_;
}
inline void PKRCUser::set_m_lljoindate(::google::protobuf::int64 value) {
  set_has_m_lljoindate();
  m_lljoindate_ = value;
}

// required int64 m_llPlayDate = 56;
inline bool PKRCUser::has_m_llplaydate() const {
  return (_has_bits_[1] & 0x00800000u) != 0;
}
inline void PKRCUser::set_has_m_llplaydate() {
  _has_bits_[1] |= 0x00800000u;
}
inline void PKRCUser::clear_has_m_llplaydate() {
  _has_bits_[1] &= ~0x00800000u;
}
inline void PKRCUser::clear_m_llplaydate() {
  m_llplaydate_ = GOOGLE_LONGLONG(0);
  clear_has_m_llplaydate();
}
inline ::google::protobuf::int64 PKRCUser::m_llplaydate() const {
  return m_llplaydate_;
}
inline void PKRCUser::set_m_llplaydate(::google::protobuf::int64 value) {
  set_has_m_llplaydate();
  m_llplaydate_ = value;
}

// -------------------------------------------------------------------

// PKBettingMsg

// required int32 m_lUSN = 1;
inline bool PKBettingMsg::has_m_lusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKBettingMsg::set_has_m_lusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKBettingMsg::clear_has_m_lusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKBettingMsg::clear_m_lusn() {
  m_lusn_ = 0;
  clear_has_m_lusn();
}
inline ::google::protobuf::int32 PKBettingMsg::m_lusn() const {
  return m_lusn_;
}
inline void PKBettingMsg::set_m_lusn(::google::protobuf::int32 value) {
  set_has_m_lusn();
  m_lusn_ = value;
}

// required int32 m_nIndex = 2;
inline bool PKBettingMsg::has_m_nindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKBettingMsg::set_has_m_nindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKBettingMsg::clear_has_m_nindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKBettingMsg::clear_m_nindex() {
  m_nindex_ = 0;
  clear_has_m_nindex();
}
inline ::google::protobuf::int32 PKBettingMsg::m_nindex() const {
  return m_nindex_;
}
inline void PKBettingMsg::set_m_nindex(::google::protobuf::int32 value) {
  set_has_m_nindex();
  m_nindex_ = value;
}

// required int32 m_BetType = 3;
inline bool PKBettingMsg::has_m_bettype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PKBettingMsg::set_has_m_bettype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PKBettingMsg::clear_has_m_bettype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PKBettingMsg::clear_m_bettype() {
  m_bettype_ = 0;
  clear_has_m_bettype();
}
inline ::google::protobuf::int32 PKBettingMsg::m_bettype() const {
  return m_bettype_;
}
inline void PKBettingMsg::set_m_bettype(::google::protobuf::int32 value) {
  set_has_m_bettype();
  m_bettype_ = value;
}

// required int32 m_bBettingMoney = 4;
inline bool PKBettingMsg::has_m_bbettingmoney() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PKBettingMsg::set_has_m_bbettingmoney() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PKBettingMsg::clear_has_m_bbettingmoney() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PKBettingMsg::clear_m_bbettingmoney() {
  m_bbettingmoney_ = 0;
  clear_has_m_bbettingmoney();
}
inline ::google::protobuf::int32 PKBettingMsg::m_bbettingmoney() const {
  return m_bbettingmoney_;
}
inline void PKBettingMsg::set_m_bbettingmoney(::google::protobuf::int32 value) {
  set_has_m_bbettingmoney();
  m_bbettingmoney_ = value;
}

// required int32 m_bMoneyLack = 5;
inline bool PKBettingMsg::has_m_bmoneylack() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PKBettingMsg::set_has_m_bmoneylack() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PKBettingMsg::clear_has_m_bmoneylack() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PKBettingMsg::clear_m_bmoneylack() {
  m_bmoneylack_ = 0;
  clear_has_m_bmoneylack();
}
inline ::google::protobuf::int32 PKBettingMsg::m_bmoneylack() const {
  return m_bmoneylack_;
}
inline void PKBettingMsg::set_m_bmoneylack(::google::protobuf::int32 value) {
  set_has_m_bmoneylack();
  m_bmoneylack_ = value;
}

// required int32 m_bCallMoneyZero = 6;
inline bool PKBettingMsg::has_m_bcallmoneyzero() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PKBettingMsg::set_has_m_bcallmoneyzero() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PKBettingMsg::clear_has_m_bcallmoneyzero() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PKBettingMsg::clear_m_bcallmoneyzero() {
  m_bcallmoneyzero_ = 0;
  clear_has_m_bcallmoneyzero();
}
inline ::google::protobuf::int32 PKBettingMsg::m_bcallmoneyzero() const {
  return m_bcallmoneyzero_;
}
inline void PKBettingMsg::set_m_bcallmoneyzero(::google::protobuf::int32 value) {
  set_has_m_bcallmoneyzero();
  m_bcallmoneyzero_ = value;
}

// required int64 m_llCallMoney = 7;
inline bool PKBettingMsg::has_m_llcallmoney() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PKBettingMsg::set_has_m_llcallmoney() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PKBettingMsg::clear_has_m_llcallmoney() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PKBettingMsg::clear_m_llcallmoney() {
  m_llcallmoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_llcallmoney();
}
inline ::google::protobuf::int64 PKBettingMsg::m_llcallmoney() const {
  return m_llcallmoney_;
}
inline void PKBettingMsg::set_m_llcallmoney(::google::protobuf::int64 value) {
  set_has_m_llcallmoney();
  m_llcallmoney_ = value;
}

// required int64 m_llRaiseMoney = 8;
inline bool PKBettingMsg::has_m_llraisemoney() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PKBettingMsg::set_has_m_llraisemoney() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PKBettingMsg::clear_has_m_llraisemoney() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PKBettingMsg::clear_m_llraisemoney() {
  m_llraisemoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_llraisemoney();
}
inline ::google::protobuf::int64 PKBettingMsg::m_llraisemoney() const {
  return m_llraisemoney_;
}
inline void PKBettingMsg::set_m_llraisemoney(::google::protobuf::int64 value) {
  set_has_m_llraisemoney();
  m_llraisemoney_ = value;
}

// -------------------------------------------------------------------

// PKBettingMsgTable

// repeated .PKBettingMsg BettingMsgTable = 1;
inline int PKBettingMsgTable::bettingmsgtable_size() const {
  return bettingmsgtable_.size();
}
inline void PKBettingMsgTable::clear_bettingmsgtable() {
  bettingmsgtable_.Clear();
}
inline const ::PKBettingMsg& PKBettingMsgTable::bettingmsgtable(int index) const {
  return bettingmsgtable_.Get(index);
}
inline ::PKBettingMsg* PKBettingMsgTable::mutable_bettingmsgtable(int index) {
  return bettingmsgtable_.Mutable(index);
}
inline ::PKBettingMsg* PKBettingMsgTable::add_bettingmsgtable() {
  return bettingmsgtable_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PKBettingMsg >&
PKBettingMsgTable::bettingmsgtable() const {
  return bettingmsgtable_;
}
inline ::google::protobuf::RepeatedPtrField< ::PKBettingMsg >*
PKBettingMsgTable::mutable_bettingmsgtable() {
  return &bettingmsgtable_;
}

// -------------------------------------------------------------------

// PKMoneyTable

// repeated .PKMoney MoneyTable = 1;
inline int PKMoneyTable::moneytable_size() const {
  return moneytable_.size();
}
inline void PKMoneyTable::clear_moneytable() {
  moneytable_.Clear();
}
inline const ::PKMoney& PKMoneyTable::moneytable(int index) const {
  return moneytable_.Get(index);
}
inline ::PKMoney* PKMoneyTable::mutable_moneytable(int index) {
  return moneytable_.Mutable(index);
}
inline ::PKMoney* PKMoneyTable::add_moneytable() {
  return moneytable_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PKMoney >&
PKMoneyTable::moneytable() const {
  return moneytable_;
}
inline ::google::protobuf::RepeatedPtrField< ::PKMoney >*
PKMoneyTable::mutable_moneytable() {
  return &moneytable_;
}

// -------------------------------------------------------------------

// PKCardTable

// repeated .PKCards CardTable = 1;
inline int PKCardTable::cardtable_size() const {
  return cardtable_.size();
}
inline void PKCardTable::clear_cardtable() {
  cardtable_.Clear();
}
inline const ::PKCards& PKCardTable::cardtable(int index) const {
  return cardtable_.Get(index);
}
inline ::PKCards* PKCardTable::mutable_cardtable(int index) {
  return cardtable_.Mutable(index);
}
inline ::PKCards* PKCardTable::add_cardtable() {
  return cardtable_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PKCards >&
PKCardTable::cardtable() const {
  return cardtable_;
}
inline ::google::protobuf::RepeatedPtrField< ::PKCards >*
PKCardTable::mutable_cardtable() {
  return &cardtable_;
}

// -------------------------------------------------------------------

// PKUITable

// repeated .PKUserInfo UITable = 1;
inline int PKUITable::uitable_size() const {
  return uitable_.size();
}
inline void PKUITable::clear_uitable() {
  uitable_.Clear();
}
inline const ::PKUserInfo& PKUITable::uitable(int index) const {
  return uitable_.Get(index);
}
inline ::PKUserInfo* PKUITable::mutable_uitable(int index) {
  return uitable_.Mutable(index);
}
inline ::PKUserInfo* PKUITable::add_uitable() {
  return uitable_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PKUserInfo >&
PKUITable::uitable() const {
  return uitable_;
}
inline ::google::protobuf::RepeatedPtrField< ::PKUserInfo >*
PKUITable::mutable_uitable() {
  return &uitable_;
}

// -------------------------------------------------------------------

// PKRCRoomData

// required int32 m_lGameMaster = 1;
inline bool PKRCRoomData::has_m_lgamemaster() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKRCRoomData::set_has_m_lgamemaster() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKRCRoomData::clear_has_m_lgamemaster() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKRCRoomData::clear_m_lgamemaster() {
  m_lgamemaster_ = 0;
  clear_has_m_lgamemaster();
}
inline ::google::protobuf::int32 PKRCRoomData::m_lgamemaster() const {
  return m_lgamemaster_;
}
inline void PKRCRoomData::set_m_lgamemaster(::google::protobuf::int32 value) {
  set_has_m_lgamemaster();
  m_lgamemaster_ = value;
}

// required int32 m_lRoomIndex = 2;
inline bool PKRCRoomData::has_m_lroomindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKRCRoomData::set_has_m_lroomindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKRCRoomData::clear_has_m_lroomindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKRCRoomData::clear_m_lroomindex() {
  m_lroomindex_ = 0;
  clear_has_m_lroomindex();
}
inline ::google::protobuf::int32 PKRCRoomData::m_lroomindex() const {
  return m_lroomindex_;
}
inline void PKRCRoomData::set_m_lroomindex(::google::protobuf::int32 value) {
  set_has_m_lroomindex();
  m_lroomindex_ = value;
}

// required int32 m_lState = 3;
inline bool PKRCRoomData::has_m_lstate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PKRCRoomData::set_has_m_lstate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PKRCRoomData::clear_has_m_lstate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PKRCRoomData::clear_m_lstate() {
  m_lstate_ = 0;
  clear_has_m_lstate();
}
inline ::google::protobuf::int32 PKRCRoomData::m_lstate() const {
  return m_lstate_;
}
inline void PKRCRoomData::set_m_lstate(::google::protobuf::int32 value) {
  set_has_m_lstate();
  m_lstate_ = value;
}

// required .PKOption m_option = 4;
inline bool PKRCRoomData::has_m_option() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PKRCRoomData::set_has_m_option() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PKRCRoomData::clear_has_m_option() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PKRCRoomData::clear_m_option() {
  if (m_option_ != NULL) m_option_->::PKOption::Clear();
  clear_has_m_option();
}
inline const ::PKOption& PKRCRoomData::m_option() const {
  return m_option_ != NULL ? *m_option_ : *default_instance_->m_option_;
}
inline ::PKOption* PKRCRoomData::mutable_m_option() {
  set_has_m_option();
  if (m_option_ == NULL) m_option_ = new ::PKOption;
  return m_option_;
}
inline ::PKOption* PKRCRoomData::release_m_option() {
  clear_has_m_option();
  ::PKOption* temp = m_option_;
  m_option_ = NULL;
  return temp;
}

// optional .PKUITable m_tblUI = 5;
inline bool PKRCRoomData::has_m_tblui() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PKRCRoomData::set_has_m_tblui() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PKRCRoomData::clear_has_m_tblui() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PKRCRoomData::clear_m_tblui() {
  if (m_tblui_ != NULL) m_tblui_->::PKUITable::Clear();
  clear_has_m_tblui();
}
inline const ::PKUITable& PKRCRoomData::m_tblui() const {
  return m_tblui_ != NULL ? *m_tblui_ : *default_instance_->m_tblui_;
}
inline ::PKUITable* PKRCRoomData::mutable_m_tblui() {
  set_has_m_tblui();
  if (m_tblui_ == NULL) m_tblui_ = new ::PKUITable;
  return m_tblui_;
}
inline ::PKUITable* PKRCRoomData::release_m_tblui() {
  clear_has_m_tblui();
  ::PKUITable* temp = m_tblui_;
  m_tblui_ = NULL;
  return temp;
}

// optional .PKCardTable m_tblCard = 6;
inline bool PKRCRoomData::has_m_tblcard() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PKRCRoomData::set_has_m_tblcard() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PKRCRoomData::clear_has_m_tblcard() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PKRCRoomData::clear_m_tblcard() {
  if (m_tblcard_ != NULL) m_tblcard_->::PKCardTable::Clear();
  clear_has_m_tblcard();
}
inline const ::PKCardTable& PKRCRoomData::m_tblcard() const {
  return m_tblcard_ != NULL ? *m_tblcard_ : *default_instance_->m_tblcard_;
}
inline ::PKCardTable* PKRCRoomData::mutable_m_tblcard() {
  set_has_m_tblcard();
  if (m_tblcard_ == NULL) m_tblcard_ = new ::PKCardTable;
  return m_tblcard_;
}
inline ::PKCardTable* PKRCRoomData::release_m_tblcard() {
  clear_has_m_tblcard();
  ::PKCardTable* temp = m_tblcard_;
  m_tblcard_ = NULL;
  return temp;
}

// optional .PKMoneyTable m_tblMoney = 7;
inline bool PKRCRoomData::has_m_tblmoney() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PKRCRoomData::set_has_m_tblmoney() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PKRCRoomData::clear_has_m_tblmoney() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PKRCRoomData::clear_m_tblmoney() {
  if (m_tblmoney_ != NULL) m_tblmoney_->::PKMoneyTable::Clear();
  clear_has_m_tblmoney();
}
inline const ::PKMoneyTable& PKRCRoomData::m_tblmoney() const {
  return m_tblmoney_ != NULL ? *m_tblmoney_ : *default_instance_->m_tblmoney_;
}
inline ::PKMoneyTable* PKRCRoomData::mutable_m_tblmoney() {
  set_has_m_tblmoney();
  if (m_tblmoney_ == NULL) m_tblmoney_ = new ::PKMoneyTable;
  return m_tblmoney_;
}
inline ::PKMoneyTable* PKRCRoomData::release_m_tblmoney() {
  clear_has_m_tblmoney();
  ::PKMoneyTable* temp = m_tblmoney_;
  m_tblmoney_ = NULL;
  return temp;
}

// optional .PKBettingMsgTable m_tblBettingMsg = 8;
inline bool PKRCRoomData::has_m_tblbettingmsg() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PKRCRoomData::set_has_m_tblbettingmsg() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PKRCRoomData::clear_has_m_tblbettingmsg() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PKRCRoomData::clear_m_tblbettingmsg() {
  if (m_tblbettingmsg_ != NULL) m_tblbettingmsg_->::PKBettingMsgTable::Clear();
  clear_has_m_tblbettingmsg();
}
inline const ::PKBettingMsgTable& PKRCRoomData::m_tblbettingmsg() const {
  return m_tblbettingmsg_ != NULL ? *m_tblbettingmsg_ : *default_instance_->m_tblbettingmsg_;
}
inline ::PKBettingMsgTable* PKRCRoomData::mutable_m_tblbettingmsg() {
  set_has_m_tblbettingmsg();
  if (m_tblbettingmsg_ == NULL) m_tblbettingmsg_ = new ::PKBettingMsgTable;
  return m_tblbettingmsg_;
}
inline ::PKBettingMsgTable* PKRCRoomData::release_m_tblbettingmsg() {
  clear_has_m_tblbettingmsg();
  ::PKBettingMsgTable* temp = m_tblbettingmsg_;
  m_tblbettingmsg_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// PKSPUserBaseInfo

// required int32 m_lUSN = 1;
inline bool PKSPUserBaseInfo::has_m_lusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKSPUserBaseInfo::set_has_m_lusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKSPUserBaseInfo::clear_has_m_lusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKSPUserBaseInfo::clear_m_lusn() {
  m_lusn_ = 0;
  clear_has_m_lusn();
}
inline ::google::protobuf::int32 PKSPUserBaseInfo::m_lusn() const {
  return m_lusn_;
}
inline void PKSPUserBaseInfo::set_m_lusn(::google::protobuf::int32 value) {
  set_has_m_lusn();
  m_lusn_ = value;
}

// required string m_sUserID = 2;
inline bool PKSPUserBaseInfo::has_m_suserid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKSPUserBaseInfo::set_has_m_suserid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKSPUserBaseInfo::clear_has_m_suserid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKSPUserBaseInfo::clear_m_suserid() {
  if (m_suserid_ != &::google::protobuf::internal::kEmptyString) {
    m_suserid_->clear();
  }
  clear_has_m_suserid();
}
inline const ::std::string& PKSPUserBaseInfo::m_suserid() const {
  return *m_suserid_;
}
inline void PKSPUserBaseInfo::set_m_suserid(const ::std::string& value) {
  set_has_m_suserid();
  if (m_suserid_ == &::google::protobuf::internal::kEmptyString) {
    m_suserid_ = new ::std::string;
  }
  m_suserid_->assign(value);
}
inline void PKSPUserBaseInfo::set_m_suserid(const char* value) {
  set_has_m_suserid();
  if (m_suserid_ == &::google::protobuf::internal::kEmptyString) {
    m_suserid_ = new ::std::string;
  }
  m_suserid_->assign(value);
}
inline void PKSPUserBaseInfo::set_m_suserid(const char* value, size_t size) {
  set_has_m_suserid();
  if (m_suserid_ == &::google::protobuf::internal::kEmptyString) {
    m_suserid_ = new ::std::string;
  }
  m_suserid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PKSPUserBaseInfo::mutable_m_suserid() {
  set_has_m_suserid();
  if (m_suserid_ == &::google::protobuf::internal::kEmptyString) {
    m_suserid_ = new ::std::string;
  }
  return m_suserid_;
}
inline ::std::string* PKSPUserBaseInfo::release_m_suserid() {
  clear_has_m_suserid();
  if (m_suserid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_suserid_;
    m_suserid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string m_sNickName = 3;
inline bool PKSPUserBaseInfo::has_m_snickname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PKSPUserBaseInfo::set_has_m_snickname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PKSPUserBaseInfo::clear_has_m_snickname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PKSPUserBaseInfo::clear_m_snickname() {
  if (m_snickname_ != &::google::protobuf::internal::kEmptyString) {
    m_snickname_->clear();
  }
  clear_has_m_snickname();
}
inline const ::std::string& PKSPUserBaseInfo::m_snickname() const {
  return *m_snickname_;
}
inline void PKSPUserBaseInfo::set_m_snickname(const ::std::string& value) {
  set_has_m_snickname();
  if (m_snickname_ == &::google::protobuf::internal::kEmptyString) {
    m_snickname_ = new ::std::string;
  }
  m_snickname_->assign(value);
}
inline void PKSPUserBaseInfo::set_m_snickname(const char* value) {
  set_has_m_snickname();
  if (m_snickname_ == &::google::protobuf::internal::kEmptyString) {
    m_snickname_ = new ::std::string;
  }
  m_snickname_->assign(value);
}
inline void PKSPUserBaseInfo::set_m_snickname(const char* value, size_t size) {
  set_has_m_snickname();
  if (m_snickname_ == &::google::protobuf::internal::kEmptyString) {
    m_snickname_ = new ::std::string;
  }
  m_snickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PKSPUserBaseInfo::mutable_m_snickname() {
  set_has_m_snickname();
  if (m_snickname_ == &::google::protobuf::internal::kEmptyString) {
    m_snickname_ = new ::std::string;
  }
  return m_snickname_;
}
inline ::std::string* PKSPUserBaseInfo::release_m_snickname() {
  clear_has_m_snickname();
  if (m_snickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_snickname_;
    m_snickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 m_lUSC = 4;
inline bool PKSPUserBaseInfo::has_m_lusc() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PKSPUserBaseInfo::set_has_m_lusc() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PKSPUserBaseInfo::clear_has_m_lusc() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PKSPUserBaseInfo::clear_m_lusc() {
  m_lusc_ = 0;
  clear_has_m_lusc();
}
inline ::google::protobuf::int32 PKSPUserBaseInfo::m_lusc() const {
  return m_lusc_;
}
inline void PKSPUserBaseInfo::set_m_lusc(::google::protobuf::int32 value) {
  set_has_m_lusc();
  m_lusc_ = value;
}

// required int32 m_lJumin = 5;
inline bool PKSPUserBaseInfo::has_m_ljumin() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PKSPUserBaseInfo::set_has_m_ljumin() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PKSPUserBaseInfo::clear_has_m_ljumin() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PKSPUserBaseInfo::clear_m_ljumin() {
  m_ljumin_ = 0;
  clear_has_m_ljumin();
}
inline ::google::protobuf::int32 PKSPUserBaseInfo::m_ljumin() const {
  return m_ljumin_;
}
inline void PKSPUserBaseInfo::set_m_ljumin(::google::protobuf::int32 value) {
  set_has_m_ljumin();
  m_ljumin_ = value;
}

// required int32 m_lFirstUSN = 6;
inline bool PKSPUserBaseInfo::has_m_lfirstusn() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PKSPUserBaseInfo::set_has_m_lfirstusn() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PKSPUserBaseInfo::clear_has_m_lfirstusn() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PKSPUserBaseInfo::clear_m_lfirstusn() {
  m_lfirstusn_ = 0;
  clear_has_m_lfirstusn();
}
inline ::google::protobuf::int32 PKSPUserBaseInfo::m_lfirstusn() const {
  return m_lfirstusn_;
}
inline void PKSPUserBaseInfo::set_m_lfirstusn(::google::protobuf::int32 value) {
  set_has_m_lfirstusn();
  m_lfirstusn_ = value;
}

// required int32 m_lAgeIndex = 7;
inline bool PKSPUserBaseInfo::has_m_lageindex() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PKSPUserBaseInfo::set_has_m_lageindex() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PKSPUserBaseInfo::clear_has_m_lageindex() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PKSPUserBaseInfo::clear_m_lageindex() {
  m_lageindex_ = 0;
  clear_has_m_lageindex();
}
inline ::google::protobuf::int32 PKSPUserBaseInfo::m_lageindex() const {
  return m_lageindex_;
}
inline void PKSPUserBaseInfo::set_m_lageindex(::google::protobuf::int32 value) {
  set_has_m_lageindex();
  m_lageindex_ = value;
}

// required int32 m_lJobIndex = 8;
inline bool PKSPUserBaseInfo::has_m_ljobindex() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PKSPUserBaseInfo::set_has_m_ljobindex() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PKSPUserBaseInfo::clear_has_m_ljobindex() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PKSPUserBaseInfo::clear_m_ljobindex() {
  m_ljobindex_ = 0;
  clear_has_m_ljobindex();
}
inline ::google::protobuf::int32 PKSPUserBaseInfo::m_ljobindex() const {
  return m_ljobindex_;
}
inline void PKSPUserBaseInfo::set_m_ljobindex(::google::protobuf::int32 value) {
  set_has_m_ljobindex();
  m_ljobindex_ = value;
}

// required int32 m_lRegionIndex = 9;
inline bool PKSPUserBaseInfo::has_m_lregionindex() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PKSPUserBaseInfo::set_has_m_lregionindex() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PKSPUserBaseInfo::clear_has_m_lregionindex() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PKSPUserBaseInfo::clear_m_lregionindex() {
  m_lregionindex_ = 0;
  clear_has_m_lregionindex();
}
inline ::google::protobuf::int32 PKSPUserBaseInfo::m_lregionindex() const {
  return m_lregionindex_;
}
inline void PKSPUserBaseInfo::set_m_lregionindex(::google::protobuf::int32 value) {
  set_has_m_lregionindex();
  m_lregionindex_ = value;
}

// required int32 m_lGuildIndex = 10;
inline bool PKSPUserBaseInfo::has_m_lguildindex() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PKSPUserBaseInfo::set_has_m_lguildindex() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PKSPUserBaseInfo::clear_has_m_lguildindex() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PKSPUserBaseInfo::clear_m_lguildindex() {
  m_lguildindex_ = 0;
  clear_has_m_lguildindex();
}
inline ::google::protobuf::int32 PKSPUserBaseInfo::m_lguildindex() const {
  return m_lguildindex_;
}
inline void PKSPUserBaseInfo::set_m_lguildindex(::google::protobuf::int32 value) {
  set_has_m_lguildindex();
  m_lguildindex_ = value;
}

// required int32 m_lMemberIndex = 11;
inline bool PKSPUserBaseInfo::has_m_lmemberindex() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PKSPUserBaseInfo::set_has_m_lmemberindex() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PKSPUserBaseInfo::clear_has_m_lmemberindex() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PKSPUserBaseInfo::clear_m_lmemberindex() {
  m_lmemberindex_ = 0;
  clear_has_m_lmemberindex();
}
inline ::google::protobuf::int32 PKSPUserBaseInfo::m_lmemberindex() const {
  return m_lmemberindex_;
}
inline void PKSPUserBaseInfo::set_m_lmemberindex(::google::protobuf::int32 value) {
  set_has_m_lmemberindex();
  m_lmemberindex_ = value;
}

// required int32 m_lClientIP = 12;
inline bool PKSPUserBaseInfo::has_m_lclientip() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PKSPUserBaseInfo::set_has_m_lclientip() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PKSPUserBaseInfo::clear_has_m_lclientip() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PKSPUserBaseInfo::clear_m_lclientip() {
  m_lclientip_ = 0;
  clear_has_m_lclientip();
}
inline ::google::protobuf::int32 PKSPUserBaseInfo::m_lclientip() const {
  return m_lclientip_;
}
inline void PKSPUserBaseInfo::set_m_lclientip(::google::protobuf::int32 value) {
  set_has_m_lclientip();
  m_lclientip_ = value;
}

// required int32 m_lGatewayIP = 13;
inline bool PKSPUserBaseInfo::has_m_lgatewayip() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PKSPUserBaseInfo::set_has_m_lgatewayip() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PKSPUserBaseInfo::clear_has_m_lgatewayip() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PKSPUserBaseInfo::clear_m_lgatewayip() {
  m_lgatewayip_ = 0;
  clear_has_m_lgatewayip();
}
inline ::google::protobuf::int32 PKSPUserBaseInfo::m_lgatewayip() const {
  return m_lgatewayip_;
}
inline void PKSPUserBaseInfo::set_m_lgatewayip(::google::protobuf::int32 value) {
  set_has_m_lgatewayip();
  m_lgatewayip_ = value;
}

// required int32 m_lMacAddress = 14;
inline bool PKSPUserBaseInfo::has_m_lmacaddress() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PKSPUserBaseInfo::set_has_m_lmacaddress() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PKSPUserBaseInfo::clear_has_m_lmacaddress() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PKSPUserBaseInfo::clear_m_lmacaddress() {
  m_lmacaddress_ = 0;
  clear_has_m_lmacaddress();
}
inline ::google::protobuf::int32 PKSPUserBaseInfo::m_lmacaddress() const {
  return m_lmacaddress_;
}
inline void PKSPUserBaseInfo::set_m_lmacaddress(::google::protobuf::int32 value) {
  set_has_m_lmacaddress();
  m_lmacaddress_ = value;
}

// required string m_sMobileInfo = 15;
inline bool PKSPUserBaseInfo::has_m_smobileinfo() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void PKSPUserBaseInfo::set_has_m_smobileinfo() {
  _has_bits_[0] |= 0x00004000u;
}
inline void PKSPUserBaseInfo::clear_has_m_smobileinfo() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void PKSPUserBaseInfo::clear_m_smobileinfo() {
  if (m_smobileinfo_ != &::google::protobuf::internal::kEmptyString) {
    m_smobileinfo_->clear();
  }
  clear_has_m_smobileinfo();
}
inline const ::std::string& PKSPUserBaseInfo::m_smobileinfo() const {
  return *m_smobileinfo_;
}
inline void PKSPUserBaseInfo::set_m_smobileinfo(const ::std::string& value) {
  set_has_m_smobileinfo();
  if (m_smobileinfo_ == &::google::protobuf::internal::kEmptyString) {
    m_smobileinfo_ = new ::std::string;
  }
  m_smobileinfo_->assign(value);
}
inline void PKSPUserBaseInfo::set_m_smobileinfo(const char* value) {
  set_has_m_smobileinfo();
  if (m_smobileinfo_ == &::google::protobuf::internal::kEmptyString) {
    m_smobileinfo_ = new ::std::string;
  }
  m_smobileinfo_->assign(value);
}
inline void PKSPUserBaseInfo::set_m_smobileinfo(const char* value, size_t size) {
  set_has_m_smobileinfo();
  if (m_smobileinfo_ == &::google::protobuf::internal::kEmptyString) {
    m_smobileinfo_ = new ::std::string;
  }
  m_smobileinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PKSPUserBaseInfo::mutable_m_smobileinfo() {
  set_has_m_smobileinfo();
  if (m_smobileinfo_ == &::google::protobuf::internal::kEmptyString) {
    m_smobileinfo_ = new ::std::string;
  }
  return m_smobileinfo_;
}
inline ::std::string* PKSPUserBaseInfo::release_m_smobileinfo() {
  clear_has_m_smobileinfo();
  if (m_smobileinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_smobileinfo_;
    m_smobileinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string m_sAuthKey = 16;
inline bool PKSPUserBaseInfo::has_m_sauthkey() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void PKSPUserBaseInfo::set_has_m_sauthkey() {
  _has_bits_[0] |= 0x00008000u;
}
inline void PKSPUserBaseInfo::clear_has_m_sauthkey() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void PKSPUserBaseInfo::clear_m_sauthkey() {
  if (m_sauthkey_ != &::google::protobuf::internal::kEmptyString) {
    m_sauthkey_->clear();
  }
  clear_has_m_sauthkey();
}
inline const ::std::string& PKSPUserBaseInfo::m_sauthkey() const {
  return *m_sauthkey_;
}
inline void PKSPUserBaseInfo::set_m_sauthkey(const ::std::string& value) {
  set_has_m_sauthkey();
  if (m_sauthkey_ == &::google::protobuf::internal::kEmptyString) {
    m_sauthkey_ = new ::std::string;
  }
  m_sauthkey_->assign(value);
}
inline void PKSPUserBaseInfo::set_m_sauthkey(const char* value) {
  set_has_m_sauthkey();
  if (m_sauthkey_ == &::google::protobuf::internal::kEmptyString) {
    m_sauthkey_ = new ::std::string;
  }
  m_sauthkey_->assign(value);
}
inline void PKSPUserBaseInfo::set_m_sauthkey(const char* value, size_t size) {
  set_has_m_sauthkey();
  if (m_sauthkey_ == &::google::protobuf::internal::kEmptyString) {
    m_sauthkey_ = new ::std::string;
  }
  m_sauthkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PKSPUserBaseInfo::mutable_m_sauthkey() {
  set_has_m_sauthkey();
  if (m_sauthkey_ == &::google::protobuf::internal::kEmptyString) {
    m_sauthkey_ = new ::std::string;
  }
  return m_sauthkey_;
}
inline ::std::string* PKSPUserBaseInfo::release_m_sauthkey() {
  clear_has_m_sauthkey();
  if (m_sauthkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_sauthkey_;
    m_sauthkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// PKMsgCS_Entry

// required int32 m_nVersion = 1;
inline bool PKMsgCS_Entry::has_m_nversion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgCS_Entry::set_has_m_nversion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgCS_Entry::clear_has_m_nversion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgCS_Entry::clear_m_nversion() {
  m_nversion_ = 0;
  clear_has_m_nversion();
}
inline ::google::protobuf::int32 PKMsgCS_Entry::m_nversion() const {
  return m_nversion_;
}
inline void PKMsgCS_Entry::set_m_nversion(::google::protobuf::int32 value) {
  set_has_m_nversion();
  m_nversion_ = value;
}

// required sint32 m_bWelcomeSound = 2;
inline bool PKMsgCS_Entry::has_m_bwelcomesound() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKMsgCS_Entry::set_has_m_bwelcomesound() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKMsgCS_Entry::clear_has_m_bwelcomesound() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKMsgCS_Entry::clear_m_bwelcomesound() {
  m_bwelcomesound_ = 0;
  clear_has_m_bwelcomesound();
}
inline ::google::protobuf::int32 PKMsgCS_Entry::m_bwelcomesound() const {
  return m_bwelcomesound_;
}
inline void PKMsgCS_Entry::set_m_bwelcomesound(::google::protobuf::int32 value) {
  set_has_m_bwelcomesound();
  m_bwelcomesound_ = value;
}

// required sint32 m_lSoundType = 3;
inline bool PKMsgCS_Entry::has_m_lsoundtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PKMsgCS_Entry::set_has_m_lsoundtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PKMsgCS_Entry::clear_has_m_lsoundtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PKMsgCS_Entry::clear_m_lsoundtype() {
  m_lsoundtype_ = 0;
  clear_has_m_lsoundtype();
}
inline ::google::protobuf::int32 PKMsgCS_Entry::m_lsoundtype() const {
  return m_lsoundtype_;
}
inline void PKMsgCS_Entry::set_m_lsoundtype(::google::protobuf::int32 value) {
  set_has_m_lsoundtype();
  m_lsoundtype_ = value;
}

// required string m_sNickName = 4;
inline bool PKMsgCS_Entry::has_m_snickname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PKMsgCS_Entry::set_has_m_snickname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PKMsgCS_Entry::clear_has_m_snickname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PKMsgCS_Entry::clear_m_snickname() {
  if (m_snickname_ != &::google::protobuf::internal::kEmptyString) {
    m_snickname_->clear();
  }
  clear_has_m_snickname();
}
inline const ::std::string& PKMsgCS_Entry::m_snickname() const {
  return *m_snickname_;
}
inline void PKMsgCS_Entry::set_m_snickname(const ::std::string& value) {
  set_has_m_snickname();
  if (m_snickname_ == &::google::protobuf::internal::kEmptyString) {
    m_snickname_ = new ::std::string;
  }
  m_snickname_->assign(value);
}
inline void PKMsgCS_Entry::set_m_snickname(const char* value) {
  set_has_m_snickname();
  if (m_snickname_ == &::google::protobuf::internal::kEmptyString) {
    m_snickname_ = new ::std::string;
  }
  m_snickname_->assign(value);
}
inline void PKMsgCS_Entry::set_m_snickname(const char* value, size_t size) {
  set_has_m_snickname();
  if (m_snickname_ == &::google::protobuf::internal::kEmptyString) {
    m_snickname_ = new ::std::string;
  }
  m_snickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PKMsgCS_Entry::mutable_m_snickname() {
  set_has_m_snickname();
  if (m_snickname_ == &::google::protobuf::internal::kEmptyString) {
    m_snickname_ = new ::std::string;
  }
  return m_snickname_;
}
inline ::std::string* PKMsgCS_Entry::release_m_snickname() {
  clear_has_m_snickname();
  if (m_snickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_snickname_;
    m_snickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string m_sAvt = 5;
inline bool PKMsgCS_Entry::has_m_savt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PKMsgCS_Entry::set_has_m_savt() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PKMsgCS_Entry::clear_has_m_savt() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PKMsgCS_Entry::clear_m_savt() {
  if (m_savt_ != &::google::protobuf::internal::kEmptyString) {
    m_savt_->clear();
  }
  clear_has_m_savt();
}
inline const ::std::string& PKMsgCS_Entry::m_savt() const {
  return *m_savt_;
}
inline void PKMsgCS_Entry::set_m_savt(const ::std::string& value) {
  set_has_m_savt();
  if (m_savt_ == &::google::protobuf::internal::kEmptyString) {
    m_savt_ = new ::std::string;
  }
  m_savt_->assign(value);
}
inline void PKMsgCS_Entry::set_m_savt(const char* value) {
  set_has_m_savt();
  if (m_savt_ == &::google::protobuf::internal::kEmptyString) {
    m_savt_ = new ::std::string;
  }
  m_savt_->assign(value);
}
inline void PKMsgCS_Entry::set_m_savt(const char* value, size_t size) {
  set_has_m_savt();
  if (m_savt_ == &::google::protobuf::internal::kEmptyString) {
    m_savt_ = new ::std::string;
  }
  m_savt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PKMsgCS_Entry::mutable_m_savt() {
  set_has_m_savt();
  if (m_savt_ == &::google::protobuf::internal::kEmptyString) {
    m_savt_ = new ::std::string;
  }
  return m_savt_;
}
inline ::std::string* PKMsgCS_Entry::release_m_savt() {
  clear_has_m_savt();
  if (m_savt_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_savt_;
    m_savt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required sint32 m_lCLevel = 6;
inline bool PKMsgCS_Entry::has_m_lclevel() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PKMsgCS_Entry::set_has_m_lclevel() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PKMsgCS_Entry::clear_has_m_lclevel() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PKMsgCS_Entry::clear_m_lclevel() {
  m_lclevel_ = 0;
  clear_has_m_lclevel();
}
inline ::google::protobuf::int32 PKMsgCS_Entry::m_lclevel() const {
  return m_lclevel_;
}
inline void PKMsgCS_Entry::set_m_lclevel(::google::protobuf::int32 value) {
  set_has_m_lclevel();
  m_lclevel_ = value;
}

// required sint32 m_lSex = 7;
inline bool PKMsgCS_Entry::has_m_lsex() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PKMsgCS_Entry::set_has_m_lsex() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PKMsgCS_Entry::clear_has_m_lsex() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PKMsgCS_Entry::clear_m_lsex() {
  m_lsex_ = 0;
  clear_has_m_lsex();
}
inline ::google::protobuf::int32 PKMsgCS_Entry::m_lsex() const {
  return m_lsex_;
}
inline void PKMsgCS_Entry::set_m_lsex(::google::protobuf::int32 value) {
  set_has_m_lsex();
  m_lsex_ = value;
}

// -------------------------------------------------------------------

// PKMsgCS_Observe

// -------------------------------------------------------------------

// PKMsgCS_Start

// -------------------------------------------------------------------

// PKMsgCS_SelectedCardReq

// required sint32 m_lCardIdx = 1;
inline bool PKMsgCS_SelectedCardReq::has_m_lcardidx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgCS_SelectedCardReq::set_has_m_lcardidx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgCS_SelectedCardReq::clear_has_m_lcardidx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgCS_SelectedCardReq::clear_m_lcardidx() {
  m_lcardidx_ = 0;
  clear_has_m_lcardidx();
}
inline ::google::protobuf::int32 PKMsgCS_SelectedCardReq::m_lcardidx() const {
  return m_lcardidx_;
}
inline void PKMsgCS_SelectedCardReq::set_m_lcardidx(::google::protobuf::int32 value) {
  set_has_m_lcardidx();
  m_lcardidx_ = value;
}

// -------------------------------------------------------------------

// PKMsgCS_BettingReq

// required sint32 m_lBetType = 1;
inline bool PKMsgCS_BettingReq::has_m_lbettype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgCS_BettingReq::set_has_m_lbettype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgCS_BettingReq::clear_has_m_lbettype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgCS_BettingReq::clear_m_lbettype() {
  m_lbettype_ = 0;
  clear_has_m_lbettype();
}
inline ::google::protobuf::int32 PKMsgCS_BettingReq::m_lbettype() const {
  return m_lbettype_;
}
inline void PKMsgCS_BettingReq::set_m_lbettype(::google::protobuf::int32 value) {
  set_has_m_lbettype();
  m_lbettype_ = value;
}

// -------------------------------------------------------------------

// PKMsgCS_ChoiceRemoveCard

// required sint32 m_lUSN = 1;
inline bool PKMsgCS_ChoiceRemoveCard::has_m_lusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgCS_ChoiceRemoveCard::set_has_m_lusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgCS_ChoiceRemoveCard::clear_has_m_lusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgCS_ChoiceRemoveCard::clear_m_lusn() {
  m_lusn_ = 0;
  clear_has_m_lusn();
}
inline ::google::protobuf::int32 PKMsgCS_ChoiceRemoveCard::m_lusn() const {
  return m_lusn_;
}
inline void PKMsgCS_ChoiceRemoveCard::set_m_lusn(::google::protobuf::int32 value) {
  set_has_m_lusn();
  m_lusn_ = value;
}

// required int32 m_nRemoveCardIndex = 2;
inline bool PKMsgCS_ChoiceRemoveCard::has_m_nremovecardindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKMsgCS_ChoiceRemoveCard::set_has_m_nremovecardindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKMsgCS_ChoiceRemoveCard::clear_has_m_nremovecardindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKMsgCS_ChoiceRemoveCard::clear_m_nremovecardindex() {
  m_nremovecardindex_ = 0;
  clear_has_m_nremovecardindex();
}
inline ::google::protobuf::int32 PKMsgCS_ChoiceRemoveCard::m_nremovecardindex() const {
  return m_nremovecardindex_;
}
inline void PKMsgCS_ChoiceRemoveCard::set_m_nremovecardindex(::google::protobuf::int32 value) {
  set_has_m_nremovecardindex();
  m_nremovecardindex_ = value;
}

// -------------------------------------------------------------------

// PKMsgCS_Purge

// required sint32 m_lType = 1;
inline bool PKMsgCS_Purge::has_m_ltype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgCS_Purge::set_has_m_ltype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgCS_Purge::clear_has_m_ltype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgCS_Purge::clear_m_ltype() {
  m_ltype_ = 0;
  clear_has_m_ltype();
}
inline ::google::protobuf::int32 PKMsgCS_Purge::m_ltype() const {
  return m_ltype_;
}
inline void PKMsgCS_Purge::set_m_ltype(::google::protobuf::int32 value) {
  set_has_m_ltype();
  m_ltype_ = value;
}

// required sint32 m_lPurgeUSN = 2;
inline bool PKMsgCS_Purge::has_m_lpurgeusn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKMsgCS_Purge::set_has_m_lpurgeusn() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKMsgCS_Purge::clear_has_m_lpurgeusn() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKMsgCS_Purge::clear_m_lpurgeusn() {
  m_lpurgeusn_ = 0;
  clear_has_m_lpurgeusn();
}
inline ::google::protobuf::int32 PKMsgCS_Purge::m_lpurgeusn() const {
  return m_lpurgeusn_;
}
inline void PKMsgCS_Purge::set_m_lpurgeusn(::google::protobuf::int32 value) {
  set_has_m_lpurgeusn();
  m_lpurgeusn_ = value;
}

// -------------------------------------------------------------------

// PKMsgCS_Abuse

// required sint32 m_lType = 1;
inline bool PKMsgCS_Abuse::has_m_ltype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgCS_Abuse::set_has_m_ltype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgCS_Abuse::clear_has_m_ltype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgCS_Abuse::clear_m_ltype() {
  m_ltype_ = 0;
  clear_has_m_ltype();
}
inline ::google::protobuf::int32 PKMsgCS_Abuse::m_ltype() const {
  return m_ltype_;
}
inline void PKMsgCS_Abuse::set_m_ltype(::google::protobuf::int32 value) {
  set_has_m_ltype();
  m_ltype_ = value;
}

// required string m_sDay = 2;
inline bool PKMsgCS_Abuse::has_m_sday() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKMsgCS_Abuse::set_has_m_sday() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKMsgCS_Abuse::clear_has_m_sday() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKMsgCS_Abuse::clear_m_sday() {
  if (m_sday_ != &::google::protobuf::internal::kEmptyString) {
    m_sday_->clear();
  }
  clear_has_m_sday();
}
inline const ::std::string& PKMsgCS_Abuse::m_sday() const {
  return *m_sday_;
}
inline void PKMsgCS_Abuse::set_m_sday(const ::std::string& value) {
  set_has_m_sday();
  if (m_sday_ == &::google::protobuf::internal::kEmptyString) {
    m_sday_ = new ::std::string;
  }
  m_sday_->assign(value);
}
inline void PKMsgCS_Abuse::set_m_sday(const char* value) {
  set_has_m_sday();
  if (m_sday_ == &::google::protobuf::internal::kEmptyString) {
    m_sday_ = new ::std::string;
  }
  m_sday_->assign(value);
}
inline void PKMsgCS_Abuse::set_m_sday(const char* value, size_t size) {
  set_has_m_sday();
  if (m_sday_ == &::google::protobuf::internal::kEmptyString) {
    m_sday_ = new ::std::string;
  }
  m_sday_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PKMsgCS_Abuse::mutable_m_sday() {
  set_has_m_sday();
  if (m_sday_ == &::google::protobuf::internal::kEmptyString) {
    m_sday_ = new ::std::string;
  }
  return m_sday_;
}
inline ::std::string* PKMsgCS_Abuse::release_m_sday() {
  clear_has_m_sday();
  if (m_sday_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_sday_;
    m_sday_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// PKMsgCS_AskPurgeVote

// required sint32 m_lPurgeUSN = 1;
inline bool PKMsgCS_AskPurgeVote::has_m_lpurgeusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgCS_AskPurgeVote::set_has_m_lpurgeusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgCS_AskPurgeVote::clear_has_m_lpurgeusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgCS_AskPurgeVote::clear_m_lpurgeusn() {
  m_lpurgeusn_ = 0;
  clear_has_m_lpurgeusn();
}
inline ::google::protobuf::int32 PKMsgCS_AskPurgeVote::m_lpurgeusn() const {
  return m_lpurgeusn_;
}
inline void PKMsgCS_AskPurgeVote::set_m_lpurgeusn(::google::protobuf::int32 value) {
  set_has_m_lpurgeusn();
  m_lpurgeusn_ = value;
}

// -------------------------------------------------------------------

// PKMsgCS_AnswerPurgeVote

// required sint32 m_lAnswer = 1;
inline bool PKMsgCS_AnswerPurgeVote::has_m_lanswer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgCS_AnswerPurgeVote::set_has_m_lanswer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgCS_AnswerPurgeVote::clear_has_m_lanswer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgCS_AnswerPurgeVote::clear_m_lanswer() {
  m_lanswer_ = 0;
  clear_has_m_lanswer();
}
inline ::google::protobuf::int32 PKMsgCS_AnswerPurgeVote::m_lanswer() const {
  return m_lanswer_;
}
inline void PKMsgCS_AnswerPurgeVote::set_m_lanswer(::google::protobuf::int32 value) {
  set_has_m_lanswer();
  m_lanswer_ = value;
}

// -------------------------------------------------------------------

// PKMsgCS_WaitingUserTicketReq

// required int32 m_nType = 1;
inline bool PKMsgCS_WaitingUserTicketReq::has_m_ntype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgCS_WaitingUserTicketReq::set_has_m_ntype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgCS_WaitingUserTicketReq::clear_has_m_ntype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgCS_WaitingUserTicketReq::clear_m_ntype() {
  m_ntype_ = 0;
  clear_has_m_ntype();
}
inline ::google::protobuf::int32 PKMsgCS_WaitingUserTicketReq::m_ntype() const {
  return m_ntype_;
}
inline void PKMsgCS_WaitingUserTicketReq::set_m_ntype(::google::protobuf::int32 value) {
  set_has_m_ntype();
  m_ntype_ = value;
}

// required sint32 m_bValue = 2;
inline bool PKMsgCS_WaitingUserTicketReq::has_m_bvalue() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKMsgCS_WaitingUserTicketReq::set_has_m_bvalue() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKMsgCS_WaitingUserTicketReq::clear_has_m_bvalue() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKMsgCS_WaitingUserTicketReq::clear_m_bvalue() {
  m_bvalue_ = 0;
  clear_has_m_bvalue();
}
inline ::google::protobuf::int32 PKMsgCS_WaitingUserTicketReq::m_bvalue() const {
  return m_bvalue_;
}
inline void PKMsgCS_WaitingUserTicketReq::set_m_bvalue(::google::protobuf::int32 value) {
  set_has_m_bvalue();
  m_bvalue_ = value;
}

// -------------------------------------------------------------------

// PKMsgCS_UpdateWaitingUserInfoReq

// -------------------------------------------------------------------

// PKMsgCS_SoundType

// required sint32 m_lSoundType = 1;
inline bool PKMsgCS_SoundType::has_m_lsoundtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgCS_SoundType::set_has_m_lsoundtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgCS_SoundType::clear_has_m_lsoundtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgCS_SoundType::clear_m_lsoundtype() {
  m_lsoundtype_ = 0;
  clear_has_m_lsoundtype();
}
inline ::google::protobuf::int32 PKMsgCS_SoundType::m_lsoundtype() const {
  return m_lsoundtype_;
}
inline void PKMsgCS_SoundType::set_m_lsoundtype(::google::protobuf::int32 value) {
  set_has_m_lsoundtype();
  m_lsoundtype_ = value;
}

// -------------------------------------------------------------------

// PKMsgCS_ExitQue

// required sint32 m_lExit = 1;
inline bool PKMsgCS_ExitQue::has_m_lexit() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgCS_ExitQue::set_has_m_lexit() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgCS_ExitQue::clear_has_m_lexit() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgCS_ExitQue::clear_m_lexit() {
  m_lexit_ = 0;
  clear_has_m_lexit();
}
inline ::google::protobuf::int32 PKMsgCS_ExitQue::m_lexit() const {
  return m_lexit_;
}
inline void PKMsgCS_ExitQue::set_m_lexit(::google::protobuf::int32 value) {
  set_has_m_lexit();
  m_lexit_ = value;
}

// required sint32 m_bAction = 2;
inline bool PKMsgCS_ExitQue::has_m_baction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKMsgCS_ExitQue::set_has_m_baction() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKMsgCS_ExitQue::clear_has_m_baction() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKMsgCS_ExitQue::clear_m_baction() {
  m_baction_ = 0;
  clear_has_m_baction();
}
inline ::google::protobuf::int32 PKMsgCS_ExitQue::m_baction() const {
  return m_baction_;
}
inline void PKMsgCS_ExitQue::set_m_baction(::google::protobuf::int32 value) {
  set_has_m_baction();
  m_baction_ = value;
}

// -------------------------------------------------------------------

// PKMsgCS_Continue

// required sint32 m_lExit = 1;
inline bool PKMsgCS_Continue::has_m_lexit() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgCS_Continue::set_has_m_lexit() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgCS_Continue::clear_has_m_lexit() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgCS_Continue::clear_m_lexit() {
  m_lexit_ = 0;
  clear_has_m_lexit();
}
inline ::google::protobuf::int32 PKMsgCS_Continue::m_lexit() const {
  return m_lexit_;
}
inline void PKMsgCS_Continue::set_m_lexit(::google::protobuf::int32 value) {
  set_has_m_lexit();
  m_lexit_ = value;
}

// -------------------------------------------------------------------

// PKMsgCS_RuleSet

// required int32 m_nRuleIdx = 1;
inline bool PKMsgCS_RuleSet::has_m_nruleidx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgCS_RuleSet::set_has_m_nruleidx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgCS_RuleSet::clear_has_m_nruleidx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgCS_RuleSet::clear_m_nruleidx() {
  m_nruleidx_ = 0;
  clear_has_m_nruleidx();
}
inline ::google::protobuf::int32 PKMsgCS_RuleSet::m_nruleidx() const {
  return m_nruleidx_;
}
inline void PKMsgCS_RuleSet::set_m_nruleidx(::google::protobuf::int32 value) {
  set_has_m_nruleidx();
  m_nruleidx_ = value;
}

// -------------------------------------------------------------------

// PKMsgCS_GameMasterCall

// -------------------------------------------------------------------

// PKMsgCS_FieldReserved

// required int32 m_nReserved1 = 1;
inline bool PKMsgCS_FieldReserved::has_m_nreserved1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgCS_FieldReserved::set_has_m_nreserved1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgCS_FieldReserved::clear_has_m_nreserved1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgCS_FieldReserved::clear_m_nreserved1() {
  m_nreserved1_ = 0;
  clear_has_m_nreserved1();
}
inline ::google::protobuf::int32 PKMsgCS_FieldReserved::m_nreserved1() const {
  return m_nreserved1_;
}
inline void PKMsgCS_FieldReserved::set_m_nreserved1(::google::protobuf::int32 value) {
  set_has_m_nreserved1();
  m_nreserved1_ = value;
}

// required int32 m_nReserved2 = 2;
inline bool PKMsgCS_FieldReserved::has_m_nreserved2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKMsgCS_FieldReserved::set_has_m_nreserved2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKMsgCS_FieldReserved::clear_has_m_nreserved2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKMsgCS_FieldReserved::clear_m_nreserved2() {
  m_nreserved2_ = 0;
  clear_has_m_nreserved2();
}
inline ::google::protobuf::int32 PKMsgCS_FieldReserved::m_nreserved2() const {
  return m_nreserved2_;
}
inline void PKMsgCS_FieldReserved::set_m_nreserved2(::google::protobuf::int32 value) {
  set_has_m_nreserved2();
  m_nreserved2_ = value;
}

// -------------------------------------------------------------------

// PKMsgCS_JokboSet

// required sint32 m_lKey1 = 1;
inline bool PKMsgCS_JokboSet::has_m_lkey1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgCS_JokboSet::set_has_m_lkey1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgCS_JokboSet::clear_has_m_lkey1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgCS_JokboSet::clear_m_lkey1() {
  m_lkey1_ = 0;
  clear_has_m_lkey1();
}
inline ::google::protobuf::int32 PKMsgCS_JokboSet::m_lkey1() const {
  return m_lkey1_;
}
inline void PKMsgCS_JokboSet::set_m_lkey1(::google::protobuf::int32 value) {
  set_has_m_lkey1();
  m_lkey1_ = value;
}

// required sint32 m_lKey2 = 2;
inline bool PKMsgCS_JokboSet::has_m_lkey2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKMsgCS_JokboSet::set_has_m_lkey2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKMsgCS_JokboSet::clear_has_m_lkey2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKMsgCS_JokboSet::clear_m_lkey2() {
  m_lkey2_ = 0;
  clear_has_m_lkey2();
}
inline ::google::protobuf::int32 PKMsgCS_JokboSet::m_lkey2() const {
  return m_lkey2_;
}
inline void PKMsgCS_JokboSet::set_m_lkey2(::google::protobuf::int32 value) {
  set_has_m_lkey2();
  m_lkey2_ = value;
}

// required sint32 m_lKey3 = 3;
inline bool PKMsgCS_JokboSet::has_m_lkey3() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PKMsgCS_JokboSet::set_has_m_lkey3() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PKMsgCS_JokboSet::clear_has_m_lkey3() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PKMsgCS_JokboSet::clear_m_lkey3() {
  m_lkey3_ = 0;
  clear_has_m_lkey3();
}
inline ::google::protobuf::int32 PKMsgCS_JokboSet::m_lkey3() const {
  return m_lkey3_;
}
inline void PKMsgCS_JokboSet::set_m_lkey3(::google::protobuf::int32 value) {
  set_has_m_lkey3();
  m_lkey3_ = value;
}

// required sint32 m_lKey4 = 4;
inline bool PKMsgCS_JokboSet::has_m_lkey4() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PKMsgCS_JokboSet::set_has_m_lkey4() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PKMsgCS_JokboSet::clear_has_m_lkey4() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PKMsgCS_JokboSet::clear_m_lkey4() {
  m_lkey4_ = 0;
  clear_has_m_lkey4();
}
inline ::google::protobuf::int32 PKMsgCS_JokboSet::m_lkey4() const {
  return m_lkey4_;
}
inline void PKMsgCS_JokboSet::set_m_lkey4(::google::protobuf::int32 value) {
  set_has_m_lkey4();
  m_lkey4_ = value;
}

// required sint32 m_lKey5 = 5;
inline bool PKMsgCS_JokboSet::has_m_lkey5() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PKMsgCS_JokboSet::set_has_m_lkey5() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PKMsgCS_JokboSet::clear_has_m_lkey5() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PKMsgCS_JokboSet::clear_m_lkey5() {
  m_lkey5_ = 0;
  clear_has_m_lkey5();
}
inline ::google::protobuf::int32 PKMsgCS_JokboSet::m_lkey5() const {
  return m_lkey5_;
}
inline void PKMsgCS_JokboSet::set_m_lkey5(::google::protobuf::int32 value) {
  set_has_m_lkey5();
  m_lkey5_ = value;
}

// -------------------------------------------------------------------

// PKMsgCS_TestKeySetting

// required uint32 m_nChar = 1;
inline bool PKMsgCS_TestKeySetting::has_m_nchar() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgCS_TestKeySetting::set_has_m_nchar() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgCS_TestKeySetting::clear_has_m_nchar() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgCS_TestKeySetting::clear_m_nchar() {
  m_nchar_ = 0u;
  clear_has_m_nchar();
}
inline ::google::protobuf::uint32 PKMsgCS_TestKeySetting::m_nchar() const {
  return m_nchar_;
}
inline void PKMsgCS_TestKeySetting::set_m_nchar(::google::protobuf::uint32 value) {
  set_has_m_nchar();
  m_nchar_ = value;
}

// -------------------------------------------------------------------

// PKMsgCS_CheckNotice

// required int32 m_nType = 1;
inline bool PKMsgCS_CheckNotice::has_m_ntype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgCS_CheckNotice::set_has_m_ntype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgCS_CheckNotice::clear_has_m_ntype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgCS_CheckNotice::clear_m_ntype() {
  m_ntype_ = 0;
  clear_has_m_ntype();
}
inline ::google::protobuf::int32 PKMsgCS_CheckNotice::m_ntype() const {
  return m_ntype_;
}
inline void PKMsgCS_CheckNotice::set_m_ntype(::google::protobuf::int32 value) {
  set_has_m_ntype();
  m_ntype_ = value;
}

// -------------------------------------------------------------------

// PKMsgCS_Ack

// required int32 m_nTagID = 1;
inline bool PKMsgCS_Ack::has_m_ntagid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgCS_Ack::set_has_m_ntagid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgCS_Ack::clear_has_m_ntagid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgCS_Ack::clear_m_ntagid() {
  m_ntagid_ = 0;
  clear_has_m_ntagid();
}
inline ::google::protobuf::int32 PKMsgCS_Ack::m_ntagid() const {
  return m_ntagid_;
}
inline void PKMsgCS_Ack::set_m_ntagid(::google::protobuf::int32 value) {
  set_has_m_ntagid();
  m_ntagid_ = value;
}

// -------------------------------------------------------------------

// PKMsgCS_Ping

// -------------------------------------------------------------------

// PKMsgSC_UserJoinAns

// required sint32 m_lState = 1;
inline bool PKMsgSC_UserJoinAns::has_m_lstate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgSC_UserJoinAns::set_has_m_lstate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgSC_UserJoinAns::clear_has_m_lstate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgSC_UserJoinAns::clear_m_lstate() {
  m_lstate_ = 0;
  clear_has_m_lstate();
}
inline ::google::protobuf::int32 PKMsgSC_UserJoinAns::m_lstate() const {
  return m_lstate_;
}
inline void PKMsgSC_UserJoinAns::set_m_lstate(::google::protobuf::int32 value) {
  set_has_m_lstate();
  m_lstate_ = value;
}

// required int32 m_nEnter = 2;
inline bool PKMsgSC_UserJoinAns::has_m_nenter() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKMsgSC_UserJoinAns::set_has_m_nenter() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKMsgSC_UserJoinAns::clear_has_m_nenter() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKMsgSC_UserJoinAns::clear_m_nenter() {
  m_nenter_ = 0;
  clear_has_m_nenter();
}
inline ::google::protobuf::int32 PKMsgSC_UserJoinAns::m_nenter() const {
  return m_nenter_;
}
inline void PKMsgSC_UserJoinAns::set_m_nenter(::google::protobuf::int32 value) {
  set_has_m_nenter();
  m_nenter_ = value;
}

// required int32 m_nSet = 3;
inline bool PKMsgSC_UserJoinAns::has_m_nset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PKMsgSC_UserJoinAns::set_has_m_nset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PKMsgSC_UserJoinAns::clear_has_m_nset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PKMsgSC_UserJoinAns::clear_m_nset() {
  m_nset_ = 0;
  clear_has_m_nset();
}
inline ::google::protobuf::int32 PKMsgSC_UserJoinAns::m_nset() const {
  return m_nset_;
}
inline void PKMsgSC_UserJoinAns::set_m_nset(::google::protobuf::int32 value) {
  set_has_m_nset();
  m_nset_ = value;
}

// required int32 m_lChannel_idx = 4;
inline bool PKMsgSC_UserJoinAns::has_m_lchannel_idx() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PKMsgSC_UserJoinAns::set_has_m_lchannel_idx() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PKMsgSC_UserJoinAns::clear_has_m_lchannel_idx() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PKMsgSC_UserJoinAns::clear_m_lchannel_idx() {
  m_lchannel_idx_ = 0;
  clear_has_m_lchannel_idx();
}
inline ::google::protobuf::int32 PKMsgSC_UserJoinAns::m_lchannel_idx() const {
  return m_lchannel_idx_;
}
inline void PKMsgSC_UserJoinAns::set_m_lchannel_idx(::google::protobuf::int32 value) {
  set_has_m_lchannel_idx();
  m_lchannel_idx_ = value;
}

// required sint32 m_lOwnerUSN = 5;
inline bool PKMsgSC_UserJoinAns::has_m_lownerusn() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PKMsgSC_UserJoinAns::set_has_m_lownerusn() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PKMsgSC_UserJoinAns::clear_has_m_lownerusn() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PKMsgSC_UserJoinAns::clear_m_lownerusn() {
  m_lownerusn_ = 0;
  clear_has_m_lownerusn();
}
inline ::google::protobuf::int32 PKMsgSC_UserJoinAns::m_lownerusn() const {
  return m_lownerusn_;
}
inline void PKMsgSC_UserJoinAns::set_m_lownerusn(::google::protobuf::int32 value) {
  set_has_m_lownerusn();
  m_lownerusn_ = value;
}

// required sint32 m_lBossUSN = 6;
inline bool PKMsgSC_UserJoinAns::has_m_lbossusn() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PKMsgSC_UserJoinAns::set_has_m_lbossusn() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PKMsgSC_UserJoinAns::clear_has_m_lbossusn() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PKMsgSC_UserJoinAns::clear_m_lbossusn() {
  m_lbossusn_ = 0;
  clear_has_m_lbossusn();
}
inline ::google::protobuf::int32 PKMsgSC_UserJoinAns::m_lbossusn() const {
  return m_lbossusn_;
}
inline void PKMsgSC_UserJoinAns::set_m_lbossusn(::google::protobuf::int32 value) {
  set_has_m_lbossusn();
  m_lbossusn_ = value;
}

// required int32 m_nRoomPurgeCnt = 7;
inline bool PKMsgSC_UserJoinAns::has_m_nroompurgecnt() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PKMsgSC_UserJoinAns::set_has_m_nroompurgecnt() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PKMsgSC_UserJoinAns::clear_has_m_nroompurgecnt() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PKMsgSC_UserJoinAns::clear_m_nroompurgecnt() {
  m_nroompurgecnt_ = 0;
  clear_has_m_nroompurgecnt();
}
inline ::google::protobuf::int32 PKMsgSC_UserJoinAns::m_nroompurgecnt() const {
  return m_nroompurgecnt_;
}
inline void PKMsgSC_UserJoinAns::set_m_nroompurgecnt(::google::protobuf::int32 value) {
  set_has_m_nroompurgecnt();
  m_nroompurgecnt_ = value;
}

// required .PKOption m_option = 8;
inline bool PKMsgSC_UserJoinAns::has_m_option() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PKMsgSC_UserJoinAns::set_has_m_option() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PKMsgSC_UserJoinAns::clear_has_m_option() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PKMsgSC_UserJoinAns::clear_m_option() {
  if (m_option_ != NULL) m_option_->::PKOption::Clear();
  clear_has_m_option();
}
inline const ::PKOption& PKMsgSC_UserJoinAns::m_option() const {
  return m_option_ != NULL ? *m_option_ : *default_instance_->m_option_;
}
inline ::PKOption* PKMsgSC_UserJoinAns::mutable_m_option() {
  set_has_m_option();
  if (m_option_ == NULL) m_option_ = new ::PKOption;
  return m_option_;
}
inline ::PKOption* PKMsgSC_UserJoinAns::release_m_option() {
  clear_has_m_option();
  ::PKOption* temp = m_option_;
  m_option_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// PKMsgSC_UserJoinErr

// required sint32 m_lUSN = 1;
inline bool PKMsgSC_UserJoinErr::has_m_lusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgSC_UserJoinErr::set_has_m_lusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgSC_UserJoinErr::clear_has_m_lusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgSC_UserJoinErr::clear_m_lusn() {
  m_lusn_ = 0;
  clear_has_m_lusn();
}
inline ::google::protobuf::int32 PKMsgSC_UserJoinErr::m_lusn() const {
  return m_lusn_;
}
inline void PKMsgSC_UserJoinErr::set_m_lusn(::google::protobuf::int32 value) {
  set_has_m_lusn();
  m_lusn_ = value;
}

// required sint32 m_lErrorCode = 2;
inline bool PKMsgSC_UserJoinErr::has_m_lerrorcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKMsgSC_UserJoinErr::set_has_m_lerrorcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKMsgSC_UserJoinErr::clear_has_m_lerrorcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKMsgSC_UserJoinErr::clear_m_lerrorcode() {
  m_lerrorcode_ = 0;
  clear_has_m_lerrorcode();
}
inline ::google::protobuf::int32 PKMsgSC_UserJoinErr::m_lerrorcode() const {
  return m_lerrorcode_;
}
inline void PKMsgSC_UserJoinErr::set_m_lerrorcode(::google::protobuf::int32 value) {
  set_has_m_lerrorcode();
  m_lerrorcode_ = value;
}

// -------------------------------------------------------------------

// PKMsgSC_UserDisconnect

// required sint32 m_lUSN = 1;
inline bool PKMsgSC_UserDisconnect::has_m_lusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgSC_UserDisconnect::set_has_m_lusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgSC_UserDisconnect::clear_has_m_lusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgSC_UserDisconnect::clear_m_lusn() {
  m_lusn_ = 0;
  clear_has_m_lusn();
}
inline ::google::protobuf::int32 PKMsgSC_UserDisconnect::m_lusn() const {
  return m_lusn_;
}
inline void PKMsgSC_UserDisconnect::set_m_lusn(::google::protobuf::int32 value) {
  set_has_m_lusn();
  m_lusn_ = value;
}

// required .PKUserInfo m_uinfo = 2;
inline bool PKMsgSC_UserDisconnect::has_m_uinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKMsgSC_UserDisconnect::set_has_m_uinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKMsgSC_UserDisconnect::clear_has_m_uinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKMsgSC_UserDisconnect::clear_m_uinfo() {
  if (m_uinfo_ != NULL) m_uinfo_->::PKUserInfo::Clear();
  clear_has_m_uinfo();
}
inline const ::PKUserInfo& PKMsgSC_UserDisconnect::m_uinfo() const {
  return m_uinfo_ != NULL ? *m_uinfo_ : *default_instance_->m_uinfo_;
}
inline ::PKUserInfo* PKMsgSC_UserDisconnect::mutable_m_uinfo() {
  set_has_m_uinfo();
  if (m_uinfo_ == NULL) m_uinfo_ = new ::PKUserInfo;
  return m_uinfo_;
}
inline ::PKUserInfo* PKMsgSC_UserDisconnect::release_m_uinfo() {
  clear_has_m_uinfo();
  ::PKUserInfo* temp = m_uinfo_;
  m_uinfo_ = NULL;
  return temp;
}

// required sint32 m_lState = 3;
inline bool PKMsgSC_UserDisconnect::has_m_lstate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PKMsgSC_UserDisconnect::set_has_m_lstate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PKMsgSC_UserDisconnect::clear_has_m_lstate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PKMsgSC_UserDisconnect::clear_m_lstate() {
  m_lstate_ = 0;
  clear_has_m_lstate();
}
inline ::google::protobuf::int32 PKMsgSC_UserDisconnect::m_lstate() const {
  return m_lstate_;
}
inline void PKMsgSC_UserDisconnect::set_m_lstate(::google::protobuf::int32 value) {
  set_has_m_lstate();
  m_lstate_ = value;
}

// required sint32 m_lOwnerUSN = 4;
inline bool PKMsgSC_UserDisconnect::has_m_lownerusn() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PKMsgSC_UserDisconnect::set_has_m_lownerusn() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PKMsgSC_UserDisconnect::clear_has_m_lownerusn() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PKMsgSC_UserDisconnect::clear_m_lownerusn() {
  m_lownerusn_ = 0;
  clear_has_m_lownerusn();
}
inline ::google::protobuf::int32 PKMsgSC_UserDisconnect::m_lownerusn() const {
  return m_lownerusn_;
}
inline void PKMsgSC_UserDisconnect::set_m_lownerusn(::google::protobuf::int32 value) {
  set_has_m_lownerusn();
  m_lownerusn_ = value;
}

// -------------------------------------------------------------------

// PKMsgSC_CardData

// required int32 m_nDealCnt = 1;
inline bool PKMsgSC_CardData::has_m_ndealcnt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgSC_CardData::set_has_m_ndealcnt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgSC_CardData::clear_has_m_ndealcnt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgSC_CardData::clear_m_ndealcnt() {
  m_ndealcnt_ = 0;
  clear_has_m_ndealcnt();
}
inline ::google::protobuf::int32 PKMsgSC_CardData::m_ndealcnt() const {
  return m_ndealcnt_;
}
inline void PKMsgSC_CardData::set_m_ndealcnt(::google::protobuf::int32 value) {
  set_has_m_ndealcnt();
  m_ndealcnt_ = value;
}

// required sint32 m_lCardsDealt = 2;
inline bool PKMsgSC_CardData::has_m_lcardsdealt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKMsgSC_CardData::set_has_m_lcardsdealt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKMsgSC_CardData::clear_has_m_lcardsdealt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKMsgSC_CardData::clear_m_lcardsdealt() {
  m_lcardsdealt_ = 0;
  clear_has_m_lcardsdealt();
}
inline ::google::protobuf::int32 PKMsgSC_CardData::m_lcardsdealt() const {
  return m_lcardsdealt_;
}
inline void PKMsgSC_CardData::set_m_lcardsdealt(::google::protobuf::int32 value) {
  set_has_m_lcardsdealt();
  m_lcardsdealt_ = value;
}

// repeated .PKCards m_tblCard = 3;
inline int PKMsgSC_CardData::m_tblcard_size() const {
  return m_tblcard_.size();
}
inline void PKMsgSC_CardData::clear_m_tblcard() {
  m_tblcard_.Clear();
}
inline const ::PKCards& PKMsgSC_CardData::m_tblcard(int index) const {
  return m_tblcard_.Get(index);
}
inline ::PKCards* PKMsgSC_CardData::mutable_m_tblcard(int index) {
  return m_tblcard_.Mutable(index);
}
inline ::PKCards* PKMsgSC_CardData::add_m_tblcard() {
  return m_tblcard_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PKCards >&
PKMsgSC_CardData::m_tblcard() const {
  return m_tblcard_;
}
inline ::google::protobuf::RepeatedPtrField< ::PKCards >*
PKMsgSC_CardData::mutable_m_tblcard() {
  return &m_tblcard_;
}

// repeated .PKMoney m_tblMoney = 4;
inline int PKMsgSC_CardData::m_tblmoney_size() const {
  return m_tblmoney_.size();
}
inline void PKMsgSC_CardData::clear_m_tblmoney() {
  m_tblmoney_.Clear();
}
inline const ::PKMoney& PKMsgSC_CardData::m_tblmoney(int index) const {
  return m_tblmoney_.Get(index);
}
inline ::PKMoney* PKMsgSC_CardData::mutable_m_tblmoney(int index) {
  return m_tblmoney_.Mutable(index);
}
inline ::PKMoney* PKMsgSC_CardData::add_m_tblmoney() {
  return m_tblmoney_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PKMoney >&
PKMsgSC_CardData::m_tblmoney() const {
  return m_tblmoney_;
}
inline ::google::protobuf::RepeatedPtrField< ::PKMoney >*
PKMsgSC_CardData::mutable_m_tblmoney() {
  return &m_tblmoney_;
}

// required sint64 m_llPoolMoney = 5;
inline bool PKMsgSC_CardData::has_m_llpoolmoney() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PKMsgSC_CardData::set_has_m_llpoolmoney() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PKMsgSC_CardData::clear_has_m_llpoolmoney() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PKMsgSC_CardData::clear_m_llpoolmoney() {
  m_llpoolmoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_llpoolmoney();
}
inline ::google::protobuf::int64 PKMsgSC_CardData::m_llpoolmoney() const {
  return m_llpoolmoney_;
}
inline void PKMsgSC_CardData::set_m_llpoolmoney(::google::protobuf::int64 value) {
  set_has_m_llpoolmoney();
  m_llpoolmoney_ = value;
}

// -------------------------------------------------------------------

// PKMsgSC_EntryAns

// required sint32 m_lUSN = 1;
inline bool PKMsgSC_EntryAns::has_m_lusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgSC_EntryAns::set_has_m_lusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgSC_EntryAns::clear_has_m_lusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgSC_EntryAns::clear_m_lusn() {
  m_lusn_ = 0;
  clear_has_m_lusn();
}
inline ::google::protobuf::int32 PKMsgSC_EntryAns::m_lusn() const {
  return m_lusn_;
}
inline void PKMsgSC_EntryAns::set_m_lusn(::google::protobuf::int32 value) {
  set_has_m_lusn();
  m_lusn_ = value;
}

// required int32 m_nIndex = 2;
inline bool PKMsgSC_EntryAns::has_m_nindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKMsgSC_EntryAns::set_has_m_nindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKMsgSC_EntryAns::clear_has_m_nindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKMsgSC_EntryAns::clear_m_nindex() {
  m_nindex_ = 0;
  clear_has_m_nindex();
}
inline ::google::protobuf::int32 PKMsgSC_EntryAns::m_nindex() const {
  return m_nindex_;
}
inline void PKMsgSC_EntryAns::set_m_nindex(::google::protobuf::int32 value) {
  set_has_m_nindex();
  m_nindex_ = value;
}

// required sint32 m_lOwnerUSN = 3;
inline bool PKMsgSC_EntryAns::has_m_lownerusn() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PKMsgSC_EntryAns::set_has_m_lownerusn() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PKMsgSC_EntryAns::clear_has_m_lownerusn() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PKMsgSC_EntryAns::clear_m_lownerusn() {
  m_lownerusn_ = 0;
  clear_has_m_lownerusn();
}
inline ::google::protobuf::int32 PKMsgSC_EntryAns::m_lownerusn() const {
  return m_lownerusn_;
}
inline void PKMsgSC_EntryAns::set_m_lownerusn(::google::protobuf::int32 value) {
  set_has_m_lownerusn();
  m_lownerusn_ = value;
}

// repeated .PKUserInfo m_tblUI = 4;
inline int PKMsgSC_EntryAns::m_tblui_size() const {
  return m_tblui_.size();
}
inline void PKMsgSC_EntryAns::clear_m_tblui() {
  m_tblui_.Clear();
}
inline const ::PKUserInfo& PKMsgSC_EntryAns::m_tblui(int index) const {
  return m_tblui_.Get(index);
}
inline ::PKUserInfo* PKMsgSC_EntryAns::mutable_m_tblui(int index) {
  return m_tblui_.Mutable(index);
}
inline ::PKUserInfo* PKMsgSC_EntryAns::add_m_tblui() {
  return m_tblui_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PKUserInfo >&
PKMsgSC_EntryAns::m_tblui() const {
  return m_tblui_;
}
inline ::google::protobuf::RepeatedPtrField< ::PKUserInfo >*
PKMsgSC_EntryAns::mutable_m_tblui() {
  return &m_tblui_;
}

// repeated .PKMoney m_tblMoney = 5;
inline int PKMsgSC_EntryAns::m_tblmoney_size() const {
  return m_tblmoney_.size();
}
inline void PKMsgSC_EntryAns::clear_m_tblmoney() {
  m_tblmoney_.Clear();
}
inline const ::PKMoney& PKMsgSC_EntryAns::m_tblmoney(int index) const {
  return m_tblmoney_.Get(index);
}
inline ::PKMoney* PKMsgSC_EntryAns::mutable_m_tblmoney(int index) {
  return m_tblmoney_.Mutable(index);
}
inline ::PKMoney* PKMsgSC_EntryAns::add_m_tblmoney() {
  return m_tblmoney_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PKMoney >&
PKMsgSC_EntryAns::m_tblmoney() const {
  return m_tblmoney_;
}
inline ::google::protobuf::RepeatedPtrField< ::PKMoney >*
PKMsgSC_EntryAns::mutable_m_tblmoney() {
  return &m_tblmoney_;
}

// required sint32 m_bWelcomeSound = 6;
inline bool PKMsgSC_EntryAns::has_m_bwelcomesound() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PKMsgSC_EntryAns::set_has_m_bwelcomesound() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PKMsgSC_EntryAns::clear_has_m_bwelcomesound() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PKMsgSC_EntryAns::clear_m_bwelcomesound() {
  m_bwelcomesound_ = 0;
  clear_has_m_bwelcomesound();
}
inline ::google::protobuf::int32 PKMsgSC_EntryAns::m_bwelcomesound() const {
  return m_bwelcomesound_;
}
inline void PKMsgSC_EntryAns::set_m_bwelcomesound(::google::protobuf::int32 value) {
  set_has_m_bwelcomesound();
  m_bwelcomesound_ = value;
}

// required sint32 m_lObserveCnt = 7;
inline bool PKMsgSC_EntryAns::has_m_lobservecnt() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PKMsgSC_EntryAns::set_has_m_lobservecnt() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PKMsgSC_EntryAns::clear_has_m_lobservecnt() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PKMsgSC_EntryAns::clear_m_lobservecnt() {
  m_lobservecnt_ = 0;
  clear_has_m_lobservecnt();
}
inline ::google::protobuf::int32 PKMsgSC_EntryAns::m_lobservecnt() const {
  return m_lobservecnt_;
}
inline void PKMsgSC_EntryAns::set_m_lobservecnt(::google::protobuf::int32 value) {
  set_has_m_lobservecnt();
  m_lobservecnt_ = value;
}

// -------------------------------------------------------------------

// PKMsgSC_EntryReject

// required sint32 m_lType = 1;
inline bool PKMsgSC_EntryReject::has_m_ltype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgSC_EntryReject::set_has_m_ltype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgSC_EntryReject::clear_has_m_ltype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgSC_EntryReject::clear_m_ltype() {
  m_ltype_ = 0;
  clear_has_m_ltype();
}
inline ::google::protobuf::int32 PKMsgSC_EntryReject::m_ltype() const {
  return m_ltype_;
}
inline void PKMsgSC_EntryReject::set_m_ltype(::google::protobuf::int32 value) {
  set_has_m_ltype();
  m_ltype_ = value;
}

// required sint64 m_llCMoney = 2;
inline bool PKMsgSC_EntryReject::has_m_llcmoney() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKMsgSC_EntryReject::set_has_m_llcmoney() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKMsgSC_EntryReject::clear_has_m_llcmoney() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKMsgSC_EntryReject::clear_m_llcmoney() {
  m_llcmoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_llcmoney();
}
inline ::google::protobuf::int64 PKMsgSC_EntryReject::m_llcmoney() const {
  return m_llcmoney_;
}
inline void PKMsgSC_EntryReject::set_m_llcmoney(::google::protobuf::int64 value) {
  set_has_m_llcmoney();
  m_llcmoney_ = value;
}

// -------------------------------------------------------------------

// PKMsgSC_ObserveAns

// required sint32 m_lUSN = 1;
inline bool PKMsgSC_ObserveAns::has_m_lusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgSC_ObserveAns::set_has_m_lusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgSC_ObserveAns::clear_has_m_lusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgSC_ObserveAns::clear_m_lusn() {
  m_lusn_ = 0;
  clear_has_m_lusn();
}
inline ::google::protobuf::int32 PKMsgSC_ObserveAns::m_lusn() const {
  return m_lusn_;
}
inline void PKMsgSC_ObserveAns::set_m_lusn(::google::protobuf::int32 value) {
  set_has_m_lusn();
  m_lusn_ = value;
}

// required int32 m_nIndex = 2;
inline bool PKMsgSC_ObserveAns::has_m_nindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKMsgSC_ObserveAns::set_has_m_nindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKMsgSC_ObserveAns::clear_has_m_nindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKMsgSC_ObserveAns::clear_m_nindex() {
  m_nindex_ = 0;
  clear_has_m_nindex();
}
inline ::google::protobuf::int32 PKMsgSC_ObserveAns::m_nindex() const {
  return m_nindex_;
}
inline void PKMsgSC_ObserveAns::set_m_nindex(::google::protobuf::int32 value) {
  set_has_m_nindex();
  m_nindex_ = value;
}

// required sint32 m_lOwnerUSN = 3;
inline bool PKMsgSC_ObserveAns::has_m_lownerusn() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PKMsgSC_ObserveAns::set_has_m_lownerusn() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PKMsgSC_ObserveAns::clear_has_m_lownerusn() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PKMsgSC_ObserveAns::clear_m_lownerusn() {
  m_lownerusn_ = 0;
  clear_has_m_lownerusn();
}
inline ::google::protobuf::int32 PKMsgSC_ObserveAns::m_lownerusn() const {
  return m_lownerusn_;
}
inline void PKMsgSC_ObserveAns::set_m_lownerusn(::google::protobuf::int32 value) {
  set_has_m_lownerusn();
  m_lownerusn_ = value;
}

// required .PKUserInfo m_uinfo = 4;
inline bool PKMsgSC_ObserveAns::has_m_uinfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PKMsgSC_ObserveAns::set_has_m_uinfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PKMsgSC_ObserveAns::clear_has_m_uinfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PKMsgSC_ObserveAns::clear_m_uinfo() {
  if (m_uinfo_ != NULL) m_uinfo_->::PKUserInfo::Clear();
  clear_has_m_uinfo();
}
inline const ::PKUserInfo& PKMsgSC_ObserveAns::m_uinfo() const {
  return m_uinfo_ != NULL ? *m_uinfo_ : *default_instance_->m_uinfo_;
}
inline ::PKUserInfo* PKMsgSC_ObserveAns::mutable_m_uinfo() {
  set_has_m_uinfo();
  if (m_uinfo_ == NULL) m_uinfo_ = new ::PKUserInfo;
  return m_uinfo_;
}
inline ::PKUserInfo* PKMsgSC_ObserveAns::release_m_uinfo() {
  clear_has_m_uinfo();
  ::PKUserInfo* temp = m_uinfo_;
  m_uinfo_ = NULL;
  return temp;
}

// required .PKMoney m_money = 5;
inline bool PKMsgSC_ObserveAns::has_m_money() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PKMsgSC_ObserveAns::set_has_m_money() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PKMsgSC_ObserveAns::clear_has_m_money() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PKMsgSC_ObserveAns::clear_m_money() {
  if (m_money_ != NULL) m_money_->::PKMoney::Clear();
  clear_has_m_money();
}
inline const ::PKMoney& PKMsgSC_ObserveAns::m_money() const {
  return m_money_ != NULL ? *m_money_ : *default_instance_->m_money_;
}
inline ::PKMoney* PKMsgSC_ObserveAns::mutable_m_money() {
  set_has_m_money();
  if (m_money_ == NULL) m_money_ = new ::PKMoney;
  return m_money_;
}
inline ::PKMoney* PKMsgSC_ObserveAns::release_m_money() {
  clear_has_m_money();
  ::PKMoney* temp = m_money_;
  m_money_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// PKMsgSC_StartReq

// -------------------------------------------------------------------

// PKMsgSC_StartAns

// required sint32 m_lState = 1;
inline bool PKMsgSC_StartAns::has_m_lstate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgSC_StartAns::set_has_m_lstate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgSC_StartAns::clear_has_m_lstate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgSC_StartAns::clear_m_lstate() {
  m_lstate_ = 0;
  clear_has_m_lstate();
}
inline ::google::protobuf::int32 PKMsgSC_StartAns::m_lstate() const {
  return m_lstate_;
}
inline void PKMsgSC_StartAns::set_m_lstate(::google::protobuf::int32 value) {
  set_has_m_lstate();
  m_lstate_ = value;
}

// repeated sint32 m_vtState = 2;
inline int PKMsgSC_StartAns::m_vtstate_size() const {
  return m_vtstate_.size();
}
inline void PKMsgSC_StartAns::clear_m_vtstate() {
  m_vtstate_.Clear();
}
inline ::google::protobuf::int32 PKMsgSC_StartAns::m_vtstate(int index) const {
  return m_vtstate_.Get(index);
}
inline void PKMsgSC_StartAns::set_m_vtstate(int index, ::google::protobuf::int32 value) {
  m_vtstate_.Set(index, value);
}
inline void PKMsgSC_StartAns::add_m_vtstate(::google::protobuf::int32 value) {
  m_vtstate_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PKMsgSC_StartAns::m_vtstate() const {
  return m_vtstate_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PKMsgSC_StartAns::mutable_m_vtstate() {
  return &m_vtstate_;
}

// required sint64 m_llSystemTime = 3;
inline bool PKMsgSC_StartAns::has_m_llsystemtime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PKMsgSC_StartAns::set_has_m_llsystemtime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PKMsgSC_StartAns::clear_has_m_llsystemtime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PKMsgSC_StartAns::clear_m_llsystemtime() {
  m_llsystemtime_ = GOOGLE_LONGLONG(0);
  clear_has_m_llsystemtime();
}
inline ::google::protobuf::int64 PKMsgSC_StartAns::m_llsystemtime() const {
  return m_llsystemtime_;
}
inline void PKMsgSC_StartAns::set_m_llsystemtime(::google::protobuf::int64 value) {
  set_has_m_llsystemtime();
  m_llsystemtime_ = value;
}

// -------------------------------------------------------------------

// PKMsgSC_NoStart

// -------------------------------------------------------------------

// PKMsgSC_DealCards

// required sint32 m_lBossUSN = 1;
inline bool PKMsgSC_DealCards::has_m_lbossusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgSC_DealCards::set_has_m_lbossusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgSC_DealCards::clear_has_m_lbossusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgSC_DealCards::clear_m_lbossusn() {
  m_lbossusn_ = 0;
  clear_has_m_lbossusn();
}
inline ::google::protobuf::int32 PKMsgSC_DealCards::m_lbossusn() const {
  return m_lbossusn_;
}
inline void PKMsgSC_DealCards::set_m_lbossusn(::google::protobuf::int32 value) {
  set_has_m_lbossusn();
  m_lbossusn_ = value;
}

// required sint32 m_lState = 2;
inline bool PKMsgSC_DealCards::has_m_lstate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKMsgSC_DealCards::set_has_m_lstate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKMsgSC_DealCards::clear_has_m_lstate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKMsgSC_DealCards::clear_m_lstate() {
  m_lstate_ = 0;
  clear_has_m_lstate();
}
inline ::google::protobuf::int32 PKMsgSC_DealCards::m_lstate() const {
  return m_lstate_;
}
inline void PKMsgSC_DealCards::set_m_lstate(::google::protobuf::int32 value) {
  set_has_m_lstate();
  m_lstate_ = value;
}

// required int32 m_nType = 3;
inline bool PKMsgSC_DealCards::has_m_ntype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PKMsgSC_DealCards::set_has_m_ntype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PKMsgSC_DealCards::clear_has_m_ntype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PKMsgSC_DealCards::clear_m_ntype() {
  m_ntype_ = 0;
  clear_has_m_ntype();
}
inline ::google::protobuf::int32 PKMsgSC_DealCards::m_ntype() const {
  return m_ntype_;
}
inline void PKMsgSC_DealCards::set_m_ntype(::google::protobuf::int32 value) {
  set_has_m_ntype();
  m_ntype_ = value;
}

// repeated .PKCards m_tblCard = 4;
inline int PKMsgSC_DealCards::m_tblcard_size() const {
  return m_tblcard_.size();
}
inline void PKMsgSC_DealCards::clear_m_tblcard() {
  m_tblcard_.Clear();
}
inline const ::PKCards& PKMsgSC_DealCards::m_tblcard(int index) const {
  return m_tblcard_.Get(index);
}
inline ::PKCards* PKMsgSC_DealCards::mutable_m_tblcard(int index) {
  return m_tblcard_.Mutable(index);
}
inline ::PKCards* PKMsgSC_DealCards::add_m_tblcard() {
  return m_tblcard_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PKCards >&
PKMsgSC_DealCards::m_tblcard() const {
  return m_tblcard_;
}
inline ::google::protobuf::RepeatedPtrField< ::PKCards >*
PKMsgSC_DealCards::mutable_m_tblcard() {
  return &m_tblcard_;
}

// repeated .PKMoney m_tblMoney = 5;
inline int PKMsgSC_DealCards::m_tblmoney_size() const {
  return m_tblmoney_.size();
}
inline void PKMsgSC_DealCards::clear_m_tblmoney() {
  m_tblmoney_.Clear();
}
inline const ::PKMoney& PKMsgSC_DealCards::m_tblmoney(int index) const {
  return m_tblmoney_.Get(index);
}
inline ::PKMoney* PKMsgSC_DealCards::mutable_m_tblmoney(int index) {
  return m_tblmoney_.Mutable(index);
}
inline ::PKMoney* PKMsgSC_DealCards::add_m_tblmoney() {
  return m_tblmoney_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PKMoney >&
PKMsgSC_DealCards::m_tblmoney() const {
  return m_tblmoney_;
}
inline ::google::protobuf::RepeatedPtrField< ::PKMoney >*
PKMsgSC_DealCards::mutable_m_tblmoney() {
  return &m_tblmoney_;
}

// required sint64 m_llPoolMoney = 6;
inline bool PKMsgSC_DealCards::has_m_llpoolmoney() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PKMsgSC_DealCards::set_has_m_llpoolmoney() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PKMsgSC_DealCards::clear_has_m_llpoolmoney() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PKMsgSC_DealCards::clear_m_llpoolmoney() {
  m_llpoolmoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_llpoolmoney();
}
inline ::google::protobuf::int64 PKMsgSC_DealCards::m_llpoolmoney() const {
  return m_llpoolmoney_;
}
inline void PKMsgSC_DealCards::set_m_llpoolmoney(::google::protobuf::int64 value) {
  set_has_m_llpoolmoney();
  m_llpoolmoney_ = value;
}

// -------------------------------------------------------------------

// PKMsgSC_SelectedCardAns

// required sint32 m_lUSN = 1;
inline bool PKMsgSC_SelectedCardAns::has_m_lusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgSC_SelectedCardAns::set_has_m_lusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgSC_SelectedCardAns::clear_has_m_lusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgSC_SelectedCardAns::clear_m_lusn() {
  m_lusn_ = 0;
  clear_has_m_lusn();
}
inline ::google::protobuf::int32 PKMsgSC_SelectedCardAns::m_lusn() const {
  return m_lusn_;
}
inline void PKMsgSC_SelectedCardAns::set_m_lusn(::google::protobuf::int32 value) {
  set_has_m_lusn();
  m_lusn_ = value;
}

// required int32 m_nSelect = 2;
inline bool PKMsgSC_SelectedCardAns::has_m_nselect() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKMsgSC_SelectedCardAns::set_has_m_nselect() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKMsgSC_SelectedCardAns::clear_has_m_nselect() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKMsgSC_SelectedCardAns::clear_m_nselect() {
  m_nselect_ = 0;
  clear_has_m_nselect();
}
inline ::google::protobuf::int32 PKMsgSC_SelectedCardAns::m_nselect() const {
  return m_nselect_;
}
inline void PKMsgSC_SelectedCardAns::set_m_nselect(::google::protobuf::int32 value) {
  set_has_m_nselect();
  m_nselect_ = value;
}

// required sint32 m_lCardIndex = 3;
inline bool PKMsgSC_SelectedCardAns::has_m_lcardindex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PKMsgSC_SelectedCardAns::set_has_m_lcardindex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PKMsgSC_SelectedCardAns::clear_has_m_lcardindex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PKMsgSC_SelectedCardAns::clear_m_lcardindex() {
  m_lcardindex_ = 0;
  clear_has_m_lcardindex();
}
inline ::google::protobuf::int32 PKMsgSC_SelectedCardAns::m_lcardindex() const {
  return m_lcardindex_;
}
inline void PKMsgSC_SelectedCardAns::set_m_lcardindex(::google::protobuf::int32 value) {
  set_has_m_lcardindex();
  m_lcardindex_ = value;
}

// required sint32 m_lChoiceType = 4;
inline bool PKMsgSC_SelectedCardAns::has_m_lchoicetype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PKMsgSC_SelectedCardAns::set_has_m_lchoicetype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PKMsgSC_SelectedCardAns::clear_has_m_lchoicetype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PKMsgSC_SelectedCardAns::clear_m_lchoicetype() {
  m_lchoicetype_ = 0;
  clear_has_m_lchoicetype();
}
inline ::google::protobuf::int32 PKMsgSC_SelectedCardAns::m_lchoicetype() const {
  return m_lchoicetype_;
}
inline void PKMsgSC_SelectedCardAns::set_m_lchoicetype(::google::protobuf::int32 value) {
  set_has_m_lchoicetype();
  m_lchoicetype_ = value;
}

// -------------------------------------------------------------------

// PKMsgSC_DealOpenCard

// required sint32 m_lState = 1;
inline bool PKMsgSC_DealOpenCard::has_m_lstate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgSC_DealOpenCard::set_has_m_lstate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgSC_DealOpenCard::clear_has_m_lstate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgSC_DealOpenCard::clear_m_lstate() {
  m_lstate_ = 0;
  clear_has_m_lstate();
}
inline ::google::protobuf::int32 PKMsgSC_DealOpenCard::m_lstate() const {
  return m_lstate_;
}
inline void PKMsgSC_DealOpenCard::set_m_lstate(::google::protobuf::int32 value) {
  set_has_m_lstate();
  m_lstate_ = value;
}

// repeated .PKCards m_tblCard = 2;
inline int PKMsgSC_DealOpenCard::m_tblcard_size() const {
  return m_tblcard_.size();
}
inline void PKMsgSC_DealOpenCard::clear_m_tblcard() {
  m_tblcard_.Clear();
}
inline const ::PKCards& PKMsgSC_DealOpenCard::m_tblcard(int index) const {
  return m_tblcard_.Get(index);
}
inline ::PKCards* PKMsgSC_DealOpenCard::mutable_m_tblcard(int index) {
  return m_tblcard_.Mutable(index);
}
inline ::PKCards* PKMsgSC_DealOpenCard::add_m_tblcard() {
  return m_tblcard_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PKCards >&
PKMsgSC_DealOpenCard::m_tblcard() const {
  return m_tblcard_;
}
inline ::google::protobuf::RepeatedPtrField< ::PKCards >*
PKMsgSC_DealOpenCard::mutable_m_tblcard() {
  return &m_tblcard_;
}

// repeated sint32 m_vtState = 3;
inline int PKMsgSC_DealOpenCard::m_vtstate_size() const {
  return m_vtstate_.size();
}
inline void PKMsgSC_DealOpenCard::clear_m_vtstate() {
  m_vtstate_.Clear();
}
inline ::google::protobuf::int32 PKMsgSC_DealOpenCard::m_vtstate(int index) const {
  return m_vtstate_.Get(index);
}
inline void PKMsgSC_DealOpenCard::set_m_vtstate(int index, ::google::protobuf::int32 value) {
  m_vtstate_.Set(index, value);
}
inline void PKMsgSC_DealOpenCard::add_m_vtstate(::google::protobuf::int32 value) {
  m_vtstate_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PKMsgSC_DealOpenCard::m_vtstate() const {
  return m_vtstate_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PKMsgSC_DealOpenCard::mutable_m_vtstate() {
  return &m_vtstate_;
}

// -------------------------------------------------------------------

// PKMsgSC_DealCard

// required sint32 m_lBossUSN = 1;
inline bool PKMsgSC_DealCard::has_m_lbossusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgSC_DealCard::set_has_m_lbossusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgSC_DealCard::clear_has_m_lbossusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgSC_DealCard::clear_m_lbossusn() {
  m_lbossusn_ = 0;
  clear_has_m_lbossusn();
}
inline ::google::protobuf::int32 PKMsgSC_DealCard::m_lbossusn() const {
  return m_lbossusn_;
}
inline void PKMsgSC_DealCard::set_m_lbossusn(::google::protobuf::int32 value) {
  set_has_m_lbossusn();
  m_lbossusn_ = value;
}

// required int32 m_nType = 2;
inline bool PKMsgSC_DealCard::has_m_ntype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKMsgSC_DealCard::set_has_m_ntype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKMsgSC_DealCard::clear_has_m_ntype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKMsgSC_DealCard::clear_m_ntype() {
  m_ntype_ = 0;
  clear_has_m_ntype();
}
inline ::google::protobuf::int32 PKMsgSC_DealCard::m_ntype() const {
  return m_ntype_;
}
inline void PKMsgSC_DealCard::set_m_ntype(::google::protobuf::int32 value) {
  set_has_m_ntype();
  m_ntype_ = value;
}

// required sint32 m_lCardsDealt = 3;
inline bool PKMsgSC_DealCard::has_m_lcardsdealt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PKMsgSC_DealCard::set_has_m_lcardsdealt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PKMsgSC_DealCard::clear_has_m_lcardsdealt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PKMsgSC_DealCard::clear_m_lcardsdealt() {
  m_lcardsdealt_ = 0;
  clear_has_m_lcardsdealt();
}
inline ::google::protobuf::int32 PKMsgSC_DealCard::m_lcardsdealt() const {
  return m_lcardsdealt_;
}
inline void PKMsgSC_DealCard::set_m_lcardsdealt(::google::protobuf::int32 value) {
  set_has_m_lcardsdealt();
  m_lcardsdealt_ = value;
}

// repeated .PKOneCard m_vtOneCard = 4;
inline int PKMsgSC_DealCard::m_vtonecard_size() const {
  return m_vtonecard_.size();
}
inline void PKMsgSC_DealCard::clear_m_vtonecard() {
  m_vtonecard_.Clear();
}
inline const ::PKOneCard& PKMsgSC_DealCard::m_vtonecard(int index) const {
  return m_vtonecard_.Get(index);
}
inline ::PKOneCard* PKMsgSC_DealCard::mutable_m_vtonecard(int index) {
  return m_vtonecard_.Mutable(index);
}
inline ::PKOneCard* PKMsgSC_DealCard::add_m_vtonecard() {
  return m_vtonecard_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PKOneCard >&
PKMsgSC_DealCard::m_vtonecard() const {
  return m_vtonecard_;
}
inline ::google::protobuf::RepeatedPtrField< ::PKOneCard >*
PKMsgSC_DealCard::mutable_m_vtonecard() {
  return &m_vtonecard_;
}

// -------------------------------------------------------------------

// PKMsgSC_Boss

// required sint32 m_lBossUSN = 1;
inline bool PKMsgSC_Boss::has_m_lbossusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgSC_Boss::set_has_m_lbossusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgSC_Boss::clear_has_m_lbossusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgSC_Boss::clear_m_lbossusn() {
  m_lbossusn_ = 0;
  clear_has_m_lbossusn();
}
inline ::google::protobuf::int32 PKMsgSC_Boss::m_lbossusn() const {
  return m_lbossusn_;
}
inline void PKMsgSC_Boss::set_m_lbossusn(::google::protobuf::int32 value) {
  set_has_m_lbossusn();
  m_lbossusn_ = value;
}

// required int32 m_nBossRank = 2;
inline bool PKMsgSC_Boss::has_m_nbossrank() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKMsgSC_Boss::set_has_m_nbossrank() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKMsgSC_Boss::clear_has_m_nbossrank() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKMsgSC_Boss::clear_m_nbossrank() {
  m_nbossrank_ = 0;
  clear_has_m_nbossrank();
}
inline ::google::protobuf::int32 PKMsgSC_Boss::m_nbossrank() const {
  return m_nbossrank_;
}
inline void PKMsgSC_Boss::set_m_nbossrank(::google::protobuf::int32 value) {
  set_has_m_nbossrank();
  m_nbossrank_ = value;
}

// -------------------------------------------------------------------

// PKMsgSC_Betting

// required sint32 m_lBetUSN = 1;
inline bool PKMsgSC_Betting::has_m_lbetusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgSC_Betting::set_has_m_lbetusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgSC_Betting::clear_has_m_lbetusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgSC_Betting::clear_m_lbetusn() {
  m_lbetusn_ = 0;
  clear_has_m_lbetusn();
}
inline ::google::protobuf::int32 PKMsgSC_Betting::m_lbetusn() const {
  return m_lbetusn_;
}
inline void PKMsgSC_Betting::set_m_lbetusn(::google::protobuf::int32 value) {
  set_has_m_lbetusn();
  m_lbetusn_ = value;
}

// required sint32 m_lBetBtnType = 2;
inline bool PKMsgSC_Betting::has_m_lbetbtntype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKMsgSC_Betting::set_has_m_lbetbtntype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKMsgSC_Betting::clear_has_m_lbetbtntype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKMsgSC_Betting::clear_m_lbetbtntype() {
  m_lbetbtntype_ = 0;
  clear_has_m_lbetbtntype();
}
inline ::google::protobuf::int32 PKMsgSC_Betting::m_lbetbtntype() const {
  return m_lbetbtntype_;
}
inline void PKMsgSC_Betting::set_m_lbetbtntype(::google::protobuf::int32 value) {
  set_has_m_lbetbtntype();
  m_lbetbtntype_ = value;
}

// -------------------------------------------------------------------

// PKMsgSC_BettingAns

// required int32 m_nIndex = 1;
inline bool PKMsgSC_BettingAns::has_m_nindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgSC_BettingAns::set_has_m_nindex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgSC_BettingAns::clear_has_m_nindex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgSC_BettingAns::clear_m_nindex() {
  m_nindex_ = 0;
  clear_has_m_nindex();
}
inline ::google::protobuf::int32 PKMsgSC_BettingAns::m_nindex() const {
  return m_nindex_;
}
inline void PKMsgSC_BettingAns::set_m_nindex(::google::protobuf::int32 value) {
  set_has_m_nindex();
  m_nindex_ = value;
}

// required sint32 m_lBetType = 2;
inline bool PKMsgSC_BettingAns::has_m_lbettype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKMsgSC_BettingAns::set_has_m_lbettype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKMsgSC_BettingAns::clear_has_m_lbettype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKMsgSC_BettingAns::clear_m_lbettype() {
  m_lbettype_ = 0;
  clear_has_m_lbettype();
}
inline ::google::protobuf::int32 PKMsgSC_BettingAns::m_lbettype() const {
  return m_lbettype_;
}
inline void PKMsgSC_BettingAns::set_m_lbettype(::google::protobuf::int32 value) {
  set_has_m_lbettype();
  m_lbettype_ = value;
}

// required .PKMoney m_money = 3;
inline bool PKMsgSC_BettingAns::has_m_money() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PKMsgSC_BettingAns::set_has_m_money() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PKMsgSC_BettingAns::clear_has_m_money() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PKMsgSC_BettingAns::clear_m_money() {
  if (m_money_ != NULL) m_money_->::PKMoney::Clear();
  clear_has_m_money();
}
inline const ::PKMoney& PKMsgSC_BettingAns::m_money() const {
  return m_money_ != NULL ? *m_money_ : *default_instance_->m_money_;
}
inline ::PKMoney* PKMsgSC_BettingAns::mutable_m_money() {
  set_has_m_money();
  if (m_money_ == NULL) m_money_ = new ::PKMoney;
  return m_money_;
}
inline ::PKMoney* PKMsgSC_BettingAns::release_m_money() {
  clear_has_m_money();
  ::PKMoney* temp = m_money_;
  m_money_ = NULL;
  return temp;
}

// repeated .PKVecMoney m_vtCallMoney = 4;
inline int PKMsgSC_BettingAns::m_vtcallmoney_size() const {
  return m_vtcallmoney_.size();
}
inline void PKMsgSC_BettingAns::clear_m_vtcallmoney() {
  m_vtcallmoney_.Clear();
}
inline const ::PKVecMoney& PKMsgSC_BettingAns::m_vtcallmoney(int index) const {
  return m_vtcallmoney_.Get(index);
}
inline ::PKVecMoney* PKMsgSC_BettingAns::mutable_m_vtcallmoney(int index) {
  return m_vtcallmoney_.Mutable(index);
}
inline ::PKVecMoney* PKMsgSC_BettingAns::add_m_vtcallmoney() {
  return m_vtcallmoney_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PKVecMoney >&
PKMsgSC_BettingAns::m_vtcallmoney() const {
  return m_vtcallmoney_;
}
inline ::google::protobuf::RepeatedPtrField< ::PKVecMoney >*
PKMsgSC_BettingAns::mutable_m_vtcallmoney() {
  return &m_vtcallmoney_;
}

// required sint64 m_lPoolMoney = 5;
inline bool PKMsgSC_BettingAns::has_m_lpoolmoney() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PKMsgSC_BettingAns::set_has_m_lpoolmoney() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PKMsgSC_BettingAns::clear_has_m_lpoolmoney() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PKMsgSC_BettingAns::clear_m_lpoolmoney() {
  m_lpoolmoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_lpoolmoney();
}
inline ::google::protobuf::int64 PKMsgSC_BettingAns::m_lpoolmoney() const {
  return m_lpoolmoney_;
}
inline void PKMsgSC_BettingAns::set_m_lpoolmoney(::google::protobuf::int64 value) {
  set_has_m_lpoolmoney();
  m_lpoolmoney_ = value;
}

// -------------------------------------------------------------------

// PKMsgSC_BettingAnsMsg

// required sint32 m_lUSN = 1;
inline bool PKMsgSC_BettingAnsMsg::has_m_lusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgSC_BettingAnsMsg::set_has_m_lusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgSC_BettingAnsMsg::clear_has_m_lusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgSC_BettingAnsMsg::clear_m_lusn() {
  m_lusn_ = 0;
  clear_has_m_lusn();
}
inline ::google::protobuf::int32 PKMsgSC_BettingAnsMsg::m_lusn() const {
  return m_lusn_;
}
inline void PKMsgSC_BettingAnsMsg::set_m_lusn(::google::protobuf::int32 value) {
  set_has_m_lusn();
  m_lusn_ = value;
}

// required int32 m_nIndex = 2;
inline bool PKMsgSC_BettingAnsMsg::has_m_nindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKMsgSC_BettingAnsMsg::set_has_m_nindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKMsgSC_BettingAnsMsg::clear_has_m_nindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKMsgSC_BettingAnsMsg::clear_m_nindex() {
  m_nindex_ = 0;
  clear_has_m_nindex();
}
inline ::google::protobuf::int32 PKMsgSC_BettingAnsMsg::m_nindex() const {
  return m_nindex_;
}
inline void PKMsgSC_BettingAnsMsg::set_m_nindex(::google::protobuf::int32 value) {
  set_has_m_nindex();
  m_nindex_ = value;
}

// required sint32 m_BetType = 3;
inline bool PKMsgSC_BettingAnsMsg::has_m_bettype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PKMsgSC_BettingAnsMsg::set_has_m_bettype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PKMsgSC_BettingAnsMsg::clear_has_m_bettype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PKMsgSC_BettingAnsMsg::clear_m_bettype() {
  m_bettype_ = 0;
  clear_has_m_bettype();
}
inline ::google::protobuf::int32 PKMsgSC_BettingAnsMsg::m_bettype() const {
  return m_bettype_;
}
inline void PKMsgSC_BettingAnsMsg::set_m_bettype(::google::protobuf::int32 value) {
  set_has_m_bettype();
  m_bettype_ = value;
}

// required sint32 m_bBettingMoney = 4;
inline bool PKMsgSC_BettingAnsMsg::has_m_bbettingmoney() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PKMsgSC_BettingAnsMsg::set_has_m_bbettingmoney() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PKMsgSC_BettingAnsMsg::clear_has_m_bbettingmoney() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PKMsgSC_BettingAnsMsg::clear_m_bbettingmoney() {
  m_bbettingmoney_ = 0;
  clear_has_m_bbettingmoney();
}
inline ::google::protobuf::int32 PKMsgSC_BettingAnsMsg::m_bbettingmoney() const {
  return m_bbettingmoney_;
}
inline void PKMsgSC_BettingAnsMsg::set_m_bbettingmoney(::google::protobuf::int32 value) {
  set_has_m_bbettingmoney();
  m_bbettingmoney_ = value;
}

// required sint32 m_bMoneyLack = 5;
inline bool PKMsgSC_BettingAnsMsg::has_m_bmoneylack() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PKMsgSC_BettingAnsMsg::set_has_m_bmoneylack() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PKMsgSC_BettingAnsMsg::clear_has_m_bmoneylack() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PKMsgSC_BettingAnsMsg::clear_m_bmoneylack() {
  m_bmoneylack_ = 0;
  clear_has_m_bmoneylack();
}
inline ::google::protobuf::int32 PKMsgSC_BettingAnsMsg::m_bmoneylack() const {
  return m_bmoneylack_;
}
inline void PKMsgSC_BettingAnsMsg::set_m_bmoneylack(::google::protobuf::int32 value) {
  set_has_m_bmoneylack();
  m_bmoneylack_ = value;
}

// required sint32 m_bCallMoneyZero = 6;
inline bool PKMsgSC_BettingAnsMsg::has_m_bcallmoneyzero() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PKMsgSC_BettingAnsMsg::set_has_m_bcallmoneyzero() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PKMsgSC_BettingAnsMsg::clear_has_m_bcallmoneyzero() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PKMsgSC_BettingAnsMsg::clear_m_bcallmoneyzero() {
  m_bcallmoneyzero_ = 0;
  clear_has_m_bcallmoneyzero();
}
inline ::google::protobuf::int32 PKMsgSC_BettingAnsMsg::m_bcallmoneyzero() const {
  return m_bcallmoneyzero_;
}
inline void PKMsgSC_BettingAnsMsg::set_m_bcallmoneyzero(::google::protobuf::int32 value) {
  set_has_m_bcallmoneyzero();
  m_bcallmoneyzero_ = value;
}

// required sint64 m_llCallMoney = 7;
inline bool PKMsgSC_BettingAnsMsg::has_m_llcallmoney() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PKMsgSC_BettingAnsMsg::set_has_m_llcallmoney() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PKMsgSC_BettingAnsMsg::clear_has_m_llcallmoney() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PKMsgSC_BettingAnsMsg::clear_m_llcallmoney() {
  m_llcallmoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_llcallmoney();
}
inline ::google::protobuf::int64 PKMsgSC_BettingAnsMsg::m_llcallmoney() const {
  return m_llcallmoney_;
}
inline void PKMsgSC_BettingAnsMsg::set_m_llcallmoney(::google::protobuf::int64 value) {
  set_has_m_llcallmoney();
  m_llcallmoney_ = value;
}

// required sint64 m_llRaiseMoney = 8;
inline bool PKMsgSC_BettingAnsMsg::has_m_llraisemoney() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PKMsgSC_BettingAnsMsg::set_has_m_llraisemoney() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PKMsgSC_BettingAnsMsg::clear_has_m_llraisemoney() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PKMsgSC_BettingAnsMsg::clear_m_llraisemoney() {
  m_llraisemoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_llraisemoney();
}
inline ::google::protobuf::int64 PKMsgSC_BettingAnsMsg::m_llraisemoney() const {
  return m_llraisemoney_;
}
inline void PKMsgSC_BettingAnsMsg::set_m_llraisemoney(::google::protobuf::int64 value) {
  set_has_m_llraisemoney();
  m_llraisemoney_ = value;
}

// required sint64 m_llSideMoney = 9;
inline bool PKMsgSC_BettingAnsMsg::has_m_llsidemoney() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PKMsgSC_BettingAnsMsg::set_has_m_llsidemoney() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PKMsgSC_BettingAnsMsg::clear_has_m_llsidemoney() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PKMsgSC_BettingAnsMsg::clear_m_llsidemoney() {
  m_llsidemoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_llsidemoney();
}
inline ::google::protobuf::int64 PKMsgSC_BettingAnsMsg::m_llsidemoney() const {
  return m_llsidemoney_;
}
inline void PKMsgSC_BettingAnsMsg::set_m_llsidemoney(::google::protobuf::int64 value) {
  set_has_m_llsidemoney();
  m_llsidemoney_ = value;
}

// required sint32 m_lBetType = 10;
inline bool PKMsgSC_BettingAnsMsg::has_m_lbettype() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PKMsgSC_BettingAnsMsg::set_has_m_lbettype() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PKMsgSC_BettingAnsMsg::clear_has_m_lbettype() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PKMsgSC_BettingAnsMsg::clear_m_lbettype() {
  m_lbettype_ = 0;
  clear_has_m_lbettype();
}
inline ::google::protobuf::int32 PKMsgSC_BettingAnsMsg::m_lbettype() const {
  return m_lbettype_;
}
inline void PKMsgSC_BettingAnsMsg::set_m_lbettype(::google::protobuf::int32 value) {
  set_has_m_lbettype();
  m_lbettype_ = value;
}

// required sint32 m_lBetTurn = 11;
inline bool PKMsgSC_BettingAnsMsg::has_m_lbetturn() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PKMsgSC_BettingAnsMsg::set_has_m_lbetturn() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PKMsgSC_BettingAnsMsg::clear_has_m_lbetturn() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PKMsgSC_BettingAnsMsg::clear_m_lbetturn() {
  m_lbetturn_ = 0;
  clear_has_m_lbetturn();
}
inline ::google::protobuf::int32 PKMsgSC_BettingAnsMsg::m_lbetturn() const {
  return m_lbetturn_;
}
inline void PKMsgSC_BettingAnsMsg::set_m_lbetturn(::google::protobuf::int32 value) {
  set_has_m_lbetturn();
  m_lbetturn_ = value;
}

// required .PKMoney m_money = 12;
inline bool PKMsgSC_BettingAnsMsg::has_m_money() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PKMsgSC_BettingAnsMsg::set_has_m_money() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PKMsgSC_BettingAnsMsg::clear_has_m_money() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PKMsgSC_BettingAnsMsg::clear_m_money() {
  if (m_money_ != NULL) m_money_->::PKMoney::Clear();
  clear_has_m_money();
}
inline const ::PKMoney& PKMsgSC_BettingAnsMsg::m_money() const {
  return m_money_ != NULL ? *m_money_ : *default_instance_->m_money_;
}
inline ::PKMoney* PKMsgSC_BettingAnsMsg::mutable_m_money() {
  set_has_m_money();
  if (m_money_ == NULL) m_money_ = new ::PKMoney;
  return m_money_;
}
inline ::PKMoney* PKMsgSC_BettingAnsMsg::release_m_money() {
  clear_has_m_money();
  ::PKMoney* temp = m_money_;
  m_money_ = NULL;
  return temp;
}

// repeated .PKVecMoney m_vtCallMoney = 13;
inline int PKMsgSC_BettingAnsMsg::m_vtcallmoney_size() const {
  return m_vtcallmoney_.size();
}
inline void PKMsgSC_BettingAnsMsg::clear_m_vtcallmoney() {
  m_vtcallmoney_.Clear();
}
inline const ::PKVecMoney& PKMsgSC_BettingAnsMsg::m_vtcallmoney(int index) const {
  return m_vtcallmoney_.Get(index);
}
inline ::PKVecMoney* PKMsgSC_BettingAnsMsg::mutable_m_vtcallmoney(int index) {
  return m_vtcallmoney_.Mutable(index);
}
inline ::PKVecMoney* PKMsgSC_BettingAnsMsg::add_m_vtcallmoney() {
  return m_vtcallmoney_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PKVecMoney >&
PKMsgSC_BettingAnsMsg::m_vtcallmoney() const {
  return m_vtcallmoney_;
}
inline ::google::protobuf::RepeatedPtrField< ::PKVecMoney >*
PKMsgSC_BettingAnsMsg::mutable_m_vtcallmoney() {
  return &m_vtcallmoney_;
}

// required sint64 m_llPoolMoney = 14;
inline bool PKMsgSC_BettingAnsMsg::has_m_llpoolmoney() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PKMsgSC_BettingAnsMsg::set_has_m_llpoolmoney() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PKMsgSC_BettingAnsMsg::clear_has_m_llpoolmoney() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PKMsgSC_BettingAnsMsg::clear_m_llpoolmoney() {
  m_llpoolmoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_llpoolmoney();
}
inline ::google::protobuf::int64 PKMsgSC_BettingAnsMsg::m_llpoolmoney() const {
  return m_llpoolmoney_;
}
inline void PKMsgSC_BettingAnsMsg::set_m_llpoolmoney(::google::protobuf::int64 value) {
  set_has_m_llpoolmoney();
  m_llpoolmoney_ = value;
}

// -------------------------------------------------------------------

// PKMsgSC_DealHiddenCard

// required sint32 m_lBossUSN = 1;
inline bool PKMsgSC_DealHiddenCard::has_m_lbossusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgSC_DealHiddenCard::set_has_m_lbossusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgSC_DealHiddenCard::clear_has_m_lbossusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgSC_DealHiddenCard::clear_m_lbossusn() {
  m_lbossusn_ = 0;
  clear_has_m_lbossusn();
}
inline ::google::protobuf::int32 PKMsgSC_DealHiddenCard::m_lbossusn() const {
  return m_lbossusn_;
}
inline void PKMsgSC_DealHiddenCard::set_m_lbossusn(::google::protobuf::int32 value) {
  set_has_m_lbossusn();
  m_lbossusn_ = value;
}

// required sint32 m_lCardsDealt = 2;
inline bool PKMsgSC_DealHiddenCard::has_m_lcardsdealt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKMsgSC_DealHiddenCard::set_has_m_lcardsdealt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKMsgSC_DealHiddenCard::clear_has_m_lcardsdealt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKMsgSC_DealHiddenCard::clear_m_lcardsdealt() {
  m_lcardsdealt_ = 0;
  clear_has_m_lcardsdealt();
}
inline ::google::protobuf::int32 PKMsgSC_DealHiddenCard::m_lcardsdealt() const {
  return m_lcardsdealt_;
}
inline void PKMsgSC_DealHiddenCard::set_m_lcardsdealt(::google::protobuf::int32 value) {
  set_has_m_lcardsdealt();
  m_lcardsdealt_ = value;
}

// repeated .PKOneCard m_vtOneCard = 3;
inline int PKMsgSC_DealHiddenCard::m_vtonecard_size() const {
  return m_vtonecard_.size();
}
inline void PKMsgSC_DealHiddenCard::clear_m_vtonecard() {
  m_vtonecard_.Clear();
}
inline const ::PKOneCard& PKMsgSC_DealHiddenCard::m_vtonecard(int index) const {
  return m_vtonecard_.Get(index);
}
inline ::PKOneCard* PKMsgSC_DealHiddenCard::mutable_m_vtonecard(int index) {
  return m_vtonecard_.Mutable(index);
}
inline ::PKOneCard* PKMsgSC_DealHiddenCard::add_m_vtonecard() {
  return m_vtonecard_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PKOneCard >&
PKMsgSC_DealHiddenCard::m_vtonecard() const {
  return m_vtonecard_;
}
inline ::google::protobuf::RepeatedPtrField< ::PKOneCard >*
PKMsgSC_DealHiddenCard::mutable_m_vtonecard() {
  return &m_vtonecard_;
}

// -------------------------------------------------------------------

// PKMsgSC_AnteMoney

// required sint64 m_llAnteMoney = 1;
inline bool PKMsgSC_AnteMoney::has_m_llantemoney() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgSC_AnteMoney::set_has_m_llantemoney() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgSC_AnteMoney::clear_has_m_llantemoney() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgSC_AnteMoney::clear_m_llantemoney() {
  m_llantemoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_llantemoney();
}
inline ::google::protobuf::int64 PKMsgSC_AnteMoney::m_llantemoney() const {
  return m_llantemoney_;
}
inline void PKMsgSC_AnteMoney::set_m_llantemoney(::google::protobuf::int64 value) {
  set_has_m_llantemoney();
  m_llantemoney_ = value;
}

// -------------------------------------------------------------------

// PKMsgSC_RuleQuaterHalf

// required sint64 m_llRuleQuaterHalf = 1;
inline bool PKMsgSC_RuleQuaterHalf::has_m_llrulequaterhalf() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgSC_RuleQuaterHalf::set_has_m_llrulequaterhalf() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgSC_RuleQuaterHalf::clear_has_m_llrulequaterhalf() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgSC_RuleQuaterHalf::clear_m_llrulequaterhalf() {
  m_llrulequaterhalf_ = GOOGLE_LONGLONG(0);
  clear_has_m_llrulequaterhalf();
}
inline ::google::protobuf::int64 PKMsgSC_RuleQuaterHalf::m_llrulequaterhalf() const {
  return m_llrulequaterhalf_;
}
inline void PKMsgSC_RuleQuaterHalf::set_m_llrulequaterhalf(::google::protobuf::int64 value) {
  set_has_m_llrulequaterhalf();
  m_llrulequaterhalf_ = value;
}

// required sint64 m_llPoolMoney = 2;
inline bool PKMsgSC_RuleQuaterHalf::has_m_llpoolmoney() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKMsgSC_RuleQuaterHalf::set_has_m_llpoolmoney() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKMsgSC_RuleQuaterHalf::clear_has_m_llpoolmoney() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKMsgSC_RuleQuaterHalf::clear_m_llpoolmoney() {
  m_llpoolmoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_llpoolmoney();
}
inline ::google::protobuf::int64 PKMsgSC_RuleQuaterHalf::m_llpoolmoney() const {
  return m_llpoolmoney_;
}
inline void PKMsgSC_RuleQuaterHalf::set_m_llpoolmoney(::google::protobuf::int64 value) {
  set_has_m_llpoolmoney();
  m_llpoolmoney_ = value;
}

// -------------------------------------------------------------------

// PKMsgSC_Finished

// required sint32 m_lState = 1;
inline bool PKMsgSC_Finished::has_m_lstate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgSC_Finished::set_has_m_lstate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgSC_Finished::clear_has_m_lstate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgSC_Finished::clear_m_lstate() {
  m_lstate_ = 0;
  clear_has_m_lstate();
}
inline ::google::protobuf::int32 PKMsgSC_Finished::m_lstate() const {
  return m_lstate_;
}
inline void PKMsgSC_Finished::set_m_lstate(::google::protobuf::int32 value) {
  set_has_m_lstate();
  m_lstate_ = value;
}

// required sint32 m_bGiveUp = 2;
inline bool PKMsgSC_Finished::has_m_bgiveup() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKMsgSC_Finished::set_has_m_bgiveup() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKMsgSC_Finished::clear_has_m_bgiveup() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKMsgSC_Finished::clear_m_bgiveup() {
  m_bgiveup_ = 0;
  clear_has_m_bgiveup();
}
inline ::google::protobuf::int32 PKMsgSC_Finished::m_bgiveup() const {
  return m_bgiveup_;
}
inline void PKMsgSC_Finished::set_m_bgiveup(::google::protobuf::int32 value) {
  set_has_m_bgiveup();
  m_bgiveup_ = value;
}

// required sint32 m_lRank = 3;
inline bool PKMsgSC_Finished::has_m_lrank() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PKMsgSC_Finished::set_has_m_lrank() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PKMsgSC_Finished::clear_has_m_lrank() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PKMsgSC_Finished::clear_m_lrank() {
  m_lrank_ = 0;
  clear_has_m_lrank();
}
inline ::google::protobuf::int32 PKMsgSC_Finished::m_lrank() const {
  return m_lrank_;
}
inline void PKMsgSC_Finished::set_m_lrank(::google::protobuf::int32 value) {
  set_has_m_lrank();
  m_lrank_ = value;
}

// required sint32 m_lBossUSN = 4;
inline bool PKMsgSC_Finished::has_m_lbossusn() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PKMsgSC_Finished::set_has_m_lbossusn() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PKMsgSC_Finished::clear_has_m_lbossusn() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PKMsgSC_Finished::clear_m_lbossusn() {
  m_lbossusn_ = 0;
  clear_has_m_lbossusn();
}
inline ::google::protobuf::int32 PKMsgSC_Finished::m_lbossusn() const {
  return m_lbossusn_;
}
inline void PKMsgSC_Finished::set_m_lbossusn(::google::protobuf::int32 value) {
  set_has_m_lbossusn();
  m_lbossusn_ = value;
}

// required sint64 m_llGiveMoney = 5;
inline bool PKMsgSC_Finished::has_m_llgivemoney() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PKMsgSC_Finished::set_has_m_llgivemoney() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PKMsgSC_Finished::clear_has_m_llgivemoney() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PKMsgSC_Finished::clear_m_llgivemoney() {
  m_llgivemoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_llgivemoney();
}
inline ::google::protobuf::int64 PKMsgSC_Finished::m_llgivemoney() const {
  return m_llgivemoney_;
}
inline void PKMsgSC_Finished::set_m_llgivemoney(::google::protobuf::int64 value) {
  set_has_m_llgivemoney();
  m_llgivemoney_ = value;
}

// repeated int32 m_vtWin = 6;
inline int PKMsgSC_Finished::m_vtwin_size() const {
  return m_vtwin_.size();
}
inline void PKMsgSC_Finished::clear_m_vtwin() {
  m_vtwin_.Clear();
}
inline ::google::protobuf::int32 PKMsgSC_Finished::m_vtwin(int index) const {
  return m_vtwin_.Get(index);
}
inline void PKMsgSC_Finished::set_m_vtwin(int index, ::google::protobuf::int32 value) {
  m_vtwin_.Set(index, value);
}
inline void PKMsgSC_Finished::add_m_vtwin(::google::protobuf::int32 value) {
  m_vtwin_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PKMsgSC_Finished::m_vtwin() const {
  return m_vtwin_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PKMsgSC_Finished::mutable_m_vtwin() {
  return &m_vtwin_;
}

// repeated int32 m_vtResult = 7;
inline int PKMsgSC_Finished::m_vtresult_size() const {
  return m_vtresult_.size();
}
inline void PKMsgSC_Finished::clear_m_vtresult() {
  m_vtresult_.Clear();
}
inline ::google::protobuf::int32 PKMsgSC_Finished::m_vtresult(int index) const {
  return m_vtresult_.Get(index);
}
inline void PKMsgSC_Finished::set_m_vtresult(int index, ::google::protobuf::int32 value) {
  m_vtresult_.Set(index, value);
}
inline void PKMsgSC_Finished::add_m_vtresult(::google::protobuf::int32 value) {
  m_vtresult_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PKMsgSC_Finished::m_vtresult() const {
  return m_vtresult_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PKMsgSC_Finished::mutable_m_vtresult() {
  return &m_vtresult_;
}

// repeated sint64 m_vtGiveMoney = 8;
inline int PKMsgSC_Finished::m_vtgivemoney_size() const {
  return m_vtgivemoney_.size();
}
inline void PKMsgSC_Finished::clear_m_vtgivemoney() {
  m_vtgivemoney_.Clear();
}
inline ::google::protobuf::int64 PKMsgSC_Finished::m_vtgivemoney(int index) const {
  return m_vtgivemoney_.Get(index);
}
inline void PKMsgSC_Finished::set_m_vtgivemoney(int index, ::google::protobuf::int64 value) {
  m_vtgivemoney_.Set(index, value);
}
inline void PKMsgSC_Finished::add_m_vtgivemoney(::google::protobuf::int64 value) {
  m_vtgivemoney_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
PKMsgSC_Finished::m_vtgivemoney() const {
  return m_vtgivemoney_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
PKMsgSC_Finished::mutable_m_vtgivemoney() {
  return &m_vtgivemoney_;
}

// repeated .PKCards m_tblCard = 9;
inline int PKMsgSC_Finished::m_tblcard_size() const {
  return m_tblcard_.size();
}
inline void PKMsgSC_Finished::clear_m_tblcard() {
  m_tblcard_.Clear();
}
inline const ::PKCards& PKMsgSC_Finished::m_tblcard(int index) const {
  return m_tblcard_.Get(index);
}
inline ::PKCards* PKMsgSC_Finished::mutable_m_tblcard(int index) {
  return m_tblcard_.Mutable(index);
}
inline ::PKCards* PKMsgSC_Finished::add_m_tblcard() {
  return m_tblcard_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PKCards >&
PKMsgSC_Finished::m_tblcard() const {
  return m_tblcard_;
}
inline ::google::protobuf::RepeatedPtrField< ::PKCards >*
PKMsgSC_Finished::mutable_m_tblcard() {
  return &m_tblcard_;
}

// repeated .PKMoney m_tblMoney = 10;
inline int PKMsgSC_Finished::m_tblmoney_size() const {
  return m_tblmoney_.size();
}
inline void PKMsgSC_Finished::clear_m_tblmoney() {
  m_tblmoney_.Clear();
}
inline const ::PKMoney& PKMsgSC_Finished::m_tblmoney(int index) const {
  return m_tblmoney_.Get(index);
}
inline ::PKMoney* PKMsgSC_Finished::mutable_m_tblmoney(int index) {
  return m_tblmoney_.Mutable(index);
}
inline ::PKMoney* PKMsgSC_Finished::add_m_tblmoney() {
  return m_tblmoney_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PKMoney >&
PKMsgSC_Finished::m_tblmoney() const {
  return m_tblmoney_;
}
inline ::google::protobuf::RepeatedPtrField< ::PKMoney >*
PKMsgSC_Finished::mutable_m_tblmoney() {
  return &m_tblmoney_;
}

// required sint64 m_llPoolMoney = 11;
inline bool PKMsgSC_Finished::has_m_llpoolmoney() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PKMsgSC_Finished::set_has_m_llpoolmoney() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PKMsgSC_Finished::clear_has_m_llpoolmoney() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PKMsgSC_Finished::clear_m_llpoolmoney() {
  m_llpoolmoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_llpoolmoney();
}
inline ::google::protobuf::int64 PKMsgSC_Finished::m_llpoolmoney() const {
  return m_llpoolmoney_;
}
inline void PKMsgSC_Finished::set_m_llpoolmoney(::google::protobuf::int64 value) {
  set_has_m_llpoolmoney();
  m_llpoolmoney_ = value;
}

// repeated .UserMoney m_vtUserMoney = 12;
inline int PKMsgSC_Finished::m_vtusermoney_size() const {
  return m_vtusermoney_.size();
}
inline void PKMsgSC_Finished::clear_m_vtusermoney() {
  m_vtusermoney_.Clear();
}
inline const ::UserMoney& PKMsgSC_Finished::m_vtusermoney(int index) const {
  return m_vtusermoney_.Get(index);
}
inline ::UserMoney* PKMsgSC_Finished::mutable_m_vtusermoney(int index) {
  return m_vtusermoney_.Mutable(index);
}
inline ::UserMoney* PKMsgSC_Finished::add_m_vtusermoney() {
  return m_vtusermoney_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::UserMoney >&
PKMsgSC_Finished::m_vtusermoney() const {
  return m_vtusermoney_;
}
inline ::google::protobuf::RepeatedPtrField< ::UserMoney >*
PKMsgSC_Finished::mutable_m_vtusermoney() {
  return &m_vtusermoney_;
}

// required sint32 m_lResultIdx = 13;
inline bool PKMsgSC_Finished::has_m_lresultidx() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PKMsgSC_Finished::set_has_m_lresultidx() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PKMsgSC_Finished::clear_has_m_lresultidx() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PKMsgSC_Finished::clear_m_lresultidx() {
  m_lresultidx_ = 0;
  clear_has_m_lresultidx();
}
inline ::google::protobuf::int32 PKMsgSC_Finished::m_lresultidx() const {
  return m_lresultidx_;
}
inline void PKMsgSC_Finished::set_m_lresultidx(::google::protobuf::int32 value) {
  set_has_m_lresultidx();
  m_lresultidx_ = value;
}

// required sint64 m_llJackpot = 14;
inline bool PKMsgSC_Finished::has_m_lljackpot() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PKMsgSC_Finished::set_has_m_lljackpot() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PKMsgSC_Finished::clear_has_m_lljackpot() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PKMsgSC_Finished::clear_m_lljackpot() {
  m_lljackpot_ = GOOGLE_LONGLONG(0);
  clear_has_m_lljackpot();
}
inline ::google::protobuf::int64 PKMsgSC_Finished::m_lljackpot() const {
  return m_lljackpot_;
}
inline void PKMsgSC_Finished::set_m_lljackpot(::google::protobuf::int64 value) {
  set_has_m_lljackpot();
  m_lljackpot_ = value;
}

// -------------------------------------------------------------------

// PKMsgSC_NewGame

// repeated .PKWinLoseInfo m_vtWinLoseInfo = 1;
inline int PKMsgSC_NewGame::m_vtwinloseinfo_size() const {
  return m_vtwinloseinfo_.size();
}
inline void PKMsgSC_NewGame::clear_m_vtwinloseinfo() {
  m_vtwinloseinfo_.Clear();
}
inline const ::PKWinLoseInfo& PKMsgSC_NewGame::m_vtwinloseinfo(int index) const {
  return m_vtwinloseinfo_.Get(index);
}
inline ::PKWinLoseInfo* PKMsgSC_NewGame::mutable_m_vtwinloseinfo(int index) {
  return m_vtwinloseinfo_.Mutable(index);
}
inline ::PKWinLoseInfo* PKMsgSC_NewGame::add_m_vtwinloseinfo() {
  return m_vtwinloseinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PKWinLoseInfo >&
PKMsgSC_NewGame::m_vtwinloseinfo() const {
  return m_vtwinloseinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::PKWinLoseInfo >*
PKMsgSC_NewGame::mutable_m_vtwinloseinfo() {
  return &m_vtwinloseinfo_;
}

// -------------------------------------------------------------------

// PKMsgSC_ContinueAns

// required sint32 m_lUSN = 1;
inline bool PKMsgSC_ContinueAns::has_m_lusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgSC_ContinueAns::set_has_m_lusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgSC_ContinueAns::clear_has_m_lusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgSC_ContinueAns::clear_m_lusn() {
  m_lusn_ = 0;
  clear_has_m_lusn();
}
inline ::google::protobuf::int32 PKMsgSC_ContinueAns::m_lusn() const {
  return m_lusn_;
}
inline void PKMsgSC_ContinueAns::set_m_lusn(::google::protobuf::int32 value) {
  set_has_m_lusn();
  m_lusn_ = value;
}

// -------------------------------------------------------------------

// PKMsgSC_Continue

// repeated .PKWinLoseInfo m_vtWinLoseInfo = 1;
inline int PKMsgSC_Continue::m_vtwinloseinfo_size() const {
  return m_vtwinloseinfo_.size();
}
inline void PKMsgSC_Continue::clear_m_vtwinloseinfo() {
  m_vtwinloseinfo_.Clear();
}
inline const ::PKWinLoseInfo& PKMsgSC_Continue::m_vtwinloseinfo(int index) const {
  return m_vtwinloseinfo_.Get(index);
}
inline ::PKWinLoseInfo* PKMsgSC_Continue::mutable_m_vtwinloseinfo(int index) {
  return m_vtwinloseinfo_.Mutable(index);
}
inline ::PKWinLoseInfo* PKMsgSC_Continue::add_m_vtwinloseinfo() {
  return m_vtwinloseinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PKWinLoseInfo >&
PKMsgSC_Continue::m_vtwinloseinfo() const {
  return m_vtwinloseinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::PKWinLoseInfo >*
PKMsgSC_Continue::mutable_m_vtwinloseinfo() {
  return &m_vtwinloseinfo_;
}

// -------------------------------------------------------------------

// PKMsgSC_SystemMsg

// required sint32 m_lType = 1;
inline bool PKMsgSC_SystemMsg::has_m_ltype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgSC_SystemMsg::set_has_m_ltype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgSC_SystemMsg::clear_has_m_ltype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgSC_SystemMsg::clear_m_ltype() {
  m_ltype_ = 0;
  clear_has_m_ltype();
}
inline ::google::protobuf::int32 PKMsgSC_SystemMsg::m_ltype() const {
  return m_ltype_;
}
inline void PKMsgSC_SystemMsg::set_m_ltype(::google::protobuf::int32 value) {
  set_has_m_ltype();
  m_ltype_ = value;
}

// -------------------------------------------------------------------

// PKMsgSC_PurgeAns

// -------------------------------------------------------------------

// PKMsgSC_PurgeInfo

// repeated .PKVecUSN m_vtPurgeUSN = 1;
inline int PKMsgSC_PurgeInfo::m_vtpurgeusn_size() const {
  return m_vtpurgeusn_.size();
}
inline void PKMsgSC_PurgeInfo::clear_m_vtpurgeusn() {
  m_vtpurgeusn_.Clear();
}
inline const ::PKVecUSN& PKMsgSC_PurgeInfo::m_vtpurgeusn(int index) const {
  return m_vtpurgeusn_.Get(index);
}
inline ::PKVecUSN* PKMsgSC_PurgeInfo::mutable_m_vtpurgeusn(int index) {
  return m_vtpurgeusn_.Mutable(index);
}
inline ::PKVecUSN* PKMsgSC_PurgeInfo::add_m_vtpurgeusn() {
  return m_vtpurgeusn_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PKVecUSN >&
PKMsgSC_PurgeInfo::m_vtpurgeusn() const {
  return m_vtpurgeusn_;
}
inline ::google::protobuf::RepeatedPtrField< ::PKVecUSN >*
PKMsgSC_PurgeInfo::mutable_m_vtpurgeusn() {
  return &m_vtpurgeusn_;
}

// required int32 m_nCount = 2;
inline bool PKMsgSC_PurgeInfo::has_m_ncount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKMsgSC_PurgeInfo::set_has_m_ncount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKMsgSC_PurgeInfo::clear_has_m_ncount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKMsgSC_PurgeInfo::clear_m_ncount() {
  m_ncount_ = 0;
  clear_has_m_ncount();
}
inline ::google::protobuf::int32 PKMsgSC_PurgeInfo::m_ncount() const {
  return m_ncount_;
}
inline void PKMsgSC_PurgeInfo::set_m_ncount(::google::protobuf::int32 value) {
  set_has_m_ncount();
  m_ncount_ = value;
}

// -------------------------------------------------------------------

// PKMsgSC_SetPurgeMoney

// required sint32 m_lUSN = 1;
inline bool PKMsgSC_SetPurgeMoney::has_m_lusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgSC_SetPurgeMoney::set_has_m_lusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgSC_SetPurgeMoney::clear_has_m_lusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgSC_SetPurgeMoney::clear_m_lusn() {
  m_lusn_ = 0;
  clear_has_m_lusn();
}
inline ::google::protobuf::int32 PKMsgSC_SetPurgeMoney::m_lusn() const {
  return m_lusn_;
}
inline void PKMsgSC_SetPurgeMoney::set_m_lusn(::google::protobuf::int32 value) {
  set_has_m_lusn();
  m_lusn_ = value;
}

// required .PKMoney m_money = 2;
inline bool PKMsgSC_SetPurgeMoney::has_m_money() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKMsgSC_SetPurgeMoney::set_has_m_money() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKMsgSC_SetPurgeMoney::clear_has_m_money() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKMsgSC_SetPurgeMoney::clear_m_money() {
  if (m_money_ != NULL) m_money_->::PKMoney::Clear();
  clear_has_m_money();
}
inline const ::PKMoney& PKMsgSC_SetPurgeMoney::m_money() const {
  return m_money_ != NULL ? *m_money_ : *default_instance_->m_money_;
}
inline ::PKMoney* PKMsgSC_SetPurgeMoney::mutable_m_money() {
  set_has_m_money();
  if (m_money_ == NULL) m_money_ = new ::PKMoney;
  return m_money_;
}
inline ::PKMoney* PKMsgSC_SetPurgeMoney::release_m_money() {
  clear_has_m_money();
  ::PKMoney* temp = m_money_;
  m_money_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// PKMsgSC_AssaItemNotify

// required sint32 m_lUSN = 1;
inline bool PKMsgSC_AssaItemNotify::has_m_lusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgSC_AssaItemNotify::set_has_m_lusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgSC_AssaItemNotify::clear_has_m_lusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgSC_AssaItemNotify::clear_m_lusn() {
  m_lusn_ = 0;
  clear_has_m_lusn();
}
inline ::google::protobuf::int32 PKMsgSC_AssaItemNotify::m_lusn() const {
  return m_lusn_;
}
inline void PKMsgSC_AssaItemNotify::set_m_lusn(::google::protobuf::int32 value) {
  set_has_m_lusn();
  m_lusn_ = value;
}

// required sint32 m_lRankType = 2;
inline bool PKMsgSC_AssaItemNotify::has_m_lranktype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKMsgSC_AssaItemNotify::set_has_m_lranktype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKMsgSC_AssaItemNotify::clear_has_m_lranktype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKMsgSC_AssaItemNotify::clear_m_lranktype() {
  m_lranktype_ = 0;
  clear_has_m_lranktype();
}
inline ::google::protobuf::int32 PKMsgSC_AssaItemNotify::m_lranktype() const {
  return m_lranktype_;
}
inline void PKMsgSC_AssaItemNotify::set_m_lranktype(::google::protobuf::int32 value) {
  set_has_m_lranktype();
  m_lranktype_ = value;
}

// required string m_sItem = 3;
inline bool PKMsgSC_AssaItemNotify::has_m_sitem() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PKMsgSC_AssaItemNotify::set_has_m_sitem() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PKMsgSC_AssaItemNotify::clear_has_m_sitem() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PKMsgSC_AssaItemNotify::clear_m_sitem() {
  if (m_sitem_ != &::google::protobuf::internal::kEmptyString) {
    m_sitem_->clear();
  }
  clear_has_m_sitem();
}
inline const ::std::string& PKMsgSC_AssaItemNotify::m_sitem() const {
  return *m_sitem_;
}
inline void PKMsgSC_AssaItemNotify::set_m_sitem(const ::std::string& value) {
  set_has_m_sitem();
  if (m_sitem_ == &::google::protobuf::internal::kEmptyString) {
    m_sitem_ = new ::std::string;
  }
  m_sitem_->assign(value);
}
inline void PKMsgSC_AssaItemNotify::set_m_sitem(const char* value) {
  set_has_m_sitem();
  if (m_sitem_ == &::google::protobuf::internal::kEmptyString) {
    m_sitem_ = new ::std::string;
  }
  m_sitem_->assign(value);
}
inline void PKMsgSC_AssaItemNotify::set_m_sitem(const char* value, size_t size) {
  set_has_m_sitem();
  if (m_sitem_ == &::google::protobuf::internal::kEmptyString) {
    m_sitem_ = new ::std::string;
  }
  m_sitem_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PKMsgSC_AssaItemNotify::mutable_m_sitem() {
  set_has_m_sitem();
  if (m_sitem_ == &::google::protobuf::internal::kEmptyString) {
    m_sitem_ = new ::std::string;
  }
  return m_sitem_;
}
inline ::std::string* PKMsgSC_AssaItemNotify::release_m_sitem() {
  clear_has_m_sitem();
  if (m_sitem_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_sitem_;
    m_sitem_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// PKMsgSC_ThankYouItemNotify

// required sint32 m_lUSN = 1;
inline bool PKMsgSC_ThankYouItemNotify::has_m_lusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgSC_ThankYouItemNotify::set_has_m_lusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgSC_ThankYouItemNotify::clear_has_m_lusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgSC_ThankYouItemNotify::clear_m_lusn() {
  m_lusn_ = 0;
  clear_has_m_lusn();
}
inline ::google::protobuf::int32 PKMsgSC_ThankYouItemNotify::m_lusn() const {
  return m_lusn_;
}
inline void PKMsgSC_ThankYouItemNotify::set_m_lusn(::google::protobuf::int32 value) {
  set_has_m_lusn();
  m_lusn_ = value;
}

// required sint32 m_lRankType = 2;
inline bool PKMsgSC_ThankYouItemNotify::has_m_lranktype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKMsgSC_ThankYouItemNotify::set_has_m_lranktype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKMsgSC_ThankYouItemNotify::clear_has_m_lranktype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKMsgSC_ThankYouItemNotify::clear_m_lranktype() {
  m_lranktype_ = 0;
  clear_has_m_lranktype();
}
inline ::google::protobuf::int32 PKMsgSC_ThankYouItemNotify::m_lranktype() const {
  return m_lranktype_;
}
inline void PKMsgSC_ThankYouItemNotify::set_m_lranktype(::google::protobuf::int32 value) {
  set_has_m_lranktype();
  m_lranktype_ = value;
}

// required sint64 m_llBasicDDangMoney = 3;
inline bool PKMsgSC_ThankYouItemNotify::has_m_llbasicddangmoney() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PKMsgSC_ThankYouItemNotify::set_has_m_llbasicddangmoney() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PKMsgSC_ThankYouItemNotify::clear_has_m_llbasicddangmoney() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PKMsgSC_ThankYouItemNotify::clear_m_llbasicddangmoney() {
  m_llbasicddangmoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_llbasicddangmoney();
}
inline ::google::protobuf::int64 PKMsgSC_ThankYouItemNotify::m_llbasicddangmoney() const {
  return m_llbasicddangmoney_;
}
inline void PKMsgSC_ThankYouItemNotify::set_m_llbasicddangmoney(::google::protobuf::int64 value) {
  set_has_m_llbasicddangmoney();
  m_llbasicddangmoney_ = value;
}

// required string m_sItem = 4;
inline bool PKMsgSC_ThankYouItemNotify::has_m_sitem() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PKMsgSC_ThankYouItemNotify::set_has_m_sitem() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PKMsgSC_ThankYouItemNotify::clear_has_m_sitem() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PKMsgSC_ThankYouItemNotify::clear_m_sitem() {
  if (m_sitem_ != &::google::protobuf::internal::kEmptyString) {
    m_sitem_->clear();
  }
  clear_has_m_sitem();
}
inline const ::std::string& PKMsgSC_ThankYouItemNotify::m_sitem() const {
  return *m_sitem_;
}
inline void PKMsgSC_ThankYouItemNotify::set_m_sitem(const ::std::string& value) {
  set_has_m_sitem();
  if (m_sitem_ == &::google::protobuf::internal::kEmptyString) {
    m_sitem_ = new ::std::string;
  }
  m_sitem_->assign(value);
}
inline void PKMsgSC_ThankYouItemNotify::set_m_sitem(const char* value) {
  set_has_m_sitem();
  if (m_sitem_ == &::google::protobuf::internal::kEmptyString) {
    m_sitem_ = new ::std::string;
  }
  m_sitem_->assign(value);
}
inline void PKMsgSC_ThankYouItemNotify::set_m_sitem(const char* value, size_t size) {
  set_has_m_sitem();
  if (m_sitem_ == &::google::protobuf::internal::kEmptyString) {
    m_sitem_ = new ::std::string;
  }
  m_sitem_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PKMsgSC_ThankYouItemNotify::mutable_m_sitem() {
  set_has_m_sitem();
  if (m_sitem_ == &::google::protobuf::internal::kEmptyString) {
    m_sitem_ = new ::std::string;
  }
  return m_sitem_;
}
inline ::std::string* PKMsgSC_ThankYouItemNotify::release_m_sitem() {
  clear_has_m_sitem();
  if (m_sitem_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_sitem_;
    m_sitem_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// PKMsgSC_MadeItemNotify

// required sint32 m_lUSN = 1;
inline bool PKMsgSC_MadeItemNotify::has_m_lusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgSC_MadeItemNotify::set_has_m_lusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgSC_MadeItemNotify::clear_has_m_lusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgSC_MadeItemNotify::clear_m_lusn() {
  m_lusn_ = 0;
  clear_has_m_lusn();
}
inline ::google::protobuf::int32 PKMsgSC_MadeItemNotify::m_lusn() const {
  return m_lusn_;
}
inline void PKMsgSC_MadeItemNotify::set_m_lusn(::google::protobuf::int32 value) {
  set_has_m_lusn();
  m_lusn_ = value;
}

// required sint32 m_lRankType = 2;
inline bool PKMsgSC_MadeItemNotify::has_m_lranktype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKMsgSC_MadeItemNotify::set_has_m_lranktype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKMsgSC_MadeItemNotify::clear_has_m_lranktype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKMsgSC_MadeItemNotify::clear_m_lranktype() {
  m_lranktype_ = 0;
  clear_has_m_lranktype();
}
inline ::google::protobuf::int32 PKMsgSC_MadeItemNotify::m_lranktype() const {
  return m_lranktype_;
}
inline void PKMsgSC_MadeItemNotify::set_m_lranktype(::google::protobuf::int32 value) {
  set_has_m_lranktype();
  m_lranktype_ = value;
}

// required string m_sItem = 3;
inline bool PKMsgSC_MadeItemNotify::has_m_sitem() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PKMsgSC_MadeItemNotify::set_has_m_sitem() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PKMsgSC_MadeItemNotify::clear_has_m_sitem() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PKMsgSC_MadeItemNotify::clear_m_sitem() {
  if (m_sitem_ != &::google::protobuf::internal::kEmptyString) {
    m_sitem_->clear();
  }
  clear_has_m_sitem();
}
inline const ::std::string& PKMsgSC_MadeItemNotify::m_sitem() const {
  return *m_sitem_;
}
inline void PKMsgSC_MadeItemNotify::set_m_sitem(const ::std::string& value) {
  set_has_m_sitem();
  if (m_sitem_ == &::google::protobuf::internal::kEmptyString) {
    m_sitem_ = new ::std::string;
  }
  m_sitem_->assign(value);
}
inline void PKMsgSC_MadeItemNotify::set_m_sitem(const char* value) {
  set_has_m_sitem();
  if (m_sitem_ == &::google::protobuf::internal::kEmptyString) {
    m_sitem_ = new ::std::string;
  }
  m_sitem_->assign(value);
}
inline void PKMsgSC_MadeItemNotify::set_m_sitem(const char* value, size_t size) {
  set_has_m_sitem();
  if (m_sitem_ == &::google::protobuf::internal::kEmptyString) {
    m_sitem_ = new ::std::string;
  }
  m_sitem_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PKMsgSC_MadeItemNotify::mutable_m_sitem() {
  set_has_m_sitem();
  if (m_sitem_ == &::google::protobuf::internal::kEmptyString) {
    m_sitem_ = new ::std::string;
  }
  return m_sitem_;
}
inline ::std::string* PKMsgSC_MadeItemNotify::release_m_sitem() {
  clear_has_m_sitem();
  if (m_sitem_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_sitem_;
    m_sitem_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// PKMsgSC_ExtMoneyNotify

// required sint32 m_lUSN = 1;
inline bool PKMsgSC_ExtMoneyNotify::has_m_lusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgSC_ExtMoneyNotify::set_has_m_lusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgSC_ExtMoneyNotify::clear_has_m_lusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgSC_ExtMoneyNotify::clear_m_lusn() {
  m_lusn_ = 0;
  clear_has_m_lusn();
}
inline ::google::protobuf::int32 PKMsgSC_ExtMoneyNotify::m_lusn() const {
  return m_lusn_;
}
inline void PKMsgSC_ExtMoneyNotify::set_m_lusn(::google::protobuf::int32 value) {
  set_has_m_lusn();
  m_lusn_ = value;
}

// required sint32 m_bExtType = 2;
inline bool PKMsgSC_ExtMoneyNotify::has_m_bexttype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKMsgSC_ExtMoneyNotify::set_has_m_bexttype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKMsgSC_ExtMoneyNotify::clear_has_m_bexttype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKMsgSC_ExtMoneyNotify::clear_m_bexttype() {
  m_bexttype_ = 0;
  clear_has_m_bexttype();
}
inline ::google::protobuf::int32 PKMsgSC_ExtMoneyNotify::m_bexttype() const {
  return m_bexttype_;
}
inline void PKMsgSC_ExtMoneyNotify::set_m_bexttype(::google::protobuf::int32 value) {
  set_has_m_bexttype();
  m_bexttype_ = value;
}

// required sint64 m_llCMoney = 3;
inline bool PKMsgSC_ExtMoneyNotify::has_m_llcmoney() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PKMsgSC_ExtMoneyNotify::set_has_m_llcmoney() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PKMsgSC_ExtMoneyNotify::clear_has_m_llcmoney() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PKMsgSC_ExtMoneyNotify::clear_m_llcmoney() {
  m_llcmoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_llcmoney();
}
inline ::google::protobuf::int64 PKMsgSC_ExtMoneyNotify::m_llcmoney() const {
  return m_llcmoney_;
}
inline void PKMsgSC_ExtMoneyNotify::set_m_llcmoney(::google::protobuf::int64 value) {
  set_has_m_llcmoney();
  m_llcmoney_ = value;
}

// required sint64 m_llCashBox = 4;
inline bool PKMsgSC_ExtMoneyNotify::has_m_llcashbox() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PKMsgSC_ExtMoneyNotify::set_has_m_llcashbox() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PKMsgSC_ExtMoneyNotify::clear_has_m_llcashbox() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PKMsgSC_ExtMoneyNotify::clear_m_llcashbox() {
  m_llcashbox_ = GOOGLE_LONGLONG(0);
  clear_has_m_llcashbox();
}
inline ::google::protobuf::int64 PKMsgSC_ExtMoneyNotify::m_llcashbox() const {
  return m_llcashbox_;
}
inline void PKMsgSC_ExtMoneyNotify::set_m_llcashbox(::google::protobuf::int64 value) {
  set_has_m_llcashbox();
  m_llcashbox_ = value;
}

// required sint64 m_llExtMoney = 5;
inline bool PKMsgSC_ExtMoneyNotify::has_m_llextmoney() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PKMsgSC_ExtMoneyNotify::set_has_m_llextmoney() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PKMsgSC_ExtMoneyNotify::clear_has_m_llextmoney() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PKMsgSC_ExtMoneyNotify::clear_m_llextmoney() {
  m_llextmoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_llextmoney();
}
inline ::google::protobuf::int64 PKMsgSC_ExtMoneyNotify::m_llextmoney() const {
  return m_llextmoney_;
}
inline void PKMsgSC_ExtMoneyNotify::set_m_llextmoney(::google::protobuf::int64 value) {
  set_has_m_llextmoney();
  m_llextmoney_ = value;
}

// required sint64 m_llExtDate = 6;
inline bool PKMsgSC_ExtMoneyNotify::has_m_llextdate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PKMsgSC_ExtMoneyNotify::set_has_m_llextdate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PKMsgSC_ExtMoneyNotify::clear_has_m_llextdate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PKMsgSC_ExtMoneyNotify::clear_m_llextdate() {
  m_llextdate_ = GOOGLE_LONGLONG(0);
  clear_has_m_llextdate();
}
inline ::google::protobuf::int64 PKMsgSC_ExtMoneyNotify::m_llextdate() const {
  return m_llextdate_;
}
inline void PKMsgSC_ExtMoneyNotify::set_m_llextdate(::google::protobuf::int64 value) {
  set_has_m_llextdate();
  m_llextdate_ = value;
}

// -------------------------------------------------------------------

// PKMsgSC_GameEndSystemMsg

// required sint32 m_lType = 1;
inline bool PKMsgSC_GameEndSystemMsg::has_m_ltype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgSC_GameEndSystemMsg::set_has_m_ltype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgSC_GameEndSystemMsg::clear_has_m_ltype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgSC_GameEndSystemMsg::clear_m_ltype() {
  m_ltype_ = 0;
  clear_has_m_ltype();
}
inline ::google::protobuf::int32 PKMsgSC_GameEndSystemMsg::m_ltype() const {
  return m_ltype_;
}
inline void PKMsgSC_GameEndSystemMsg::set_m_ltype(::google::protobuf::int32 value) {
  set_has_m_ltype();
  m_ltype_ = value;
}

// required sint32 m_lUSN = 2;
inline bool PKMsgSC_GameEndSystemMsg::has_m_lusn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKMsgSC_GameEndSystemMsg::set_has_m_lusn() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKMsgSC_GameEndSystemMsg::clear_has_m_lusn() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKMsgSC_GameEndSystemMsg::clear_m_lusn() {
  m_lusn_ = 0;
  clear_has_m_lusn();
}
inline ::google::protobuf::int32 PKMsgSC_GameEndSystemMsg::m_lusn() const {
  return m_lusn_;
}
inline void PKMsgSC_GameEndSystemMsg::set_m_lusn(::google::protobuf::int32 value) {
  set_has_m_lusn();
  m_lusn_ = value;
}

// required sint32 m_bGiveUp = 3;
inline bool PKMsgSC_GameEndSystemMsg::has_m_bgiveup() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PKMsgSC_GameEndSystemMsg::set_has_m_bgiveup() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PKMsgSC_GameEndSystemMsg::clear_has_m_bgiveup() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PKMsgSC_GameEndSystemMsg::clear_m_bgiveup() {
  m_bgiveup_ = 0;
  clear_has_m_bgiveup();
}
inline ::google::protobuf::int32 PKMsgSC_GameEndSystemMsg::m_bgiveup() const {
  return m_bgiveup_;
}
inline void PKMsgSC_GameEndSystemMsg::set_m_bgiveup(::google::protobuf::int32 value) {
  set_has_m_bgiveup();
  m_bgiveup_ = value;
}

// required sint64 m_llMoney = 4;
inline bool PKMsgSC_GameEndSystemMsg::has_m_llmoney() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PKMsgSC_GameEndSystemMsg::set_has_m_llmoney() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PKMsgSC_GameEndSystemMsg::clear_has_m_llmoney() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PKMsgSC_GameEndSystemMsg::clear_m_llmoney() {
  m_llmoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_llmoney();
}
inline ::google::protobuf::int64 PKMsgSC_GameEndSystemMsg::m_llmoney() const {
  return m_llmoney_;
}
inline void PKMsgSC_GameEndSystemMsg::set_m_llmoney(::google::protobuf::int64 value) {
  set_has_m_llmoney();
  m_llmoney_ = value;
}

// required string m_sMsg = 5;
inline bool PKMsgSC_GameEndSystemMsg::has_m_smsg() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PKMsgSC_GameEndSystemMsg::set_has_m_smsg() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PKMsgSC_GameEndSystemMsg::clear_has_m_smsg() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PKMsgSC_GameEndSystemMsg::clear_m_smsg() {
  if (m_smsg_ != &::google::protobuf::internal::kEmptyString) {
    m_smsg_->clear();
  }
  clear_has_m_smsg();
}
inline const ::std::string& PKMsgSC_GameEndSystemMsg::m_smsg() const {
  return *m_smsg_;
}
inline void PKMsgSC_GameEndSystemMsg::set_m_smsg(const ::std::string& value) {
  set_has_m_smsg();
  if (m_smsg_ == &::google::protobuf::internal::kEmptyString) {
    m_smsg_ = new ::std::string;
  }
  m_smsg_->assign(value);
}
inline void PKMsgSC_GameEndSystemMsg::set_m_smsg(const char* value) {
  set_has_m_smsg();
  if (m_smsg_ == &::google::protobuf::internal::kEmptyString) {
    m_smsg_ = new ::std::string;
  }
  m_smsg_->assign(value);
}
inline void PKMsgSC_GameEndSystemMsg::set_m_smsg(const char* value, size_t size) {
  set_has_m_smsg();
  if (m_smsg_ == &::google::protobuf::internal::kEmptyString) {
    m_smsg_ = new ::std::string;
  }
  m_smsg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PKMsgSC_GameEndSystemMsg::mutable_m_smsg() {
  set_has_m_smsg();
  if (m_smsg_ == &::google::protobuf::internal::kEmptyString) {
    m_smsg_ = new ::std::string;
  }
  return m_smsg_;
}
inline ::std::string* PKMsgSC_GameEndSystemMsg::release_m_smsg() {
  clear_has_m_smsg();
  if (m_smsg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_smsg_;
    m_smsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// PKMsgSC_ChangeAvatarNotify

// required sint32 m_lUSN = 1;
inline bool PKMsgSC_ChangeAvatarNotify::has_m_lusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgSC_ChangeAvatarNotify::set_has_m_lusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgSC_ChangeAvatarNotify::clear_has_m_lusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgSC_ChangeAvatarNotify::clear_m_lusn() {
  m_lusn_ = 0;
  clear_has_m_lusn();
}
inline ::google::protobuf::int32 PKMsgSC_ChangeAvatarNotify::m_lusn() const {
  return m_lusn_;
}
inline void PKMsgSC_ChangeAvatarNotify::set_m_lusn(::google::protobuf::int32 value) {
  set_has_m_lusn();
  m_lusn_ = value;
}

// required int32 m_nIndex = 2;
inline bool PKMsgSC_ChangeAvatarNotify::has_m_nindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKMsgSC_ChangeAvatarNotify::set_has_m_nindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKMsgSC_ChangeAvatarNotify::clear_has_m_nindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKMsgSC_ChangeAvatarNotify::clear_m_nindex() {
  m_nindex_ = 0;
  clear_has_m_nindex();
}
inline ::google::protobuf::int32 PKMsgSC_ChangeAvatarNotify::m_nindex() const {
  return m_nindex_;
}
inline void PKMsgSC_ChangeAvatarNotify::set_m_nindex(::google::protobuf::int32 value) {
  set_has_m_nindex();
  m_nindex_ = value;
}

// required .PKUserInfo m_uinfo = 3;
inline bool PKMsgSC_ChangeAvatarNotify::has_m_uinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PKMsgSC_ChangeAvatarNotify::set_has_m_uinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PKMsgSC_ChangeAvatarNotify::clear_has_m_uinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PKMsgSC_ChangeAvatarNotify::clear_m_uinfo() {
  if (m_uinfo_ != NULL) m_uinfo_->::PKUserInfo::Clear();
  clear_has_m_uinfo();
}
inline const ::PKUserInfo& PKMsgSC_ChangeAvatarNotify::m_uinfo() const {
  return m_uinfo_ != NULL ? *m_uinfo_ : *default_instance_->m_uinfo_;
}
inline ::PKUserInfo* PKMsgSC_ChangeAvatarNotify::mutable_m_uinfo() {
  set_has_m_uinfo();
  if (m_uinfo_ == NULL) m_uinfo_ = new ::PKUserInfo;
  return m_uinfo_;
}
inline ::PKUserInfo* PKMsgSC_ChangeAvatarNotify::release_m_uinfo() {
  clear_has_m_uinfo();
  ::PKUserInfo* temp = m_uinfo_;
  m_uinfo_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// PKMsgSC_AbuseAns

// -------------------------------------------------------------------

// PKMsgSC_SoundTypeAns

// required sint32 m_lUSN = 1;
inline bool PKMsgSC_SoundTypeAns::has_m_lusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgSC_SoundTypeAns::set_has_m_lusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgSC_SoundTypeAns::clear_has_m_lusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgSC_SoundTypeAns::clear_m_lusn() {
  m_lusn_ = 0;
  clear_has_m_lusn();
}
inline ::google::protobuf::int32 PKMsgSC_SoundTypeAns::m_lusn() const {
  return m_lusn_;
}
inline void PKMsgSC_SoundTypeAns::set_m_lusn(::google::protobuf::int32 value) {
  set_has_m_lusn();
  m_lusn_ = value;
}

// required int32 m_nIndex = 2;
inline bool PKMsgSC_SoundTypeAns::has_m_nindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKMsgSC_SoundTypeAns::set_has_m_nindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKMsgSC_SoundTypeAns::clear_has_m_nindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKMsgSC_SoundTypeAns::clear_m_nindex() {
  m_nindex_ = 0;
  clear_has_m_nindex();
}
inline ::google::protobuf::int32 PKMsgSC_SoundTypeAns::m_nindex() const {
  return m_nindex_;
}
inline void PKMsgSC_SoundTypeAns::set_m_nindex(::google::protobuf::int32 value) {
  set_has_m_nindex();
  m_nindex_ = value;
}

// required sint32 m_lSoundType = 3;
inline bool PKMsgSC_SoundTypeAns::has_m_lsoundtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PKMsgSC_SoundTypeAns::set_has_m_lsoundtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PKMsgSC_SoundTypeAns::clear_has_m_lsoundtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PKMsgSC_SoundTypeAns::clear_m_lsoundtype() {
  m_lsoundtype_ = 0;
  clear_has_m_lsoundtype();
}
inline ::google::protobuf::int32 PKMsgSC_SoundTypeAns::m_lsoundtype() const {
  return m_lsoundtype_;
}
inline void PKMsgSC_SoundTypeAns::set_m_lsoundtype(::google::protobuf::int32 value) {
  set_has_m_lsoundtype();
  m_lsoundtype_ = value;
}

// -------------------------------------------------------------------

// PKMsgSC_FMoney

// required string m_sFMoney = 1;
inline bool PKMsgSC_FMoney::has_m_sfmoney() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgSC_FMoney::set_has_m_sfmoney() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgSC_FMoney::clear_has_m_sfmoney() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgSC_FMoney::clear_m_sfmoney() {
  if (m_sfmoney_ != &::google::protobuf::internal::kEmptyString) {
    m_sfmoney_->clear();
  }
  clear_has_m_sfmoney();
}
inline const ::std::string& PKMsgSC_FMoney::m_sfmoney() const {
  return *m_sfmoney_;
}
inline void PKMsgSC_FMoney::set_m_sfmoney(const ::std::string& value) {
  set_has_m_sfmoney();
  if (m_sfmoney_ == &::google::protobuf::internal::kEmptyString) {
    m_sfmoney_ = new ::std::string;
  }
  m_sfmoney_->assign(value);
}
inline void PKMsgSC_FMoney::set_m_sfmoney(const char* value) {
  set_has_m_sfmoney();
  if (m_sfmoney_ == &::google::protobuf::internal::kEmptyString) {
    m_sfmoney_ = new ::std::string;
  }
  m_sfmoney_->assign(value);
}
inline void PKMsgSC_FMoney::set_m_sfmoney(const char* value, size_t size) {
  set_has_m_sfmoney();
  if (m_sfmoney_ == &::google::protobuf::internal::kEmptyString) {
    m_sfmoney_ = new ::std::string;
  }
  m_sfmoney_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PKMsgSC_FMoney::mutable_m_sfmoney() {
  set_has_m_sfmoney();
  if (m_sfmoney_ == &::google::protobuf::internal::kEmptyString) {
    m_sfmoney_ = new ::std::string;
  }
  return m_sfmoney_;
}
inline ::std::string* PKMsgSC_FMoney::release_m_sfmoney() {
  clear_has_m_sfmoney();
  if (m_sfmoney_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_sfmoney_;
    m_sfmoney_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// PKMsgSC_ItemNotify

// required sint32 m_lLimitTotalCnt = 1;
inline bool PKMsgSC_ItemNotify::has_m_llimittotalcnt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgSC_ItemNotify::set_has_m_llimittotalcnt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgSC_ItemNotify::clear_has_m_llimittotalcnt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgSC_ItemNotify::clear_m_llimittotalcnt() {
  m_llimittotalcnt_ = 0;
  clear_has_m_llimittotalcnt();
}
inline ::google::protobuf::int32 PKMsgSC_ItemNotify::m_llimittotalcnt() const {
  return m_llimittotalcnt_;
}
inline void PKMsgSC_ItemNotify::set_m_llimittotalcnt(::google::protobuf::int32 value) {
  set_has_m_llimittotalcnt();
  m_llimittotalcnt_ = value;
}

// required sint32 m_lLimitTodayCnt = 2;
inline bool PKMsgSC_ItemNotify::has_m_llimittodaycnt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKMsgSC_ItemNotify::set_has_m_llimittodaycnt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKMsgSC_ItemNotify::clear_has_m_llimittodaycnt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKMsgSC_ItemNotify::clear_m_llimittodaycnt() {
  m_llimittodaycnt_ = 0;
  clear_has_m_llimittodaycnt();
}
inline ::google::protobuf::int32 PKMsgSC_ItemNotify::m_llimittodaycnt() const {
  return m_llimittodaycnt_;
}
inline void PKMsgSC_ItemNotify::set_m_llimittodaycnt(::google::protobuf::int32 value) {
  set_has_m_llimittodaycnt();
  m_llimittodaycnt_ = value;
}

// required sint32 m_bInfinitySpeedItem = 3;
inline bool PKMsgSC_ItemNotify::has_m_binfinityspeeditem() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PKMsgSC_ItemNotify::set_has_m_binfinityspeeditem() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PKMsgSC_ItemNotify::clear_has_m_binfinityspeeditem() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PKMsgSC_ItemNotify::clear_m_binfinityspeeditem() {
  m_binfinityspeeditem_ = 0;
  clear_has_m_binfinityspeeditem();
}
inline ::google::protobuf::int32 PKMsgSC_ItemNotify::m_binfinityspeeditem() const {
  return m_binfinityspeeditem_;
}
inline void PKMsgSC_ItemNotify::set_m_binfinityspeeditem(::google::protobuf::int32 value) {
  set_has_m_binfinityspeeditem();
  m_binfinityspeeditem_ = value;
}

// required sint64 m_llSpeedToTime = 4;
inline bool PKMsgSC_ItemNotify::has_m_llspeedtotime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PKMsgSC_ItemNotify::set_has_m_llspeedtotime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PKMsgSC_ItemNotify::clear_has_m_llspeedtotime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PKMsgSC_ItemNotify::clear_m_llspeedtotime() {
  m_llspeedtotime_ = GOOGLE_LONGLONG(0);
  clear_has_m_llspeedtotime();
}
inline ::google::protobuf::int64 PKMsgSC_ItemNotify::m_llspeedtotime() const {
  return m_llspeedtotime_;
}
inline void PKMsgSC_ItemNotify::set_m_llspeedtotime(::google::protobuf::int64 value) {
  set_has_m_llspeedtotime();
  m_llspeedtotime_ = value;
}

// -------------------------------------------------------------------

// PKMsgSC_DisconnectMoneyNotify

// required string m_sNickName = 1;
inline bool PKMsgSC_DisconnectMoneyNotify::has_m_snickname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgSC_DisconnectMoneyNotify::set_has_m_snickname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgSC_DisconnectMoneyNotify::clear_has_m_snickname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgSC_DisconnectMoneyNotify::clear_m_snickname() {
  if (m_snickname_ != &::google::protobuf::internal::kEmptyString) {
    m_snickname_->clear();
  }
  clear_has_m_snickname();
}
inline const ::std::string& PKMsgSC_DisconnectMoneyNotify::m_snickname() const {
  return *m_snickname_;
}
inline void PKMsgSC_DisconnectMoneyNotify::set_m_snickname(const ::std::string& value) {
  set_has_m_snickname();
  if (m_snickname_ == &::google::protobuf::internal::kEmptyString) {
    m_snickname_ = new ::std::string;
  }
  m_snickname_->assign(value);
}
inline void PKMsgSC_DisconnectMoneyNotify::set_m_snickname(const char* value) {
  set_has_m_snickname();
  if (m_snickname_ == &::google::protobuf::internal::kEmptyString) {
    m_snickname_ = new ::std::string;
  }
  m_snickname_->assign(value);
}
inline void PKMsgSC_DisconnectMoneyNotify::set_m_snickname(const char* value, size_t size) {
  set_has_m_snickname();
  if (m_snickname_ == &::google::protobuf::internal::kEmptyString) {
    m_snickname_ = new ::std::string;
  }
  m_snickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PKMsgSC_DisconnectMoneyNotify::mutable_m_snickname() {
  set_has_m_snickname();
  if (m_snickname_ == &::google::protobuf::internal::kEmptyString) {
    m_snickname_ = new ::std::string;
  }
  return m_snickname_;
}
inline ::std::string* PKMsgSC_DisconnectMoneyNotify::release_m_snickname() {
  clear_has_m_snickname();
  if (m_snickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_snickname_;
    m_snickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required sint64 m_llDisconnectMoney = 2;
inline bool PKMsgSC_DisconnectMoneyNotify::has_m_lldisconnectmoney() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKMsgSC_DisconnectMoneyNotify::set_has_m_lldisconnectmoney() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKMsgSC_DisconnectMoneyNotify::clear_has_m_lldisconnectmoney() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKMsgSC_DisconnectMoneyNotify::clear_m_lldisconnectmoney() {
  m_lldisconnectmoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_lldisconnectmoney();
}
inline ::google::protobuf::int64 PKMsgSC_DisconnectMoneyNotify::m_lldisconnectmoney() const {
  return m_lldisconnectmoney_;
}
inline void PKMsgSC_DisconnectMoneyNotify::set_m_lldisconnectmoney(::google::protobuf::int64 value) {
  set_has_m_lldisconnectmoney();
  m_lldisconnectmoney_ = value;
}

// -------------------------------------------------------------------

// PKMsgSC_ExitNtf

// required sint32 m_lUSN = 1;
inline bool PKMsgSC_ExitNtf::has_m_lusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgSC_ExitNtf::set_has_m_lusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgSC_ExitNtf::clear_has_m_lusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgSC_ExitNtf::clear_m_lusn() {
  m_lusn_ = 0;
  clear_has_m_lusn();
}
inline ::google::protobuf::int32 PKMsgSC_ExitNtf::m_lusn() const {
  return m_lusn_;
}
inline void PKMsgSC_ExitNtf::set_m_lusn(::google::protobuf::int32 value) {
  set_has_m_lusn();
  m_lusn_ = value;
}

// required int32 m_nIndex = 2;
inline bool PKMsgSC_ExitNtf::has_m_nindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKMsgSC_ExitNtf::set_has_m_nindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKMsgSC_ExitNtf::clear_has_m_nindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKMsgSC_ExitNtf::clear_m_nindex() {
  m_nindex_ = 0;
  clear_has_m_nindex();
}
inline ::google::protobuf::int32 PKMsgSC_ExitNtf::m_nindex() const {
  return m_nindex_;
}
inline void PKMsgSC_ExitNtf::set_m_nindex(::google::protobuf::int32 value) {
  set_has_m_nindex();
  m_nindex_ = value;
}

// required sint32 m_lExit = 3;
inline bool PKMsgSC_ExitNtf::has_m_lexit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PKMsgSC_ExitNtf::set_has_m_lexit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PKMsgSC_ExitNtf::clear_has_m_lexit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PKMsgSC_ExitNtf::clear_m_lexit() {
  m_lexit_ = 0;
  clear_has_m_lexit();
}
inline ::google::protobuf::int32 PKMsgSC_ExitNtf::m_lexit() const {
  return m_lexit_;
}
inline void PKMsgSC_ExitNtf::set_m_lexit(::google::protobuf::int32 value) {
  set_has_m_lexit();
  m_lexit_ = value;
}

// required sint32 m_bExit = 4;
inline bool PKMsgSC_ExitNtf::has_m_bexit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PKMsgSC_ExitNtf::set_has_m_bexit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PKMsgSC_ExitNtf::clear_has_m_bexit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PKMsgSC_ExitNtf::clear_m_bexit() {
  m_bexit_ = 0;
  clear_has_m_bexit();
}
inline ::google::protobuf::int32 PKMsgSC_ExitNtf::m_bexit() const {
  return m_bexit_;
}
inline void PKMsgSC_ExitNtf::set_m_bexit(::google::protobuf::int32 value) {
  set_has_m_bexit();
  m_bexit_ = value;
}

// -------------------------------------------------------------------

// PKMsgSC_RematchOKAns

// required sint32 m_lUSN = 1;
inline bool PKMsgSC_RematchOKAns::has_m_lusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgSC_RematchOKAns::set_has_m_lusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgSC_RematchOKAns::clear_has_m_lusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgSC_RematchOKAns::clear_m_lusn() {
  m_lusn_ = 0;
  clear_has_m_lusn();
}
inline ::google::protobuf::int32 PKMsgSC_RematchOKAns::m_lusn() const {
  return m_lusn_;
}
inline void PKMsgSC_RematchOKAns::set_m_lusn(::google::protobuf::int32 value) {
  set_has_m_lusn();
  m_lusn_ = value;
}

// required sint64 m_llPoolMoney = 2;
inline bool PKMsgSC_RematchOKAns::has_m_llpoolmoney() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKMsgSC_RematchOKAns::set_has_m_llpoolmoney() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKMsgSC_RematchOKAns::clear_has_m_llpoolmoney() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKMsgSC_RematchOKAns::clear_m_llpoolmoney() {
  m_llpoolmoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_llpoolmoney();
}
inline ::google::protobuf::int64 PKMsgSC_RematchOKAns::m_llpoolmoney() const {
  return m_llpoolmoney_;
}
inline void PKMsgSC_RematchOKAns::set_m_llpoolmoney(::google::protobuf::int64 value) {
  set_has_m_llpoolmoney();
  m_llpoolmoney_ = value;
}

// required .PKMoney m_money = 3;
inline bool PKMsgSC_RematchOKAns::has_m_money() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PKMsgSC_RematchOKAns::set_has_m_money() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PKMsgSC_RematchOKAns::clear_has_m_money() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PKMsgSC_RematchOKAns::clear_m_money() {
  if (m_money_ != NULL) m_money_->::PKMoney::Clear();
  clear_has_m_money();
}
inline const ::PKMoney& PKMsgSC_RematchOKAns::m_money() const {
  return m_money_ != NULL ? *m_money_ : *default_instance_->m_money_;
}
inline ::PKMoney* PKMsgSC_RematchOKAns::mutable_m_money() {
  set_has_m_money();
  if (m_money_ == NULL) m_money_ = new ::PKMoney;
  return m_money_;
}
inline ::PKMoney* PKMsgSC_RematchOKAns::release_m_money() {
  clear_has_m_money();
  ::PKMoney* temp = m_money_;
  m_money_ = NULL;
  return temp;
}

// required sint32 m_bRematchOK = 4;
inline bool PKMsgSC_RematchOKAns::has_m_brematchok() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PKMsgSC_RematchOKAns::set_has_m_brematchok() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PKMsgSC_RematchOKAns::clear_has_m_brematchok() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PKMsgSC_RematchOKAns::clear_m_brematchok() {
  m_brematchok_ = 0;
  clear_has_m_brematchok();
}
inline ::google::protobuf::int32 PKMsgSC_RematchOKAns::m_brematchok() const {
  return m_brematchok_;
}
inline void PKMsgSC_RematchOKAns::set_m_brematchok(::google::protobuf::int32 value) {
  set_has_m_brematchok();
  m_brematchok_ = value;
}

// -------------------------------------------------------------------

// PKMsgSC_RuleNotify

// required int32 m_nRuleIdx = 1;
inline bool PKMsgSC_RuleNotify::has_m_nruleidx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgSC_RuleNotify::set_has_m_nruleidx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgSC_RuleNotify::clear_has_m_nruleidx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgSC_RuleNotify::clear_m_nruleidx() {
  m_nruleidx_ = 0;
  clear_has_m_nruleidx();
}
inline ::google::protobuf::int32 PKMsgSC_RuleNotify::m_nruleidx() const {
  return m_nruleidx_;
}
inline void PKMsgSC_RuleNotify::set_m_nruleidx(::google::protobuf::int32 value) {
  set_has_m_nruleidx();
  m_nruleidx_ = value;
}

// -------------------------------------------------------------------

// PKMsgSC_AllowEntryWaitingUser

// -------------------------------------------------------------------

// PKMsgSC_AllWaitingUserDataNtf

// required sint32 m_bSendWaitingUser = 1;
inline bool PKMsgSC_AllWaitingUserDataNtf::has_m_bsendwaitinguser() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgSC_AllWaitingUserDataNtf::set_has_m_bsendwaitinguser() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgSC_AllWaitingUserDataNtf::clear_has_m_bsendwaitinguser() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgSC_AllWaitingUserDataNtf::clear_m_bsendwaitinguser() {
  m_bsendwaitinguser_ = 0;
  clear_has_m_bsendwaitinguser();
}
inline ::google::protobuf::int32 PKMsgSC_AllWaitingUserDataNtf::m_bsendwaitinguser() const {
  return m_bsendwaitinguser_;
}
inline void PKMsgSC_AllWaitingUserDataNtf::set_m_bsendwaitinguser(::google::protobuf::int32 value) {
  set_has_m_bsendwaitinguser();
  m_bsendwaitinguser_ = value;
}

// repeated .PKWAITINGUSERDATA m_WaitingUserData = 2;
inline int PKMsgSC_AllWaitingUserDataNtf::m_waitinguserdata_size() const {
  return m_waitinguserdata_.size();
}
inline void PKMsgSC_AllWaitingUserDataNtf::clear_m_waitinguserdata() {
  m_waitinguserdata_.Clear();
}
inline const ::PKWAITINGUSERDATA& PKMsgSC_AllWaitingUserDataNtf::m_waitinguserdata(int index) const {
  return m_waitinguserdata_.Get(index);
}
inline ::PKWAITINGUSERDATA* PKMsgSC_AllWaitingUserDataNtf::mutable_m_waitinguserdata(int index) {
  return m_waitinguserdata_.Mutable(index);
}
inline ::PKWAITINGUSERDATA* PKMsgSC_AllWaitingUserDataNtf::add_m_waitinguserdata() {
  return m_waitinguserdata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PKWAITINGUSERDATA >&
PKMsgSC_AllWaitingUserDataNtf::m_waitinguserdata() const {
  return m_waitinguserdata_;
}
inline ::google::protobuf::RepeatedPtrField< ::PKWAITINGUSERDATA >*
PKMsgSC_AllWaitingUserDataNtf::mutable_m_waitinguserdata() {
  return &m_waitinguserdata_;
}

// -------------------------------------------------------------------

// PKMsgSC_UserDataChangeNtf

// required .PKRCUserData m_userData = 1;
inline bool PKMsgSC_UserDataChangeNtf::has_m_userdata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgSC_UserDataChangeNtf::set_has_m_userdata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgSC_UserDataChangeNtf::clear_has_m_userdata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgSC_UserDataChangeNtf::clear_m_userdata() {
  if (m_userdata_ != NULL) m_userdata_->::PKRCUserData::Clear();
  clear_has_m_userdata();
}
inline const ::PKRCUserData& PKMsgSC_UserDataChangeNtf::m_userdata() const {
  return m_userdata_ != NULL ? *m_userdata_ : *default_instance_->m_userdata_;
}
inline ::PKRCUserData* PKMsgSC_UserDataChangeNtf::mutable_m_userdata() {
  set_has_m_userdata();
  if (m_userdata_ == NULL) m_userdata_ = new ::PKRCUserData;
  return m_userdata_;
}
inline ::PKRCUserData* PKMsgSC_UserDataChangeNtf::release_m_userdata() {
  clear_has_m_userdata();
  ::PKRCUserData* temp = m_userdata_;
  m_userdata_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// PKMsgSC_RefillMoneyNtf

// required sint32 m_lUSN = 1;
inline bool PKMsgSC_RefillMoneyNtf::has_m_lusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgSC_RefillMoneyNtf::set_has_m_lusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgSC_RefillMoneyNtf::clear_has_m_lusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgSC_RefillMoneyNtf::clear_m_lusn() {
  m_lusn_ = 0;
  clear_has_m_lusn();
}
inline ::google::protobuf::int32 PKMsgSC_RefillMoneyNtf::m_lusn() const {
  return m_lusn_;
}
inline void PKMsgSC_RefillMoneyNtf::set_m_lusn(::google::protobuf::int32 value) {
  set_has_m_lusn();
  m_lusn_ = value;
}

// required int32 m_nRefillCnt = 2;
inline bool PKMsgSC_RefillMoneyNtf::has_m_nrefillcnt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKMsgSC_RefillMoneyNtf::set_has_m_nrefillcnt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKMsgSC_RefillMoneyNtf::clear_has_m_nrefillcnt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKMsgSC_RefillMoneyNtf::clear_m_nrefillcnt() {
  m_nrefillcnt_ = 0;
  clear_has_m_nrefillcnt();
}
inline ::google::protobuf::int32 PKMsgSC_RefillMoneyNtf::m_nrefillcnt() const {
  return m_nrefillcnt_;
}
inline void PKMsgSC_RefillMoneyNtf::set_m_nrefillcnt(::google::protobuf::int32 value) {
  set_has_m_nrefillcnt();
  m_nrefillcnt_ = value;
}

// required sint64 m_llRefillMoney = 3;
inline bool PKMsgSC_RefillMoneyNtf::has_m_llrefillmoney() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PKMsgSC_RefillMoneyNtf::set_has_m_llrefillmoney() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PKMsgSC_RefillMoneyNtf::clear_has_m_llrefillmoney() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PKMsgSC_RefillMoneyNtf::clear_m_llrefillmoney() {
  m_llrefillmoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_llrefillmoney();
}
inline ::google::protobuf::int64 PKMsgSC_RefillMoneyNtf::m_llrefillmoney() const {
  return m_llrefillmoney_;
}
inline void PKMsgSC_RefillMoneyNtf::set_m_llrefillmoney(::google::protobuf::int64 value) {
  set_has_m_llrefillmoney();
  m_llrefillmoney_ = value;
}

// -------------------------------------------------------------------

// PKMsgSC_JackpotMoneyNtf

// required sint32 m_lUSN = 1;
inline bool PKMsgSC_JackpotMoneyNtf::has_m_lusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgSC_JackpotMoneyNtf::set_has_m_lusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgSC_JackpotMoneyNtf::clear_has_m_lusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgSC_JackpotMoneyNtf::clear_m_lusn() {
  m_lusn_ = 0;
  clear_has_m_lusn();
}
inline ::google::protobuf::int32 PKMsgSC_JackpotMoneyNtf::m_lusn() const {
  return m_lusn_;
}
inline void PKMsgSC_JackpotMoneyNtf::set_m_lusn(::google::protobuf::int32 value) {
  set_has_m_lusn();
  m_lusn_ = value;
}

// required sint64 m_llJackpotMoney = 2;
inline bool PKMsgSC_JackpotMoneyNtf::has_m_lljackpotmoney() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKMsgSC_JackpotMoneyNtf::set_has_m_lljackpotmoney() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKMsgSC_JackpotMoneyNtf::clear_has_m_lljackpotmoney() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKMsgSC_JackpotMoneyNtf::clear_m_lljackpotmoney() {
  m_lljackpotmoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_lljackpotmoney();
}
inline ::google::protobuf::int64 PKMsgSC_JackpotMoneyNtf::m_lljackpotmoney() const {
  return m_lljackpotmoney_;
}
inline void PKMsgSC_JackpotMoneyNtf::set_m_lljackpotmoney(::google::protobuf::int64 value) {
  set_has_m_lljackpotmoney();
  m_lljackpotmoney_ = value;
}

// -------------------------------------------------------------------

// PKMsgSC_GuardianAngelMoney

// required sint32 m_lUSN = 1;
inline bool PKMsgSC_GuardianAngelMoney::has_m_lusn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgSC_GuardianAngelMoney::set_has_m_lusn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgSC_GuardianAngelMoney::clear_has_m_lusn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgSC_GuardianAngelMoney::clear_m_lusn() {
  m_lusn_ = 0;
  clear_has_m_lusn();
}
inline ::google::protobuf::int32 PKMsgSC_GuardianAngelMoney::m_lusn() const {
  return m_lusn_;
}
inline void PKMsgSC_GuardianAngelMoney::set_m_lusn(::google::protobuf::int32 value) {
  set_has_m_lusn();
  m_lusn_ = value;
}

// required int32 m_nGuardianAngelCnt = 2;
inline bool PKMsgSC_GuardianAngelMoney::has_m_nguardianangelcnt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKMsgSC_GuardianAngelMoney::set_has_m_nguardianangelcnt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKMsgSC_GuardianAngelMoney::clear_has_m_nguardianangelcnt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKMsgSC_GuardianAngelMoney::clear_m_nguardianangelcnt() {
  m_nguardianangelcnt_ = 0;
  clear_has_m_nguardianangelcnt();
}
inline ::google::protobuf::int32 PKMsgSC_GuardianAngelMoney::m_nguardianangelcnt() const {
  return m_nguardianangelcnt_;
}
inline void PKMsgSC_GuardianAngelMoney::set_m_nguardianangelcnt(::google::protobuf::int32 value) {
  set_has_m_nguardianangelcnt();
  m_nguardianangelcnt_ = value;
}

// required sint64 m_llAngelMoney = 3;
inline bool PKMsgSC_GuardianAngelMoney::has_m_llangelmoney() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PKMsgSC_GuardianAngelMoney::set_has_m_llangelmoney() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PKMsgSC_GuardianAngelMoney::clear_has_m_llangelmoney() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PKMsgSC_GuardianAngelMoney::clear_m_llangelmoney() {
  m_llangelmoney_ = GOOGLE_LONGLONG(0);
  clear_has_m_llangelmoney();
}
inline ::google::protobuf::int64 PKMsgSC_GuardianAngelMoney::m_llangelmoney() const {
  return m_llangelmoney_;
}
inline void PKMsgSC_GuardianAngelMoney::set_m_llangelmoney(::google::protobuf::int64 value) {
  set_has_m_llangelmoney();
  m_llangelmoney_ = value;
}

// -------------------------------------------------------------------

// PKMsgSC_GameMasterCallNtf

// required sint32 m_lGMCall_USN = 1;
inline bool PKMsgSC_GameMasterCallNtf::has_m_lgmcall_usn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgSC_GameMasterCallNtf::set_has_m_lgmcall_usn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgSC_GameMasterCallNtf::clear_has_m_lgmcall_usn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgSC_GameMasterCallNtf::clear_m_lgmcall_usn() {
  m_lgmcall_usn_ = 0;
  clear_has_m_lgmcall_usn();
}
inline ::google::protobuf::int32 PKMsgSC_GameMasterCallNtf::m_lgmcall_usn() const {
  return m_lgmcall_usn_;
}
inline void PKMsgSC_GameMasterCallNtf::set_m_lgmcall_usn(::google::protobuf::int32 value) {
  set_has_m_lgmcall_usn();
  m_lgmcall_usn_ = value;
}

// -------------------------------------------------------------------

// PKMsgSC_ObserverCnt

// required int32 m_nObserverCnt = 1;
inline bool PKMsgSC_ObserverCnt::has_m_nobservercnt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgSC_ObserverCnt::set_has_m_nobservercnt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgSC_ObserverCnt::clear_has_m_nobservercnt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgSC_ObserverCnt::clear_m_nobservercnt() {
  m_nobservercnt_ = 0;
  clear_has_m_nobservercnt();
}
inline ::google::protobuf::int32 PKMsgSC_ObserverCnt::m_nobservercnt() const {
  return m_nobservercnt_;
}
inline void PKMsgSC_ObserverCnt::set_m_nobservercnt(::google::protobuf::int32 value) {
  set_has_m_nobservercnt();
  m_nobservercnt_ = value;
}

// -------------------------------------------------------------------

// PKMsgSC_Bonus

// required sint64 m_llBonus = 1;
inline bool PKMsgSC_Bonus::has_m_llbonus() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgSC_Bonus::set_has_m_llbonus() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgSC_Bonus::clear_has_m_llbonus() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgSC_Bonus::clear_m_llbonus() {
  m_llbonus_ = GOOGLE_LONGLONG(0);
  clear_has_m_llbonus();
}
inline ::google::protobuf::int64 PKMsgSC_Bonus::m_llbonus() const {
  return m_llbonus_;
}
inline void PKMsgSC_Bonus::set_m_llbonus(::google::protobuf::int64 value) {
  set_has_m_llbonus();
  m_llbonus_ = value;
}

// -------------------------------------------------------------------

// PKMsgSC_PoliceNotify

// required string m_policeMsg = 1;
inline bool PKMsgSC_PoliceNotify::has_m_policemsg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKMsgSC_PoliceNotify::set_has_m_policemsg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKMsgSC_PoliceNotify::clear_has_m_policemsg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKMsgSC_PoliceNotify::clear_m_policemsg() {
  if (m_policemsg_ != &::google::protobuf::internal::kEmptyString) {
    m_policemsg_->clear();
  }
  clear_has_m_policemsg();
}
inline const ::std::string& PKMsgSC_PoliceNotify::m_policemsg() const {
  return *m_policemsg_;
}
inline void PKMsgSC_PoliceNotify::set_m_policemsg(const ::std::string& value) {
  set_has_m_policemsg();
  if (m_policemsg_ == &::google::protobuf::internal::kEmptyString) {
    m_policemsg_ = new ::std::string;
  }
  m_policemsg_->assign(value);
}
inline void PKMsgSC_PoliceNotify::set_m_policemsg(const char* value) {
  set_has_m_policemsg();
  if (m_policemsg_ == &::google::protobuf::internal::kEmptyString) {
    m_policemsg_ = new ::std::string;
  }
  m_policemsg_->assign(value);
}
inline void PKMsgSC_PoliceNotify::set_m_policemsg(const char* value, size_t size) {
  set_has_m_policemsg();
  if (m_policemsg_ == &::google::protobuf::internal::kEmptyString) {
    m_policemsg_ = new ::std::string;
  }
  m_policemsg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PKMsgSC_PoliceNotify::mutable_m_policemsg() {
  set_has_m_policemsg();
  if (m_policemsg_ == &::google::protobuf::internal::kEmptyString) {
    m_policemsg_ = new ::std::string;
  }
  return m_policemsg_;
}
inline ::std::string* PKMsgSC_PoliceNotify::release_m_policemsg() {
  clear_has_m_policemsg();
  if (m_policemsg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_policemsg_;
    m_policemsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_gameLogic_2eproto__INCLUDED
