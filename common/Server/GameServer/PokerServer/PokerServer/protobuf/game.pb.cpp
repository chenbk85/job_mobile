// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "game.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

void protobuf_ShutdownFile_game_2eproto() {
  delete GReqGameEnter::default_instance_;
  delete GAnsGameEnter::default_instance_;
  delete GReqGameLeave::default_instance_;
  delete GAnsGameLeave::default_instance_;
  delete GReqDetach::default_instance_;
  delete GAnsDetach::default_instance_;
  delete GReqPlug::default_instance_;
  delete GAnsPlug::default_instance_;
  delete GError::default_instance_;
  delete GErrPlug::default_instance_;
  delete GReqProtocol::default_instance_;
  delete GAnsProtocol::default_instance_;
}

void protobuf_AddDesc_game_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::protobuf_AddDesc_db_2eproto();
  ::protobuf_AddDesc_gameLogic_2eproto();
  GReqGameEnter::default_instance_ = new GReqGameEnter();
  GAnsGameEnter::default_instance_ = new GAnsGameEnter();
  GReqGameLeave::default_instance_ = new GReqGameLeave();
  GAnsGameLeave::default_instance_ = new GAnsGameLeave();
  GReqDetach::default_instance_ = new GReqDetach();
  GAnsDetach::default_instance_ = new GAnsDetach();
  GReqPlug::default_instance_ = new GReqPlug();
  GAnsPlug::default_instance_ = new GAnsPlug();
  GError::default_instance_ = new GError();
  GErrPlug::default_instance_ = new GErrPlug();
  GReqProtocol::default_instance_ = new GReqProtocol();
  GAnsProtocol::default_instance_ = new GAnsProtocol();
  GReqGameEnter::default_instance_->InitAsDefaultInstance();
  GAnsGameEnter::default_instance_->InitAsDefaultInstance();
  GReqGameLeave::default_instance_->InitAsDefaultInstance();
  GAnsGameLeave::default_instance_->InitAsDefaultInstance();
  GReqDetach::default_instance_->InitAsDefaultInstance();
  GAnsDetach::default_instance_->InitAsDefaultInstance();
  GReqPlug::default_instance_->InitAsDefaultInstance();
  GAnsPlug::default_instance_->InitAsDefaultInstance();
  GError::default_instance_->InitAsDefaultInstance();
  GErrPlug::default_instance_->InitAsDefaultInstance();
  GReqProtocol::default_instance_->InitAsDefaultInstance();
  GAnsProtocol::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_game_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_game_2eproto {
  StaticDescriptorInitializer_game_2eproto() {
    protobuf_AddDesc_game_2eproto();
  }
} static_descriptor_initializer_game_2eproto_;


// ===================================================================

#ifndef _MSC_VER
const int GReqGameEnter::kCategoryIDFieldNumber;
const int GReqGameEnter::kChannelIDFieldNumber;
const int GReqGameEnter::kRoomIDFieldNumber;
const int GReqGameEnter::kGameUserInfoFieldNumber;
#endif  // !_MSC_VER

GReqGameEnter::GReqGameEnter()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GReqGameEnter::InitAsDefaultInstance() {
  gameuserinfo_ = const_cast< ::GameUserInfo*>(&::GameUserInfo::default_instance());
}

GReqGameEnter::GReqGameEnter(const GReqGameEnter& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GReqGameEnter::SharedCtor() {
  _cached_size_ = 0;
  categoryid_ = 0;
  channelid_ = 0;
  roomid_ = 0;
  gameuserinfo_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GReqGameEnter::~GReqGameEnter() {
  SharedDtor();
}

void GReqGameEnter::SharedDtor() {
  if (this != default_instance_) {
    delete gameuserinfo_;
  }
}

void GReqGameEnter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GReqGameEnter& GReqGameEnter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_game_2eproto();  return *default_instance_;
}

GReqGameEnter* GReqGameEnter::default_instance_ = NULL;

GReqGameEnter* GReqGameEnter::New() const {
  return new GReqGameEnter;
}

void GReqGameEnter::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    categoryid_ = 0;
    channelid_ = 0;
    roomid_ = 0;
    if (has_gameuserinfo()) {
      if (gameuserinfo_ != NULL) gameuserinfo_->::GameUserInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GReqGameEnter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 categoryID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &categoryid_)));
          set_has_categoryid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_channelID;
        break;
      }
      
      // required int32 channelID = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_channelID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &channelid_)));
          set_has_channelid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_roomID;
        break;
      }
      
      // required int32 roomID = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_roomID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &roomid_)));
          set_has_roomid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_gameUserInfo;
        break;
      }
      
      // required .GameUserInfo gameUserInfo = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_gameUserInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_gameuserinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GReqGameEnter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 categoryID = 1;
  if (has_categoryid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->categoryid(), output);
  }
  
  // required int32 channelID = 2;
  if (has_channelid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->channelid(), output);
  }
  
  // required int32 roomID = 3;
  if (has_roomid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->roomid(), output);
  }
  
  // required .GameUserInfo gameUserInfo = 4;
  if (has_gameuserinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->gameuserinfo(), output);
  }
  
}

int GReqGameEnter::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 categoryID = 1;
    if (has_categoryid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->categoryid());
    }
    
    // required int32 channelID = 2;
    if (has_channelid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->channelid());
    }
    
    // required int32 roomID = 3;
    if (has_roomid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->roomid());
    }
    
    // required .GameUserInfo gameUserInfo = 4;
    if (has_gameuserinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->gameuserinfo());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GReqGameEnter::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GReqGameEnter*>(&from));
}

void GReqGameEnter::MergeFrom(const GReqGameEnter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_categoryid()) {
      set_categoryid(from.categoryid());
    }
    if (from.has_channelid()) {
      set_channelid(from.channelid());
    }
    if (from.has_roomid()) {
      set_roomid(from.roomid());
    }
    if (from.has_gameuserinfo()) {
      mutable_gameuserinfo()->::GameUserInfo::MergeFrom(from.gameuserinfo());
    }
  }
}

void GReqGameEnter::CopyFrom(const GReqGameEnter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GReqGameEnter::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;
  
  if (has_gameuserinfo()) {
    if (!this->gameuserinfo().IsInitialized()) return false;
  }
  return true;
}

void GReqGameEnter::Swap(GReqGameEnter* other) {
  if (other != this) {
    std::swap(categoryid_, other->categoryid_);
    std::swap(channelid_, other->channelid_);
    std::swap(roomid_, other->roomid_);
    std::swap(gameuserinfo_, other->gameuserinfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GReqGameEnter::GetTypeName() const {
  return "GReqGameEnter";
}


// ===================================================================

#ifndef _MSC_VER
const int GAnsGameEnter::kGameRoomInfoFieldNumber;
#endif  // !_MSC_VER

GAnsGameEnter::GAnsGameEnter()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GAnsGameEnter::InitAsDefaultInstance() {
  gameroominfo_ = const_cast< ::GameRoomInfo*>(&::GameRoomInfo::default_instance());
}

GAnsGameEnter::GAnsGameEnter(const GAnsGameEnter& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GAnsGameEnter::SharedCtor() {
  _cached_size_ = 0;
  gameroominfo_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GAnsGameEnter::~GAnsGameEnter() {
  SharedDtor();
}

void GAnsGameEnter::SharedDtor() {
  if (this != default_instance_) {
    delete gameroominfo_;
  }
}

void GAnsGameEnter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GAnsGameEnter& GAnsGameEnter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_game_2eproto();  return *default_instance_;
}

GAnsGameEnter* GAnsGameEnter::default_instance_ = NULL;

GAnsGameEnter* GAnsGameEnter::New() const {
  return new GAnsGameEnter;
}

void GAnsGameEnter::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_gameroominfo()) {
      if (gameroominfo_ != NULL) gameroominfo_->::GameRoomInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GAnsGameEnter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .GameRoomInfo gameRoomInfo = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_gameroominfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GAnsGameEnter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .GameRoomInfo gameRoomInfo = 1;
  if (has_gameroominfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->gameroominfo(), output);
  }
  
}

int GAnsGameEnter::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .GameRoomInfo gameRoomInfo = 1;
    if (has_gameroominfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->gameroominfo());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GAnsGameEnter::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GAnsGameEnter*>(&from));
}

void GAnsGameEnter::MergeFrom(const GAnsGameEnter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_gameroominfo()) {
      mutable_gameroominfo()->::GameRoomInfo::MergeFrom(from.gameroominfo());
    }
  }
}

void GAnsGameEnter::CopyFrom(const GAnsGameEnter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GAnsGameEnter::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_gameroominfo()) {
    if (!this->gameroominfo().IsInitialized()) return false;
  }
  return true;
}

void GAnsGameEnter::Swap(GAnsGameEnter* other) {
  if (other != this) {
    std::swap(gameroominfo_, other->gameroominfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GAnsGameEnter::GetTypeName() const {
  return "GAnsGameEnter";
}


// ===================================================================

#ifndef _MSC_VER
const int GReqGameLeave::kGameIDFieldNumber;
const int GReqGameLeave::kKickFieldNumber;
#endif  // !_MSC_VER

GReqGameLeave::GReqGameLeave()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GReqGameLeave::InitAsDefaultInstance() {
}

GReqGameLeave::GReqGameLeave(const GReqGameLeave& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GReqGameLeave::SharedCtor() {
  _cached_size_ = 0;
  gameid_ = 0;
  kick_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GReqGameLeave::~GReqGameLeave() {
  SharedDtor();
}

void GReqGameLeave::SharedDtor() {
  if (this != default_instance_) {
  }
}

void GReqGameLeave::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GReqGameLeave& GReqGameLeave::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_game_2eproto();  return *default_instance_;
}

GReqGameLeave* GReqGameLeave::default_instance_ = NULL;

GReqGameLeave* GReqGameLeave::New() const {
  return new GReqGameLeave;
}

void GReqGameLeave::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    gameid_ = 0;
    kick_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GReqGameLeave::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 gameID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &gameid_)));
          set_has_gameid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_kick;
        break;
      }
      
      // required bool kick = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_kick:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &kick_)));
          set_has_kick();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GReqGameLeave::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 gameID = 1;
  if (has_gameid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->gameid(), output);
  }
  
  // required bool kick = 2;
  if (has_kick()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->kick(), output);
  }
  
}

int GReqGameLeave::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 gameID = 1;
    if (has_gameid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->gameid());
    }
    
    // required bool kick = 2;
    if (has_kick()) {
      total_size += 1 + 1;
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GReqGameLeave::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GReqGameLeave*>(&from));
}

void GReqGameLeave::MergeFrom(const GReqGameLeave& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_gameid()) {
      set_gameid(from.gameid());
    }
    if (from.has_kick()) {
      set_kick(from.kick());
    }
  }
}

void GReqGameLeave::CopyFrom(const GReqGameLeave& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GReqGameLeave::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void GReqGameLeave::Swap(GReqGameLeave* other) {
  if (other != this) {
    std::swap(gameid_, other->gameid_);
    std::swap(kick_, other->kick_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GReqGameLeave::GetTypeName() const {
  return "GReqGameLeave";
}


// ===================================================================

bool GAnsGameLeave_KICK_TYPE_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const GAnsGameLeave_KICK_TYPE GAnsGameLeave::EXIT_RESERVATION;
const GAnsGameLeave_KICK_TYPE GAnsGameLeave::LIMITMONEY;
const GAnsGameLeave_KICK_TYPE GAnsGameLeave::ALLIN;
const GAnsGameLeave_KICK_TYPE GAnsGameLeave::SYSTEM_ERROR;
const GAnsGameLeave_KICK_TYPE GAnsGameLeave::KICK_ZERO;
const GAnsGameLeave_KICK_TYPE GAnsGameLeave::KICK_TYPE_MIN;
const GAnsGameLeave_KICK_TYPE GAnsGameLeave::KICK_TYPE_MAX;
const int GAnsGameLeave::KICK_TYPE_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int GAnsGameLeave::kGameIDFieldNumber;
const int GAnsGameLeave::kNTypeFieldNumber;
#endif  // !_MSC_VER

GAnsGameLeave::GAnsGameLeave()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GAnsGameLeave::InitAsDefaultInstance() {
}

GAnsGameLeave::GAnsGameLeave(const GAnsGameLeave& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GAnsGameLeave::SharedCtor() {
  _cached_size_ = 0;
  gameid_ = 0;
  ntype_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GAnsGameLeave::~GAnsGameLeave() {
  SharedDtor();
}

void GAnsGameLeave::SharedDtor() {
  if (this != default_instance_) {
  }
}

void GAnsGameLeave::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GAnsGameLeave& GAnsGameLeave::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_game_2eproto();  return *default_instance_;
}

GAnsGameLeave* GAnsGameLeave::default_instance_ = NULL;

GAnsGameLeave* GAnsGameLeave::New() const {
  return new GAnsGameLeave;
}

void GAnsGameLeave::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    gameid_ = 0;
    ntype_ = 1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GAnsGameLeave::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 gameID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &gameid_)));
          set_has_gameid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_nType;
        break;
      }
      
      // required .GAnsGameLeave.KICK_TYPE nType = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_nType:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::GAnsGameLeave_KICK_TYPE_IsValid(value)) {
            set_ntype(static_cast< ::GAnsGameLeave_KICK_TYPE >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GAnsGameLeave::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 gameID = 1;
  if (has_gameid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->gameid(), output);
  }
  
  // required .GAnsGameLeave.KICK_TYPE nType = 2;
  if (has_ntype()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->ntype(), output);
  }
  
}

int GAnsGameLeave::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 gameID = 1;
    if (has_gameid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->gameid());
    }
    
    // required .GAnsGameLeave.KICK_TYPE nType = 2;
    if (has_ntype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->ntype());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GAnsGameLeave::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GAnsGameLeave*>(&from));
}

void GAnsGameLeave::MergeFrom(const GAnsGameLeave& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_gameid()) {
      set_gameid(from.gameid());
    }
    if (from.has_ntype()) {
      set_ntype(from.ntype());
    }
  }
}

void GAnsGameLeave::CopyFrom(const GAnsGameLeave& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GAnsGameLeave::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void GAnsGameLeave::Swap(GAnsGameLeave* other) {
  if (other != this) {
    std::swap(gameid_, other->gameid_);
    std::swap(ntype_, other->ntype_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GAnsGameLeave::GetTypeName() const {
  return "GAnsGameLeave";
}


// ===================================================================

#ifndef _MSC_VER
const int GReqDetach::kGameIDFieldNumber;
#endif  // !_MSC_VER

GReqDetach::GReqDetach()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GReqDetach::InitAsDefaultInstance() {
}

GReqDetach::GReqDetach(const GReqDetach& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GReqDetach::SharedCtor() {
  _cached_size_ = 0;
  gameid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GReqDetach::~GReqDetach() {
  SharedDtor();
}

void GReqDetach::SharedDtor() {
  if (this != default_instance_) {
  }
}

void GReqDetach::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GReqDetach& GReqDetach::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_game_2eproto();  return *default_instance_;
}

GReqDetach* GReqDetach::default_instance_ = NULL;

GReqDetach* GReqDetach::New() const {
  return new GReqDetach;
}

void GReqDetach::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    gameid_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GReqDetach::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 gameID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &gameid_)));
          set_has_gameid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GReqDetach::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 gameID = 1;
  if (has_gameid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->gameid(), output);
  }
  
}

int GReqDetach::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 gameID = 1;
    if (has_gameid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->gameid());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GReqDetach::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GReqDetach*>(&from));
}

void GReqDetach::MergeFrom(const GReqDetach& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_gameid()) {
      set_gameid(from.gameid());
    }
  }
}

void GReqDetach::CopyFrom(const GReqDetach& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GReqDetach::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void GReqDetach::Swap(GReqDetach* other) {
  if (other != this) {
    std::swap(gameid_, other->gameid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GReqDetach::GetTypeName() const {
  return "GReqDetach";
}


// ===================================================================

#ifndef _MSC_VER
const int GAnsDetach::kGameIDFieldNumber;
#endif  // !_MSC_VER

GAnsDetach::GAnsDetach()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GAnsDetach::InitAsDefaultInstance() {
}

GAnsDetach::GAnsDetach(const GAnsDetach& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GAnsDetach::SharedCtor() {
  _cached_size_ = 0;
  gameid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GAnsDetach::~GAnsDetach() {
  SharedDtor();
}

void GAnsDetach::SharedDtor() {
  if (this != default_instance_) {
  }
}

void GAnsDetach::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GAnsDetach& GAnsDetach::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_game_2eproto();  return *default_instance_;
}

GAnsDetach* GAnsDetach::default_instance_ = NULL;

GAnsDetach* GAnsDetach::New() const {
  return new GAnsDetach;
}

void GAnsDetach::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    gameid_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GAnsDetach::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 gameID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &gameid_)));
          set_has_gameid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GAnsDetach::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 gameID = 1;
  if (has_gameid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->gameid(), output);
  }
  
}

int GAnsDetach::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 gameID = 1;
    if (has_gameid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->gameid());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GAnsDetach::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GAnsDetach*>(&from));
}

void GAnsDetach::MergeFrom(const GAnsDetach& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_gameid()) {
      set_gameid(from.gameid());
    }
  }
}

void GAnsDetach::CopyFrom(const GAnsDetach& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GAnsDetach::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void GAnsDetach::Swap(GAnsDetach* other) {
  if (other != this) {
    std::swap(gameid_, other->gameid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GAnsDetach::GetTypeName() const {
  return "GAnsDetach";
}


// ===================================================================

#ifndef _MSC_VER
const int GReqPlug::kGameIDFieldNumber;
#endif  // !_MSC_VER

GReqPlug::GReqPlug()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GReqPlug::InitAsDefaultInstance() {
}

GReqPlug::GReqPlug(const GReqPlug& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GReqPlug::SharedCtor() {
  _cached_size_ = 0;
  gameid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GReqPlug::~GReqPlug() {
  SharedDtor();
}

void GReqPlug::SharedDtor() {
  if (this != default_instance_) {
  }
}

void GReqPlug::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GReqPlug& GReqPlug::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_game_2eproto();  return *default_instance_;
}

GReqPlug* GReqPlug::default_instance_ = NULL;

GReqPlug* GReqPlug::New() const {
  return new GReqPlug;
}

void GReqPlug::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    gameid_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GReqPlug::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 gameID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &gameid_)));
          set_has_gameid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GReqPlug::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 gameID = 1;
  if (has_gameid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->gameid(), output);
  }
  
}

int GReqPlug::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 gameID = 1;
    if (has_gameid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->gameid());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GReqPlug::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GReqPlug*>(&from));
}

void GReqPlug::MergeFrom(const GReqPlug& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_gameid()) {
      set_gameid(from.gameid());
    }
  }
}

void GReqPlug::CopyFrom(const GReqPlug& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GReqPlug::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void GReqPlug::Swap(GReqPlug* other) {
  if (other != this) {
    std::swap(gameid_, other->gameid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GReqPlug::GetTypeName() const {
  return "GReqPlug";
}


// ===================================================================

#ifndef _MSC_VER
const int GAnsPlug::kGameIDFieldNumber;
#endif  // !_MSC_VER

GAnsPlug::GAnsPlug()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GAnsPlug::InitAsDefaultInstance() {
}

GAnsPlug::GAnsPlug(const GAnsPlug& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GAnsPlug::SharedCtor() {
  _cached_size_ = 0;
  gameid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GAnsPlug::~GAnsPlug() {
  SharedDtor();
}

void GAnsPlug::SharedDtor() {
  if (this != default_instance_) {
  }
}

void GAnsPlug::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GAnsPlug& GAnsPlug::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_game_2eproto();  return *default_instance_;
}

GAnsPlug* GAnsPlug::default_instance_ = NULL;

GAnsPlug* GAnsPlug::New() const {
  return new GAnsPlug;
}

void GAnsPlug::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    gameid_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GAnsPlug::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 gameID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &gameid_)));
          set_has_gameid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GAnsPlug::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 gameID = 1;
  if (has_gameid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->gameid(), output);
  }
  
}

int GAnsPlug::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 gameID = 1;
    if (has_gameid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->gameid());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GAnsPlug::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GAnsPlug*>(&from));
}

void GAnsPlug::MergeFrom(const GAnsPlug& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_gameid()) {
      set_gameid(from.gameid());
    }
  }
}

void GAnsPlug::CopyFrom(const GAnsPlug& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GAnsPlug::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void GAnsPlug::Swap(GAnsPlug* other) {
  if (other != this) {
    std::swap(gameid_, other->gameid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GAnsPlug::GetTypeName() const {
  return "GAnsPlug";
}


// ===================================================================

#ifndef _MSC_VER
const int GError::kErrorCodeFieldNumber;
const int GError::kErrorInfoFieldNumber;
#endif  // !_MSC_VER

GError::GError()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GError::InitAsDefaultInstance() {
}

GError::GError(const GError& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GError::SharedCtor() {
  _cached_size_ = 0;
  errorcode_ = 0;
  errorinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GError::~GError() {
  SharedDtor();
}

void GError::SharedDtor() {
  if (errorinfo_ != &::google::protobuf::internal::kEmptyString) {
    delete errorinfo_;
  }
  if (this != default_instance_) {
  }
}

void GError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GError& GError::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_game_2eproto();  return *default_instance_;
}

GError* GError::default_instance_ = NULL;

GError* GError::New() const {
  return new GError;
}

void GError::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    errorcode_ = 0;
    if (has_errorinfo()) {
      if (errorinfo_ != &::google::protobuf::internal::kEmptyString) {
        errorinfo_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 errorCode = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &errorcode_)));
          set_has_errorcode();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_errorInfo;
        break;
      }
      
      // required string errorInfo = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_errorInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_errorinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 errorCode = 1;
  if (has_errorcode()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->errorcode(), output);
  }
  
  // required string errorInfo = 2;
  if (has_errorinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->errorinfo(), output);
  }
  
}

int GError::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 errorCode = 1;
    if (has_errorcode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->errorcode());
    }
    
    // required string errorInfo = 2;
    if (has_errorinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->errorinfo());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GError::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GError*>(&from));
}

void GError::MergeFrom(const GError& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_errorcode()) {
      set_errorcode(from.errorcode());
    }
    if (from.has_errorinfo()) {
      set_errorinfo(from.errorinfo());
    }
  }
}

void GError::CopyFrom(const GError& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GError::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void GError::Swap(GError* other) {
  if (other != this) {
    std::swap(errorcode_, other->errorcode_);
    std::swap(errorinfo_, other->errorinfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GError::GetTypeName() const {
  return "GError";
}


// ===================================================================

#ifndef _MSC_VER
const int GErrPlug::kErrorFieldNumber;
#endif  // !_MSC_VER

GErrPlug::GErrPlug()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GErrPlug::InitAsDefaultInstance() {
  error_ = const_cast< ::GError*>(&::GError::default_instance());
}

GErrPlug::GErrPlug(const GErrPlug& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GErrPlug::SharedCtor() {
  _cached_size_ = 0;
  error_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GErrPlug::~GErrPlug() {
  SharedDtor();
}

void GErrPlug::SharedDtor() {
  if (this != default_instance_) {
    delete error_;
  }
}

void GErrPlug::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GErrPlug& GErrPlug::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_game_2eproto();  return *default_instance_;
}

GErrPlug* GErrPlug::default_instance_ = NULL;

GErrPlug* GErrPlug::New() const {
  return new GErrPlug;
}

void GErrPlug::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_error()) {
      if (error_ != NULL) error_->::GError::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GErrPlug::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .GError error = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_error()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GErrPlug::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .GError error = 1;
  if (has_error()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->error(), output);
  }
  
}

int GErrPlug::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .GError error = 1;
    if (has_error()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->error());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GErrPlug::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GErrPlug*>(&from));
}

void GErrPlug::MergeFrom(const GErrPlug& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_error()) {
      mutable_error()->::GError::MergeFrom(from.error());
    }
  }
}

void GErrPlug::CopyFrom(const GErrPlug& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GErrPlug::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_error()) {
    if (!this->error().IsInitialized()) return false;
  }
  return true;
}

void GErrPlug::Swap(GErrPlug* other) {
  if (other != this) {
    std::swap(error_, other->error_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GErrPlug::GetTypeName() const {
  return "GErrPlug";
}


// ===================================================================

bool GReqProtocol_Type_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const GReqProtocol_Type GReqProtocol::NONE;
const GReqProtocol_Type GReqProtocol::GREQGAMEENTER;
const GReqProtocol_Type GReqProtocol::GREQGAMELEAVE;
const GReqProtocol_Type GReqProtocol::GREQDETACH;
const GReqProtocol_Type GReqProtocol::GREQPLUG;
const GReqProtocol_Type GReqProtocol::GLREQGAMEPROTOCOL;
const GReqProtocol_Type GReqProtocol::GDBANS;
const GReqProtocol_Type GReqProtocol::Type_MIN;
const GReqProtocol_Type GReqProtocol::Type_MAX;
const int GReqProtocol::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int GReqProtocol::kTypeFieldNumber;
const int GReqProtocol::kReqGameEnterFieldNumber;
const int GReqProtocol::kReqGameLeaveFieldNumber;
const int GReqProtocol::kReqDetachFieldNumber;
const int GReqProtocol::kReqPlugFieldNumber;
const int GReqProtocol::kReqGameProtocolFieldNumber;
const int GReqProtocol::kAnsDBFieldNumber;
#endif  // !_MSC_VER

GReqProtocol::GReqProtocol()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GReqProtocol::InitAsDefaultInstance() {
  reqgameenter_ = const_cast< ::GReqGameEnter*>(&::GReqGameEnter::default_instance());
  reqgameleave_ = const_cast< ::GReqGameLeave*>(&::GReqGameLeave::default_instance());
  reqdetach_ = const_cast< ::GReqDetach*>(&::GReqDetach::default_instance());
  reqplug_ = const_cast< ::GReqPlug*>(&::GReqPlug::default_instance());
  reqgameprotocol_ = const_cast< ::GLReqGameProtocol*>(&::GLReqGameProtocol::default_instance());
  ansdb_ = const_cast< ::AnsDB*>(&::AnsDB::default_instance());
}

GReqProtocol::GReqProtocol(const GReqProtocol& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GReqProtocol::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  reqgameenter_ = NULL;
  reqgameleave_ = NULL;
  reqdetach_ = NULL;
  reqplug_ = NULL;
  reqgameprotocol_ = NULL;
  ansdb_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GReqProtocol::~GReqProtocol() {
  SharedDtor();
}

void GReqProtocol::SharedDtor() {
  if (this != default_instance_) {
    delete reqgameenter_;
    delete reqgameleave_;
    delete reqdetach_;
    delete reqplug_;
    delete reqgameprotocol_;
    delete ansdb_;
  }
}

void GReqProtocol::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GReqProtocol& GReqProtocol::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_game_2eproto();  return *default_instance_;
}

GReqProtocol* GReqProtocol::default_instance_ = NULL;

GReqProtocol* GReqProtocol::New() const {
  return new GReqProtocol;
}

void GReqProtocol::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 1;
    if (has_reqgameenter()) {
      if (reqgameenter_ != NULL) reqgameenter_->::GReqGameEnter::Clear();
    }
    if (has_reqgameleave()) {
      if (reqgameleave_ != NULL) reqgameleave_->::GReqGameLeave::Clear();
    }
    if (has_reqdetach()) {
      if (reqdetach_ != NULL) reqdetach_->::GReqDetach::Clear();
    }
    if (has_reqplug()) {
      if (reqplug_ != NULL) reqplug_->::GReqPlug::Clear();
    }
    if (has_reqgameprotocol()) {
      if (reqgameprotocol_ != NULL) reqgameprotocol_->::GLReqGameProtocol::Clear();
    }
    if (has_ansdb()) {
      if (ansdb_ != NULL) ansdb_->::AnsDB::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GReqProtocol::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .GReqProtocol.Type type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::GReqProtocol_Type_IsValid(value)) {
            set_type(static_cast< ::GReqProtocol_Type >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_reqGameEnter;
        break;
      }
      
      // optional .GReqGameEnter reqGameEnter = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reqGameEnter:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reqgameenter()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_reqGameLeave;
        break;
      }
      
      // optional .GReqGameLeave reqGameLeave = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reqGameLeave:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reqgameleave()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_reqDetach;
        break;
      }
      
      // optional .GReqDetach reqDetach = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reqDetach:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reqdetach()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_reqPlug;
        break;
      }
      
      // optional .GReqPlug reqPlug = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reqPlug:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reqplug()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_reqGameProtocol;
        break;
      }
      
      // optional .GLReqGameProtocol reqGameProtocol = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reqGameProtocol:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reqgameprotocol()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_ansDB;
        break;
      }
      
      // optional .AnsDB ansDB = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ansDB:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ansdb()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GReqProtocol::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .GReqProtocol.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }
  
  // optional .GReqGameEnter reqGameEnter = 2;
  if (has_reqgameenter()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->reqgameenter(), output);
  }
  
  // optional .GReqGameLeave reqGameLeave = 3;
  if (has_reqgameleave()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->reqgameleave(), output);
  }
  
  // optional .GReqDetach reqDetach = 4;
  if (has_reqdetach()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->reqdetach(), output);
  }
  
  // optional .GReqPlug reqPlug = 5;
  if (has_reqplug()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->reqplug(), output);
  }
  
  // optional .GLReqGameProtocol reqGameProtocol = 6;
  if (has_reqgameprotocol()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->reqgameprotocol(), output);
  }
  
  // optional .AnsDB ansDB = 7;
  if (has_ansdb()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, this->ansdb(), output);
  }
  
}

int GReqProtocol::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .GReqProtocol.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }
    
    // optional .GReqGameEnter reqGameEnter = 2;
    if (has_reqgameenter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->reqgameenter());
    }
    
    // optional .GReqGameLeave reqGameLeave = 3;
    if (has_reqgameleave()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->reqgameleave());
    }
    
    // optional .GReqDetach reqDetach = 4;
    if (has_reqdetach()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->reqdetach());
    }
    
    // optional .GReqPlug reqPlug = 5;
    if (has_reqplug()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->reqplug());
    }
    
    // optional .GLReqGameProtocol reqGameProtocol = 6;
    if (has_reqgameprotocol()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->reqgameprotocol());
    }
    
    // optional .AnsDB ansDB = 7;
    if (has_ansdb()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ansdb());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GReqProtocol::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GReqProtocol*>(&from));
}

void GReqProtocol::MergeFrom(const GReqProtocol& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_reqgameenter()) {
      mutable_reqgameenter()->::GReqGameEnter::MergeFrom(from.reqgameenter());
    }
    if (from.has_reqgameleave()) {
      mutable_reqgameleave()->::GReqGameLeave::MergeFrom(from.reqgameleave());
    }
    if (from.has_reqdetach()) {
      mutable_reqdetach()->::GReqDetach::MergeFrom(from.reqdetach());
    }
    if (from.has_reqplug()) {
      mutable_reqplug()->::GReqPlug::MergeFrom(from.reqplug());
    }
    if (from.has_reqgameprotocol()) {
      mutable_reqgameprotocol()->::GLReqGameProtocol::MergeFrom(from.reqgameprotocol());
    }
    if (from.has_ansdb()) {
      mutable_ansdb()->::AnsDB::MergeFrom(from.ansdb());
    }
  }
}

void GReqProtocol::CopyFrom(const GReqProtocol& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GReqProtocol::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_reqgameenter()) {
    if (!this->reqgameenter().IsInitialized()) return false;
  }
  if (has_reqgameleave()) {
    if (!this->reqgameleave().IsInitialized()) return false;
  }
  if (has_reqdetach()) {
    if (!this->reqdetach().IsInitialized()) return false;
  }
  if (has_reqplug()) {
    if (!this->reqplug().IsInitialized()) return false;
  }
  if (has_reqgameprotocol()) {
    if (!this->reqgameprotocol().IsInitialized()) return false;
  }
  if (has_ansdb()) {
    if (!this->ansdb().IsInitialized()) return false;
  }
  return true;
}

void GReqProtocol::Swap(GReqProtocol* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(reqgameenter_, other->reqgameenter_);
    std::swap(reqgameleave_, other->reqgameleave_);
    std::swap(reqdetach_, other->reqdetach_);
    std::swap(reqplug_, other->reqplug_);
    std::swap(reqgameprotocol_, other->reqgameprotocol_);
    std::swap(ansdb_, other->ansdb_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GReqProtocol::GetTypeName() const {
  return "GReqProtocol";
}


// ===================================================================

bool GAnsProtocol_Type_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const GAnsProtocol_Type GAnsProtocol::NONE;
const GAnsProtocol_Type GAnsProtocol::GANSGAMEENTER;
const GAnsProtocol_Type GAnsProtocol::GANSGAMELEAVE;
const GAnsProtocol_Type GAnsProtocol::GANSDETACH;
const GAnsProtocol_Type GAnsProtocol::GANSPLUG;
const GAnsProtocol_Type GAnsProtocol::GERRPLUG;
const GAnsProtocol_Type GAnsProtocol::GLANSGAMEPROTOCOL;
const GAnsProtocol_Type GAnsProtocol::GDBREQ;
const GAnsProtocol_Type GAnsProtocol::Type_MIN;
const GAnsProtocol_Type GAnsProtocol::Type_MAX;
const int GAnsProtocol::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int GAnsProtocol::kTypeFieldNumber;
const int GAnsProtocol::kAnsGameEnterFieldNumber;
const int GAnsProtocol::kAnsGameLeaveFieldNumber;
const int GAnsProtocol::kAnsDetachFieldNumber;
const int GAnsProtocol::kAnsPlugFieldNumber;
const int GAnsProtocol::kAnsErrFieldNumber;
const int GAnsProtocol::kAnsGameProtocolFieldNumber;
const int GAnsProtocol::kReqDBFieldNumber;
#endif  // !_MSC_VER

GAnsProtocol::GAnsProtocol()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GAnsProtocol::InitAsDefaultInstance() {
  ansgameenter_ = const_cast< ::GAnsGameEnter*>(&::GAnsGameEnter::default_instance());
  ansgameleave_ = const_cast< ::GAnsGameLeave*>(&::GAnsGameLeave::default_instance());
  ansdetach_ = const_cast< ::GAnsDetach*>(&::GAnsDetach::default_instance());
  ansplug_ = const_cast< ::GAnsPlug*>(&::GAnsPlug::default_instance());
  anserr_ = const_cast< ::GErrPlug*>(&::GErrPlug::default_instance());
  ansgameprotocol_ = const_cast< ::GLAnsGameProtocol*>(&::GLAnsGameProtocol::default_instance());
  reqdb_ = const_cast< ::ReqDB*>(&::ReqDB::default_instance());
}

GAnsProtocol::GAnsProtocol(const GAnsProtocol& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GAnsProtocol::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  ansgameenter_ = NULL;
  ansgameleave_ = NULL;
  ansdetach_ = NULL;
  ansplug_ = NULL;
  anserr_ = NULL;
  ansgameprotocol_ = NULL;
  reqdb_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GAnsProtocol::~GAnsProtocol() {
  SharedDtor();
}

void GAnsProtocol::SharedDtor() {
  if (this != default_instance_) {
    delete ansgameenter_;
    delete ansgameleave_;
    delete ansdetach_;
    delete ansplug_;
    delete anserr_;
    delete ansgameprotocol_;
    delete reqdb_;
  }
}

void GAnsProtocol::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GAnsProtocol& GAnsProtocol::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_game_2eproto();  return *default_instance_;
}

GAnsProtocol* GAnsProtocol::default_instance_ = NULL;

GAnsProtocol* GAnsProtocol::New() const {
  return new GAnsProtocol;
}

void GAnsProtocol::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 1;
    if (has_ansgameenter()) {
      if (ansgameenter_ != NULL) ansgameenter_->::GAnsGameEnter::Clear();
    }
    if (has_ansgameleave()) {
      if (ansgameleave_ != NULL) ansgameleave_->::GAnsGameLeave::Clear();
    }
    if (has_ansdetach()) {
      if (ansdetach_ != NULL) ansdetach_->::GAnsDetach::Clear();
    }
    if (has_ansplug()) {
      if (ansplug_ != NULL) ansplug_->::GAnsPlug::Clear();
    }
    if (has_anserr()) {
      if (anserr_ != NULL) anserr_->::GErrPlug::Clear();
    }
    if (has_ansgameprotocol()) {
      if (ansgameprotocol_ != NULL) ansgameprotocol_->::GLAnsGameProtocol::Clear();
    }
    if (has_reqdb()) {
      if (reqdb_ != NULL) reqdb_->::ReqDB::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GAnsProtocol::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .GAnsProtocol.Type type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::GAnsProtocol_Type_IsValid(value)) {
            set_type(static_cast< ::GAnsProtocol_Type >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_ansGameEnter;
        break;
      }
      
      // optional .GAnsGameEnter ansGameEnter = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ansGameEnter:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ansgameenter()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_ansGameLeave;
        break;
      }
      
      // optional .GAnsGameLeave ansGameLeave = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ansGameLeave:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ansgameleave()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_ansDetach;
        break;
      }
      
      // optional .GAnsDetach ansDetach = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ansDetach:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ansdetach()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_ansPlug;
        break;
      }
      
      // optional .GAnsPlug ansPlug = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ansPlug:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ansplug()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_ansErr;
        break;
      }
      
      // optional .GErrPlug ansErr = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ansErr:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_anserr()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_ansGameProtocol;
        break;
      }
      
      // optional .GLAnsGameProtocol ansGameProtocol = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ansGameProtocol:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ansgameprotocol()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_reqDB;
        break;
      }
      
      // optional .ReqDB reqDB = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reqDB:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reqdb()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GAnsProtocol::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .GAnsProtocol.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }
  
  // optional .GAnsGameEnter ansGameEnter = 2;
  if (has_ansgameenter()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->ansgameenter(), output);
  }
  
  // optional .GAnsGameLeave ansGameLeave = 3;
  if (has_ansgameleave()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->ansgameleave(), output);
  }
  
  // optional .GAnsDetach ansDetach = 4;
  if (has_ansdetach()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->ansdetach(), output);
  }
  
  // optional .GAnsPlug ansPlug = 5;
  if (has_ansplug()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->ansplug(), output);
  }
  
  // optional .GErrPlug ansErr = 6;
  if (has_anserr()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->anserr(), output);
  }
  
  // optional .GLAnsGameProtocol ansGameProtocol = 7;
  if (has_ansgameprotocol()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, this->ansgameprotocol(), output);
  }
  
  // optional .ReqDB reqDB = 8;
  if (has_reqdb()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, this->reqdb(), output);
  }
  
}

int GAnsProtocol::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .GAnsProtocol.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }
    
    // optional .GAnsGameEnter ansGameEnter = 2;
    if (has_ansgameenter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ansgameenter());
    }
    
    // optional .GAnsGameLeave ansGameLeave = 3;
    if (has_ansgameleave()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ansgameleave());
    }
    
    // optional .GAnsDetach ansDetach = 4;
    if (has_ansdetach()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ansdetach());
    }
    
    // optional .GAnsPlug ansPlug = 5;
    if (has_ansplug()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ansplug());
    }
    
    // optional .GErrPlug ansErr = 6;
    if (has_anserr()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->anserr());
    }
    
    // optional .GLAnsGameProtocol ansGameProtocol = 7;
    if (has_ansgameprotocol()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ansgameprotocol());
    }
    
    // optional .ReqDB reqDB = 8;
    if (has_reqdb()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->reqdb());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GAnsProtocol::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GAnsProtocol*>(&from));
}

void GAnsProtocol::MergeFrom(const GAnsProtocol& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_ansgameenter()) {
      mutable_ansgameenter()->::GAnsGameEnter::MergeFrom(from.ansgameenter());
    }
    if (from.has_ansgameleave()) {
      mutable_ansgameleave()->::GAnsGameLeave::MergeFrom(from.ansgameleave());
    }
    if (from.has_ansdetach()) {
      mutable_ansdetach()->::GAnsDetach::MergeFrom(from.ansdetach());
    }
    if (from.has_ansplug()) {
      mutable_ansplug()->::GAnsPlug::MergeFrom(from.ansplug());
    }
    if (from.has_anserr()) {
      mutable_anserr()->::GErrPlug::MergeFrom(from.anserr());
    }
    if (from.has_ansgameprotocol()) {
      mutable_ansgameprotocol()->::GLAnsGameProtocol::MergeFrom(from.ansgameprotocol());
    }
    if (from.has_reqdb()) {
      mutable_reqdb()->::ReqDB::MergeFrom(from.reqdb());
    }
  }
}

void GAnsProtocol::CopyFrom(const GAnsProtocol& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GAnsProtocol::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_ansgameenter()) {
    if (!this->ansgameenter().IsInitialized()) return false;
  }
  if (has_ansgameleave()) {
    if (!this->ansgameleave().IsInitialized()) return false;
  }
  if (has_ansdetach()) {
    if (!this->ansdetach().IsInitialized()) return false;
  }
  if (has_ansplug()) {
    if (!this->ansplug().IsInitialized()) return false;
  }
  if (has_anserr()) {
    if (!this->anserr().IsInitialized()) return false;
  }
  if (has_ansgameprotocol()) {
    if (!this->ansgameprotocol().IsInitialized()) return false;
  }
  if (has_reqdb()) {
    if (!this->reqdb().IsInitialized()) return false;
  }
  return true;
}

void GAnsProtocol::Swap(GAnsProtocol* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(ansgameenter_, other->ansgameenter_);
    std::swap(ansgameleave_, other->ansgameleave_);
    std::swap(ansdetach_, other->ansdetach_);
    std::swap(ansplug_, other->ansplug_);
    std::swap(anserr_, other->anserr_);
    std::swap(ansgameprotocol_, other->ansgameprotocol_);
    std::swap(reqdb_, other->reqdb_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GAnsProtocol::GetTypeName() const {
  return "GAnsProtocol";
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
