// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gameLogic.proto

#ifndef PROTOBUF_gameLogic_2eproto__INCLUDED
#define PROTOBUF_gameLogic_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "excel_baseball_table_db.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_gameLogic_2eproto();
void protobuf_AssignDesc_gameLogic_2eproto();
void protobuf_ShutdownFile_gameLogic_2eproto();

class GameUserInfo;
class GameInfo;
class s_game_play_info;
class s_result_round;
class s_result_game;
class GameRoomInfo;
class s_vector3;
class s_vector2;
class s_pitcher_throw_info;
class s_better_hit_info;
class GLReqGameProtocol;
class GLAnsGameProtocol;

// ===================================================================

class GameUserInfo : public ::google::protobuf::Message {
 public:
  GameUserInfo();
  virtual ~GameUserInfo();
  
  GameUserInfo(const GameUserInfo& from);
  
  inline GameUserInfo& operator=(const GameUserInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GameUserInfo& default_instance();
  
  void Swap(GameUserInfo* other);
  
  // implements Message ----------------------------------------------
  
  GameUserInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameUserInfo& from);
  void MergeFrom(const GameUserInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .GameInfo game_info = 1;
  inline bool has_game_info() const;
  inline void clear_game_info();
  static const int kGameInfoFieldNumber = 1;
  inline const ::GameInfo& game_info() const;
  inline ::GameInfo* mutable_game_info();
  inline ::GameInfo* release_game_info();
  
  // required bytes member_info = 2;
  inline bool has_member_info() const;
  inline void clear_member_info();
  static const int kMemberInfoFieldNumber = 2;
  inline const ::std::string& member_info() const;
  inline void set_member_info(const ::std::string& value);
  inline void set_member_info(const char* value);
  inline void set_member_info(const void* value, size_t size);
  inline ::std::string* mutable_member_info();
  inline ::std::string* release_member_info();
  
  // @@protoc_insertion_point(class_scope:GameUserInfo)
 private:
  inline void set_has_game_info();
  inline void clear_has_game_info();
  inline void set_has_member_info();
  inline void clear_has_member_info();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::GameInfo* game_info_;
  ::std::string* member_info_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GameUserInfo* default_instance_;
};
// -------------------------------------------------------------------

class GameInfo : public ::google::protobuf::Message {
 public:
  GameInfo();
  virtual ~GameInfo();
  
  GameInfo(const GameInfo& from);
  
  inline GameInfo& operator=(const GameInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GameInfo& default_instance();
  
  void Swap(GameInfo* other);
  
  // implements Message ----------------------------------------------
  
  GameInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameInfo& from);
  void MergeFrom(const GameInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .s_tbl_user m_tbl_user = 1;
  inline int m_tbl_user_size() const;
  inline void clear_m_tbl_user();
  static const int kMTblUserFieldNumber = 1;
  inline const ::s_tbl_user& m_tbl_user(int index) const;
  inline ::s_tbl_user* mutable_m_tbl_user(int index);
  inline ::s_tbl_user* add_m_tbl_user();
  inline const ::google::protobuf::RepeatedPtrField< ::s_tbl_user >&
      m_tbl_user() const;
  inline ::google::protobuf::RepeatedPtrField< ::s_tbl_user >*
      mutable_m_tbl_user();
  
  // @@protoc_insertion_point(class_scope:GameInfo)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::s_tbl_user > m_tbl_user_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GameInfo* default_instance_;
};
// -------------------------------------------------------------------

class s_game_play_info : public ::google::protobuf::Message {
 public:
  s_game_play_info();
  virtual ~s_game_play_info();
  
  s_game_play_info(const s_game_play_info& from);
  
  inline s_game_play_info& operator=(const s_game_play_info& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const s_game_play_info& default_instance();
  
  void Swap(s_game_play_info* other);
  
  // implements Message ----------------------------------------------
  
  s_game_play_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const s_game_play_info& from);
  void MergeFrom(const s_game_play_info& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .s_tbl_user m_tbl_user = 1;
  inline bool has_m_tbl_user() const;
  inline void clear_m_tbl_user();
  static const int kMTblUserFieldNumber = 1;
  inline const ::s_tbl_user& m_tbl_user() const;
  inline ::s_tbl_user* mutable_m_tbl_user();
  inline ::s_tbl_user* release_m_tbl_user();
  
  // optional int32 m_e_user_gps = 2;
  inline bool has_m_e_user_gps() const;
  inline void clear_m_e_user_gps();
  static const int kMEUserGpsFieldNumber = 2;
  inline ::google::protobuf::int32 m_e_user_gps() const;
  inline void set_m_e_user_gps(::google::protobuf::int32 value);
  
  // optional int32 m_pitcher_sid = 3;
  inline bool has_m_pitcher_sid() const;
  inline void clear_m_pitcher_sid();
  static const int kMPitcherSidFieldNumber = 3;
  inline ::google::protobuf::int32 m_pitcher_sid() const;
  inline void set_m_pitcher_sid(::google::protobuf::int32 value);
  
  // optional int32 m_batter_sid = 4;
  inline bool has_m_batter_sid() const;
  inline void clear_m_batter_sid();
  static const int kMBatterSidFieldNumber = 4;
  inline ::google::protobuf::int32 m_batter_sid() const;
  inline void set_m_batter_sid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:s_game_play_info)
 private:
  inline void set_has_m_tbl_user();
  inline void clear_has_m_tbl_user();
  inline void set_has_m_e_user_gps();
  inline void clear_has_m_e_user_gps();
  inline void set_has_m_pitcher_sid();
  inline void clear_has_m_pitcher_sid();
  inline void set_has_m_batter_sid();
  inline void clear_has_m_batter_sid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::s_tbl_user* m_tbl_user_;
  ::google::protobuf::int32 m_e_user_gps_;
  ::google::protobuf::int32 m_pitcher_sid_;
  ::google::protobuf::int32 m_batter_sid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_game_play_info* default_instance_;
};
// -------------------------------------------------------------------

class s_result_round : public ::google::protobuf::Message {
 public:
  s_result_round();
  virtual ~s_result_round();
  
  s_result_round(const s_result_round& from);
  
  inline s_result_round& operator=(const s_result_round& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const s_result_round& default_instance();
  
  void Swap(s_result_round* other);
  
  // implements Message ----------------------------------------------
  
  s_result_round* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const s_result_round& from);
  void MergeFrom(const s_result_round& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .s_tbl_roundresult m_tbl_roundresult = 1;
  inline bool has_m_tbl_roundresult() const;
  inline void clear_m_tbl_roundresult();
  static const int kMTblRoundresultFieldNumber = 1;
  inline const ::s_tbl_roundresult& m_tbl_roundresult() const;
  inline ::s_tbl_roundresult* mutable_m_tbl_roundresult();
  inline ::s_tbl_roundresult* release_m_tbl_roundresult();
  
  // @@protoc_insertion_point(class_scope:s_result_round)
 private:
  inline void set_has_m_tbl_roundresult();
  inline void clear_has_m_tbl_roundresult();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::s_tbl_roundresult* m_tbl_roundresult_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_result_round* default_instance_;
};
// -------------------------------------------------------------------

class s_result_game : public ::google::protobuf::Message {
 public:
  s_result_game();
  virtual ~s_result_game();
  
  s_result_game(const s_result_game& from);
  
  inline s_result_game& operator=(const s_result_game& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const s_result_game& default_instance();
  
  void Swap(s_result_game* other);
  
  // implements Message ----------------------------------------------
  
  s_result_game* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const s_result_game& from);
  void MergeFrom(const s_result_game& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .s_tbl_result m_tbl_result = 1;
  inline bool has_m_tbl_result() const;
  inline void clear_m_tbl_result();
  static const int kMTblResultFieldNumber = 1;
  inline const ::s_tbl_result& m_tbl_result() const;
  inline ::s_tbl_result* mutable_m_tbl_result();
  inline ::s_tbl_result* release_m_tbl_result();
  
  // @@protoc_insertion_point(class_scope:s_result_game)
 private:
  inline void set_has_m_tbl_result();
  inline void clear_has_m_tbl_result();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::s_tbl_result* m_tbl_result_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_result_game* default_instance_;
};
// -------------------------------------------------------------------

class GameRoomInfo : public ::google::protobuf::Message {
 public:
  GameRoomInfo();
  virtual ~GameRoomInfo();
  
  GameRoomInfo(const GameRoomInfo& from);
  
  inline GameRoomInfo& operator=(const GameRoomInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GameRoomInfo& default_instance();
  
  void Swap(GameRoomInfo* other);
  
  // implements Message ----------------------------------------------
  
  GameRoomInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameRoomInfo& from);
  void MergeFrom(const GameRoomInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 room_id = 1;
  inline bool has_room_id() const;
  inline void clear_room_id();
  static const int kRoomIdFieldNumber = 1;
  inline ::google::protobuf::int32 room_id() const;
  inline void set_room_id(::google::protobuf::int32 value);
  
  // repeated .s_game_play_info m_game_play_info = 2;
  inline int m_game_play_info_size() const;
  inline void clear_m_game_play_info();
  static const int kMGamePlayInfoFieldNumber = 2;
  inline const ::s_game_play_info& m_game_play_info(int index) const;
  inline ::s_game_play_info* mutable_m_game_play_info(int index);
  inline ::s_game_play_info* add_m_game_play_info();
  inline const ::google::protobuf::RepeatedPtrField< ::s_game_play_info >&
      m_game_play_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::s_game_play_info >*
      mutable_m_game_play_info();
  
  // optional int64 m_attack_user = 3;
  inline bool has_m_attack_user() const;
  inline void clear_m_attack_user();
  static const int kMAttackUserFieldNumber = 3;
  inline ::google::protobuf::int64 m_attack_user() const;
  inline void set_m_attack_user(::google::protobuf::int64 value);
  
  // optional int32 m_round_count = 4;
  inline bool has_m_round_count() const;
  inline void clear_m_round_count();
  static const int kMRoundCountFieldNumber = 4;
  inline ::google::protobuf::int32 m_round_count() const;
  inline void set_m_round_count(::google::protobuf::int32 value);
  
  // repeated .s_result_round m_result_round = 5;
  inline int m_result_round_size() const;
  inline void clear_m_result_round();
  static const int kMResultRoundFieldNumber = 5;
  inline const ::s_result_round& m_result_round(int index) const;
  inline ::s_result_round* mutable_m_result_round(int index);
  inline ::s_result_round* add_m_result_round();
  inline const ::google::protobuf::RepeatedPtrField< ::s_result_round >&
      m_result_round() const;
  inline ::google::protobuf::RepeatedPtrField< ::s_result_round >*
      mutable_m_result_round();
  
  // optional .s_result_game m_result_game = 6;
  inline bool has_m_result_game() const;
  inline void clear_m_result_game();
  static const int kMResultGameFieldNumber = 6;
  inline const ::s_result_game& m_result_game() const;
  inline ::s_result_game* mutable_m_result_game();
  inline ::s_result_game* release_m_result_game();
  
  // optional bool m_is_auto_play = 7;
  inline bool has_m_is_auto_play() const;
  inline void clear_m_is_auto_play();
  static const int kMIsAutoPlayFieldNumber = 7;
  inline bool m_is_auto_play() const;
  inline void set_m_is_auto_play(bool value);
  
  // optional int32 m_baseball_park = 8;
  inline bool has_m_baseball_park() const;
  inline void clear_m_baseball_park();
  static const int kMBaseballParkFieldNumber = 8;
  inline ::google::protobuf::int32 m_baseball_park() const;
  inline void set_m_baseball_park(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:GameRoomInfo)
 private:
  inline void set_has_room_id();
  inline void clear_has_room_id();
  inline void set_has_m_attack_user();
  inline void clear_has_m_attack_user();
  inline void set_has_m_round_count();
  inline void clear_has_m_round_count();
  inline void set_has_m_result_game();
  inline void clear_has_m_result_game();
  inline void set_has_m_is_auto_play();
  inline void clear_has_m_is_auto_play();
  inline void set_has_m_baseball_park();
  inline void clear_has_m_baseball_park();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::s_game_play_info > m_game_play_info_;
  ::google::protobuf::int32 room_id_;
  ::google::protobuf::int32 m_round_count_;
  ::google::protobuf::int64 m_attack_user_;
  ::google::protobuf::RepeatedPtrField< ::s_result_round > m_result_round_;
  ::s_result_game* m_result_game_;
  bool m_is_auto_play_;
  ::google::protobuf::int32 m_baseball_park_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GameRoomInfo* default_instance_;
};
// -------------------------------------------------------------------

class s_vector3 : public ::google::protobuf::Message {
 public:
  s_vector3();
  virtual ~s_vector3();
  
  s_vector3(const s_vector3& from);
  
  inline s_vector3& operator=(const s_vector3& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const s_vector3& default_instance();
  
  void Swap(s_vector3* other);
  
  // implements Message ----------------------------------------------
  
  s_vector3* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const s_vector3& from);
  void MergeFrom(const s_vector3& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);
  
  // optional float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);
  
  // optional float z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline float z() const;
  inline void set_z(float value);
  
  // @@protoc_insertion_point(class_scope:s_vector3)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float x_;
  float y_;
  float z_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_vector3* default_instance_;
};
// -------------------------------------------------------------------

class s_vector2 : public ::google::protobuf::Message {
 public:
  s_vector2();
  virtual ~s_vector2();
  
  s_vector2(const s_vector2& from);
  
  inline s_vector2& operator=(const s_vector2& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const s_vector2& default_instance();
  
  void Swap(s_vector2* other);
  
  // implements Message ----------------------------------------------
  
  s_vector2* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const s_vector2& from);
  void MergeFrom(const s_vector2& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);
  
  // optional float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);
  
  // @@protoc_insertion_point(class_scope:s_vector2)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float x_;
  float y_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_vector2* default_instance_;
};
// -------------------------------------------------------------------

class s_pitcher_throw_info : public ::google::protobuf::Message {
 public:
  s_pitcher_throw_info();
  virtual ~s_pitcher_throw_info();
  
  s_pitcher_throw_info(const s_pitcher_throw_info& from);
  
  inline s_pitcher_throw_info& operator=(const s_pitcher_throw_info& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const s_pitcher_throw_info& default_instance();
  
  void Swap(s_pitcher_throw_info* other);
  
  // implements Message ----------------------------------------------
  
  s_pitcher_throw_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const s_pitcher_throw_info& from);
  void MergeFrom(const s_pitcher_throw_info& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .s_vector3 screen_to_world = 1;
  inline bool has_screen_to_world() const;
  inline void clear_screen_to_world();
  static const int kScreenToWorldFieldNumber = 1;
  inline const ::s_vector3& screen_to_world() const;
  inline ::s_vector3* mutable_screen_to_world();
  inline ::s_vector3* release_screen_to_world();
  
  // optional int32 ball_type = 2;
  inline bool has_ball_type() const;
  inline void clear_ball_type();
  static const int kBallTypeFieldNumber = 2;
  inline ::google::protobuf::int32 ball_type() const;
  inline void set_ball_type(::google::protobuf::int32 value);
  
  // optional float scale_rate = 3;
  inline bool has_scale_rate() const;
  inline void clear_scale_rate();
  static const int kScaleRateFieldNumber = 3;
  inline float scale_rate() const;
  inline void set_scale_rate(float value);
  
  // optional float ball_breaking = 4;
  inline bool has_ball_breaking() const;
  inline void clear_ball_breaking();
  static const int kBallBreakingFieldNumber = 4;
  inline float ball_breaking() const;
  inline void set_ball_breaking(float value);
  
  // optional float angle = 5;
  inline bool has_angle() const;
  inline void clear_angle();
  static const int kAngleFieldNumber = 5;
  inline float angle() const;
  inline void set_angle(float value);
  
  // optional int64 uid = 6;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 6;
  inline ::google::protobuf::int64 uid() const;
  inline void set_uid(::google::protobuf::int64 value);
  
  // optional int32 round = 7;
  inline bool has_round() const;
  inline void clear_round();
  static const int kRoundFieldNumber = 7;
  inline ::google::protobuf::int32 round() const;
  inline void set_round(::google::protobuf::int32 value);
  
  // optional int32 rhythm_judge_verifi = 8;
  inline bool has_rhythm_judge_verifi() const;
  inline void clear_rhythm_judge_verifi();
  static const int kRhythmJudgeVerifiFieldNumber = 8;
  inline ::google::protobuf::int32 rhythm_judge_verifi() const;
  inline void set_rhythm_judge_verifi(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:s_pitcher_throw_info)
 private:
  inline void set_has_screen_to_world();
  inline void clear_has_screen_to_world();
  inline void set_has_ball_type();
  inline void clear_has_ball_type();
  inline void set_has_scale_rate();
  inline void clear_has_scale_rate();
  inline void set_has_ball_breaking();
  inline void clear_has_ball_breaking();
  inline void set_has_angle();
  inline void clear_has_angle();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_round();
  inline void clear_has_round();
  inline void set_has_rhythm_judge_verifi();
  inline void clear_has_rhythm_judge_verifi();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::s_vector3* screen_to_world_;
  ::google::protobuf::int32 ball_type_;
  float scale_rate_;
  float ball_breaking_;
  float angle_;
  ::google::protobuf::int64 uid_;
  ::google::protobuf::int32 round_;
  ::google::protobuf::int32 rhythm_judge_verifi_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_pitcher_throw_info* default_instance_;
};
// -------------------------------------------------------------------

class s_better_hit_info : public ::google::protobuf::Message {
 public:
  s_better_hit_info();
  virtual ~s_better_hit_info();
  
  s_better_hit_info(const s_better_hit_info& from);
  
  inline s_better_hit_info& operator=(const s_better_hit_info& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const s_better_hit_info& default_instance();
  
  void Swap(s_better_hit_info* other);
  
  // implements Message ----------------------------------------------
  
  s_better_hit_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const s_better_hit_info& from);
  void MergeFrom(const s_better_hit_info& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .s_vector3 screen_to_world = 1;
  inline bool has_screen_to_world() const;
  inline void clear_screen_to_world();
  static const int kScreenToWorldFieldNumber = 1;
  inline const ::s_vector3& screen_to_world() const;
  inline ::s_vector3* mutable_screen_to_world();
  inline ::s_vector3* release_screen_to_world();
  
  // optional .s_vector2 force_xy = 2;
  inline bool has_force_xy() const;
  inline void clear_force_xy();
  static const int kForceXyFieldNumber = 2;
  inline const ::s_vector2& force_xy() const;
  inline ::s_vector2* mutable_force_xy();
  inline ::s_vector2* release_force_xy();
  
  // optional float force = 3;
  inline bool has_force() const;
  inline void clear_force();
  static const int kForceFieldNumber = 3;
  inline float force() const;
  inline void set_force(float value);
  
  // optional float torque = 4;
  inline bool has_torque() const;
  inline void clear_torque();
  static const int kTorqueFieldNumber = 4;
  inline float torque() const;
  inline void set_torque(float value);
  
  // optional float velocity_x = 5;
  inline bool has_velocity_x() const;
  inline void clear_velocity_x();
  static const int kVelocityXFieldNumber = 5;
  inline float velocity_x() const;
  inline void set_velocity_x(float value);
  
  // optional int64 uid = 6;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 6;
  inline ::google::protobuf::int64 uid() const;
  inline void set_uid(::google::protobuf::int64 value);
  
  // optional int32 round = 7;
  inline bool has_round() const;
  inline void clear_round();
  static const int kRoundFieldNumber = 7;
  inline ::google::protobuf::int32 round() const;
  inline void set_round(::google::protobuf::int32 value);
  
  // optional int32 hit_info = 8;
  inline bool has_hit_info() const;
  inline void clear_hit_info();
  static const int kHitInfoFieldNumber = 8;
  inline ::google::protobuf::int32 hit_info() const;
  inline void set_hit_info(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:s_better_hit_info)
 private:
  inline void set_has_screen_to_world();
  inline void clear_has_screen_to_world();
  inline void set_has_force_xy();
  inline void clear_has_force_xy();
  inline void set_has_force();
  inline void clear_has_force();
  inline void set_has_torque();
  inline void clear_has_torque();
  inline void set_has_velocity_x();
  inline void clear_has_velocity_x();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_round();
  inline void clear_has_round();
  inline void set_has_hit_info();
  inline void clear_has_hit_info();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::s_vector3* screen_to_world_;
  ::s_vector2* force_xy_;
  float force_;
  float torque_;
  ::google::protobuf::int64 uid_;
  float velocity_x_;
  ::google::protobuf::int32 round_;
  ::google::protobuf::int32 hit_info_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_better_hit_info* default_instance_;
};
// -------------------------------------------------------------------

class GLReqGameProtocol : public ::google::protobuf::Message {
 public:
  GLReqGameProtocol();
  virtual ~GLReqGameProtocol();
  
  GLReqGameProtocol(const GLReqGameProtocol& from);
  
  inline GLReqGameProtocol& operator=(const GLReqGameProtocol& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GLReqGameProtocol& default_instance();
  
  void Swap(GLReqGameProtocol* other);
  
  // implements Message ----------------------------------------------
  
  GLReqGameProtocol* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GLReqGameProtocol& from);
  void MergeFrom(const GLReqGameProtocol& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:GLReqGameProtocol)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLReqGameProtocol* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameProtocol : public ::google::protobuf::Message {
 public:
  GLAnsGameProtocol();
  virtual ~GLAnsGameProtocol();
  
  GLAnsGameProtocol(const GLAnsGameProtocol& from);
  
  inline GLAnsGameProtocol& operator=(const GLAnsGameProtocol& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GLAnsGameProtocol& default_instance();
  
  void Swap(GLAnsGameProtocol* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameProtocol* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GLAnsGameProtocol& from);
  void MergeFrom(const GLAnsGameProtocol& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:GLAnsGameProtocol)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameProtocol* default_instance_;
};
// ===================================================================


// ===================================================================

// GameUserInfo

// required .GameInfo game_info = 1;
inline bool GameUserInfo::has_game_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameUserInfo::set_has_game_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameUserInfo::clear_has_game_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameUserInfo::clear_game_info() {
  if (game_info_ != NULL) game_info_->::GameInfo::Clear();
  clear_has_game_info();
}
inline const ::GameInfo& GameUserInfo::game_info() const {
  return game_info_ != NULL ? *game_info_ : *default_instance_->game_info_;
}
inline ::GameInfo* GameUserInfo::mutable_game_info() {
  set_has_game_info();
  if (game_info_ == NULL) game_info_ = new ::GameInfo;
  return game_info_;
}
inline ::GameInfo* GameUserInfo::release_game_info() {
  clear_has_game_info();
  ::GameInfo* temp = game_info_;
  game_info_ = NULL;
  return temp;
}

// required bytes member_info = 2;
inline bool GameUserInfo::has_member_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameUserInfo::set_has_member_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameUserInfo::clear_has_member_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameUserInfo::clear_member_info() {
  if (member_info_ != &::google::protobuf::internal::kEmptyString) {
    member_info_->clear();
  }
  clear_has_member_info();
}
inline const ::std::string& GameUserInfo::member_info() const {
  return *member_info_;
}
inline void GameUserInfo::set_member_info(const ::std::string& value) {
  set_has_member_info();
  if (member_info_ == &::google::protobuf::internal::kEmptyString) {
    member_info_ = new ::std::string;
  }
  member_info_->assign(value);
}
inline void GameUserInfo::set_member_info(const char* value) {
  set_has_member_info();
  if (member_info_ == &::google::protobuf::internal::kEmptyString) {
    member_info_ = new ::std::string;
  }
  member_info_->assign(value);
}
inline void GameUserInfo::set_member_info(const void* value, size_t size) {
  set_has_member_info();
  if (member_info_ == &::google::protobuf::internal::kEmptyString) {
    member_info_ = new ::std::string;
  }
  member_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameUserInfo::mutable_member_info() {
  set_has_member_info();
  if (member_info_ == &::google::protobuf::internal::kEmptyString) {
    member_info_ = new ::std::string;
  }
  return member_info_;
}
inline ::std::string* GameUserInfo::release_member_info() {
  clear_has_member_info();
  if (member_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = member_info_;
    member_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GameInfo

// repeated .s_tbl_user m_tbl_user = 1;
inline int GameInfo::m_tbl_user_size() const {
  return m_tbl_user_.size();
}
inline void GameInfo::clear_m_tbl_user() {
  m_tbl_user_.Clear();
}
inline const ::s_tbl_user& GameInfo::m_tbl_user(int index) const {
  return m_tbl_user_.Get(index);
}
inline ::s_tbl_user* GameInfo::mutable_m_tbl_user(int index) {
  return m_tbl_user_.Mutable(index);
}
inline ::s_tbl_user* GameInfo::add_m_tbl_user() {
  return m_tbl_user_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::s_tbl_user >&
GameInfo::m_tbl_user() const {
  return m_tbl_user_;
}
inline ::google::protobuf::RepeatedPtrField< ::s_tbl_user >*
GameInfo::mutable_m_tbl_user() {
  return &m_tbl_user_;
}

// -------------------------------------------------------------------

// s_game_play_info

// required .s_tbl_user m_tbl_user = 1;
inline bool s_game_play_info::has_m_tbl_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_game_play_info::set_has_m_tbl_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_game_play_info::clear_has_m_tbl_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_game_play_info::clear_m_tbl_user() {
  if (m_tbl_user_ != NULL) m_tbl_user_->::s_tbl_user::Clear();
  clear_has_m_tbl_user();
}
inline const ::s_tbl_user& s_game_play_info::m_tbl_user() const {
  return m_tbl_user_ != NULL ? *m_tbl_user_ : *default_instance_->m_tbl_user_;
}
inline ::s_tbl_user* s_game_play_info::mutable_m_tbl_user() {
  set_has_m_tbl_user();
  if (m_tbl_user_ == NULL) m_tbl_user_ = new ::s_tbl_user;
  return m_tbl_user_;
}
inline ::s_tbl_user* s_game_play_info::release_m_tbl_user() {
  clear_has_m_tbl_user();
  ::s_tbl_user* temp = m_tbl_user_;
  m_tbl_user_ = NULL;
  return temp;
}

// optional int32 m_e_user_gps = 2;
inline bool s_game_play_info::has_m_e_user_gps() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void s_game_play_info::set_has_m_e_user_gps() {
  _has_bits_[0] |= 0x00000002u;
}
inline void s_game_play_info::clear_has_m_e_user_gps() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void s_game_play_info::clear_m_e_user_gps() {
  m_e_user_gps_ = 0;
  clear_has_m_e_user_gps();
}
inline ::google::protobuf::int32 s_game_play_info::m_e_user_gps() const {
  return m_e_user_gps_;
}
inline void s_game_play_info::set_m_e_user_gps(::google::protobuf::int32 value) {
  set_has_m_e_user_gps();
  m_e_user_gps_ = value;
}

// optional int32 m_pitcher_sid = 3;
inline bool s_game_play_info::has_m_pitcher_sid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void s_game_play_info::set_has_m_pitcher_sid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void s_game_play_info::clear_has_m_pitcher_sid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void s_game_play_info::clear_m_pitcher_sid() {
  m_pitcher_sid_ = 0;
  clear_has_m_pitcher_sid();
}
inline ::google::protobuf::int32 s_game_play_info::m_pitcher_sid() const {
  return m_pitcher_sid_;
}
inline void s_game_play_info::set_m_pitcher_sid(::google::protobuf::int32 value) {
  set_has_m_pitcher_sid();
  m_pitcher_sid_ = value;
}

// optional int32 m_batter_sid = 4;
inline bool s_game_play_info::has_m_batter_sid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void s_game_play_info::set_has_m_batter_sid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void s_game_play_info::clear_has_m_batter_sid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void s_game_play_info::clear_m_batter_sid() {
  m_batter_sid_ = 0;
  clear_has_m_batter_sid();
}
inline ::google::protobuf::int32 s_game_play_info::m_batter_sid() const {
  return m_batter_sid_;
}
inline void s_game_play_info::set_m_batter_sid(::google::protobuf::int32 value) {
  set_has_m_batter_sid();
  m_batter_sid_ = value;
}

// -------------------------------------------------------------------

// s_result_round

// optional .s_tbl_roundresult m_tbl_roundresult = 1;
inline bool s_result_round::has_m_tbl_roundresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_result_round::set_has_m_tbl_roundresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_result_round::clear_has_m_tbl_roundresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_result_round::clear_m_tbl_roundresult() {
  if (m_tbl_roundresult_ != NULL) m_tbl_roundresult_->::s_tbl_roundresult::Clear();
  clear_has_m_tbl_roundresult();
}
inline const ::s_tbl_roundresult& s_result_round::m_tbl_roundresult() const {
  return m_tbl_roundresult_ != NULL ? *m_tbl_roundresult_ : *default_instance_->m_tbl_roundresult_;
}
inline ::s_tbl_roundresult* s_result_round::mutable_m_tbl_roundresult() {
  set_has_m_tbl_roundresult();
  if (m_tbl_roundresult_ == NULL) m_tbl_roundresult_ = new ::s_tbl_roundresult;
  return m_tbl_roundresult_;
}
inline ::s_tbl_roundresult* s_result_round::release_m_tbl_roundresult() {
  clear_has_m_tbl_roundresult();
  ::s_tbl_roundresult* temp = m_tbl_roundresult_;
  m_tbl_roundresult_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// s_result_game

// optional .s_tbl_result m_tbl_result = 1;
inline bool s_result_game::has_m_tbl_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_result_game::set_has_m_tbl_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_result_game::clear_has_m_tbl_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_result_game::clear_m_tbl_result() {
  if (m_tbl_result_ != NULL) m_tbl_result_->::s_tbl_result::Clear();
  clear_has_m_tbl_result();
}
inline const ::s_tbl_result& s_result_game::m_tbl_result() const {
  return m_tbl_result_ != NULL ? *m_tbl_result_ : *default_instance_->m_tbl_result_;
}
inline ::s_tbl_result* s_result_game::mutable_m_tbl_result() {
  set_has_m_tbl_result();
  if (m_tbl_result_ == NULL) m_tbl_result_ = new ::s_tbl_result;
  return m_tbl_result_;
}
inline ::s_tbl_result* s_result_game::release_m_tbl_result() {
  clear_has_m_tbl_result();
  ::s_tbl_result* temp = m_tbl_result_;
  m_tbl_result_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// GameRoomInfo

// required int32 room_id = 1;
inline bool GameRoomInfo::has_room_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameRoomInfo::set_has_room_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameRoomInfo::clear_has_room_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameRoomInfo::clear_room_id() {
  room_id_ = 0;
  clear_has_room_id();
}
inline ::google::protobuf::int32 GameRoomInfo::room_id() const {
  return room_id_;
}
inline void GameRoomInfo::set_room_id(::google::protobuf::int32 value) {
  set_has_room_id();
  room_id_ = value;
}

// repeated .s_game_play_info m_game_play_info = 2;
inline int GameRoomInfo::m_game_play_info_size() const {
  return m_game_play_info_.size();
}
inline void GameRoomInfo::clear_m_game_play_info() {
  m_game_play_info_.Clear();
}
inline const ::s_game_play_info& GameRoomInfo::m_game_play_info(int index) const {
  return m_game_play_info_.Get(index);
}
inline ::s_game_play_info* GameRoomInfo::mutable_m_game_play_info(int index) {
  return m_game_play_info_.Mutable(index);
}
inline ::s_game_play_info* GameRoomInfo::add_m_game_play_info() {
  return m_game_play_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::s_game_play_info >&
GameRoomInfo::m_game_play_info() const {
  return m_game_play_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::s_game_play_info >*
GameRoomInfo::mutable_m_game_play_info() {
  return &m_game_play_info_;
}

// optional int64 m_attack_user = 3;
inline bool GameRoomInfo::has_m_attack_user() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameRoomInfo::set_has_m_attack_user() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameRoomInfo::clear_has_m_attack_user() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameRoomInfo::clear_m_attack_user() {
  m_attack_user_ = GOOGLE_LONGLONG(0);
  clear_has_m_attack_user();
}
inline ::google::protobuf::int64 GameRoomInfo::m_attack_user() const {
  return m_attack_user_;
}
inline void GameRoomInfo::set_m_attack_user(::google::protobuf::int64 value) {
  set_has_m_attack_user();
  m_attack_user_ = value;
}

// optional int32 m_round_count = 4;
inline bool GameRoomInfo::has_m_round_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameRoomInfo::set_has_m_round_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameRoomInfo::clear_has_m_round_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameRoomInfo::clear_m_round_count() {
  m_round_count_ = 0;
  clear_has_m_round_count();
}
inline ::google::protobuf::int32 GameRoomInfo::m_round_count() const {
  return m_round_count_;
}
inline void GameRoomInfo::set_m_round_count(::google::protobuf::int32 value) {
  set_has_m_round_count();
  m_round_count_ = value;
}

// repeated .s_result_round m_result_round = 5;
inline int GameRoomInfo::m_result_round_size() const {
  return m_result_round_.size();
}
inline void GameRoomInfo::clear_m_result_round() {
  m_result_round_.Clear();
}
inline const ::s_result_round& GameRoomInfo::m_result_round(int index) const {
  return m_result_round_.Get(index);
}
inline ::s_result_round* GameRoomInfo::mutable_m_result_round(int index) {
  return m_result_round_.Mutable(index);
}
inline ::s_result_round* GameRoomInfo::add_m_result_round() {
  return m_result_round_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::s_result_round >&
GameRoomInfo::m_result_round() const {
  return m_result_round_;
}
inline ::google::protobuf::RepeatedPtrField< ::s_result_round >*
GameRoomInfo::mutable_m_result_round() {
  return &m_result_round_;
}

// optional .s_result_game m_result_game = 6;
inline bool GameRoomInfo::has_m_result_game() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GameRoomInfo::set_has_m_result_game() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GameRoomInfo::clear_has_m_result_game() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GameRoomInfo::clear_m_result_game() {
  if (m_result_game_ != NULL) m_result_game_->::s_result_game::Clear();
  clear_has_m_result_game();
}
inline const ::s_result_game& GameRoomInfo::m_result_game() const {
  return m_result_game_ != NULL ? *m_result_game_ : *default_instance_->m_result_game_;
}
inline ::s_result_game* GameRoomInfo::mutable_m_result_game() {
  set_has_m_result_game();
  if (m_result_game_ == NULL) m_result_game_ = new ::s_result_game;
  return m_result_game_;
}
inline ::s_result_game* GameRoomInfo::release_m_result_game() {
  clear_has_m_result_game();
  ::s_result_game* temp = m_result_game_;
  m_result_game_ = NULL;
  return temp;
}

// optional bool m_is_auto_play = 7;
inline bool GameRoomInfo::has_m_is_auto_play() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GameRoomInfo::set_has_m_is_auto_play() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GameRoomInfo::clear_has_m_is_auto_play() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GameRoomInfo::clear_m_is_auto_play() {
  m_is_auto_play_ = false;
  clear_has_m_is_auto_play();
}
inline bool GameRoomInfo::m_is_auto_play() const {
  return m_is_auto_play_;
}
inline void GameRoomInfo::set_m_is_auto_play(bool value) {
  set_has_m_is_auto_play();
  m_is_auto_play_ = value;
}

// optional int32 m_baseball_park = 8;
inline bool GameRoomInfo::has_m_baseball_park() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GameRoomInfo::set_has_m_baseball_park() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GameRoomInfo::clear_has_m_baseball_park() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GameRoomInfo::clear_m_baseball_park() {
  m_baseball_park_ = 0;
  clear_has_m_baseball_park();
}
inline ::google::protobuf::int32 GameRoomInfo::m_baseball_park() const {
  return m_baseball_park_;
}
inline void GameRoomInfo::set_m_baseball_park(::google::protobuf::int32 value) {
  set_has_m_baseball_park();
  m_baseball_park_ = value;
}

// -------------------------------------------------------------------

// s_vector3

// optional float x = 1;
inline bool s_vector3::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_vector3::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_vector3::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_vector3::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float s_vector3::x() const {
  return x_;
}
inline void s_vector3::set_x(float value) {
  set_has_x();
  x_ = value;
}

// optional float y = 2;
inline bool s_vector3::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void s_vector3::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void s_vector3::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void s_vector3::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float s_vector3::y() const {
  return y_;
}
inline void s_vector3::set_y(float value) {
  set_has_y();
  y_ = value;
}

// optional float z = 3;
inline bool s_vector3::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void s_vector3::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void s_vector3::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void s_vector3::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float s_vector3::z() const {
  return z_;
}
inline void s_vector3::set_z(float value) {
  set_has_z();
  z_ = value;
}

// -------------------------------------------------------------------

// s_vector2

// optional float x = 1;
inline bool s_vector2::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_vector2::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_vector2::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_vector2::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float s_vector2::x() const {
  return x_;
}
inline void s_vector2::set_x(float value) {
  set_has_x();
  x_ = value;
}

// optional float y = 2;
inline bool s_vector2::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void s_vector2::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void s_vector2::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void s_vector2::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float s_vector2::y() const {
  return y_;
}
inline void s_vector2::set_y(float value) {
  set_has_y();
  y_ = value;
}

// -------------------------------------------------------------------

// s_pitcher_throw_info

// optional .s_vector3 screen_to_world = 1;
inline bool s_pitcher_throw_info::has_screen_to_world() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_pitcher_throw_info::set_has_screen_to_world() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_pitcher_throw_info::clear_has_screen_to_world() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_pitcher_throw_info::clear_screen_to_world() {
  if (screen_to_world_ != NULL) screen_to_world_->::s_vector3::Clear();
  clear_has_screen_to_world();
}
inline const ::s_vector3& s_pitcher_throw_info::screen_to_world() const {
  return screen_to_world_ != NULL ? *screen_to_world_ : *default_instance_->screen_to_world_;
}
inline ::s_vector3* s_pitcher_throw_info::mutable_screen_to_world() {
  set_has_screen_to_world();
  if (screen_to_world_ == NULL) screen_to_world_ = new ::s_vector3;
  return screen_to_world_;
}
inline ::s_vector3* s_pitcher_throw_info::release_screen_to_world() {
  clear_has_screen_to_world();
  ::s_vector3* temp = screen_to_world_;
  screen_to_world_ = NULL;
  return temp;
}

// optional int32 ball_type = 2;
inline bool s_pitcher_throw_info::has_ball_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void s_pitcher_throw_info::set_has_ball_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void s_pitcher_throw_info::clear_has_ball_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void s_pitcher_throw_info::clear_ball_type() {
  ball_type_ = 0;
  clear_has_ball_type();
}
inline ::google::protobuf::int32 s_pitcher_throw_info::ball_type() const {
  return ball_type_;
}
inline void s_pitcher_throw_info::set_ball_type(::google::protobuf::int32 value) {
  set_has_ball_type();
  ball_type_ = value;
}

// optional float scale_rate = 3;
inline bool s_pitcher_throw_info::has_scale_rate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void s_pitcher_throw_info::set_has_scale_rate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void s_pitcher_throw_info::clear_has_scale_rate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void s_pitcher_throw_info::clear_scale_rate() {
  scale_rate_ = 0;
  clear_has_scale_rate();
}
inline float s_pitcher_throw_info::scale_rate() const {
  return scale_rate_;
}
inline void s_pitcher_throw_info::set_scale_rate(float value) {
  set_has_scale_rate();
  scale_rate_ = value;
}

// optional float ball_breaking = 4;
inline bool s_pitcher_throw_info::has_ball_breaking() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void s_pitcher_throw_info::set_has_ball_breaking() {
  _has_bits_[0] |= 0x00000008u;
}
inline void s_pitcher_throw_info::clear_has_ball_breaking() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void s_pitcher_throw_info::clear_ball_breaking() {
  ball_breaking_ = 0;
  clear_has_ball_breaking();
}
inline float s_pitcher_throw_info::ball_breaking() const {
  return ball_breaking_;
}
inline void s_pitcher_throw_info::set_ball_breaking(float value) {
  set_has_ball_breaking();
  ball_breaking_ = value;
}

// optional float angle = 5;
inline bool s_pitcher_throw_info::has_angle() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void s_pitcher_throw_info::set_has_angle() {
  _has_bits_[0] |= 0x00000010u;
}
inline void s_pitcher_throw_info::clear_has_angle() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void s_pitcher_throw_info::clear_angle() {
  angle_ = 0;
  clear_has_angle();
}
inline float s_pitcher_throw_info::angle() const {
  return angle_;
}
inline void s_pitcher_throw_info::set_angle(float value) {
  set_has_angle();
  angle_ = value;
}

// optional int64 uid = 6;
inline bool s_pitcher_throw_info::has_uid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void s_pitcher_throw_info::set_has_uid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void s_pitcher_throw_info::clear_has_uid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void s_pitcher_throw_info::clear_uid() {
  uid_ = GOOGLE_LONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::int64 s_pitcher_throw_info::uid() const {
  return uid_;
}
inline void s_pitcher_throw_info::set_uid(::google::protobuf::int64 value) {
  set_has_uid();
  uid_ = value;
}

// optional int32 round = 7;
inline bool s_pitcher_throw_info::has_round() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void s_pitcher_throw_info::set_has_round() {
  _has_bits_[0] |= 0x00000040u;
}
inline void s_pitcher_throw_info::clear_has_round() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void s_pitcher_throw_info::clear_round() {
  round_ = 0;
  clear_has_round();
}
inline ::google::protobuf::int32 s_pitcher_throw_info::round() const {
  return round_;
}
inline void s_pitcher_throw_info::set_round(::google::protobuf::int32 value) {
  set_has_round();
  round_ = value;
}

// optional int32 rhythm_judge_verifi = 8;
inline bool s_pitcher_throw_info::has_rhythm_judge_verifi() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void s_pitcher_throw_info::set_has_rhythm_judge_verifi() {
  _has_bits_[0] |= 0x00000080u;
}
inline void s_pitcher_throw_info::clear_has_rhythm_judge_verifi() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void s_pitcher_throw_info::clear_rhythm_judge_verifi() {
  rhythm_judge_verifi_ = 0;
  clear_has_rhythm_judge_verifi();
}
inline ::google::protobuf::int32 s_pitcher_throw_info::rhythm_judge_verifi() const {
  return rhythm_judge_verifi_;
}
inline void s_pitcher_throw_info::set_rhythm_judge_verifi(::google::protobuf::int32 value) {
  set_has_rhythm_judge_verifi();
  rhythm_judge_verifi_ = value;
}

// -------------------------------------------------------------------

// s_better_hit_info

// optional .s_vector3 screen_to_world = 1;
inline bool s_better_hit_info::has_screen_to_world() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_better_hit_info::set_has_screen_to_world() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_better_hit_info::clear_has_screen_to_world() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_better_hit_info::clear_screen_to_world() {
  if (screen_to_world_ != NULL) screen_to_world_->::s_vector3::Clear();
  clear_has_screen_to_world();
}
inline const ::s_vector3& s_better_hit_info::screen_to_world() const {
  return screen_to_world_ != NULL ? *screen_to_world_ : *default_instance_->screen_to_world_;
}
inline ::s_vector3* s_better_hit_info::mutable_screen_to_world() {
  set_has_screen_to_world();
  if (screen_to_world_ == NULL) screen_to_world_ = new ::s_vector3;
  return screen_to_world_;
}
inline ::s_vector3* s_better_hit_info::release_screen_to_world() {
  clear_has_screen_to_world();
  ::s_vector3* temp = screen_to_world_;
  screen_to_world_ = NULL;
  return temp;
}

// optional .s_vector2 force_xy = 2;
inline bool s_better_hit_info::has_force_xy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void s_better_hit_info::set_has_force_xy() {
  _has_bits_[0] |= 0x00000002u;
}
inline void s_better_hit_info::clear_has_force_xy() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void s_better_hit_info::clear_force_xy() {
  if (force_xy_ != NULL) force_xy_->::s_vector2::Clear();
  clear_has_force_xy();
}
inline const ::s_vector2& s_better_hit_info::force_xy() const {
  return force_xy_ != NULL ? *force_xy_ : *default_instance_->force_xy_;
}
inline ::s_vector2* s_better_hit_info::mutable_force_xy() {
  set_has_force_xy();
  if (force_xy_ == NULL) force_xy_ = new ::s_vector2;
  return force_xy_;
}
inline ::s_vector2* s_better_hit_info::release_force_xy() {
  clear_has_force_xy();
  ::s_vector2* temp = force_xy_;
  force_xy_ = NULL;
  return temp;
}

// optional float force = 3;
inline bool s_better_hit_info::has_force() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void s_better_hit_info::set_has_force() {
  _has_bits_[0] |= 0x00000004u;
}
inline void s_better_hit_info::clear_has_force() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void s_better_hit_info::clear_force() {
  force_ = 0;
  clear_has_force();
}
inline float s_better_hit_info::force() const {
  return force_;
}
inline void s_better_hit_info::set_force(float value) {
  set_has_force();
  force_ = value;
}

// optional float torque = 4;
inline bool s_better_hit_info::has_torque() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void s_better_hit_info::set_has_torque() {
  _has_bits_[0] |= 0x00000008u;
}
inline void s_better_hit_info::clear_has_torque() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void s_better_hit_info::clear_torque() {
  torque_ = 0;
  clear_has_torque();
}
inline float s_better_hit_info::torque() const {
  return torque_;
}
inline void s_better_hit_info::set_torque(float value) {
  set_has_torque();
  torque_ = value;
}

// optional float velocity_x = 5;
inline bool s_better_hit_info::has_velocity_x() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void s_better_hit_info::set_has_velocity_x() {
  _has_bits_[0] |= 0x00000010u;
}
inline void s_better_hit_info::clear_has_velocity_x() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void s_better_hit_info::clear_velocity_x() {
  velocity_x_ = 0;
  clear_has_velocity_x();
}
inline float s_better_hit_info::velocity_x() const {
  return velocity_x_;
}
inline void s_better_hit_info::set_velocity_x(float value) {
  set_has_velocity_x();
  velocity_x_ = value;
}

// optional int64 uid = 6;
inline bool s_better_hit_info::has_uid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void s_better_hit_info::set_has_uid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void s_better_hit_info::clear_has_uid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void s_better_hit_info::clear_uid() {
  uid_ = GOOGLE_LONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::int64 s_better_hit_info::uid() const {
  return uid_;
}
inline void s_better_hit_info::set_uid(::google::protobuf::int64 value) {
  set_has_uid();
  uid_ = value;
}

// optional int32 round = 7;
inline bool s_better_hit_info::has_round() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void s_better_hit_info::set_has_round() {
  _has_bits_[0] |= 0x00000040u;
}
inline void s_better_hit_info::clear_has_round() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void s_better_hit_info::clear_round() {
  round_ = 0;
  clear_has_round();
}
inline ::google::protobuf::int32 s_better_hit_info::round() const {
  return round_;
}
inline void s_better_hit_info::set_round(::google::protobuf::int32 value) {
  set_has_round();
  round_ = value;
}

// optional int32 hit_info = 8;
inline bool s_better_hit_info::has_hit_info() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void s_better_hit_info::set_has_hit_info() {
  _has_bits_[0] |= 0x00000080u;
}
inline void s_better_hit_info::clear_has_hit_info() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void s_better_hit_info::clear_hit_info() {
  hit_info_ = 0;
  clear_has_hit_info();
}
inline ::google::protobuf::int32 s_better_hit_info::hit_info() const {
  return hit_info_;
}
inline void s_better_hit_info::set_hit_info(::google::protobuf::int32 value) {
  set_has_hit_info();
  hit_info_ = value;
}

// -------------------------------------------------------------------

// GLReqGameProtocol

// -------------------------------------------------------------------

// GLAnsGameProtocol


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_gameLogic_2eproto__INCLUDED
