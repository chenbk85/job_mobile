// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "ug.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace {

const ::google::protobuf::Descriptor* Version_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Version_reflection_ = NULL;
const ::google::protobuf::Descriptor* Error_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Error_reflection_ = NULL;
const ::google::protobuf::Descriptor* Desc_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Desc_reflection_ = NULL;
const ::google::protobuf::Descriptor* Notice_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Notice_reflection_ = NULL;
const ::google::protobuf::Descriptor* UError_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UError_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* UError_EErrorType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* UReqConnect_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UReqConnect_reflection_ = NULL;
const ::google::protobuf::Descriptor* UAnsConnect_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UAnsConnect_reflection_ = NULL;
const ::google::protobuf::Descriptor* UReqNotice_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UReqNotice_reflection_ = NULL;
const ::google::protobuf::Descriptor* UAnsNotice_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UAnsNotice_reflection_ = NULL;
const ::google::protobuf::Descriptor* UReqChannel_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UReqChannel_reflection_ = NULL;
const ::google::protobuf::Descriptor* UAnsChannel_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UAnsChannel_reflection_ = NULL;
const ::google::protobuf::Descriptor* UErrChannel_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UErrChannel_reflection_ = NULL;
const ::google::protobuf::Descriptor* UReqStore_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UReqStore_reflection_ = NULL;
const ::google::protobuf::Descriptor* UAnsStore_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UAnsStore_reflection_ = NULL;
const ::google::protobuf::Descriptor* UReqInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UReqInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* UAnsInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UAnsInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* UReqAutoJoin_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UReqAutoJoin_reflection_ = NULL;
const ::google::protobuf::Descriptor* UAnsAutoJoin_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UAnsAutoJoin_reflection_ = NULL;
const ::google::protobuf::Descriptor* UReqLeaveGame_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UReqLeaveGame_reflection_ = NULL;
const ::google::protobuf::Descriptor* UAnsLeaveGame_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UAnsLeaveGame_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* UAnsLeaveGame_KICK_TYPE_descriptor_ = NULL;
const ::google::protobuf::Descriptor* UReqClose_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UReqClose_reflection_ = NULL;
const ::google::protobuf::Descriptor* UAnsClose_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UAnsClose_reflection_ = NULL;
const ::google::protobuf::Descriptor* UReqPong_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UReqPong_reflection_ = NULL;
const ::google::protobuf::Descriptor* UAnsPing_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UAnsPing_reflection_ = NULL;
const ::google::protobuf::Descriptor* UReqPlug_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UReqPlug_reflection_ = NULL;
const ::google::protobuf::Descriptor* UAnsPlug_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UAnsPlug_reflection_ = NULL;
const ::google::protobuf::Descriptor* UReqProtocol_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UReqProtocol_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* UReqProtocol_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* UAnsProtocol_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UAnsProtocol_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* UAnsProtocol_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* MemberInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MemberInfo_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_ug_2eproto() {
  protobuf_AddDesc_ug_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "ug.proto");
  GOOGLE_CHECK(file != NULL);
  Version_descriptor_ = file->message_type(0);
  static const int Version_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Version, major_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Version, protocol_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Version, framework_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Version, service_),
  };
  Version_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Version_descriptor_,
      Version::default_instance_,
      Version_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Version, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Version, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Version));
  Error_descriptor_ = file->message_type(1);
  static const int Error_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Error, errorcode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Error, errorinfo_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Error, reqmode_),
  };
  Error_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Error_descriptor_,
      Error::default_instance_,
      Error_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Error, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Error, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Error));
  Desc_descriptor_ = file->message_type(2);
  static const int Desc_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Desc, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Desc, desc_),
  };
  Desc_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Desc_descriptor_,
      Desc::default_instance_,
      Desc_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Desc, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Desc, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Desc));
  Notice_descriptor_ = file->message_type(3);
  static const int Notice_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Notice, popup_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Notice, srl_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Notice, notice_),
  };
  Notice_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Notice_descriptor_,
      Notice::default_instance_,
      Notice_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Notice, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Notice, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Notice));
  UError_descriptor_ = file->message_type(4);
  static const int UError_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UError, error_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UError, over_),
  };
  UError_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UError_descriptor_,
      UError::default_instance_,
      UError_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UError, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UError, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UError));
  UError_EErrorType_descriptor_ = UError_descriptor_->enum_type(0);
  UReqConnect_descriptor_ = file->message_type(5);
  static const int UReqConnect_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqConnect, svcid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqConnect, gameid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqConnect, lastclosetime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqConnect, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqConnect, memberinfo_),
  };
  UReqConnect_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UReqConnect_descriptor_,
      UReqConnect::default_instance_,
      UReqConnect_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqConnect, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqConnect, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UReqConnect));
  UAnsConnect_descriptor_ = file->message_type(6);
  static const int UAnsConnect_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsConnect, svcid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsConnect, gameid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsConnect, status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsConnect, ip_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsConnect, port_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsConnect, passwd_),
  };
  UAnsConnect_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UAnsConnect_descriptor_,
      UAnsConnect::default_instance_,
      UAnsConnect_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsConnect, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsConnect, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UAnsConnect));
  UReqNotice_descriptor_ = file->message_type(7);
  static const int UReqNotice_offsets_[1] = {
  };
  UReqNotice_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UReqNotice_descriptor_,
      UReqNotice::default_instance_,
      UReqNotice_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqNotice, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqNotice, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UReqNotice));
  UAnsNotice_descriptor_ = file->message_type(8);
  static const int UAnsNotice_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsNotice, notices_),
  };
  UAnsNotice_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UAnsNotice_descriptor_,
      UAnsNotice::default_instance_,
      UAnsNotice_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsNotice, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsNotice, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UAnsNotice));
  UReqChannel_descriptor_ = file->message_type(9);
  static const int UReqChannel_offsets_[1] = {
  };
  UReqChannel_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UReqChannel_descriptor_,
      UReqChannel::default_instance_,
      UReqChannel_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqChannel, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqChannel, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UReqChannel));
  UAnsChannel_descriptor_ = file->message_type(10);
  static const int UAnsChannel_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsChannel, channelinfo_),
  };
  UAnsChannel_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UAnsChannel_descriptor_,
      UAnsChannel::default_instance_,
      UAnsChannel_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsChannel, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsChannel, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UAnsChannel));
  UErrChannel_descriptor_ = file->message_type(11);
  static const int UErrChannel_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UErrChannel, error_),
  };
  UErrChannel_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UErrChannel_descriptor_,
      UErrChannel::default_instance_,
      UErrChannel_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UErrChannel, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UErrChannel, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UErrChannel));
  UReqStore_descriptor_ = file->message_type(12);
  static const int UReqStore_offsets_[1] = {
  };
  UReqStore_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UReqStore_descriptor_,
      UReqStore::default_instance_,
      UReqStore_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqStore, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqStore, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UReqStore));
  UAnsStore_descriptor_ = file->message_type(13);
  static const int UAnsStore_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsStore, iteminfo_),
  };
  UAnsStore_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UAnsStore_descriptor_,
      UAnsStore::default_instance_,
      UAnsStore_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsStore, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsStore, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UAnsStore));
  UReqInfo_descriptor_ = file->message_type(14);
  static const int UReqInfo_offsets_[1] = {
  };
  UReqInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UReqInfo_descriptor_,
      UReqInfo::default_instance_,
      UReqInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UReqInfo));
  UAnsInfo_descriptor_ = file->message_type(15);
  static const int UAnsInfo_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsInfo, gameinfo_),
  };
  UAnsInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UAnsInfo_descriptor_,
      UAnsInfo::default_instance_,
      UAnsInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UAnsInfo));
  UReqAutoJoin_descriptor_ = file->message_type(16);
  static const int UReqAutoJoin_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqAutoJoin, categoryid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqAutoJoin, channelid_),
  };
  UReqAutoJoin_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UReqAutoJoin_descriptor_,
      UReqAutoJoin::default_instance_,
      UReqAutoJoin_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqAutoJoin, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqAutoJoin, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UReqAutoJoin));
  UAnsAutoJoin_descriptor_ = file->message_type(17);
  static const int UAnsAutoJoin_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsAutoJoin, gameroominfo_),
  };
  UAnsAutoJoin_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UAnsAutoJoin_descriptor_,
      UAnsAutoJoin::default_instance_,
      UAnsAutoJoin_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsAutoJoin, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsAutoJoin, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UAnsAutoJoin));
  UReqLeaveGame_descriptor_ = file->message_type(18);
  static const int UReqLeaveGame_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqLeaveGame, gameid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqLeaveGame, kick_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqLeaveGame, leave_info_),
  };
  UReqLeaveGame_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UReqLeaveGame_descriptor_,
      UReqLeaveGame::default_instance_,
      UReqLeaveGame_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqLeaveGame, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqLeaveGame, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UReqLeaveGame));
  UAnsLeaveGame_descriptor_ = file->message_type(19);
  static const int UAnsLeaveGame_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsLeaveGame, gameid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsLeaveGame, ntype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsLeaveGame, leave_info_),
  };
  UAnsLeaveGame_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UAnsLeaveGame_descriptor_,
      UAnsLeaveGame::default_instance_,
      UAnsLeaveGame_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsLeaveGame, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsLeaveGame, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UAnsLeaveGame));
  UAnsLeaveGame_KICK_TYPE_descriptor_ = UAnsLeaveGame_descriptor_->enum_type(0);
  UReqClose_descriptor_ = file->message_type(20);
  static const int UReqClose_offsets_[1] = {
  };
  UReqClose_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UReqClose_descriptor_,
      UReqClose::default_instance_,
      UReqClose_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqClose, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqClose, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UReqClose));
  UAnsClose_descriptor_ = file->message_type(21);
  static const int UAnsClose_offsets_[1] = {
  };
  UAnsClose_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UAnsClose_descriptor_,
      UAnsClose::default_instance_,
      UAnsClose_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsClose, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsClose, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UAnsClose));
  UReqPong_descriptor_ = file->message_type(22);
  static const int UReqPong_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqPong, seq_),
  };
  UReqPong_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UReqPong_descriptor_,
      UReqPong::default_instance_,
      UReqPong_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqPong, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqPong, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UReqPong));
  UAnsPing_descriptor_ = file->message_type(23);
  static const int UAnsPing_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsPing, seq_),
  };
  UAnsPing_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UAnsPing_descriptor_,
      UAnsPing::default_instance_,
      UAnsPing_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsPing, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsPing, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UAnsPing));
  UReqPlug_descriptor_ = file->message_type(24);
  static const int UReqPlug_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqPlug, gameid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqPlug, passwd_),
  };
  UReqPlug_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UReqPlug_descriptor_,
      UReqPlug::default_instance_,
      UReqPlug_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqPlug, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqPlug, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UReqPlug));
  UAnsPlug_descriptor_ = file->message_type(25);
  static const int UAnsPlug_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsPlug, gameid_),
  };
  UAnsPlug_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UAnsPlug_descriptor_,
      UAnsPlug::default_instance_,
      UAnsPlug_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsPlug, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsPlug, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UAnsPlug));
  UReqProtocol_descriptor_ = file->message_type(26);
  static const int UReqProtocol_offsets_[14] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqProtocol, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqProtocol, reqconnect_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqProtocol, reqchannel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqProtocol, reqstore_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqProtocol, reqinfo_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqProtocol, reqautojoin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqProtocol, reqleavegame_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqProtocol, reqclose_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqProtocol, reqpong_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqProtocol, reqplug_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqProtocol, reqgameprotocol_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqProtocol, reqdb_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqProtocol, reqnotice_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqProtocol, reqgatewayprotocol_),
  };
  UReqProtocol_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UReqProtocol_descriptor_,
      UReqProtocol::default_instance_,
      UReqProtocol_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqProtocol, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UReqProtocol, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UReqProtocol));
  UReqProtocol_Type_descriptor_ = UReqProtocol_descriptor_->enum_type(0);
  UAnsProtocol_descriptor_ = file->message_type(27);
  static const int UAnsProtocol_offsets_[15] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsProtocol, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsProtocol, ansconnect_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsProtocol, anschannel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsProtocol, ansstore_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsProtocol, ansinfo_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsProtocol, ansautojoin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsProtocol, ansleavegame_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsProtocol, ansclose_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsProtocol, ansping_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsProtocol, ansplug_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsProtocol, ansgameprotocol_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsProtocol, ansdb_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsProtocol, ansnotice_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsProtocol, anserror_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsProtocol, ansgatewayprotocol_),
  };
  UAnsProtocol_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UAnsProtocol_descriptor_,
      UAnsProtocol::default_instance_,
      UAnsProtocol_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsProtocol, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UAnsProtocol, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UAnsProtocol));
  UAnsProtocol_Type_descriptor_ = UAnsProtocol_descriptor_->enum_type(0);
  MemberInfo_descriptor_ = file->message_type(28);
  static const int MemberInfo_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemberInfo, game_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemberInfo, avatar_url_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemberInfo, nick_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemberInfo, gender_option_),
  };
  MemberInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MemberInfo_descriptor_,
      MemberInfo::default_instance_,
      MemberInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemberInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemberInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MemberInfo));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_ug_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Version_descriptor_, &Version::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Error_descriptor_, &Error::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Desc_descriptor_, &Desc::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Notice_descriptor_, &Notice::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UError_descriptor_, &UError::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UReqConnect_descriptor_, &UReqConnect::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UAnsConnect_descriptor_, &UAnsConnect::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UReqNotice_descriptor_, &UReqNotice::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UAnsNotice_descriptor_, &UAnsNotice::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UReqChannel_descriptor_, &UReqChannel::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UAnsChannel_descriptor_, &UAnsChannel::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UErrChannel_descriptor_, &UErrChannel::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UReqStore_descriptor_, &UReqStore::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UAnsStore_descriptor_, &UAnsStore::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UReqInfo_descriptor_, &UReqInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UAnsInfo_descriptor_, &UAnsInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UReqAutoJoin_descriptor_, &UReqAutoJoin::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UAnsAutoJoin_descriptor_, &UAnsAutoJoin::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UReqLeaveGame_descriptor_, &UReqLeaveGame::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UAnsLeaveGame_descriptor_, &UAnsLeaveGame::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UReqClose_descriptor_, &UReqClose::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UAnsClose_descriptor_, &UAnsClose::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UReqPong_descriptor_, &UReqPong::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UAnsPing_descriptor_, &UAnsPing::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UReqPlug_descriptor_, &UReqPlug::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UAnsPlug_descriptor_, &UAnsPlug::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UReqProtocol_descriptor_, &UReqProtocol::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UAnsProtocol_descriptor_, &UAnsProtocol::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MemberInfo_descriptor_, &MemberInfo::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_ug_2eproto() {
  delete Version::default_instance_;
  delete Version_reflection_;
  delete Error::default_instance_;
  delete Error_reflection_;
  delete Desc::default_instance_;
  delete Desc_reflection_;
  delete Notice::default_instance_;
  delete Notice_reflection_;
  delete UError::default_instance_;
  delete UError_reflection_;
  delete UReqConnect::default_instance_;
  delete UReqConnect_reflection_;
  delete UAnsConnect::default_instance_;
  delete UAnsConnect_reflection_;
  delete UReqNotice::default_instance_;
  delete UReqNotice_reflection_;
  delete UAnsNotice::default_instance_;
  delete UAnsNotice_reflection_;
  delete UReqChannel::default_instance_;
  delete UReqChannel_reflection_;
  delete UAnsChannel::default_instance_;
  delete UAnsChannel_reflection_;
  delete UErrChannel::default_instance_;
  delete UErrChannel_reflection_;
  delete UReqStore::default_instance_;
  delete UReqStore_reflection_;
  delete UAnsStore::default_instance_;
  delete UAnsStore_reflection_;
  delete UReqInfo::default_instance_;
  delete UReqInfo_reflection_;
  delete UAnsInfo::default_instance_;
  delete UAnsInfo_reflection_;
  delete UReqAutoJoin::default_instance_;
  delete UReqAutoJoin_reflection_;
  delete UAnsAutoJoin::default_instance_;
  delete UAnsAutoJoin_reflection_;
  delete UReqLeaveGame::default_instance_;
  delete UReqLeaveGame_reflection_;
  delete UAnsLeaveGame::default_instance_;
  delete UAnsLeaveGame_reflection_;
  delete UReqClose::default_instance_;
  delete UReqClose_reflection_;
  delete UAnsClose::default_instance_;
  delete UAnsClose_reflection_;
  delete UReqPong::default_instance_;
  delete UReqPong_reflection_;
  delete UAnsPing::default_instance_;
  delete UAnsPing_reflection_;
  delete UReqPlug::default_instance_;
  delete UReqPlug_reflection_;
  delete UAnsPlug::default_instance_;
  delete UAnsPlug_reflection_;
  delete UReqProtocol::default_instance_;
  delete UReqProtocol_reflection_;
  delete UAnsProtocol::default_instance_;
  delete UAnsProtocol_reflection_;
  delete MemberInfo::default_instance_;
  delete MemberInfo_reflection_;
}

void protobuf_AddDesc_ug_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::protobuf_AddDesc_db_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\010ug.proto\032\010db.proto\"Z\n\007Version\022\020\n\005major"
    "\030\001 \001(\005:\0011\022\031\n\010protocol\030\002 \001(\005:\0071204010\022\021\n\t"
    "framework\030\003 \002(\005\022\017\n\007service\030\004 \002(\005\">\n\005Erro"
    "r\022\021\n\terrorCode\030\001 \002(\005\022\021\n\terrorInfo\030\002 \002(\t\022"
    "\017\n\007reqMode\030\003 \002(\005\" \n\004Desc\022\n\n\002id\030\001 \002(\005\022\014\n\004"
    "desc\030\002 \002(\t\"4\n\006Notice\022\r\n\005popup\030\001 \002(\010\022\013\n\003s"
    "rl\030\002 \002(\005\022\016\n\006notice\030\003 \002(\t\"\351\002\n\006UError\022\025\n\005e"
    "rror\030\001 \002(\0132\006.Error\022\014\n\004over\030\002 \001(\010\"\271\002\n\nEEr"
    "rorType\022\031\n\025EET_VERSION_INCORRECT\020\001\022\020\n\014EE"
    "T_DATABASE\020\002\022\020\n\014EET_INTERNAL\020\003\022\026\n\022EET_AL"
    "READY_LOGGED\020\004\022\022\n\016EET_NOT_LOGGED\020\005\022\027\n\023EE"
    "T_ALREADY_PLAYING\020\006\022\023\n\017EET_NOT_PLAYING\020\007"
    "\022\024\n\020EET_CANT_PLUG_GS\020\010\022\025\n\021EET_INVALID_VA"
    "LUE\020\t\022\020\n\014EET_TIME_OUT\020\n\022\020\n\014EET_UNDEFINE\020"
    "\013\022\022\n\016EET_MAX_REFILL\020\014\022\021\n\rEET_OVER_USER\020\r"
    "\022\014\n\010EET_PLUG\020\016\022\014\n\010EET_BUSY\020\017\"\177\n\013UReqConn"
    "ect\022\r\n\005svcID\030\001 \002(\005\022\016\n\006gameID\030\002 \002(\003\022\025\n\rla"
    "stCloseTime\030\003 \002(\005\022\031\n\007version\030\004 \002(\0132\010.Ver"
    "sion\022\037\n\nmemberInfo\030\005 \002(\0132\013.MemberInfo\"f\n"
    "\013UAnsConnect\022\r\n\005svcID\030\001 \002(\005\022\016\n\006gameID\030\002 "
    "\002(\003\022\016\n\006status\030\003 \002(\005\022\n\n\002ip\030\004 \002(\t\022\014\n\004port\030"
    "\005 \002(\005\022\016\n\006passwd\030\006 \002(\t\"\014\n\nUReqNotice\"&\n\nU"
    "AnsNotice\022\030\n\007notices\030\001 \003(\0132\007.Notice\"\r\n\013U"
    "ReqChannel\")\n\013UAnsChannel\022\032\n\013channelInfo"
    "\030\001 \003(\0132\005.Desc\"$\n\013UErrChannel\022\025\n\005error\030\001 "
    "\002(\0132\006.Error\"\013\n\tUReqStore\"$\n\tUAnsStore\022\027\n"
    "\010itemInfo\030\001 \003(\0132\005.Desc\"\n\n\010UReqInfo\"\034\n\010UA"
    "nsInfo\022\020\n\010gameInfo\030\001 \002(\014\"5\n\014UReqAutoJoin"
    "\022\022\n\ncategoryID\030\001 \002(\005\022\021\n\tchannelID\030\002 \002(\005\""
    "$\n\014UAnsAutoJoin\022\024\n\014gameRoomInfo\030\001 \002(\014\"A\n"
    "\rUReqLeaveGame\022\016\n\006gameID\030\001 \002(\003\022\014\n\004kick\030\002"
    " \002(\010\022\022\n\nleave_info\030\003 \001(\014\"\320\001\n\rUAnsLeaveGa"
    "me\022\016\n\006gameID\030\001 \002(\003\022\'\n\005nType\030\002 \002(\0162\030.UAns"
    "LeaveGame.KICK_TYPE\022\022\n\nleave_info\030\003 \001(\014\""
    "r\n\tKICK_TYPE\022\024\n\020EXIT_RESERVATION\020\001\022\016\n\nLI"
    "MITMONEY\020\002\022\t\n\005ALLIN\020\003\022\020\n\014SYSTEM_ERROR\020\004\022"
    "\r\n\tKICK_ZERO\020\005\022\t\n\005PURGE\020\006\022\010\n\004KILL\020\007\"\013\n\tU"
    "ReqClose\"\013\n\tUAnsClose\"\027\n\010UReqPong\022\013\n\003seq"
    "\030\001 \002(\005\"\027\n\010UAnsPing\022\013\n\003seq\030\001 \002(\005\"*\n\010UReqP"
    "lug\022\016\n\006gameID\030\001 \002(\003\022\016\n\006passwd\030\002 \002(\t\"\032\n\010U"
    "AnsPlug\022\016\n\006gameID\030\001 \002(\003\"\250\005\n\014UReqProtocol"
    "\022 \n\004type\030\001 \002(\0162\022.UReqProtocol.Type\022 \n\nre"
    "qConnect\030\002 \001(\0132\014.UReqConnect\022 \n\nreqChann"
    "el\030\003 \001(\0132\014.UReqChannel\022\034\n\010reqStore\030\004 \001(\013"
    "2\n.UReqStore\022\032\n\007reqInfo\030\005 \001(\0132\t.UReqInfo"
    "\022\"\n\013reqAutoJoin\030\006 \001(\0132\r.UReqAutoJoin\022$\n\014"
    "reqLeaveGame\030\007 \001(\0132\016.UReqLeaveGame\022\034\n\010re"
    "qClose\030\010 \001(\0132\n.UReqClose\022\032\n\007reqPong\030\t \001("
    "\0132\t.UReqPong\022\032\n\007reqPlug\030\n \001(\0132\t.UReqPlug"
    "\022\027\n\017reqGameProtocol\030\013 \001(\014\022\025\n\005reqDB\030\014 \001(\013"
    "2\006.ReqDB\022\036\n\treqNotice\030\r \001(\0132\013.UReqNotice"
    "\022\032\n\022reqGatewayProtocol\030\016 \001(\014\"\353\001\n\004Type\022\010\n"
    "\004NONE\020\001\022\017\n\013UREQCONNECT\020\002\022\017\n\013UREQCHANNEL\020"
    "\003\022\r\n\tUREQSTORE\020\004\022\014\n\010UREQINFO\020\005\022\020\n\014UREQAU"
    "TOJOIN\020\006\022\021\n\rUREQLEAVEGAME\020\007\022\r\n\tUREQCLOSE"
    "\020\010\022\014\n\010UREQPONG\020\t\022\014\n\010UREQPLUG\020\n\022\025\n\021GLREQG"
    "AMEPROTOCOL\020\013\022\n\n\006UREQDB\020\014\022\016\n\nUREQNOTICE\020"
    "\r\022\027\n\023UREQGATEWAYPROTOCOL\020\016\"\317\005\n\014UAnsProto"
    "col\022 \n\004type\030\001 \002(\0162\022.UAnsProtocol.Type\022 \n"
    "\nansConnect\030\002 \001(\0132\014.UAnsConnect\022 \n\nansCh"
    "annel\030\003 \001(\0132\014.UAnsChannel\022\034\n\010ansStore\030\004 "
    "\001(\0132\n.UAnsStore\022\032\n\007ansInfo\030\005 \001(\0132\t.UAnsI"
    "nfo\022\"\n\013ansAutoJoin\030\006 \001(\0132\r.UAnsAutoJoin\022"
    "$\n\014ansLeaveGame\030\007 \001(\0132\016.UAnsLeaveGame\022\034\n"
    "\010ansClose\030\010 \001(\0132\n.UAnsClose\022\032\n\007ansPing\030\t"
    " \001(\0132\t.UAnsPing\022\032\n\007ansPlug\030\n \001(\0132\t.UAnsP"
    "lug\022\027\n\017ansGameProtocol\030\013 \001(\014\022\025\n\005ansDB\030\014 "
    "\001(\0132\006.AnsDB\022\036\n\tansNotice\030\r \001(\0132\013.UAnsNot"
    "ice\022\031\n\010ansError\030\016 \001(\0132\007.UError\022\032\n\022ansGat"
    "ewayProtocol\030\017 \001(\014\"\367\001\n\004Type\022\010\n\004NONE\020\001\022\017\n"
    "\013UANSCONNECT\020\002\022\017\n\013UANSCHANNEL\020\003\022\r\n\tUANSS"
    "TORE\020\004\022\014\n\010UANSINFO\020\005\022\020\n\014UANSAUTOJOIN\020\006\022\021"
    "\n\rUANSLEAVEGAME\020\007\022\r\n\tUANSCLOSE\020\010\022\014\n\010UANS"
    "PING\020\t\022\014\n\010UANSPLUG\020\n\022\025\n\021GLANSGAMEPROTOCO"
    "L\020\013\022\n\n\006UANSDB\020\014\022\016\n\nUANSNOTICE\020\r\022\n\n\006UERRO"
    "R\020\016\022\027\n\023UANSGATEWAYPROTOCOL\020\017\"[\n\nMemberIn"
    "fo\022\017\n\007game_id\030\001 \002(\003\022\022\n\navatar_url\030\002 \002(\t\022"
    "\021\n\tnick_name\030\003 \002(\t\022\025\n\rgender_option\030\004 \002("
    "\010", 3121);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "ug.proto", &protobuf_RegisterTypes);
  Version::default_instance_ = new Version();
  Error::default_instance_ = new Error();
  Desc::default_instance_ = new Desc();
  Notice::default_instance_ = new Notice();
  UError::default_instance_ = new UError();
  UReqConnect::default_instance_ = new UReqConnect();
  UAnsConnect::default_instance_ = new UAnsConnect();
  UReqNotice::default_instance_ = new UReqNotice();
  UAnsNotice::default_instance_ = new UAnsNotice();
  UReqChannel::default_instance_ = new UReqChannel();
  UAnsChannel::default_instance_ = new UAnsChannel();
  UErrChannel::default_instance_ = new UErrChannel();
  UReqStore::default_instance_ = new UReqStore();
  UAnsStore::default_instance_ = new UAnsStore();
  UReqInfo::default_instance_ = new UReqInfo();
  UAnsInfo::default_instance_ = new UAnsInfo();
  UReqAutoJoin::default_instance_ = new UReqAutoJoin();
  UAnsAutoJoin::default_instance_ = new UAnsAutoJoin();
  UReqLeaveGame::default_instance_ = new UReqLeaveGame();
  UAnsLeaveGame::default_instance_ = new UAnsLeaveGame();
  UReqClose::default_instance_ = new UReqClose();
  UAnsClose::default_instance_ = new UAnsClose();
  UReqPong::default_instance_ = new UReqPong();
  UAnsPing::default_instance_ = new UAnsPing();
  UReqPlug::default_instance_ = new UReqPlug();
  UAnsPlug::default_instance_ = new UAnsPlug();
  UReqProtocol::default_instance_ = new UReqProtocol();
  UAnsProtocol::default_instance_ = new UAnsProtocol();
  MemberInfo::default_instance_ = new MemberInfo();
  Version::default_instance_->InitAsDefaultInstance();
  Error::default_instance_->InitAsDefaultInstance();
  Desc::default_instance_->InitAsDefaultInstance();
  Notice::default_instance_->InitAsDefaultInstance();
  UError::default_instance_->InitAsDefaultInstance();
  UReqConnect::default_instance_->InitAsDefaultInstance();
  UAnsConnect::default_instance_->InitAsDefaultInstance();
  UReqNotice::default_instance_->InitAsDefaultInstance();
  UAnsNotice::default_instance_->InitAsDefaultInstance();
  UReqChannel::default_instance_->InitAsDefaultInstance();
  UAnsChannel::default_instance_->InitAsDefaultInstance();
  UErrChannel::default_instance_->InitAsDefaultInstance();
  UReqStore::default_instance_->InitAsDefaultInstance();
  UAnsStore::default_instance_->InitAsDefaultInstance();
  UReqInfo::default_instance_->InitAsDefaultInstance();
  UAnsInfo::default_instance_->InitAsDefaultInstance();
  UReqAutoJoin::default_instance_->InitAsDefaultInstance();
  UAnsAutoJoin::default_instance_->InitAsDefaultInstance();
  UReqLeaveGame::default_instance_->InitAsDefaultInstance();
  UAnsLeaveGame::default_instance_->InitAsDefaultInstance();
  UReqClose::default_instance_->InitAsDefaultInstance();
  UAnsClose::default_instance_->InitAsDefaultInstance();
  UReqPong::default_instance_->InitAsDefaultInstance();
  UAnsPing::default_instance_->InitAsDefaultInstance();
  UReqPlug::default_instance_->InitAsDefaultInstance();
  UAnsPlug::default_instance_->InitAsDefaultInstance();
  UReqProtocol::default_instance_->InitAsDefaultInstance();
  UAnsProtocol::default_instance_->InitAsDefaultInstance();
  MemberInfo::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_ug_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_ug_2eproto {
  StaticDescriptorInitializer_ug_2eproto() {
    protobuf_AddDesc_ug_2eproto();
  }
} static_descriptor_initializer_ug_2eproto_;


// ===================================================================

#ifndef _MSC_VER
const int Version::kMajorFieldNumber;
const int Version::kProtocolFieldNumber;
const int Version::kFrameworkFieldNumber;
const int Version::kServiceFieldNumber;
#endif  // !_MSC_VER

Version::Version()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Version::InitAsDefaultInstance() {
}

Version::Version(const Version& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Version::SharedCtor() {
  _cached_size_ = 0;
  major_ = 1;
  protocol_ = 1204010;
  framework_ = 0;
  service_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Version::~Version() {
  SharedDtor();
}

void Version::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Version::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Version::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Version_descriptor_;
}

const Version& Version::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

Version* Version::default_instance_ = NULL;

Version* Version::New() const {
  return new Version;
}

void Version::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    major_ = 1;
    protocol_ = 1204010;
    framework_ = 0;
    service_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Version::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 major = 1 [default = 1];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &major_)));
          set_has_major();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_protocol;
        break;
      }
      
      // optional int32 protocol = 2 [default = 1204010];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_protocol:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &protocol_)));
          set_has_protocol();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_framework;
        break;
      }
      
      // required int32 framework = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_framework:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &framework_)));
          set_has_framework();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_service;
        break;
      }
      
      // required int32 service = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_service:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &service_)));
          set_has_service();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Version::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 major = 1 [default = 1];
  if (has_major()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->major(), output);
  }
  
  // optional int32 protocol = 2 [default = 1204010];
  if (has_protocol()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->protocol(), output);
  }
  
  // required int32 framework = 3;
  if (has_framework()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->framework(), output);
  }
  
  // required int32 service = 4;
  if (has_service()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->service(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Version::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 major = 1 [default = 1];
  if (has_major()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->major(), target);
  }
  
  // optional int32 protocol = 2 [default = 1204010];
  if (has_protocol()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->protocol(), target);
  }
  
  // required int32 framework = 3;
  if (has_framework()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->framework(), target);
  }
  
  // required int32 service = 4;
  if (has_service()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->service(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Version::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 major = 1 [default = 1];
    if (has_major()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->major());
    }
    
    // optional int32 protocol = 2 [default = 1204010];
    if (has_protocol()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->protocol());
    }
    
    // required int32 framework = 3;
    if (has_framework()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->framework());
    }
    
    // required int32 service = 4;
    if (has_service()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->service());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Version::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Version* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Version*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Version::MergeFrom(const Version& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_major()) {
      set_major(from.major());
    }
    if (from.has_protocol()) {
      set_protocol(from.protocol());
    }
    if (from.has_framework()) {
      set_framework(from.framework());
    }
    if (from.has_service()) {
      set_service(from.service());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Version::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Version::CopyFrom(const Version& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Version::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000c) != 0x0000000c) return false;
  
  return true;
}

void Version::Swap(Version* other) {
  if (other != this) {
    std::swap(major_, other->major_);
    std::swap(protocol_, other->protocol_);
    std::swap(framework_, other->framework_);
    std::swap(service_, other->service_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Version::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Version_descriptor_;
  metadata.reflection = Version_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Error::kErrorCodeFieldNumber;
const int Error::kErrorInfoFieldNumber;
const int Error::kReqModeFieldNumber;
#endif  // !_MSC_VER

Error::Error()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Error::InitAsDefaultInstance() {
}

Error::Error(const Error& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Error::SharedCtor() {
  _cached_size_ = 0;
  errorcode_ = 0;
  errorinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  reqmode_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Error::~Error() {
  SharedDtor();
}

void Error::SharedDtor() {
  if (errorinfo_ != &::google::protobuf::internal::kEmptyString) {
    delete errorinfo_;
  }
  if (this != default_instance_) {
  }
}

void Error::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Error::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Error_descriptor_;
}

const Error& Error::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

Error* Error::default_instance_ = NULL;

Error* Error::New() const {
  return new Error;
}

void Error::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    errorcode_ = 0;
    if (has_errorinfo()) {
      if (errorinfo_ != &::google::protobuf::internal::kEmptyString) {
        errorinfo_->clear();
      }
    }
    reqmode_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Error::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 errorCode = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &errorcode_)));
          set_has_errorcode();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_errorInfo;
        break;
      }
      
      // required string errorInfo = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_errorInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_errorinfo()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->errorinfo().data(), this->errorinfo().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_reqMode;
        break;
      }
      
      // required int32 reqMode = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_reqMode:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &reqmode_)));
          set_has_reqmode();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Error::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 errorCode = 1;
  if (has_errorcode()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->errorcode(), output);
  }
  
  // required string errorInfo = 2;
  if (has_errorinfo()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->errorinfo().data(), this->errorinfo().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->errorinfo(), output);
  }
  
  // required int32 reqMode = 3;
  if (has_reqmode()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->reqmode(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Error::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 errorCode = 1;
  if (has_errorcode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->errorcode(), target);
  }
  
  // required string errorInfo = 2;
  if (has_errorinfo()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->errorinfo().data(), this->errorinfo().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->errorinfo(), target);
  }
  
  // required int32 reqMode = 3;
  if (has_reqmode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->reqmode(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Error::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 errorCode = 1;
    if (has_errorcode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->errorcode());
    }
    
    // required string errorInfo = 2;
    if (has_errorinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->errorinfo());
    }
    
    // required int32 reqMode = 3;
    if (has_reqmode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->reqmode());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Error::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Error* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Error*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Error::MergeFrom(const Error& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_errorcode()) {
      set_errorcode(from.errorcode());
    }
    if (from.has_errorinfo()) {
      set_errorinfo(from.errorinfo());
    }
    if (from.has_reqmode()) {
      set_reqmode(from.reqmode());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Error::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Error::CopyFrom(const Error& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Error::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  return true;
}

void Error::Swap(Error* other) {
  if (other != this) {
    std::swap(errorcode_, other->errorcode_);
    std::swap(errorinfo_, other->errorinfo_);
    std::swap(reqmode_, other->reqmode_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Error::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Error_descriptor_;
  metadata.reflection = Error_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Desc::kIdFieldNumber;
const int Desc::kDescFieldNumber;
#endif  // !_MSC_VER

Desc::Desc()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Desc::InitAsDefaultInstance() {
}

Desc::Desc(const Desc& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Desc::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Desc::~Desc() {
  SharedDtor();
}

void Desc::SharedDtor() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    delete desc_;
  }
  if (this != default_instance_) {
  }
}

void Desc::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Desc::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Desc_descriptor_;
}

const Desc& Desc::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

Desc* Desc::default_instance_ = NULL;

Desc* Desc::New() const {
  return new Desc;
}

void Desc::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
    if (has_desc()) {
      if (desc_ != &::google::protobuf::internal::kEmptyString) {
        desc_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Desc::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_desc;
        break;
      }
      
      // required string desc = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_desc:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_desc()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->desc().data(), this->desc().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Desc::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }
  
  // required string desc = 2;
  if (has_desc()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->desc().data(), this->desc().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->desc(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Desc::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->id(), target);
  }
  
  // required string desc = 2;
  if (has_desc()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->desc().data(), this->desc().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->desc(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Desc::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }
    
    // required string desc = 2;
    if (has_desc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->desc());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Desc::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Desc* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Desc*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Desc::MergeFrom(const Desc& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_desc()) {
      set_desc(from.desc());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Desc::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Desc::CopyFrom(const Desc& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Desc::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void Desc::Swap(Desc* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(desc_, other->desc_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Desc::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Desc_descriptor_;
  metadata.reflection = Desc_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Notice::kPopupFieldNumber;
const int Notice::kSrlFieldNumber;
const int Notice::kNoticeFieldNumber;
#endif  // !_MSC_VER

Notice::Notice()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Notice::InitAsDefaultInstance() {
}

Notice::Notice(const Notice& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Notice::SharedCtor() {
  _cached_size_ = 0;
  popup_ = false;
  srl_ = 0;
  notice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Notice::~Notice() {
  SharedDtor();
}

void Notice::SharedDtor() {
  if (notice_ != &::google::protobuf::internal::kEmptyString) {
    delete notice_;
  }
  if (this != default_instance_) {
  }
}

void Notice::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Notice::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Notice_descriptor_;
}

const Notice& Notice::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

Notice* Notice::default_instance_ = NULL;

Notice* Notice::New() const {
  return new Notice;
}

void Notice::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    popup_ = false;
    srl_ = 0;
    if (has_notice()) {
      if (notice_ != &::google::protobuf::internal::kEmptyString) {
        notice_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Notice::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool popup = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &popup_)));
          set_has_popup();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_srl;
        break;
      }
      
      // required int32 srl = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_srl:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &srl_)));
          set_has_srl();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_notice;
        break;
      }
      
      // required string notice = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_notice:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_notice()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->notice().data(), this->notice().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Notice::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bool popup = 1;
  if (has_popup()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->popup(), output);
  }
  
  // required int32 srl = 2;
  if (has_srl()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->srl(), output);
  }
  
  // required string notice = 3;
  if (has_notice()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->notice().data(), this->notice().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->notice(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Notice::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bool popup = 1;
  if (has_popup()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->popup(), target);
  }
  
  // required int32 srl = 2;
  if (has_srl()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->srl(), target);
  }
  
  // required string notice = 3;
  if (has_notice()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->notice().data(), this->notice().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->notice(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Notice::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool popup = 1;
    if (has_popup()) {
      total_size += 1 + 1;
    }
    
    // required int32 srl = 2;
    if (has_srl()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->srl());
    }
    
    // required string notice = 3;
    if (has_notice()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->notice());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Notice::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Notice* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Notice*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Notice::MergeFrom(const Notice& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_popup()) {
      set_popup(from.popup());
    }
    if (from.has_srl()) {
      set_srl(from.srl());
    }
    if (from.has_notice()) {
      set_notice(from.notice());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Notice::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Notice::CopyFrom(const Notice& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Notice::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  return true;
}

void Notice::Swap(Notice* other) {
  if (other != this) {
    std::swap(popup_, other->popup_);
    std::swap(srl_, other->srl_);
    std::swap(notice_, other->notice_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Notice::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Notice_descriptor_;
  metadata.reflection = Notice_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* UError_EErrorType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UError_EErrorType_descriptor_;
}
bool UError_EErrorType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const UError_EErrorType UError::EET_VERSION_INCORRECT;
const UError_EErrorType UError::EET_DATABASE;
const UError_EErrorType UError::EET_INTERNAL;
const UError_EErrorType UError::EET_ALREADY_LOGGED;
const UError_EErrorType UError::EET_NOT_LOGGED;
const UError_EErrorType UError::EET_ALREADY_PLAYING;
const UError_EErrorType UError::EET_NOT_PLAYING;
const UError_EErrorType UError::EET_CANT_PLUG_GS;
const UError_EErrorType UError::EET_INVALID_VALUE;
const UError_EErrorType UError::EET_TIME_OUT;
const UError_EErrorType UError::EET_UNDEFINE;
const UError_EErrorType UError::EET_MAX_REFILL;
const UError_EErrorType UError::EET_OVER_USER;
const UError_EErrorType UError::EET_PLUG;
const UError_EErrorType UError::EET_BUSY;
const UError_EErrorType UError::EErrorType_MIN;
const UError_EErrorType UError::EErrorType_MAX;
const int UError::EErrorType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int UError::kErrorFieldNumber;
const int UError::kOverFieldNumber;
#endif  // !_MSC_VER

UError::UError()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UError::InitAsDefaultInstance() {
  error_ = const_cast< ::Error*>(&::Error::default_instance());
}

UError::UError(const UError& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UError::SharedCtor() {
  _cached_size_ = 0;
  error_ = NULL;
  over_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UError::~UError() {
  SharedDtor();
}

void UError::SharedDtor() {
  if (this != default_instance_) {
    delete error_;
  }
}

void UError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UError::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UError_descriptor_;
}

const UError& UError::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

UError* UError::default_instance_ = NULL;

UError* UError::New() const {
  return new UError;
}

void UError::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_error()) {
      if (error_ != NULL) error_->::Error::Clear();
    }
    over_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Error error = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_error()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_over;
        break;
      }
      
      // optional bool over = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_over:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &over_)));
          set_has_over();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .Error error = 1;
  if (has_error()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->error(), output);
  }
  
  // optional bool over = 2;
  if (has_over()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->over(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UError::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .Error error = 1;
  if (has_error()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->error(), target);
  }
  
  // optional bool over = 2;
  if (has_over()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->over(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UError::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .Error error = 1;
    if (has_error()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->error());
    }
    
    // optional bool over = 2;
    if (has_over()) {
      total_size += 1 + 1;
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UError::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UError* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UError*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UError::MergeFrom(const UError& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_error()) {
      mutable_error()->::Error::MergeFrom(from.error());
    }
    if (from.has_over()) {
      set_over(from.over());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UError::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UError::CopyFrom(const UError& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UError::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_error()) {
    if (!this->error().IsInitialized()) return false;
  }
  return true;
}

void UError::Swap(UError* other) {
  if (other != this) {
    std::swap(error_, other->error_);
    std::swap(over_, other->over_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UError::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UError_descriptor_;
  metadata.reflection = UError_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int UReqConnect::kSvcIDFieldNumber;
const int UReqConnect::kGameIDFieldNumber;
const int UReqConnect::kLastCloseTimeFieldNumber;
const int UReqConnect::kVersionFieldNumber;
const int UReqConnect::kMemberInfoFieldNumber;
#endif  // !_MSC_VER

UReqConnect::UReqConnect()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UReqConnect::InitAsDefaultInstance() {
  version_ = const_cast< ::Version*>(&::Version::default_instance());
  memberinfo_ = const_cast< ::MemberInfo*>(&::MemberInfo::default_instance());
}

UReqConnect::UReqConnect(const UReqConnect& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UReqConnect::SharedCtor() {
  _cached_size_ = 0;
  svcid_ = 0;
  gameid_ = GOOGLE_LONGLONG(0);
  lastclosetime_ = 0;
  version_ = NULL;
  memberinfo_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UReqConnect::~UReqConnect() {
  SharedDtor();
}

void UReqConnect::SharedDtor() {
  if (this != default_instance_) {
    delete version_;
    delete memberinfo_;
  }
}

void UReqConnect::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UReqConnect::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UReqConnect_descriptor_;
}

const UReqConnect& UReqConnect::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

UReqConnect* UReqConnect::default_instance_ = NULL;

UReqConnect* UReqConnect::New() const {
  return new UReqConnect;
}

void UReqConnect::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    svcid_ = 0;
    gameid_ = GOOGLE_LONGLONG(0);
    lastclosetime_ = 0;
    if (has_version()) {
      if (version_ != NULL) version_->::Version::Clear();
    }
    if (has_memberinfo()) {
      if (memberinfo_ != NULL) memberinfo_->::MemberInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UReqConnect::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 svcID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &svcid_)));
          set_has_svcid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_gameID;
        break;
      }
      
      // required int64 gameID = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_gameID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &gameid_)));
          set_has_gameid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_lastCloseTime;
        break;
      }
      
      // required int32 lastCloseTime = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_lastCloseTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lastclosetime_)));
          set_has_lastclosetime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_version;
        break;
      }
      
      // required .Version version = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_version()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_memberInfo;
        break;
      }
      
      // required .MemberInfo memberInfo = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_memberInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_memberinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UReqConnect::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 svcID = 1;
  if (has_svcid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->svcid(), output);
  }
  
  // required int64 gameID = 2;
  if (has_gameid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->gameid(), output);
  }
  
  // required int32 lastCloseTime = 3;
  if (has_lastclosetime()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->lastclosetime(), output);
  }
  
  // required .Version version = 4;
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->version(), output);
  }
  
  // required .MemberInfo memberInfo = 5;
  if (has_memberinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->memberinfo(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UReqConnect::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 svcID = 1;
  if (has_svcid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->svcid(), target);
  }
  
  // required int64 gameID = 2;
  if (has_gameid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->gameid(), target);
  }
  
  // required int32 lastCloseTime = 3;
  if (has_lastclosetime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->lastclosetime(), target);
  }
  
  // required .Version version = 4;
  if (has_version()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->version(), target);
  }
  
  // required .MemberInfo memberInfo = 5;
  if (has_memberinfo()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->memberinfo(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UReqConnect::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 svcID = 1;
    if (has_svcid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->svcid());
    }
    
    // required int64 gameID = 2;
    if (has_gameid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->gameid());
    }
    
    // required int32 lastCloseTime = 3;
    if (has_lastclosetime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lastclosetime());
    }
    
    // required .Version version = 4;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->version());
    }
    
    // required .MemberInfo memberInfo = 5;
    if (has_memberinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->memberinfo());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UReqConnect::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UReqConnect* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UReqConnect*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UReqConnect::MergeFrom(const UReqConnect& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_svcid()) {
      set_svcid(from.svcid());
    }
    if (from.has_gameid()) {
      set_gameid(from.gameid());
    }
    if (from.has_lastclosetime()) {
      set_lastclosetime(from.lastclosetime());
    }
    if (from.has_version()) {
      mutable_version()->::Version::MergeFrom(from.version());
    }
    if (from.has_memberinfo()) {
      mutable_memberinfo()->::MemberInfo::MergeFrom(from.memberinfo());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UReqConnect::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UReqConnect::CopyFrom(const UReqConnect& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UReqConnect::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;
  
  if (has_version()) {
    if (!this->version().IsInitialized()) return false;
  }
  if (has_memberinfo()) {
    if (!this->memberinfo().IsInitialized()) return false;
  }
  return true;
}

void UReqConnect::Swap(UReqConnect* other) {
  if (other != this) {
    std::swap(svcid_, other->svcid_);
    std::swap(gameid_, other->gameid_);
    std::swap(lastclosetime_, other->lastclosetime_);
    std::swap(version_, other->version_);
    std::swap(memberinfo_, other->memberinfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UReqConnect::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UReqConnect_descriptor_;
  metadata.reflection = UReqConnect_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int UAnsConnect::kSvcIDFieldNumber;
const int UAnsConnect::kGameIDFieldNumber;
const int UAnsConnect::kStatusFieldNumber;
const int UAnsConnect::kIpFieldNumber;
const int UAnsConnect::kPortFieldNumber;
const int UAnsConnect::kPasswdFieldNumber;
#endif  // !_MSC_VER

UAnsConnect::UAnsConnect()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UAnsConnect::InitAsDefaultInstance() {
}

UAnsConnect::UAnsConnect(const UAnsConnect& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UAnsConnect::SharedCtor() {
  _cached_size_ = 0;
  svcid_ = 0;
  gameid_ = GOOGLE_LONGLONG(0);
  status_ = 0;
  ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  port_ = 0;
  passwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UAnsConnect::~UAnsConnect() {
  SharedDtor();
}

void UAnsConnect::SharedDtor() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (passwd_ != &::google::protobuf::internal::kEmptyString) {
    delete passwd_;
  }
  if (this != default_instance_) {
  }
}

void UAnsConnect::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UAnsConnect::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UAnsConnect_descriptor_;
}

const UAnsConnect& UAnsConnect::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

UAnsConnect* UAnsConnect::default_instance_ = NULL;

UAnsConnect* UAnsConnect::New() const {
  return new UAnsConnect;
}

void UAnsConnect::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    svcid_ = 0;
    gameid_ = GOOGLE_LONGLONG(0);
    status_ = 0;
    if (has_ip()) {
      if (ip_ != &::google::protobuf::internal::kEmptyString) {
        ip_->clear();
      }
    }
    port_ = 0;
    if (has_passwd()) {
      if (passwd_ != &::google::protobuf::internal::kEmptyString) {
        passwd_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UAnsConnect::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 svcID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &svcid_)));
          set_has_svcid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_gameID;
        break;
      }
      
      // required int64 gameID = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_gameID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &gameid_)));
          set_has_gameid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_status;
        break;
      }
      
      // required int32 status = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &status_)));
          set_has_status();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_ip;
        break;
      }
      
      // required string ip = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ip:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ip()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->ip().data(), this->ip().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_port;
        break;
      }
      
      // required int32 port = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_passwd;
        break;
      }
      
      // required string passwd = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_passwd:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_passwd()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->passwd().data(), this->passwd().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UAnsConnect::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 svcID = 1;
  if (has_svcid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->svcid(), output);
  }
  
  // required int64 gameID = 2;
  if (has_gameid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->gameid(), output);
  }
  
  // required int32 status = 3;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->status(), output);
  }
  
  // required string ip = 4;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->ip().data(), this->ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->ip(), output);
  }
  
  // required int32 port = 5;
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->port(), output);
  }
  
  // required string passwd = 6;
  if (has_passwd()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->passwd().data(), this->passwd().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->passwd(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UAnsConnect::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 svcID = 1;
  if (has_svcid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->svcid(), target);
  }
  
  // required int64 gameID = 2;
  if (has_gameid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->gameid(), target);
  }
  
  // required int32 status = 3;
  if (has_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->status(), target);
  }
  
  // required string ip = 4;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->ip().data(), this->ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->ip(), target);
  }
  
  // required int32 port = 5;
  if (has_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->port(), target);
  }
  
  // required string passwd = 6;
  if (has_passwd()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->passwd().data(), this->passwd().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->passwd(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UAnsConnect::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 svcID = 1;
    if (has_svcid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->svcid());
    }
    
    // required int64 gameID = 2;
    if (has_gameid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->gameid());
    }
    
    // required int32 status = 3;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->status());
    }
    
    // required string ip = 4;
    if (has_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ip());
    }
    
    // required int32 port = 5;
    if (has_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->port());
    }
    
    // required string passwd = 6;
    if (has_passwd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->passwd());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UAnsConnect::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UAnsConnect* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UAnsConnect*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UAnsConnect::MergeFrom(const UAnsConnect& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_svcid()) {
      set_svcid(from.svcid());
    }
    if (from.has_gameid()) {
      set_gameid(from.gameid());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_ip()) {
      set_ip(from.ip());
    }
    if (from.has_port()) {
      set_port(from.port());
    }
    if (from.has_passwd()) {
      set_passwd(from.passwd());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UAnsConnect::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UAnsConnect::CopyFrom(const UAnsConnect& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UAnsConnect::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;
  
  return true;
}

void UAnsConnect::Swap(UAnsConnect* other) {
  if (other != this) {
    std::swap(svcid_, other->svcid_);
    std::swap(gameid_, other->gameid_);
    std::swap(status_, other->status_);
    std::swap(ip_, other->ip_);
    std::swap(port_, other->port_);
    std::swap(passwd_, other->passwd_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UAnsConnect::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UAnsConnect_descriptor_;
  metadata.reflection = UAnsConnect_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

UReqNotice::UReqNotice()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UReqNotice::InitAsDefaultInstance() {
}

UReqNotice::UReqNotice(const UReqNotice& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UReqNotice::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UReqNotice::~UReqNotice() {
  SharedDtor();
}

void UReqNotice::SharedDtor() {
  if (this != default_instance_) {
  }
}

void UReqNotice::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UReqNotice::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UReqNotice_descriptor_;
}

const UReqNotice& UReqNotice::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

UReqNotice* UReqNotice::default_instance_ = NULL;

UReqNotice* UReqNotice::New() const {
  return new UReqNotice;
}

void UReqNotice::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UReqNotice::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void UReqNotice::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UReqNotice::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UReqNotice::ByteSize() const {
  int total_size = 0;
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UReqNotice::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UReqNotice* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UReqNotice*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UReqNotice::MergeFrom(const UReqNotice& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UReqNotice::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UReqNotice::CopyFrom(const UReqNotice& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UReqNotice::IsInitialized() const {
  
  return true;
}

void UReqNotice::Swap(UReqNotice* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UReqNotice::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UReqNotice_descriptor_;
  metadata.reflection = UReqNotice_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int UAnsNotice::kNoticesFieldNumber;
#endif  // !_MSC_VER

UAnsNotice::UAnsNotice()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UAnsNotice::InitAsDefaultInstance() {
}

UAnsNotice::UAnsNotice(const UAnsNotice& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UAnsNotice::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UAnsNotice::~UAnsNotice() {
  SharedDtor();
}

void UAnsNotice::SharedDtor() {
  if (this != default_instance_) {
  }
}

void UAnsNotice::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UAnsNotice::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UAnsNotice_descriptor_;
}

const UAnsNotice& UAnsNotice::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

UAnsNotice* UAnsNotice::default_instance_ = NULL;

UAnsNotice* UAnsNotice::New() const {
  return new UAnsNotice;
}

void UAnsNotice::Clear() {
  notices_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UAnsNotice::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Notice notices = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_notices:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_notices()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_notices;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UAnsNotice::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .Notice notices = 1;
  for (int i = 0; i < this->notices_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->notices(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UAnsNotice::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .Notice notices = 1;
  for (int i = 0; i < this->notices_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->notices(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UAnsNotice::ByteSize() const {
  int total_size = 0;
  
  // repeated .Notice notices = 1;
  total_size += 1 * this->notices_size();
  for (int i = 0; i < this->notices_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->notices(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UAnsNotice::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UAnsNotice* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UAnsNotice*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UAnsNotice::MergeFrom(const UAnsNotice& from) {
  GOOGLE_CHECK_NE(&from, this);
  notices_.MergeFrom(from.notices_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UAnsNotice::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UAnsNotice::CopyFrom(const UAnsNotice& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UAnsNotice::IsInitialized() const {
  
  for (int i = 0; i < notices_size(); i++) {
    if (!this->notices(i).IsInitialized()) return false;
  }
  return true;
}

void UAnsNotice::Swap(UAnsNotice* other) {
  if (other != this) {
    notices_.Swap(&other->notices_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UAnsNotice::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UAnsNotice_descriptor_;
  metadata.reflection = UAnsNotice_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

UReqChannel::UReqChannel()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UReqChannel::InitAsDefaultInstance() {
}

UReqChannel::UReqChannel(const UReqChannel& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UReqChannel::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UReqChannel::~UReqChannel() {
  SharedDtor();
}

void UReqChannel::SharedDtor() {
  if (this != default_instance_) {
  }
}

void UReqChannel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UReqChannel::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UReqChannel_descriptor_;
}

const UReqChannel& UReqChannel::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

UReqChannel* UReqChannel::default_instance_ = NULL;

UReqChannel* UReqChannel::New() const {
  return new UReqChannel;
}

void UReqChannel::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UReqChannel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void UReqChannel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UReqChannel::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UReqChannel::ByteSize() const {
  int total_size = 0;
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UReqChannel::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UReqChannel* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UReqChannel*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UReqChannel::MergeFrom(const UReqChannel& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UReqChannel::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UReqChannel::CopyFrom(const UReqChannel& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UReqChannel::IsInitialized() const {
  
  return true;
}

void UReqChannel::Swap(UReqChannel* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UReqChannel::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UReqChannel_descriptor_;
  metadata.reflection = UReqChannel_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int UAnsChannel::kChannelInfoFieldNumber;
#endif  // !_MSC_VER

UAnsChannel::UAnsChannel()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UAnsChannel::InitAsDefaultInstance() {
}

UAnsChannel::UAnsChannel(const UAnsChannel& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UAnsChannel::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UAnsChannel::~UAnsChannel() {
  SharedDtor();
}

void UAnsChannel::SharedDtor() {
  if (this != default_instance_) {
  }
}

void UAnsChannel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UAnsChannel::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UAnsChannel_descriptor_;
}

const UAnsChannel& UAnsChannel::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

UAnsChannel* UAnsChannel::default_instance_ = NULL;

UAnsChannel* UAnsChannel::New() const {
  return new UAnsChannel;
}

void UAnsChannel::Clear() {
  channelinfo_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UAnsChannel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Desc channelInfo = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_channelInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_channelinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_channelInfo;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UAnsChannel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .Desc channelInfo = 1;
  for (int i = 0; i < this->channelinfo_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->channelinfo(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UAnsChannel::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .Desc channelInfo = 1;
  for (int i = 0; i < this->channelinfo_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->channelinfo(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UAnsChannel::ByteSize() const {
  int total_size = 0;
  
  // repeated .Desc channelInfo = 1;
  total_size += 1 * this->channelinfo_size();
  for (int i = 0; i < this->channelinfo_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->channelinfo(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UAnsChannel::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UAnsChannel* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UAnsChannel*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UAnsChannel::MergeFrom(const UAnsChannel& from) {
  GOOGLE_CHECK_NE(&from, this);
  channelinfo_.MergeFrom(from.channelinfo_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UAnsChannel::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UAnsChannel::CopyFrom(const UAnsChannel& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UAnsChannel::IsInitialized() const {
  
  for (int i = 0; i < channelinfo_size(); i++) {
    if (!this->channelinfo(i).IsInitialized()) return false;
  }
  return true;
}

void UAnsChannel::Swap(UAnsChannel* other) {
  if (other != this) {
    channelinfo_.Swap(&other->channelinfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UAnsChannel::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UAnsChannel_descriptor_;
  metadata.reflection = UAnsChannel_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int UErrChannel::kErrorFieldNumber;
#endif  // !_MSC_VER

UErrChannel::UErrChannel()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UErrChannel::InitAsDefaultInstance() {
  error_ = const_cast< ::Error*>(&::Error::default_instance());
}

UErrChannel::UErrChannel(const UErrChannel& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UErrChannel::SharedCtor() {
  _cached_size_ = 0;
  error_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UErrChannel::~UErrChannel() {
  SharedDtor();
}

void UErrChannel::SharedDtor() {
  if (this != default_instance_) {
    delete error_;
  }
}

void UErrChannel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UErrChannel::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UErrChannel_descriptor_;
}

const UErrChannel& UErrChannel::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

UErrChannel* UErrChannel::default_instance_ = NULL;

UErrChannel* UErrChannel::New() const {
  return new UErrChannel;
}

void UErrChannel::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_error()) {
      if (error_ != NULL) error_->::Error::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UErrChannel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Error error = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_error()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UErrChannel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .Error error = 1;
  if (has_error()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->error(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UErrChannel::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .Error error = 1;
  if (has_error()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->error(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UErrChannel::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .Error error = 1;
    if (has_error()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->error());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UErrChannel::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UErrChannel* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UErrChannel*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UErrChannel::MergeFrom(const UErrChannel& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_error()) {
      mutable_error()->::Error::MergeFrom(from.error());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UErrChannel::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UErrChannel::CopyFrom(const UErrChannel& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UErrChannel::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_error()) {
    if (!this->error().IsInitialized()) return false;
  }
  return true;
}

void UErrChannel::Swap(UErrChannel* other) {
  if (other != this) {
    std::swap(error_, other->error_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UErrChannel::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UErrChannel_descriptor_;
  metadata.reflection = UErrChannel_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

UReqStore::UReqStore()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UReqStore::InitAsDefaultInstance() {
}

UReqStore::UReqStore(const UReqStore& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UReqStore::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UReqStore::~UReqStore() {
  SharedDtor();
}

void UReqStore::SharedDtor() {
  if (this != default_instance_) {
  }
}

void UReqStore::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UReqStore::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UReqStore_descriptor_;
}

const UReqStore& UReqStore::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

UReqStore* UReqStore::default_instance_ = NULL;

UReqStore* UReqStore::New() const {
  return new UReqStore;
}

void UReqStore::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UReqStore::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void UReqStore::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UReqStore::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UReqStore::ByteSize() const {
  int total_size = 0;
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UReqStore::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UReqStore* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UReqStore*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UReqStore::MergeFrom(const UReqStore& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UReqStore::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UReqStore::CopyFrom(const UReqStore& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UReqStore::IsInitialized() const {
  
  return true;
}

void UReqStore::Swap(UReqStore* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UReqStore::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UReqStore_descriptor_;
  metadata.reflection = UReqStore_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int UAnsStore::kItemInfoFieldNumber;
#endif  // !_MSC_VER

UAnsStore::UAnsStore()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UAnsStore::InitAsDefaultInstance() {
}

UAnsStore::UAnsStore(const UAnsStore& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UAnsStore::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UAnsStore::~UAnsStore() {
  SharedDtor();
}

void UAnsStore::SharedDtor() {
  if (this != default_instance_) {
  }
}

void UAnsStore::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UAnsStore::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UAnsStore_descriptor_;
}

const UAnsStore& UAnsStore::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

UAnsStore* UAnsStore::default_instance_ = NULL;

UAnsStore* UAnsStore::New() const {
  return new UAnsStore;
}

void UAnsStore::Clear() {
  iteminfo_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UAnsStore::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Desc itemInfo = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_itemInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_iteminfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_itemInfo;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UAnsStore::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .Desc itemInfo = 1;
  for (int i = 0; i < this->iteminfo_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->iteminfo(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UAnsStore::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .Desc itemInfo = 1;
  for (int i = 0; i < this->iteminfo_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->iteminfo(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UAnsStore::ByteSize() const {
  int total_size = 0;
  
  // repeated .Desc itemInfo = 1;
  total_size += 1 * this->iteminfo_size();
  for (int i = 0; i < this->iteminfo_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->iteminfo(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UAnsStore::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UAnsStore* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UAnsStore*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UAnsStore::MergeFrom(const UAnsStore& from) {
  GOOGLE_CHECK_NE(&from, this);
  iteminfo_.MergeFrom(from.iteminfo_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UAnsStore::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UAnsStore::CopyFrom(const UAnsStore& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UAnsStore::IsInitialized() const {
  
  for (int i = 0; i < iteminfo_size(); i++) {
    if (!this->iteminfo(i).IsInitialized()) return false;
  }
  return true;
}

void UAnsStore::Swap(UAnsStore* other) {
  if (other != this) {
    iteminfo_.Swap(&other->iteminfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UAnsStore::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UAnsStore_descriptor_;
  metadata.reflection = UAnsStore_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

UReqInfo::UReqInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UReqInfo::InitAsDefaultInstance() {
}

UReqInfo::UReqInfo(const UReqInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UReqInfo::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UReqInfo::~UReqInfo() {
  SharedDtor();
}

void UReqInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void UReqInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UReqInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UReqInfo_descriptor_;
}

const UReqInfo& UReqInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

UReqInfo* UReqInfo::default_instance_ = NULL;

UReqInfo* UReqInfo::New() const {
  return new UReqInfo;
}

void UReqInfo::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UReqInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void UReqInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UReqInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UReqInfo::ByteSize() const {
  int total_size = 0;
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UReqInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UReqInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UReqInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UReqInfo::MergeFrom(const UReqInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UReqInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UReqInfo::CopyFrom(const UReqInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UReqInfo::IsInitialized() const {
  
  return true;
}

void UReqInfo::Swap(UReqInfo* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UReqInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UReqInfo_descriptor_;
  metadata.reflection = UReqInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int UAnsInfo::kGameInfoFieldNumber;
#endif  // !_MSC_VER

UAnsInfo::UAnsInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UAnsInfo::InitAsDefaultInstance() {
}

UAnsInfo::UAnsInfo(const UAnsInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UAnsInfo::SharedCtor() {
  _cached_size_ = 0;
  gameinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UAnsInfo::~UAnsInfo() {
  SharedDtor();
}

void UAnsInfo::SharedDtor() {
  if (gameinfo_ != &::google::protobuf::internal::kEmptyString) {
    delete gameinfo_;
  }
  if (this != default_instance_) {
  }
}

void UAnsInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UAnsInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UAnsInfo_descriptor_;
}

const UAnsInfo& UAnsInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

UAnsInfo* UAnsInfo::default_instance_ = NULL;

UAnsInfo* UAnsInfo::New() const {
  return new UAnsInfo;
}

void UAnsInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_gameinfo()) {
      if (gameinfo_ != &::google::protobuf::internal::kEmptyString) {
        gameinfo_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UAnsInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes gameInfo = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_gameinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UAnsInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes gameInfo = 1;
  if (has_gameinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->gameinfo(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UAnsInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bytes gameInfo = 1;
  if (has_gameinfo()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->gameinfo(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UAnsInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes gameInfo = 1;
    if (has_gameinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->gameinfo());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UAnsInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UAnsInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UAnsInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UAnsInfo::MergeFrom(const UAnsInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_gameinfo()) {
      set_gameinfo(from.gameinfo());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UAnsInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UAnsInfo::CopyFrom(const UAnsInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UAnsInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void UAnsInfo::Swap(UAnsInfo* other) {
  if (other != this) {
    std::swap(gameinfo_, other->gameinfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UAnsInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UAnsInfo_descriptor_;
  metadata.reflection = UAnsInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int UReqAutoJoin::kCategoryIDFieldNumber;
const int UReqAutoJoin::kChannelIDFieldNumber;
#endif  // !_MSC_VER

UReqAutoJoin::UReqAutoJoin()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UReqAutoJoin::InitAsDefaultInstance() {
}

UReqAutoJoin::UReqAutoJoin(const UReqAutoJoin& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UReqAutoJoin::SharedCtor() {
  _cached_size_ = 0;
  categoryid_ = 0;
  channelid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UReqAutoJoin::~UReqAutoJoin() {
  SharedDtor();
}

void UReqAutoJoin::SharedDtor() {
  if (this != default_instance_) {
  }
}

void UReqAutoJoin::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UReqAutoJoin::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UReqAutoJoin_descriptor_;
}

const UReqAutoJoin& UReqAutoJoin::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

UReqAutoJoin* UReqAutoJoin::default_instance_ = NULL;

UReqAutoJoin* UReqAutoJoin::New() const {
  return new UReqAutoJoin;
}

void UReqAutoJoin::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    categoryid_ = 0;
    channelid_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UReqAutoJoin::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 categoryID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &categoryid_)));
          set_has_categoryid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_channelID;
        break;
      }
      
      // required int32 channelID = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_channelID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &channelid_)));
          set_has_channelid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UReqAutoJoin::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 categoryID = 1;
  if (has_categoryid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->categoryid(), output);
  }
  
  // required int32 channelID = 2;
  if (has_channelid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->channelid(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UReqAutoJoin::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 categoryID = 1;
  if (has_categoryid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->categoryid(), target);
  }
  
  // required int32 channelID = 2;
  if (has_channelid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->channelid(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UReqAutoJoin::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 categoryID = 1;
    if (has_categoryid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->categoryid());
    }
    
    // required int32 channelID = 2;
    if (has_channelid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->channelid());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UReqAutoJoin::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UReqAutoJoin* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UReqAutoJoin*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UReqAutoJoin::MergeFrom(const UReqAutoJoin& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_categoryid()) {
      set_categoryid(from.categoryid());
    }
    if (from.has_channelid()) {
      set_channelid(from.channelid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UReqAutoJoin::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UReqAutoJoin::CopyFrom(const UReqAutoJoin& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UReqAutoJoin::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void UReqAutoJoin::Swap(UReqAutoJoin* other) {
  if (other != this) {
    std::swap(categoryid_, other->categoryid_);
    std::swap(channelid_, other->channelid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UReqAutoJoin::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UReqAutoJoin_descriptor_;
  metadata.reflection = UReqAutoJoin_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int UAnsAutoJoin::kGameRoomInfoFieldNumber;
#endif  // !_MSC_VER

UAnsAutoJoin::UAnsAutoJoin()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UAnsAutoJoin::InitAsDefaultInstance() {
}

UAnsAutoJoin::UAnsAutoJoin(const UAnsAutoJoin& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UAnsAutoJoin::SharedCtor() {
  _cached_size_ = 0;
  gameroominfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UAnsAutoJoin::~UAnsAutoJoin() {
  SharedDtor();
}

void UAnsAutoJoin::SharedDtor() {
  if (gameroominfo_ != &::google::protobuf::internal::kEmptyString) {
    delete gameroominfo_;
  }
  if (this != default_instance_) {
  }
}

void UAnsAutoJoin::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UAnsAutoJoin::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UAnsAutoJoin_descriptor_;
}

const UAnsAutoJoin& UAnsAutoJoin::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

UAnsAutoJoin* UAnsAutoJoin::default_instance_ = NULL;

UAnsAutoJoin* UAnsAutoJoin::New() const {
  return new UAnsAutoJoin;
}

void UAnsAutoJoin::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_gameroominfo()) {
      if (gameroominfo_ != &::google::protobuf::internal::kEmptyString) {
        gameroominfo_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UAnsAutoJoin::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes gameRoomInfo = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_gameroominfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UAnsAutoJoin::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes gameRoomInfo = 1;
  if (has_gameroominfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->gameroominfo(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UAnsAutoJoin::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bytes gameRoomInfo = 1;
  if (has_gameroominfo()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->gameroominfo(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UAnsAutoJoin::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes gameRoomInfo = 1;
    if (has_gameroominfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->gameroominfo());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UAnsAutoJoin::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UAnsAutoJoin* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UAnsAutoJoin*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UAnsAutoJoin::MergeFrom(const UAnsAutoJoin& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_gameroominfo()) {
      set_gameroominfo(from.gameroominfo());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UAnsAutoJoin::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UAnsAutoJoin::CopyFrom(const UAnsAutoJoin& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UAnsAutoJoin::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void UAnsAutoJoin::Swap(UAnsAutoJoin* other) {
  if (other != this) {
    std::swap(gameroominfo_, other->gameroominfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UAnsAutoJoin::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UAnsAutoJoin_descriptor_;
  metadata.reflection = UAnsAutoJoin_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int UReqLeaveGame::kGameIDFieldNumber;
const int UReqLeaveGame::kKickFieldNumber;
const int UReqLeaveGame::kLeaveInfoFieldNumber;
#endif  // !_MSC_VER

UReqLeaveGame::UReqLeaveGame()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UReqLeaveGame::InitAsDefaultInstance() {
}

UReqLeaveGame::UReqLeaveGame(const UReqLeaveGame& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UReqLeaveGame::SharedCtor() {
  _cached_size_ = 0;
  gameid_ = GOOGLE_LONGLONG(0);
  kick_ = false;
  leave_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UReqLeaveGame::~UReqLeaveGame() {
  SharedDtor();
}

void UReqLeaveGame::SharedDtor() {
  if (leave_info_ != &::google::protobuf::internal::kEmptyString) {
    delete leave_info_;
  }
  if (this != default_instance_) {
  }
}

void UReqLeaveGame::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UReqLeaveGame::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UReqLeaveGame_descriptor_;
}

const UReqLeaveGame& UReqLeaveGame::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

UReqLeaveGame* UReqLeaveGame::default_instance_ = NULL;

UReqLeaveGame* UReqLeaveGame::New() const {
  return new UReqLeaveGame;
}

void UReqLeaveGame::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    gameid_ = GOOGLE_LONGLONG(0);
    kick_ = false;
    if (has_leave_info()) {
      if (leave_info_ != &::google::protobuf::internal::kEmptyString) {
        leave_info_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UReqLeaveGame::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 gameID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &gameid_)));
          set_has_gameid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_kick;
        break;
      }
      
      // required bool kick = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_kick:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &kick_)));
          set_has_kick();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_leave_info;
        break;
      }
      
      // optional bytes leave_info = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_leave_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_leave_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UReqLeaveGame::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 gameID = 1;
  if (has_gameid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->gameid(), output);
  }
  
  // required bool kick = 2;
  if (has_kick()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->kick(), output);
  }
  
  // optional bytes leave_info = 3;
  if (has_leave_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->leave_info(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UReqLeaveGame::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int64 gameID = 1;
  if (has_gameid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->gameid(), target);
  }
  
  // required bool kick = 2;
  if (has_kick()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->kick(), target);
  }
  
  // optional bytes leave_info = 3;
  if (has_leave_info()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->leave_info(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UReqLeaveGame::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 gameID = 1;
    if (has_gameid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->gameid());
    }
    
    // required bool kick = 2;
    if (has_kick()) {
      total_size += 1 + 1;
    }
    
    // optional bytes leave_info = 3;
    if (has_leave_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->leave_info());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UReqLeaveGame::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UReqLeaveGame* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UReqLeaveGame*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UReqLeaveGame::MergeFrom(const UReqLeaveGame& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_gameid()) {
      set_gameid(from.gameid());
    }
    if (from.has_kick()) {
      set_kick(from.kick());
    }
    if (from.has_leave_info()) {
      set_leave_info(from.leave_info());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UReqLeaveGame::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UReqLeaveGame::CopyFrom(const UReqLeaveGame& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UReqLeaveGame::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void UReqLeaveGame::Swap(UReqLeaveGame* other) {
  if (other != this) {
    std::swap(gameid_, other->gameid_);
    std::swap(kick_, other->kick_);
    std::swap(leave_info_, other->leave_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UReqLeaveGame::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UReqLeaveGame_descriptor_;
  metadata.reflection = UReqLeaveGame_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* UAnsLeaveGame_KICK_TYPE_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UAnsLeaveGame_KICK_TYPE_descriptor_;
}
bool UAnsLeaveGame_KICK_TYPE_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const UAnsLeaveGame_KICK_TYPE UAnsLeaveGame::EXIT_RESERVATION;
const UAnsLeaveGame_KICK_TYPE UAnsLeaveGame::LIMITMONEY;
const UAnsLeaveGame_KICK_TYPE UAnsLeaveGame::ALLIN;
const UAnsLeaveGame_KICK_TYPE UAnsLeaveGame::SYSTEM_ERROR;
const UAnsLeaveGame_KICK_TYPE UAnsLeaveGame::KICK_ZERO;
const UAnsLeaveGame_KICK_TYPE UAnsLeaveGame::PURGE;
const UAnsLeaveGame_KICK_TYPE UAnsLeaveGame::KILL;
const UAnsLeaveGame_KICK_TYPE UAnsLeaveGame::KICK_TYPE_MIN;
const UAnsLeaveGame_KICK_TYPE UAnsLeaveGame::KICK_TYPE_MAX;
const int UAnsLeaveGame::KICK_TYPE_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int UAnsLeaveGame::kGameIDFieldNumber;
const int UAnsLeaveGame::kNTypeFieldNumber;
const int UAnsLeaveGame::kLeaveInfoFieldNumber;
#endif  // !_MSC_VER

UAnsLeaveGame::UAnsLeaveGame()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UAnsLeaveGame::InitAsDefaultInstance() {
}

UAnsLeaveGame::UAnsLeaveGame(const UAnsLeaveGame& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UAnsLeaveGame::SharedCtor() {
  _cached_size_ = 0;
  gameid_ = GOOGLE_LONGLONG(0);
  ntype_ = 1;
  leave_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UAnsLeaveGame::~UAnsLeaveGame() {
  SharedDtor();
}

void UAnsLeaveGame::SharedDtor() {
  if (leave_info_ != &::google::protobuf::internal::kEmptyString) {
    delete leave_info_;
  }
  if (this != default_instance_) {
  }
}

void UAnsLeaveGame::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UAnsLeaveGame::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UAnsLeaveGame_descriptor_;
}

const UAnsLeaveGame& UAnsLeaveGame::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

UAnsLeaveGame* UAnsLeaveGame::default_instance_ = NULL;

UAnsLeaveGame* UAnsLeaveGame::New() const {
  return new UAnsLeaveGame;
}

void UAnsLeaveGame::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    gameid_ = GOOGLE_LONGLONG(0);
    ntype_ = 1;
    if (has_leave_info()) {
      if (leave_info_ != &::google::protobuf::internal::kEmptyString) {
        leave_info_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UAnsLeaveGame::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 gameID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &gameid_)));
          set_has_gameid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_nType;
        break;
      }
      
      // required .UAnsLeaveGame.KICK_TYPE nType = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_nType:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::UAnsLeaveGame_KICK_TYPE_IsValid(value)) {
            set_ntype(static_cast< ::UAnsLeaveGame_KICK_TYPE >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_leave_info;
        break;
      }
      
      // optional bytes leave_info = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_leave_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_leave_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UAnsLeaveGame::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 gameID = 1;
  if (has_gameid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->gameid(), output);
  }
  
  // required .UAnsLeaveGame.KICK_TYPE nType = 2;
  if (has_ntype()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->ntype(), output);
  }
  
  // optional bytes leave_info = 3;
  if (has_leave_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->leave_info(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UAnsLeaveGame::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int64 gameID = 1;
  if (has_gameid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->gameid(), target);
  }
  
  // required .UAnsLeaveGame.KICK_TYPE nType = 2;
  if (has_ntype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->ntype(), target);
  }
  
  // optional bytes leave_info = 3;
  if (has_leave_info()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->leave_info(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UAnsLeaveGame::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 gameID = 1;
    if (has_gameid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->gameid());
    }
    
    // required .UAnsLeaveGame.KICK_TYPE nType = 2;
    if (has_ntype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->ntype());
    }
    
    // optional bytes leave_info = 3;
    if (has_leave_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->leave_info());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UAnsLeaveGame::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UAnsLeaveGame* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UAnsLeaveGame*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UAnsLeaveGame::MergeFrom(const UAnsLeaveGame& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_gameid()) {
      set_gameid(from.gameid());
    }
    if (from.has_ntype()) {
      set_ntype(from.ntype());
    }
    if (from.has_leave_info()) {
      set_leave_info(from.leave_info());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UAnsLeaveGame::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UAnsLeaveGame::CopyFrom(const UAnsLeaveGame& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UAnsLeaveGame::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void UAnsLeaveGame::Swap(UAnsLeaveGame* other) {
  if (other != this) {
    std::swap(gameid_, other->gameid_);
    std::swap(ntype_, other->ntype_);
    std::swap(leave_info_, other->leave_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UAnsLeaveGame::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UAnsLeaveGame_descriptor_;
  metadata.reflection = UAnsLeaveGame_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

UReqClose::UReqClose()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UReqClose::InitAsDefaultInstance() {
}

UReqClose::UReqClose(const UReqClose& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UReqClose::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UReqClose::~UReqClose() {
  SharedDtor();
}

void UReqClose::SharedDtor() {
  if (this != default_instance_) {
  }
}

void UReqClose::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UReqClose::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UReqClose_descriptor_;
}

const UReqClose& UReqClose::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

UReqClose* UReqClose::default_instance_ = NULL;

UReqClose* UReqClose::New() const {
  return new UReqClose;
}

void UReqClose::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UReqClose::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void UReqClose::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UReqClose::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UReqClose::ByteSize() const {
  int total_size = 0;
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UReqClose::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UReqClose* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UReqClose*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UReqClose::MergeFrom(const UReqClose& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UReqClose::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UReqClose::CopyFrom(const UReqClose& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UReqClose::IsInitialized() const {
  
  return true;
}

void UReqClose::Swap(UReqClose* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UReqClose::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UReqClose_descriptor_;
  metadata.reflection = UReqClose_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

UAnsClose::UAnsClose()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UAnsClose::InitAsDefaultInstance() {
}

UAnsClose::UAnsClose(const UAnsClose& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UAnsClose::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UAnsClose::~UAnsClose() {
  SharedDtor();
}

void UAnsClose::SharedDtor() {
  if (this != default_instance_) {
  }
}

void UAnsClose::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UAnsClose::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UAnsClose_descriptor_;
}

const UAnsClose& UAnsClose::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

UAnsClose* UAnsClose::default_instance_ = NULL;

UAnsClose* UAnsClose::New() const {
  return new UAnsClose;
}

void UAnsClose::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UAnsClose::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void UAnsClose::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UAnsClose::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UAnsClose::ByteSize() const {
  int total_size = 0;
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UAnsClose::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UAnsClose* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UAnsClose*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UAnsClose::MergeFrom(const UAnsClose& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UAnsClose::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UAnsClose::CopyFrom(const UAnsClose& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UAnsClose::IsInitialized() const {
  
  return true;
}

void UAnsClose::Swap(UAnsClose* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UAnsClose::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UAnsClose_descriptor_;
  metadata.reflection = UAnsClose_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int UReqPong::kSeqFieldNumber;
#endif  // !_MSC_VER

UReqPong::UReqPong()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UReqPong::InitAsDefaultInstance() {
}

UReqPong::UReqPong(const UReqPong& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UReqPong::SharedCtor() {
  _cached_size_ = 0;
  seq_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UReqPong::~UReqPong() {
  SharedDtor();
}

void UReqPong::SharedDtor() {
  if (this != default_instance_) {
  }
}

void UReqPong::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UReqPong::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UReqPong_descriptor_;
}

const UReqPong& UReqPong::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

UReqPong* UReqPong::default_instance_ = NULL;

UReqPong* UReqPong::New() const {
  return new UReqPong;
}

void UReqPong::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    seq_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UReqPong::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 seq = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &seq_)));
          set_has_seq();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UReqPong::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 seq = 1;
  if (has_seq()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->seq(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UReqPong::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 seq = 1;
  if (has_seq()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->seq(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UReqPong::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 seq = 1;
    if (has_seq()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->seq());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UReqPong::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UReqPong* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UReqPong*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UReqPong::MergeFrom(const UReqPong& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_seq()) {
      set_seq(from.seq());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UReqPong::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UReqPong::CopyFrom(const UReqPong& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UReqPong::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void UReqPong::Swap(UReqPong* other) {
  if (other != this) {
    std::swap(seq_, other->seq_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UReqPong::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UReqPong_descriptor_;
  metadata.reflection = UReqPong_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int UAnsPing::kSeqFieldNumber;
#endif  // !_MSC_VER

UAnsPing::UAnsPing()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UAnsPing::InitAsDefaultInstance() {
}

UAnsPing::UAnsPing(const UAnsPing& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UAnsPing::SharedCtor() {
  _cached_size_ = 0;
  seq_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UAnsPing::~UAnsPing() {
  SharedDtor();
}

void UAnsPing::SharedDtor() {
  if (this != default_instance_) {
  }
}

void UAnsPing::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UAnsPing::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UAnsPing_descriptor_;
}

const UAnsPing& UAnsPing::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

UAnsPing* UAnsPing::default_instance_ = NULL;

UAnsPing* UAnsPing::New() const {
  return new UAnsPing;
}

void UAnsPing::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    seq_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UAnsPing::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 seq = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &seq_)));
          set_has_seq();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UAnsPing::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 seq = 1;
  if (has_seq()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->seq(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UAnsPing::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 seq = 1;
  if (has_seq()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->seq(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UAnsPing::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 seq = 1;
    if (has_seq()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->seq());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UAnsPing::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UAnsPing* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UAnsPing*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UAnsPing::MergeFrom(const UAnsPing& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_seq()) {
      set_seq(from.seq());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UAnsPing::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UAnsPing::CopyFrom(const UAnsPing& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UAnsPing::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void UAnsPing::Swap(UAnsPing* other) {
  if (other != this) {
    std::swap(seq_, other->seq_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UAnsPing::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UAnsPing_descriptor_;
  metadata.reflection = UAnsPing_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int UReqPlug::kGameIDFieldNumber;
const int UReqPlug::kPasswdFieldNumber;
#endif  // !_MSC_VER

UReqPlug::UReqPlug()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UReqPlug::InitAsDefaultInstance() {
}

UReqPlug::UReqPlug(const UReqPlug& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UReqPlug::SharedCtor() {
  _cached_size_ = 0;
  gameid_ = GOOGLE_LONGLONG(0);
  passwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UReqPlug::~UReqPlug() {
  SharedDtor();
}

void UReqPlug::SharedDtor() {
  if (passwd_ != &::google::protobuf::internal::kEmptyString) {
    delete passwd_;
  }
  if (this != default_instance_) {
  }
}

void UReqPlug::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UReqPlug::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UReqPlug_descriptor_;
}

const UReqPlug& UReqPlug::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

UReqPlug* UReqPlug::default_instance_ = NULL;

UReqPlug* UReqPlug::New() const {
  return new UReqPlug;
}

void UReqPlug::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    gameid_ = GOOGLE_LONGLONG(0);
    if (has_passwd()) {
      if (passwd_ != &::google::protobuf::internal::kEmptyString) {
        passwd_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UReqPlug::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 gameID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &gameid_)));
          set_has_gameid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_passwd;
        break;
      }
      
      // required string passwd = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_passwd:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_passwd()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->passwd().data(), this->passwd().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UReqPlug::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 gameID = 1;
  if (has_gameid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->gameid(), output);
  }
  
  // required string passwd = 2;
  if (has_passwd()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->passwd().data(), this->passwd().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->passwd(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UReqPlug::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int64 gameID = 1;
  if (has_gameid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->gameid(), target);
  }
  
  // required string passwd = 2;
  if (has_passwd()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->passwd().data(), this->passwd().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->passwd(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UReqPlug::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 gameID = 1;
    if (has_gameid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->gameid());
    }
    
    // required string passwd = 2;
    if (has_passwd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->passwd());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UReqPlug::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UReqPlug* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UReqPlug*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UReqPlug::MergeFrom(const UReqPlug& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_gameid()) {
      set_gameid(from.gameid());
    }
    if (from.has_passwd()) {
      set_passwd(from.passwd());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UReqPlug::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UReqPlug::CopyFrom(const UReqPlug& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UReqPlug::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void UReqPlug::Swap(UReqPlug* other) {
  if (other != this) {
    std::swap(gameid_, other->gameid_);
    std::swap(passwd_, other->passwd_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UReqPlug::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UReqPlug_descriptor_;
  metadata.reflection = UReqPlug_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int UAnsPlug::kGameIDFieldNumber;
#endif  // !_MSC_VER

UAnsPlug::UAnsPlug()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UAnsPlug::InitAsDefaultInstance() {
}

UAnsPlug::UAnsPlug(const UAnsPlug& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UAnsPlug::SharedCtor() {
  _cached_size_ = 0;
  gameid_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UAnsPlug::~UAnsPlug() {
  SharedDtor();
}

void UAnsPlug::SharedDtor() {
  if (this != default_instance_) {
  }
}

void UAnsPlug::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UAnsPlug::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UAnsPlug_descriptor_;
}

const UAnsPlug& UAnsPlug::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

UAnsPlug* UAnsPlug::default_instance_ = NULL;

UAnsPlug* UAnsPlug::New() const {
  return new UAnsPlug;
}

void UAnsPlug::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    gameid_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UAnsPlug::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 gameID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &gameid_)));
          set_has_gameid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UAnsPlug::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 gameID = 1;
  if (has_gameid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->gameid(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UAnsPlug::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int64 gameID = 1;
  if (has_gameid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->gameid(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UAnsPlug::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 gameID = 1;
    if (has_gameid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->gameid());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UAnsPlug::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UAnsPlug* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UAnsPlug*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UAnsPlug::MergeFrom(const UAnsPlug& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_gameid()) {
      set_gameid(from.gameid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UAnsPlug::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UAnsPlug::CopyFrom(const UAnsPlug& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UAnsPlug::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void UAnsPlug::Swap(UAnsPlug* other) {
  if (other != this) {
    std::swap(gameid_, other->gameid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UAnsPlug::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UAnsPlug_descriptor_;
  metadata.reflection = UAnsPlug_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* UReqProtocol_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UReqProtocol_Type_descriptor_;
}
bool UReqProtocol_Type_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const UReqProtocol_Type UReqProtocol::NONE;
const UReqProtocol_Type UReqProtocol::UREQCONNECT;
const UReqProtocol_Type UReqProtocol::UREQCHANNEL;
const UReqProtocol_Type UReqProtocol::UREQSTORE;
const UReqProtocol_Type UReqProtocol::UREQINFO;
const UReqProtocol_Type UReqProtocol::UREQAUTOJOIN;
const UReqProtocol_Type UReqProtocol::UREQLEAVEGAME;
const UReqProtocol_Type UReqProtocol::UREQCLOSE;
const UReqProtocol_Type UReqProtocol::UREQPONG;
const UReqProtocol_Type UReqProtocol::UREQPLUG;
const UReqProtocol_Type UReqProtocol::GLREQGAMEPROTOCOL;
const UReqProtocol_Type UReqProtocol::UREQDB;
const UReqProtocol_Type UReqProtocol::UREQNOTICE;
const UReqProtocol_Type UReqProtocol::UREQGATEWAYPROTOCOL;
const UReqProtocol_Type UReqProtocol::Type_MIN;
const UReqProtocol_Type UReqProtocol::Type_MAX;
const int UReqProtocol::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int UReqProtocol::kTypeFieldNumber;
const int UReqProtocol::kReqConnectFieldNumber;
const int UReqProtocol::kReqChannelFieldNumber;
const int UReqProtocol::kReqStoreFieldNumber;
const int UReqProtocol::kReqInfoFieldNumber;
const int UReqProtocol::kReqAutoJoinFieldNumber;
const int UReqProtocol::kReqLeaveGameFieldNumber;
const int UReqProtocol::kReqCloseFieldNumber;
const int UReqProtocol::kReqPongFieldNumber;
const int UReqProtocol::kReqPlugFieldNumber;
const int UReqProtocol::kReqGameProtocolFieldNumber;
const int UReqProtocol::kReqDBFieldNumber;
const int UReqProtocol::kReqNoticeFieldNumber;
const int UReqProtocol::kReqGatewayProtocolFieldNumber;
#endif  // !_MSC_VER

UReqProtocol::UReqProtocol()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UReqProtocol::InitAsDefaultInstance() {
  reqconnect_ = const_cast< ::UReqConnect*>(&::UReqConnect::default_instance());
  reqchannel_ = const_cast< ::UReqChannel*>(&::UReqChannel::default_instance());
  reqstore_ = const_cast< ::UReqStore*>(&::UReqStore::default_instance());
  reqinfo_ = const_cast< ::UReqInfo*>(&::UReqInfo::default_instance());
  reqautojoin_ = const_cast< ::UReqAutoJoin*>(&::UReqAutoJoin::default_instance());
  reqleavegame_ = const_cast< ::UReqLeaveGame*>(&::UReqLeaveGame::default_instance());
  reqclose_ = const_cast< ::UReqClose*>(&::UReqClose::default_instance());
  reqpong_ = const_cast< ::UReqPong*>(&::UReqPong::default_instance());
  reqplug_ = const_cast< ::UReqPlug*>(&::UReqPlug::default_instance());
  reqdb_ = const_cast< ::ReqDB*>(&::ReqDB::default_instance());
  reqnotice_ = const_cast< ::UReqNotice*>(&::UReqNotice::default_instance());
}

UReqProtocol::UReqProtocol(const UReqProtocol& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UReqProtocol::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  reqconnect_ = NULL;
  reqchannel_ = NULL;
  reqstore_ = NULL;
  reqinfo_ = NULL;
  reqautojoin_ = NULL;
  reqleavegame_ = NULL;
  reqclose_ = NULL;
  reqpong_ = NULL;
  reqplug_ = NULL;
  reqgameprotocol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  reqdb_ = NULL;
  reqnotice_ = NULL;
  reqgatewayprotocol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UReqProtocol::~UReqProtocol() {
  SharedDtor();
}

void UReqProtocol::SharedDtor() {
  if (reqgameprotocol_ != &::google::protobuf::internal::kEmptyString) {
    delete reqgameprotocol_;
  }
  if (reqgatewayprotocol_ != &::google::protobuf::internal::kEmptyString) {
    delete reqgatewayprotocol_;
  }
  if (this != default_instance_) {
    delete reqconnect_;
    delete reqchannel_;
    delete reqstore_;
    delete reqinfo_;
    delete reqautojoin_;
    delete reqleavegame_;
    delete reqclose_;
    delete reqpong_;
    delete reqplug_;
    delete reqdb_;
    delete reqnotice_;
  }
}

void UReqProtocol::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UReqProtocol::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UReqProtocol_descriptor_;
}

const UReqProtocol& UReqProtocol::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

UReqProtocol* UReqProtocol::default_instance_ = NULL;

UReqProtocol* UReqProtocol::New() const {
  return new UReqProtocol;
}

void UReqProtocol::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 1;
    if (has_reqconnect()) {
      if (reqconnect_ != NULL) reqconnect_->::UReqConnect::Clear();
    }
    if (has_reqchannel()) {
      if (reqchannel_ != NULL) reqchannel_->::UReqChannel::Clear();
    }
    if (has_reqstore()) {
      if (reqstore_ != NULL) reqstore_->::UReqStore::Clear();
    }
    if (has_reqinfo()) {
      if (reqinfo_ != NULL) reqinfo_->::UReqInfo::Clear();
    }
    if (has_reqautojoin()) {
      if (reqautojoin_ != NULL) reqautojoin_->::UReqAutoJoin::Clear();
    }
    if (has_reqleavegame()) {
      if (reqleavegame_ != NULL) reqleavegame_->::UReqLeaveGame::Clear();
    }
    if (has_reqclose()) {
      if (reqclose_ != NULL) reqclose_->::UReqClose::Clear();
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_reqpong()) {
      if (reqpong_ != NULL) reqpong_->::UReqPong::Clear();
    }
    if (has_reqplug()) {
      if (reqplug_ != NULL) reqplug_->::UReqPlug::Clear();
    }
    if (has_reqgameprotocol()) {
      if (reqgameprotocol_ != &::google::protobuf::internal::kEmptyString) {
        reqgameprotocol_->clear();
      }
    }
    if (has_reqdb()) {
      if (reqdb_ != NULL) reqdb_->::ReqDB::Clear();
    }
    if (has_reqnotice()) {
      if (reqnotice_ != NULL) reqnotice_->::UReqNotice::Clear();
    }
    if (has_reqgatewayprotocol()) {
      if (reqgatewayprotocol_ != &::google::protobuf::internal::kEmptyString) {
        reqgatewayprotocol_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UReqProtocol::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .UReqProtocol.Type type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::UReqProtocol_Type_IsValid(value)) {
            set_type(static_cast< ::UReqProtocol_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_reqConnect;
        break;
      }
      
      // optional .UReqConnect reqConnect = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reqConnect:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reqconnect()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_reqChannel;
        break;
      }
      
      // optional .UReqChannel reqChannel = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reqChannel:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reqchannel()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_reqStore;
        break;
      }
      
      // optional .UReqStore reqStore = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reqStore:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reqstore()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_reqInfo;
        break;
      }
      
      // optional .UReqInfo reqInfo = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reqInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reqinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_reqAutoJoin;
        break;
      }
      
      // optional .UReqAutoJoin reqAutoJoin = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reqAutoJoin:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reqautojoin()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_reqLeaveGame;
        break;
      }
      
      // optional .UReqLeaveGame reqLeaveGame = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reqLeaveGame:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reqleavegame()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_reqClose;
        break;
      }
      
      // optional .UReqClose reqClose = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reqClose:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reqclose()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_reqPong;
        break;
      }
      
      // optional .UReqPong reqPong = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reqPong:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reqpong()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_reqPlug;
        break;
      }
      
      // optional .UReqPlug reqPlug = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reqPlug:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reqplug()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_reqGameProtocol;
        break;
      }
      
      // optional bytes reqGameProtocol = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reqGameProtocol:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_reqgameprotocol()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(98)) goto parse_reqDB;
        break;
      }
      
      // optional .ReqDB reqDB = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reqDB:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reqdb()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(106)) goto parse_reqNotice;
        break;
      }
      
      // optional .UReqNotice reqNotice = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reqNotice:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reqnotice()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(114)) goto parse_reqGatewayProtocol;
        break;
      }
      
      // optional bytes reqGatewayProtocol = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reqGatewayProtocol:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_reqgatewayprotocol()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UReqProtocol::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .UReqProtocol.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }
  
  // optional .UReqConnect reqConnect = 2;
  if (has_reqconnect()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->reqconnect(), output);
  }
  
  // optional .UReqChannel reqChannel = 3;
  if (has_reqchannel()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->reqchannel(), output);
  }
  
  // optional .UReqStore reqStore = 4;
  if (has_reqstore()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->reqstore(), output);
  }
  
  // optional .UReqInfo reqInfo = 5;
  if (has_reqinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->reqinfo(), output);
  }
  
  // optional .UReqAutoJoin reqAutoJoin = 6;
  if (has_reqautojoin()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->reqautojoin(), output);
  }
  
  // optional .UReqLeaveGame reqLeaveGame = 7;
  if (has_reqleavegame()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->reqleavegame(), output);
  }
  
  // optional .UReqClose reqClose = 8;
  if (has_reqclose()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->reqclose(), output);
  }
  
  // optional .UReqPong reqPong = 9;
  if (has_reqpong()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, this->reqpong(), output);
  }
  
  // optional .UReqPlug reqPlug = 10;
  if (has_reqplug()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, this->reqplug(), output);
  }
  
  // optional bytes reqGameProtocol = 11;
  if (has_reqgameprotocol()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      11, this->reqgameprotocol(), output);
  }
  
  // optional .ReqDB reqDB = 12;
  if (has_reqdb()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      12, this->reqdb(), output);
  }
  
  // optional .UReqNotice reqNotice = 13;
  if (has_reqnotice()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      13, this->reqnotice(), output);
  }
  
  // optional bytes reqGatewayProtocol = 14;
  if (has_reqgatewayprotocol()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      14, this->reqgatewayprotocol(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UReqProtocol::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .UReqProtocol.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }
  
  // optional .UReqConnect reqConnect = 2;
  if (has_reqconnect()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->reqconnect(), target);
  }
  
  // optional .UReqChannel reqChannel = 3;
  if (has_reqchannel()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->reqchannel(), target);
  }
  
  // optional .UReqStore reqStore = 4;
  if (has_reqstore()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->reqstore(), target);
  }
  
  // optional .UReqInfo reqInfo = 5;
  if (has_reqinfo()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->reqinfo(), target);
  }
  
  // optional .UReqAutoJoin reqAutoJoin = 6;
  if (has_reqautojoin()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->reqautojoin(), target);
  }
  
  // optional .UReqLeaveGame reqLeaveGame = 7;
  if (has_reqleavegame()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->reqleavegame(), target);
  }
  
  // optional .UReqClose reqClose = 8;
  if (has_reqclose()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->reqclose(), target);
  }
  
  // optional .UReqPong reqPong = 9;
  if (has_reqpong()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, this->reqpong(), target);
  }
  
  // optional .UReqPlug reqPlug = 10;
  if (has_reqplug()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        10, this->reqplug(), target);
  }
  
  // optional bytes reqGameProtocol = 11;
  if (has_reqgameprotocol()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        11, this->reqgameprotocol(), target);
  }
  
  // optional .ReqDB reqDB = 12;
  if (has_reqdb()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        12, this->reqdb(), target);
  }
  
  // optional .UReqNotice reqNotice = 13;
  if (has_reqnotice()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        13, this->reqnotice(), target);
  }
  
  // optional bytes reqGatewayProtocol = 14;
  if (has_reqgatewayprotocol()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        14, this->reqgatewayprotocol(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UReqProtocol::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .UReqProtocol.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }
    
    // optional .UReqConnect reqConnect = 2;
    if (has_reqconnect()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->reqconnect());
    }
    
    // optional .UReqChannel reqChannel = 3;
    if (has_reqchannel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->reqchannel());
    }
    
    // optional .UReqStore reqStore = 4;
    if (has_reqstore()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->reqstore());
    }
    
    // optional .UReqInfo reqInfo = 5;
    if (has_reqinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->reqinfo());
    }
    
    // optional .UReqAutoJoin reqAutoJoin = 6;
    if (has_reqautojoin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->reqautojoin());
    }
    
    // optional .UReqLeaveGame reqLeaveGame = 7;
    if (has_reqleavegame()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->reqleavegame());
    }
    
    // optional .UReqClose reqClose = 8;
    if (has_reqclose()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->reqclose());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .UReqPong reqPong = 9;
    if (has_reqpong()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->reqpong());
    }
    
    // optional .UReqPlug reqPlug = 10;
    if (has_reqplug()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->reqplug());
    }
    
    // optional bytes reqGameProtocol = 11;
    if (has_reqgameprotocol()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->reqgameprotocol());
    }
    
    // optional .ReqDB reqDB = 12;
    if (has_reqdb()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->reqdb());
    }
    
    // optional .UReqNotice reqNotice = 13;
    if (has_reqnotice()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->reqnotice());
    }
    
    // optional bytes reqGatewayProtocol = 14;
    if (has_reqgatewayprotocol()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->reqgatewayprotocol());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UReqProtocol::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UReqProtocol* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UReqProtocol*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UReqProtocol::MergeFrom(const UReqProtocol& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_reqconnect()) {
      mutable_reqconnect()->::UReqConnect::MergeFrom(from.reqconnect());
    }
    if (from.has_reqchannel()) {
      mutable_reqchannel()->::UReqChannel::MergeFrom(from.reqchannel());
    }
    if (from.has_reqstore()) {
      mutable_reqstore()->::UReqStore::MergeFrom(from.reqstore());
    }
    if (from.has_reqinfo()) {
      mutable_reqinfo()->::UReqInfo::MergeFrom(from.reqinfo());
    }
    if (from.has_reqautojoin()) {
      mutable_reqautojoin()->::UReqAutoJoin::MergeFrom(from.reqautojoin());
    }
    if (from.has_reqleavegame()) {
      mutable_reqleavegame()->::UReqLeaveGame::MergeFrom(from.reqleavegame());
    }
    if (from.has_reqclose()) {
      mutable_reqclose()->::UReqClose::MergeFrom(from.reqclose());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_reqpong()) {
      mutable_reqpong()->::UReqPong::MergeFrom(from.reqpong());
    }
    if (from.has_reqplug()) {
      mutable_reqplug()->::UReqPlug::MergeFrom(from.reqplug());
    }
    if (from.has_reqgameprotocol()) {
      set_reqgameprotocol(from.reqgameprotocol());
    }
    if (from.has_reqdb()) {
      mutable_reqdb()->::ReqDB::MergeFrom(from.reqdb());
    }
    if (from.has_reqnotice()) {
      mutable_reqnotice()->::UReqNotice::MergeFrom(from.reqnotice());
    }
    if (from.has_reqgatewayprotocol()) {
      set_reqgatewayprotocol(from.reqgatewayprotocol());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UReqProtocol::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UReqProtocol::CopyFrom(const UReqProtocol& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UReqProtocol::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_reqconnect()) {
    if (!this->reqconnect().IsInitialized()) return false;
  }
  if (has_reqautojoin()) {
    if (!this->reqautojoin().IsInitialized()) return false;
  }
  if (has_reqleavegame()) {
    if (!this->reqleavegame().IsInitialized()) return false;
  }
  if (has_reqpong()) {
    if (!this->reqpong().IsInitialized()) return false;
  }
  if (has_reqplug()) {
    if (!this->reqplug().IsInitialized()) return false;
  }
  if (has_reqdb()) {
    if (!this->reqdb().IsInitialized()) return false;
  }
  return true;
}

void UReqProtocol::Swap(UReqProtocol* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(reqconnect_, other->reqconnect_);
    std::swap(reqchannel_, other->reqchannel_);
    std::swap(reqstore_, other->reqstore_);
    std::swap(reqinfo_, other->reqinfo_);
    std::swap(reqautojoin_, other->reqautojoin_);
    std::swap(reqleavegame_, other->reqleavegame_);
    std::swap(reqclose_, other->reqclose_);
    std::swap(reqpong_, other->reqpong_);
    std::swap(reqplug_, other->reqplug_);
    std::swap(reqgameprotocol_, other->reqgameprotocol_);
    std::swap(reqdb_, other->reqdb_);
    std::swap(reqnotice_, other->reqnotice_);
    std::swap(reqgatewayprotocol_, other->reqgatewayprotocol_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UReqProtocol::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UReqProtocol_descriptor_;
  metadata.reflection = UReqProtocol_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* UAnsProtocol_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UAnsProtocol_Type_descriptor_;
}
bool UAnsProtocol_Type_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const UAnsProtocol_Type UAnsProtocol::NONE;
const UAnsProtocol_Type UAnsProtocol::UANSCONNECT;
const UAnsProtocol_Type UAnsProtocol::UANSCHANNEL;
const UAnsProtocol_Type UAnsProtocol::UANSSTORE;
const UAnsProtocol_Type UAnsProtocol::UANSINFO;
const UAnsProtocol_Type UAnsProtocol::UANSAUTOJOIN;
const UAnsProtocol_Type UAnsProtocol::UANSLEAVEGAME;
const UAnsProtocol_Type UAnsProtocol::UANSCLOSE;
const UAnsProtocol_Type UAnsProtocol::UANSPING;
const UAnsProtocol_Type UAnsProtocol::UANSPLUG;
const UAnsProtocol_Type UAnsProtocol::GLANSGAMEPROTOCOL;
const UAnsProtocol_Type UAnsProtocol::UANSDB;
const UAnsProtocol_Type UAnsProtocol::UANSNOTICE;
const UAnsProtocol_Type UAnsProtocol::UERROR;
const UAnsProtocol_Type UAnsProtocol::UANSGATEWAYPROTOCOL;
const UAnsProtocol_Type UAnsProtocol::Type_MIN;
const UAnsProtocol_Type UAnsProtocol::Type_MAX;
const int UAnsProtocol::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int UAnsProtocol::kTypeFieldNumber;
const int UAnsProtocol::kAnsConnectFieldNumber;
const int UAnsProtocol::kAnsChannelFieldNumber;
const int UAnsProtocol::kAnsStoreFieldNumber;
const int UAnsProtocol::kAnsInfoFieldNumber;
const int UAnsProtocol::kAnsAutoJoinFieldNumber;
const int UAnsProtocol::kAnsLeaveGameFieldNumber;
const int UAnsProtocol::kAnsCloseFieldNumber;
const int UAnsProtocol::kAnsPingFieldNumber;
const int UAnsProtocol::kAnsPlugFieldNumber;
const int UAnsProtocol::kAnsGameProtocolFieldNumber;
const int UAnsProtocol::kAnsDBFieldNumber;
const int UAnsProtocol::kAnsNoticeFieldNumber;
const int UAnsProtocol::kAnsErrorFieldNumber;
const int UAnsProtocol::kAnsGatewayProtocolFieldNumber;
#endif  // !_MSC_VER

UAnsProtocol::UAnsProtocol()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UAnsProtocol::InitAsDefaultInstance() {
  ansconnect_ = const_cast< ::UAnsConnect*>(&::UAnsConnect::default_instance());
  anschannel_ = const_cast< ::UAnsChannel*>(&::UAnsChannel::default_instance());
  ansstore_ = const_cast< ::UAnsStore*>(&::UAnsStore::default_instance());
  ansinfo_ = const_cast< ::UAnsInfo*>(&::UAnsInfo::default_instance());
  ansautojoin_ = const_cast< ::UAnsAutoJoin*>(&::UAnsAutoJoin::default_instance());
  ansleavegame_ = const_cast< ::UAnsLeaveGame*>(&::UAnsLeaveGame::default_instance());
  ansclose_ = const_cast< ::UAnsClose*>(&::UAnsClose::default_instance());
  ansping_ = const_cast< ::UAnsPing*>(&::UAnsPing::default_instance());
  ansplug_ = const_cast< ::UAnsPlug*>(&::UAnsPlug::default_instance());
  ansdb_ = const_cast< ::AnsDB*>(&::AnsDB::default_instance());
  ansnotice_ = const_cast< ::UAnsNotice*>(&::UAnsNotice::default_instance());
  anserror_ = const_cast< ::UError*>(&::UError::default_instance());
}

UAnsProtocol::UAnsProtocol(const UAnsProtocol& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UAnsProtocol::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  ansconnect_ = NULL;
  anschannel_ = NULL;
  ansstore_ = NULL;
  ansinfo_ = NULL;
  ansautojoin_ = NULL;
  ansleavegame_ = NULL;
  ansclose_ = NULL;
  ansping_ = NULL;
  ansplug_ = NULL;
  ansgameprotocol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ansdb_ = NULL;
  ansnotice_ = NULL;
  anserror_ = NULL;
  ansgatewayprotocol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UAnsProtocol::~UAnsProtocol() {
  SharedDtor();
}

void UAnsProtocol::SharedDtor() {
  if (ansgameprotocol_ != &::google::protobuf::internal::kEmptyString) {
    delete ansgameprotocol_;
  }
  if (ansgatewayprotocol_ != &::google::protobuf::internal::kEmptyString) {
    delete ansgatewayprotocol_;
  }
  if (this != default_instance_) {
    delete ansconnect_;
    delete anschannel_;
    delete ansstore_;
    delete ansinfo_;
    delete ansautojoin_;
    delete ansleavegame_;
    delete ansclose_;
    delete ansping_;
    delete ansplug_;
    delete ansdb_;
    delete ansnotice_;
    delete anserror_;
  }
}

void UAnsProtocol::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UAnsProtocol::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UAnsProtocol_descriptor_;
}

const UAnsProtocol& UAnsProtocol::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

UAnsProtocol* UAnsProtocol::default_instance_ = NULL;

UAnsProtocol* UAnsProtocol::New() const {
  return new UAnsProtocol;
}

void UAnsProtocol::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 1;
    if (has_ansconnect()) {
      if (ansconnect_ != NULL) ansconnect_->::UAnsConnect::Clear();
    }
    if (has_anschannel()) {
      if (anschannel_ != NULL) anschannel_->::UAnsChannel::Clear();
    }
    if (has_ansstore()) {
      if (ansstore_ != NULL) ansstore_->::UAnsStore::Clear();
    }
    if (has_ansinfo()) {
      if (ansinfo_ != NULL) ansinfo_->::UAnsInfo::Clear();
    }
    if (has_ansautojoin()) {
      if (ansautojoin_ != NULL) ansautojoin_->::UAnsAutoJoin::Clear();
    }
    if (has_ansleavegame()) {
      if (ansleavegame_ != NULL) ansleavegame_->::UAnsLeaveGame::Clear();
    }
    if (has_ansclose()) {
      if (ansclose_ != NULL) ansclose_->::UAnsClose::Clear();
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_ansping()) {
      if (ansping_ != NULL) ansping_->::UAnsPing::Clear();
    }
    if (has_ansplug()) {
      if (ansplug_ != NULL) ansplug_->::UAnsPlug::Clear();
    }
    if (has_ansgameprotocol()) {
      if (ansgameprotocol_ != &::google::protobuf::internal::kEmptyString) {
        ansgameprotocol_->clear();
      }
    }
    if (has_ansdb()) {
      if (ansdb_ != NULL) ansdb_->::AnsDB::Clear();
    }
    if (has_ansnotice()) {
      if (ansnotice_ != NULL) ansnotice_->::UAnsNotice::Clear();
    }
    if (has_anserror()) {
      if (anserror_ != NULL) anserror_->::UError::Clear();
    }
    if (has_ansgatewayprotocol()) {
      if (ansgatewayprotocol_ != &::google::protobuf::internal::kEmptyString) {
        ansgatewayprotocol_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UAnsProtocol::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .UAnsProtocol.Type type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::UAnsProtocol_Type_IsValid(value)) {
            set_type(static_cast< ::UAnsProtocol_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_ansConnect;
        break;
      }
      
      // optional .UAnsConnect ansConnect = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ansConnect:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ansconnect()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_ansChannel;
        break;
      }
      
      // optional .UAnsChannel ansChannel = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ansChannel:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_anschannel()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_ansStore;
        break;
      }
      
      // optional .UAnsStore ansStore = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ansStore:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ansstore()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_ansInfo;
        break;
      }
      
      // optional .UAnsInfo ansInfo = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ansInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ansinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_ansAutoJoin;
        break;
      }
      
      // optional .UAnsAutoJoin ansAutoJoin = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ansAutoJoin:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ansautojoin()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_ansLeaveGame;
        break;
      }
      
      // optional .UAnsLeaveGame ansLeaveGame = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ansLeaveGame:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ansleavegame()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_ansClose;
        break;
      }
      
      // optional .UAnsClose ansClose = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ansClose:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ansclose()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_ansPing;
        break;
      }
      
      // optional .UAnsPing ansPing = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ansPing:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ansping()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_ansPlug;
        break;
      }
      
      // optional .UAnsPlug ansPlug = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ansPlug:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ansplug()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_ansGameProtocol;
        break;
      }
      
      // optional bytes ansGameProtocol = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ansGameProtocol:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_ansgameprotocol()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(98)) goto parse_ansDB;
        break;
      }
      
      // optional .AnsDB ansDB = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ansDB:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ansdb()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(106)) goto parse_ansNotice;
        break;
      }
      
      // optional .UAnsNotice ansNotice = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ansNotice:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ansnotice()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(114)) goto parse_ansError;
        break;
      }
      
      // optional .UError ansError = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ansError:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_anserror()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(122)) goto parse_ansGatewayProtocol;
        break;
      }
      
      // optional bytes ansGatewayProtocol = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ansGatewayProtocol:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_ansgatewayprotocol()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UAnsProtocol::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .UAnsProtocol.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }
  
  // optional .UAnsConnect ansConnect = 2;
  if (has_ansconnect()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->ansconnect(), output);
  }
  
  // optional .UAnsChannel ansChannel = 3;
  if (has_anschannel()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->anschannel(), output);
  }
  
  // optional .UAnsStore ansStore = 4;
  if (has_ansstore()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->ansstore(), output);
  }
  
  // optional .UAnsInfo ansInfo = 5;
  if (has_ansinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->ansinfo(), output);
  }
  
  // optional .UAnsAutoJoin ansAutoJoin = 6;
  if (has_ansautojoin()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->ansautojoin(), output);
  }
  
  // optional .UAnsLeaveGame ansLeaveGame = 7;
  if (has_ansleavegame()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->ansleavegame(), output);
  }
  
  // optional .UAnsClose ansClose = 8;
  if (has_ansclose()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->ansclose(), output);
  }
  
  // optional .UAnsPing ansPing = 9;
  if (has_ansping()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, this->ansping(), output);
  }
  
  // optional .UAnsPlug ansPlug = 10;
  if (has_ansplug()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, this->ansplug(), output);
  }
  
  // optional bytes ansGameProtocol = 11;
  if (has_ansgameprotocol()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      11, this->ansgameprotocol(), output);
  }
  
  // optional .AnsDB ansDB = 12;
  if (has_ansdb()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      12, this->ansdb(), output);
  }
  
  // optional .UAnsNotice ansNotice = 13;
  if (has_ansnotice()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      13, this->ansnotice(), output);
  }
  
  // optional .UError ansError = 14;
  if (has_anserror()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      14, this->anserror(), output);
  }
  
  // optional bytes ansGatewayProtocol = 15;
  if (has_ansgatewayprotocol()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      15, this->ansgatewayprotocol(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UAnsProtocol::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .UAnsProtocol.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }
  
  // optional .UAnsConnect ansConnect = 2;
  if (has_ansconnect()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->ansconnect(), target);
  }
  
  // optional .UAnsChannel ansChannel = 3;
  if (has_anschannel()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->anschannel(), target);
  }
  
  // optional .UAnsStore ansStore = 4;
  if (has_ansstore()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->ansstore(), target);
  }
  
  // optional .UAnsInfo ansInfo = 5;
  if (has_ansinfo()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->ansinfo(), target);
  }
  
  // optional .UAnsAutoJoin ansAutoJoin = 6;
  if (has_ansautojoin()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->ansautojoin(), target);
  }
  
  // optional .UAnsLeaveGame ansLeaveGame = 7;
  if (has_ansleavegame()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->ansleavegame(), target);
  }
  
  // optional .UAnsClose ansClose = 8;
  if (has_ansclose()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->ansclose(), target);
  }
  
  // optional .UAnsPing ansPing = 9;
  if (has_ansping()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, this->ansping(), target);
  }
  
  // optional .UAnsPlug ansPlug = 10;
  if (has_ansplug()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        10, this->ansplug(), target);
  }
  
  // optional bytes ansGameProtocol = 11;
  if (has_ansgameprotocol()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        11, this->ansgameprotocol(), target);
  }
  
  // optional .AnsDB ansDB = 12;
  if (has_ansdb()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        12, this->ansdb(), target);
  }
  
  // optional .UAnsNotice ansNotice = 13;
  if (has_ansnotice()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        13, this->ansnotice(), target);
  }
  
  // optional .UError ansError = 14;
  if (has_anserror()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        14, this->anserror(), target);
  }
  
  // optional bytes ansGatewayProtocol = 15;
  if (has_ansgatewayprotocol()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        15, this->ansgatewayprotocol(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UAnsProtocol::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .UAnsProtocol.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }
    
    // optional .UAnsConnect ansConnect = 2;
    if (has_ansconnect()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ansconnect());
    }
    
    // optional .UAnsChannel ansChannel = 3;
    if (has_anschannel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->anschannel());
    }
    
    // optional .UAnsStore ansStore = 4;
    if (has_ansstore()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ansstore());
    }
    
    // optional .UAnsInfo ansInfo = 5;
    if (has_ansinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ansinfo());
    }
    
    // optional .UAnsAutoJoin ansAutoJoin = 6;
    if (has_ansautojoin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ansautojoin());
    }
    
    // optional .UAnsLeaveGame ansLeaveGame = 7;
    if (has_ansleavegame()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ansleavegame());
    }
    
    // optional .UAnsClose ansClose = 8;
    if (has_ansclose()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ansclose());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .UAnsPing ansPing = 9;
    if (has_ansping()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ansping());
    }
    
    // optional .UAnsPlug ansPlug = 10;
    if (has_ansplug()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ansplug());
    }
    
    // optional bytes ansGameProtocol = 11;
    if (has_ansgameprotocol()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->ansgameprotocol());
    }
    
    // optional .AnsDB ansDB = 12;
    if (has_ansdb()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ansdb());
    }
    
    // optional .UAnsNotice ansNotice = 13;
    if (has_ansnotice()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ansnotice());
    }
    
    // optional .UError ansError = 14;
    if (has_anserror()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->anserror());
    }
    
    // optional bytes ansGatewayProtocol = 15;
    if (has_ansgatewayprotocol()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->ansgatewayprotocol());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UAnsProtocol::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UAnsProtocol* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UAnsProtocol*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UAnsProtocol::MergeFrom(const UAnsProtocol& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_ansconnect()) {
      mutable_ansconnect()->::UAnsConnect::MergeFrom(from.ansconnect());
    }
    if (from.has_anschannel()) {
      mutable_anschannel()->::UAnsChannel::MergeFrom(from.anschannel());
    }
    if (from.has_ansstore()) {
      mutable_ansstore()->::UAnsStore::MergeFrom(from.ansstore());
    }
    if (from.has_ansinfo()) {
      mutable_ansinfo()->::UAnsInfo::MergeFrom(from.ansinfo());
    }
    if (from.has_ansautojoin()) {
      mutable_ansautojoin()->::UAnsAutoJoin::MergeFrom(from.ansautojoin());
    }
    if (from.has_ansleavegame()) {
      mutable_ansleavegame()->::UAnsLeaveGame::MergeFrom(from.ansleavegame());
    }
    if (from.has_ansclose()) {
      mutable_ansclose()->::UAnsClose::MergeFrom(from.ansclose());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_ansping()) {
      mutable_ansping()->::UAnsPing::MergeFrom(from.ansping());
    }
    if (from.has_ansplug()) {
      mutable_ansplug()->::UAnsPlug::MergeFrom(from.ansplug());
    }
    if (from.has_ansgameprotocol()) {
      set_ansgameprotocol(from.ansgameprotocol());
    }
    if (from.has_ansdb()) {
      mutable_ansdb()->::AnsDB::MergeFrom(from.ansdb());
    }
    if (from.has_ansnotice()) {
      mutable_ansnotice()->::UAnsNotice::MergeFrom(from.ansnotice());
    }
    if (from.has_anserror()) {
      mutable_anserror()->::UError::MergeFrom(from.anserror());
    }
    if (from.has_ansgatewayprotocol()) {
      set_ansgatewayprotocol(from.ansgatewayprotocol());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UAnsProtocol::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UAnsProtocol::CopyFrom(const UAnsProtocol& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UAnsProtocol::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_ansconnect()) {
    if (!this->ansconnect().IsInitialized()) return false;
  }
  if (has_anschannel()) {
    if (!this->anschannel().IsInitialized()) return false;
  }
  if (has_ansstore()) {
    if (!this->ansstore().IsInitialized()) return false;
  }
  if (has_ansinfo()) {
    if (!this->ansinfo().IsInitialized()) return false;
  }
  if (has_ansautojoin()) {
    if (!this->ansautojoin().IsInitialized()) return false;
  }
  if (has_ansleavegame()) {
    if (!this->ansleavegame().IsInitialized()) return false;
  }
  if (has_ansping()) {
    if (!this->ansping().IsInitialized()) return false;
  }
  if (has_ansplug()) {
    if (!this->ansplug().IsInitialized()) return false;
  }
  if (has_ansdb()) {
    if (!this->ansdb().IsInitialized()) return false;
  }
  if (has_ansnotice()) {
    if (!this->ansnotice().IsInitialized()) return false;
  }
  if (has_anserror()) {
    if (!this->anserror().IsInitialized()) return false;
  }
  return true;
}

void UAnsProtocol::Swap(UAnsProtocol* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(ansconnect_, other->ansconnect_);
    std::swap(anschannel_, other->anschannel_);
    std::swap(ansstore_, other->ansstore_);
    std::swap(ansinfo_, other->ansinfo_);
    std::swap(ansautojoin_, other->ansautojoin_);
    std::swap(ansleavegame_, other->ansleavegame_);
    std::swap(ansclose_, other->ansclose_);
    std::swap(ansping_, other->ansping_);
    std::swap(ansplug_, other->ansplug_);
    std::swap(ansgameprotocol_, other->ansgameprotocol_);
    std::swap(ansdb_, other->ansdb_);
    std::swap(ansnotice_, other->ansnotice_);
    std::swap(anserror_, other->anserror_);
    std::swap(ansgatewayprotocol_, other->ansgatewayprotocol_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UAnsProtocol::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UAnsProtocol_descriptor_;
  metadata.reflection = UAnsProtocol_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MemberInfo::kGameIdFieldNumber;
const int MemberInfo::kAvatarUrlFieldNumber;
const int MemberInfo::kNickNameFieldNumber;
const int MemberInfo::kGenderOptionFieldNumber;
#endif  // !_MSC_VER

MemberInfo::MemberInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MemberInfo::InitAsDefaultInstance() {
}

MemberInfo::MemberInfo(const MemberInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MemberInfo::SharedCtor() {
  _cached_size_ = 0;
  game_id_ = GOOGLE_LONGLONG(0);
  avatar_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  nick_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  gender_option_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MemberInfo::~MemberInfo() {
  SharedDtor();
}

void MemberInfo::SharedDtor() {
  if (avatar_url_ != &::google::protobuf::internal::kEmptyString) {
    delete avatar_url_;
  }
  if (nick_name_ != &::google::protobuf::internal::kEmptyString) {
    delete nick_name_;
  }
  if (this != default_instance_) {
  }
}

void MemberInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MemberInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MemberInfo_descriptor_;
}

const MemberInfo& MemberInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

MemberInfo* MemberInfo::default_instance_ = NULL;

MemberInfo* MemberInfo::New() const {
  return new MemberInfo;
}

void MemberInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    game_id_ = GOOGLE_LONGLONG(0);
    if (has_avatar_url()) {
      if (avatar_url_ != &::google::protobuf::internal::kEmptyString) {
        avatar_url_->clear();
      }
    }
    if (has_nick_name()) {
      if (nick_name_ != &::google::protobuf::internal::kEmptyString) {
        nick_name_->clear();
      }
    }
    gender_option_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MemberInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 game_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &game_id_)));
          set_has_game_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_avatar_url;
        break;
      }
      
      // required string avatar_url = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_avatar_url:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_avatar_url()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->avatar_url().data(), this->avatar_url().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_nick_name;
        break;
      }
      
      // required string nick_name = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_nick_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_nick_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->nick_name().data(), this->nick_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_gender_option;
        break;
      }
      
      // required bool gender_option = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_gender_option:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &gender_option_)));
          set_has_gender_option();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MemberInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 game_id = 1;
  if (has_game_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->game_id(), output);
  }
  
  // required string avatar_url = 2;
  if (has_avatar_url()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->avatar_url().data(), this->avatar_url().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->avatar_url(), output);
  }
  
  // required string nick_name = 3;
  if (has_nick_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->nick_name().data(), this->nick_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->nick_name(), output);
  }
  
  // required bool gender_option = 4;
  if (has_gender_option()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->gender_option(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MemberInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int64 game_id = 1;
  if (has_game_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->game_id(), target);
  }
  
  // required string avatar_url = 2;
  if (has_avatar_url()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->avatar_url().data(), this->avatar_url().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->avatar_url(), target);
  }
  
  // required string nick_name = 3;
  if (has_nick_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->nick_name().data(), this->nick_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->nick_name(), target);
  }
  
  // required bool gender_option = 4;
  if (has_gender_option()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->gender_option(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MemberInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 game_id = 1;
    if (has_game_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->game_id());
    }
    
    // required string avatar_url = 2;
    if (has_avatar_url()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->avatar_url());
    }
    
    // required string nick_name = 3;
    if (has_nick_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->nick_name());
    }
    
    // required bool gender_option = 4;
    if (has_gender_option()) {
      total_size += 1 + 1;
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MemberInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MemberInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MemberInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MemberInfo::MergeFrom(const MemberInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_game_id()) {
      set_game_id(from.game_id());
    }
    if (from.has_avatar_url()) {
      set_avatar_url(from.avatar_url());
    }
    if (from.has_nick_name()) {
      set_nick_name(from.nick_name());
    }
    if (from.has_gender_option()) {
      set_gender_option(from.gender_option());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MemberInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MemberInfo::CopyFrom(const MemberInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MemberInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;
  
  return true;
}

void MemberInfo::Swap(MemberInfo* other) {
  if (other != this) {
    std::swap(game_id_, other->game_id_);
    std::swap(avatar_url_, other->avatar_url_);
    std::swap(nick_name_, other->nick_name_);
    std::swap(gender_option_, other->gender_option_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MemberInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MemberInfo_descriptor_;
  metadata.reflection = MemberInfo_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
