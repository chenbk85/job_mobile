// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "ug.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

void protobuf_ShutdownFile_ug_2eproto() {
  delete Version::default_instance_;
  delete Error::default_instance_;
  delete Desc::default_instance_;
  delete Notice::default_instance_;
  delete UError::default_instance_;
  delete UReqConnect::default_instance_;
  delete UAnsConnect::default_instance_;
  delete UReqNotice::default_instance_;
  delete UAnsNotice::default_instance_;
  delete UReqChannel::default_instance_;
  delete UAnsChannel::default_instance_;
  delete UErrChannel::default_instance_;
  delete UReqStore::default_instance_;
  delete UAnsStore::default_instance_;
  delete UReqInfo::default_instance_;
  delete UAnsInfo::default_instance_;
  delete UReqAutoJoin::default_instance_;
  delete UAnsAutoJoin::default_instance_;
  delete UReqLeaveGame::default_instance_;
  delete UAnsLeaveGame::default_instance_;
  delete UReqClose::default_instance_;
  delete UAnsClose::default_instance_;
  delete UReqPing::default_instance_;
  delete UAnsPong::default_instance_;
  delete UReqPlug::default_instance_;
  delete UAnsPlug::default_instance_;
  delete UReqProtocol::default_instance_;
  delete UAnsProtocol::default_instance_;
}

void protobuf_AddDesc_ug_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::protobuf_AddDesc_db_2eproto();
  ::protobuf_AddDesc_gameLogic_2eproto();
  Version::default_instance_ = new Version();
  Error::default_instance_ = new Error();
  Desc::default_instance_ = new Desc();
  Notice::default_instance_ = new Notice();
  UError::default_instance_ = new UError();
  UReqConnect::default_instance_ = new UReqConnect();
  UAnsConnect::default_instance_ = new UAnsConnect();
  UReqNotice::default_instance_ = new UReqNotice();
  UAnsNotice::default_instance_ = new UAnsNotice();
  UReqChannel::default_instance_ = new UReqChannel();
  UAnsChannel::default_instance_ = new UAnsChannel();
  UErrChannel::default_instance_ = new UErrChannel();
  UReqStore::default_instance_ = new UReqStore();
  UAnsStore::default_instance_ = new UAnsStore();
  UReqInfo::default_instance_ = new UReqInfo();
  UAnsInfo::default_instance_ = new UAnsInfo();
  UReqAutoJoin::default_instance_ = new UReqAutoJoin();
  UAnsAutoJoin::default_instance_ = new UAnsAutoJoin();
  UReqLeaveGame::default_instance_ = new UReqLeaveGame();
  UAnsLeaveGame::default_instance_ = new UAnsLeaveGame();
  UReqClose::default_instance_ = new UReqClose();
  UAnsClose::default_instance_ = new UAnsClose();
  UReqPing::default_instance_ = new UReqPing();
  UAnsPong::default_instance_ = new UAnsPong();
  UReqPlug::default_instance_ = new UReqPlug();
  UAnsPlug::default_instance_ = new UAnsPlug();
  UReqProtocol::default_instance_ = new UReqProtocol();
  UAnsProtocol::default_instance_ = new UAnsProtocol();
  Version::default_instance_->InitAsDefaultInstance();
  Error::default_instance_->InitAsDefaultInstance();
  Desc::default_instance_->InitAsDefaultInstance();
  Notice::default_instance_->InitAsDefaultInstance();
  UError::default_instance_->InitAsDefaultInstance();
  UReqConnect::default_instance_->InitAsDefaultInstance();
  UAnsConnect::default_instance_->InitAsDefaultInstance();
  UReqNotice::default_instance_->InitAsDefaultInstance();
  UAnsNotice::default_instance_->InitAsDefaultInstance();
  UReqChannel::default_instance_->InitAsDefaultInstance();
  UAnsChannel::default_instance_->InitAsDefaultInstance();
  UErrChannel::default_instance_->InitAsDefaultInstance();
  UReqStore::default_instance_->InitAsDefaultInstance();
  UAnsStore::default_instance_->InitAsDefaultInstance();
  UReqInfo::default_instance_->InitAsDefaultInstance();
  UAnsInfo::default_instance_->InitAsDefaultInstance();
  UReqAutoJoin::default_instance_->InitAsDefaultInstance();
  UAnsAutoJoin::default_instance_->InitAsDefaultInstance();
  UReqLeaveGame::default_instance_->InitAsDefaultInstance();
  UAnsLeaveGame::default_instance_->InitAsDefaultInstance();
  UReqClose::default_instance_->InitAsDefaultInstance();
  UAnsClose::default_instance_->InitAsDefaultInstance();
  UReqPing::default_instance_->InitAsDefaultInstance();
  UAnsPong::default_instance_->InitAsDefaultInstance();
  UReqPlug::default_instance_->InitAsDefaultInstance();
  UAnsPlug::default_instance_->InitAsDefaultInstance();
  UReqProtocol::default_instance_->InitAsDefaultInstance();
  UAnsProtocol::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_ug_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_ug_2eproto {
  StaticDescriptorInitializer_ug_2eproto() {
    protobuf_AddDesc_ug_2eproto();
  }
} static_descriptor_initializer_ug_2eproto_;


// ===================================================================

#ifndef _MSC_VER
const int Version::kMajorFieldNumber;
const int Version::kMinorFieldNumber;
const int Version::kSubFieldNumber;
#endif  // !_MSC_VER

Version::Version()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Version::InitAsDefaultInstance() {
}

Version::Version(const Version& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Version::SharedCtor() {
  _cached_size_ = 0;
  major_ = 0;
  minor_ = 0;
  sub_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Version::~Version() {
  SharedDtor();
}

void Version::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Version::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Version& Version::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

Version* Version::default_instance_ = NULL;

Version* Version::New() const {
  return new Version;
}

void Version::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    major_ = 0;
    minor_ = 0;
    sub_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Version::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 major = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &major_)));
          set_has_major();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_minor;
        break;
      }
      
      // required int32 minor = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_minor:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &minor_)));
          set_has_minor();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_sub;
        break;
      }
      
      // required int32 sub = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sub:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &sub_)));
          set_has_sub();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Version::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 major = 1;
  if (has_major()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->major(), output);
  }
  
  // required int32 minor = 2;
  if (has_minor()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->minor(), output);
  }
  
  // required int32 sub = 3;
  if (has_sub()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->sub(), output);
  }
  
}

int Version::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 major = 1;
    if (has_major()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->major());
    }
    
    // required int32 minor = 2;
    if (has_minor()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->minor());
    }
    
    // required int32 sub = 3;
    if (has_sub()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->sub());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Version::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Version*>(&from));
}

void Version::MergeFrom(const Version& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_major()) {
      set_major(from.major());
    }
    if (from.has_minor()) {
      set_minor(from.minor());
    }
    if (from.has_sub()) {
      set_sub(from.sub());
    }
  }
}

void Version::CopyFrom(const Version& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Version::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  return true;
}

void Version::Swap(Version* other) {
  if (other != this) {
    std::swap(major_, other->major_);
    std::swap(minor_, other->minor_);
    std::swap(sub_, other->sub_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Version::GetTypeName() const {
  return "Version";
}


// ===================================================================

#ifndef _MSC_VER
const int Error::kErrorCodeFieldNumber;
const int Error::kErrorInfoFieldNumber;
const int Error::kReqModeFieldNumber;
#endif  // !_MSC_VER

Error::Error()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Error::InitAsDefaultInstance() {
}

Error::Error(const Error& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Error::SharedCtor() {
  _cached_size_ = 0;
  errorcode_ = 0;
  errorinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  reqmode_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Error::~Error() {
  SharedDtor();
}

void Error::SharedDtor() {
  if (errorinfo_ != &::google::protobuf::internal::kEmptyString) {
    delete errorinfo_;
  }
  if (this != default_instance_) {
  }
}

void Error::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Error& Error::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

Error* Error::default_instance_ = NULL;

Error* Error::New() const {
  return new Error;
}

void Error::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    errorcode_ = 0;
    if (has_errorinfo()) {
      if (errorinfo_ != &::google::protobuf::internal::kEmptyString) {
        errorinfo_->clear();
      }
    }
    reqmode_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Error::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 errorCode = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &errorcode_)));
          set_has_errorcode();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_errorInfo;
        break;
      }
      
      // required string errorInfo = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_errorInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_errorinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_reqMode;
        break;
      }
      
      // required int32 reqMode = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_reqMode:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &reqmode_)));
          set_has_reqmode();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Error::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 errorCode = 1;
  if (has_errorcode()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->errorcode(), output);
  }
  
  // required string errorInfo = 2;
  if (has_errorinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->errorinfo(), output);
  }
  
  // required int32 reqMode = 3;
  if (has_reqmode()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->reqmode(), output);
  }
  
}

int Error::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 errorCode = 1;
    if (has_errorcode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->errorcode());
    }
    
    // required string errorInfo = 2;
    if (has_errorinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->errorinfo());
    }
    
    // required int32 reqMode = 3;
    if (has_reqmode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->reqmode());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Error::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Error*>(&from));
}

void Error::MergeFrom(const Error& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_errorcode()) {
      set_errorcode(from.errorcode());
    }
    if (from.has_errorinfo()) {
      set_errorinfo(from.errorinfo());
    }
    if (from.has_reqmode()) {
      set_reqmode(from.reqmode());
    }
  }
}

void Error::CopyFrom(const Error& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Error::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  return true;
}

void Error::Swap(Error* other) {
  if (other != this) {
    std::swap(errorcode_, other->errorcode_);
    std::swap(errorinfo_, other->errorinfo_);
    std::swap(reqmode_, other->reqmode_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Error::GetTypeName() const {
  return "Error";
}


// ===================================================================

#ifndef _MSC_VER
const int Desc::kIdFieldNumber;
const int Desc::kDescFieldNumber;
#endif  // !_MSC_VER

Desc::Desc()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Desc::InitAsDefaultInstance() {
}

Desc::Desc(const Desc& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Desc::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Desc::~Desc() {
  SharedDtor();
}

void Desc::SharedDtor() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    delete desc_;
  }
  if (this != default_instance_) {
  }
}

void Desc::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Desc& Desc::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

Desc* Desc::default_instance_ = NULL;

Desc* Desc::New() const {
  return new Desc;
}

void Desc::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
    if (has_desc()) {
      if (desc_ != &::google::protobuf::internal::kEmptyString) {
        desc_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Desc::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_desc;
        break;
      }
      
      // required string desc = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_desc:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_desc()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Desc::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }
  
  // required string desc = 2;
  if (has_desc()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->desc(), output);
  }
  
}

int Desc::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }
    
    // required string desc = 2;
    if (has_desc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->desc());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Desc::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Desc*>(&from));
}

void Desc::MergeFrom(const Desc& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_desc()) {
      set_desc(from.desc());
    }
  }
}

void Desc::CopyFrom(const Desc& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Desc::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void Desc::Swap(Desc* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(desc_, other->desc_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Desc::GetTypeName() const {
  return "Desc";
}


// ===================================================================

#ifndef _MSC_VER
const int Notice::kPopupFieldNumber;
const int Notice::kSrlFieldNumber;
const int Notice::kNoticeFieldNumber;
#endif  // !_MSC_VER

Notice::Notice()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Notice::InitAsDefaultInstance() {
}

Notice::Notice(const Notice& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Notice::SharedCtor() {
  _cached_size_ = 0;
  popup_ = false;
  srl_ = 0;
  notice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Notice::~Notice() {
  SharedDtor();
}

void Notice::SharedDtor() {
  if (notice_ != &::google::protobuf::internal::kEmptyString) {
    delete notice_;
  }
  if (this != default_instance_) {
  }
}

void Notice::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Notice& Notice::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

Notice* Notice::default_instance_ = NULL;

Notice* Notice::New() const {
  return new Notice;
}

void Notice::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    popup_ = false;
    srl_ = 0;
    if (has_notice()) {
      if (notice_ != &::google::protobuf::internal::kEmptyString) {
        notice_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Notice::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool popup = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &popup_)));
          set_has_popup();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_srl;
        break;
      }
      
      // required int32 srl = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_srl:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &srl_)));
          set_has_srl();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_notice;
        break;
      }
      
      // required string notice = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_notice:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_notice()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Notice::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bool popup = 1;
  if (has_popup()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->popup(), output);
  }
  
  // required int32 srl = 2;
  if (has_srl()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->srl(), output);
  }
  
  // required string notice = 3;
  if (has_notice()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->notice(), output);
  }
  
}

int Notice::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool popup = 1;
    if (has_popup()) {
      total_size += 1 + 1;
    }
    
    // required int32 srl = 2;
    if (has_srl()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->srl());
    }
    
    // required string notice = 3;
    if (has_notice()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->notice());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Notice::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Notice*>(&from));
}

void Notice::MergeFrom(const Notice& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_popup()) {
      set_popup(from.popup());
    }
    if (from.has_srl()) {
      set_srl(from.srl());
    }
    if (from.has_notice()) {
      set_notice(from.notice());
    }
  }
}

void Notice::CopyFrom(const Notice& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Notice::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  return true;
}

void Notice::Swap(Notice* other) {
  if (other != this) {
    std::swap(popup_, other->popup_);
    std::swap(srl_, other->srl_);
    std::swap(notice_, other->notice_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Notice::GetTypeName() const {
  return "Notice";
}


// ===================================================================

bool UError_EErrorType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const UError_EErrorType UError::EET_VERSION_INCORRECT;
const UError_EErrorType UError::EET_DATABASE;
const UError_EErrorType UError::EET_INTERNAL;
const UError_EErrorType UError::EET_ALREADY_LOGGED;
const UError_EErrorType UError::EET_NOT_LOGGED;
const UError_EErrorType UError::EET_ALREADY_PLAYING;
const UError_EErrorType UError::EET_NOT_PLAYING;
const UError_EErrorType UError::EET_CANT_PLUG_GS;
const UError_EErrorType UError::EET_INVALID_VALUE;
const UError_EErrorType UError::EET_TIME_OUT;
const UError_EErrorType UError::EET_UNDEFINE;
const UError_EErrorType UError::EET_MAX_REFILL;
const UError_EErrorType UError::EET_OVER_USER;
const UError_EErrorType UError::EErrorType_MIN;
const UError_EErrorType UError::EErrorType_MAX;
const int UError::EErrorType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int UError::kErrorFieldNumber;
#endif  // !_MSC_VER

UError::UError()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UError::InitAsDefaultInstance() {
  error_ = const_cast< ::Error*>(&::Error::default_instance());
}

UError::UError(const UError& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UError::SharedCtor() {
  _cached_size_ = 0;
  error_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UError::~UError() {
  SharedDtor();
}

void UError::SharedDtor() {
  if (this != default_instance_) {
    delete error_;
  }
}

void UError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UError& UError::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

UError* UError::default_instance_ = NULL;

UError* UError::New() const {
  return new UError;
}

void UError::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_error()) {
      if (error_ != NULL) error_->::Error::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Error error = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_error()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .Error error = 1;
  if (has_error()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->error(), output);
  }
  
}

int UError::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .Error error = 1;
    if (has_error()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->error());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UError::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UError*>(&from));
}

void UError::MergeFrom(const UError& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_error()) {
      mutable_error()->::Error::MergeFrom(from.error());
    }
  }
}

void UError::CopyFrom(const UError& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UError::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_error()) {
    if (!this->error().IsInitialized()) return false;
  }
  return true;
}

void UError::Swap(UError* other) {
  if (other != this) {
    std::swap(error_, other->error_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UError::GetTypeName() const {
  return "UError";
}


// ===================================================================

#ifndef _MSC_VER
const int UReqConnect::kSvcIDFieldNumber;
const int UReqConnect::kGameIDFieldNumber;
const int UReqConnect::kLastCloseTimeFieldNumber;
const int UReqConnect::kProgramVerFieldNumber;
const int UReqConnect::kProtoVerFieldNumber;
const int UReqConnect::kMemberInfoFieldNumber;
#endif  // !_MSC_VER

UReqConnect::UReqConnect()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UReqConnect::InitAsDefaultInstance() {
  programver_ = const_cast< ::Version*>(&::Version::default_instance());
  protover_ = const_cast< ::Version*>(&::Version::default_instance());
  memberinfo_ = const_cast< ::MemberInfo*>(&::MemberInfo::default_instance());
}

UReqConnect::UReqConnect(const UReqConnect& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UReqConnect::SharedCtor() {
  _cached_size_ = 0;
  svcid_ = 0;
  gameid_ = 0;
  lastclosetime_ = 0;
  programver_ = NULL;
  protover_ = NULL;
  memberinfo_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UReqConnect::~UReqConnect() {
  SharedDtor();
}

void UReqConnect::SharedDtor() {
  if (this != default_instance_) {
    delete programver_;
    delete protover_;
    delete memberinfo_;
  }
}

void UReqConnect::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UReqConnect& UReqConnect::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

UReqConnect* UReqConnect::default_instance_ = NULL;

UReqConnect* UReqConnect::New() const {
  return new UReqConnect;
}

void UReqConnect::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    svcid_ = 0;
    gameid_ = 0;
    lastclosetime_ = 0;
    if (has_programver()) {
      if (programver_ != NULL) programver_->::Version::Clear();
    }
    if (has_protover()) {
      if (protover_ != NULL) protover_->::Version::Clear();
    }
    if (has_memberinfo()) {
      if (memberinfo_ != NULL) memberinfo_->::MemberInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UReqConnect::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 svcID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &svcid_)));
          set_has_svcid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_gameID;
        break;
      }
      
      // required int32 gameID = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_gameID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &gameid_)));
          set_has_gameid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_lastCloseTime;
        break;
      }
      
      // required int32 lastCloseTime = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_lastCloseTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lastclosetime_)));
          set_has_lastclosetime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_programVer;
        break;
      }
      
      // required .Version programVer = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_programVer:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_programver()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_protoVer;
        break;
      }
      
      // required .Version protoVer = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_protoVer:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_protover()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_memberInfo;
        break;
      }
      
      // required .MemberInfo memberInfo = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_memberInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_memberinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UReqConnect::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 svcID = 1;
  if (has_svcid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->svcid(), output);
  }
  
  // required int32 gameID = 2;
  if (has_gameid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->gameid(), output);
  }
  
  // required int32 lastCloseTime = 3;
  if (has_lastclosetime()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->lastclosetime(), output);
  }
  
  // required .Version programVer = 4;
  if (has_programver()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->programver(), output);
  }
  
  // required .Version protoVer = 5;
  if (has_protover()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->protover(), output);
  }
  
  // required .MemberInfo memberInfo = 6;
  if (has_memberinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->memberinfo(), output);
  }
  
}

int UReqConnect::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 svcID = 1;
    if (has_svcid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->svcid());
    }
    
    // required int32 gameID = 2;
    if (has_gameid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->gameid());
    }
    
    // required int32 lastCloseTime = 3;
    if (has_lastclosetime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lastclosetime());
    }
    
    // required .Version programVer = 4;
    if (has_programver()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->programver());
    }
    
    // required .Version protoVer = 5;
    if (has_protover()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->protover());
    }
    
    // required .MemberInfo memberInfo = 6;
    if (has_memberinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->memberinfo());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UReqConnect::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UReqConnect*>(&from));
}

void UReqConnect::MergeFrom(const UReqConnect& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_svcid()) {
      set_svcid(from.svcid());
    }
    if (from.has_gameid()) {
      set_gameid(from.gameid());
    }
    if (from.has_lastclosetime()) {
      set_lastclosetime(from.lastclosetime());
    }
    if (from.has_programver()) {
      mutable_programver()->::Version::MergeFrom(from.programver());
    }
    if (from.has_protover()) {
      mutable_protover()->::Version::MergeFrom(from.protover());
    }
    if (from.has_memberinfo()) {
      mutable_memberinfo()->::MemberInfo::MergeFrom(from.memberinfo());
    }
  }
}

void UReqConnect::CopyFrom(const UReqConnect& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UReqConnect::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;
  
  if (has_programver()) {
    if (!this->programver().IsInitialized()) return false;
  }
  if (has_protover()) {
    if (!this->protover().IsInitialized()) return false;
  }
  if (has_memberinfo()) {
    if (!this->memberinfo().IsInitialized()) return false;
  }
  return true;
}

void UReqConnect::Swap(UReqConnect* other) {
  if (other != this) {
    std::swap(svcid_, other->svcid_);
    std::swap(gameid_, other->gameid_);
    std::swap(lastclosetime_, other->lastclosetime_);
    std::swap(programver_, other->programver_);
    std::swap(protover_, other->protover_);
    std::swap(memberinfo_, other->memberinfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UReqConnect::GetTypeName() const {
  return "UReqConnect";
}


// ===================================================================

#ifndef _MSC_VER
const int UAnsConnect::kSvcIDFieldNumber;
const int UAnsConnect::kGameIDFieldNumber;
const int UAnsConnect::kStatusFieldNumber;
const int UAnsConnect::kIpFieldNumber;
const int UAnsConnect::kPortFieldNumber;
const int UAnsConnect::kPasswdFieldNumber;
#endif  // !_MSC_VER

UAnsConnect::UAnsConnect()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UAnsConnect::InitAsDefaultInstance() {
}

UAnsConnect::UAnsConnect(const UAnsConnect& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UAnsConnect::SharedCtor() {
  _cached_size_ = 0;
  svcid_ = 0;
  gameid_ = 0;
  status_ = 0;
  ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  port_ = 0;
  passwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UAnsConnect::~UAnsConnect() {
  SharedDtor();
}

void UAnsConnect::SharedDtor() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (passwd_ != &::google::protobuf::internal::kEmptyString) {
    delete passwd_;
  }
  if (this != default_instance_) {
  }
}

void UAnsConnect::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UAnsConnect& UAnsConnect::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

UAnsConnect* UAnsConnect::default_instance_ = NULL;

UAnsConnect* UAnsConnect::New() const {
  return new UAnsConnect;
}

void UAnsConnect::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    svcid_ = 0;
    gameid_ = 0;
    status_ = 0;
    if (has_ip()) {
      if (ip_ != &::google::protobuf::internal::kEmptyString) {
        ip_->clear();
      }
    }
    port_ = 0;
    if (has_passwd()) {
      if (passwd_ != &::google::protobuf::internal::kEmptyString) {
        passwd_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UAnsConnect::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 svcID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &svcid_)));
          set_has_svcid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_gameID;
        break;
      }
      
      // required int32 gameID = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_gameID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &gameid_)));
          set_has_gameid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_status;
        break;
      }
      
      // required int32 status = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &status_)));
          set_has_status();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_ip;
        break;
      }
      
      // required string ip = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ip:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ip()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_port;
        break;
      }
      
      // required int32 port = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_passwd;
        break;
      }
      
      // required string passwd = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_passwd:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_passwd()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UAnsConnect::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 svcID = 1;
  if (has_svcid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->svcid(), output);
  }
  
  // required int32 gameID = 2;
  if (has_gameid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->gameid(), output);
  }
  
  // required int32 status = 3;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->status(), output);
  }
  
  // required string ip = 4;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->ip(), output);
  }
  
  // required int32 port = 5;
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->port(), output);
  }
  
  // required string passwd = 6;
  if (has_passwd()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->passwd(), output);
  }
  
}

int UAnsConnect::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 svcID = 1;
    if (has_svcid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->svcid());
    }
    
    // required int32 gameID = 2;
    if (has_gameid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->gameid());
    }
    
    // required int32 status = 3;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->status());
    }
    
    // required string ip = 4;
    if (has_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ip());
    }
    
    // required int32 port = 5;
    if (has_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->port());
    }
    
    // required string passwd = 6;
    if (has_passwd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->passwd());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UAnsConnect::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UAnsConnect*>(&from));
}

void UAnsConnect::MergeFrom(const UAnsConnect& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_svcid()) {
      set_svcid(from.svcid());
    }
    if (from.has_gameid()) {
      set_gameid(from.gameid());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_ip()) {
      set_ip(from.ip());
    }
    if (from.has_port()) {
      set_port(from.port());
    }
    if (from.has_passwd()) {
      set_passwd(from.passwd());
    }
  }
}

void UAnsConnect::CopyFrom(const UAnsConnect& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UAnsConnect::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;
  
  return true;
}

void UAnsConnect::Swap(UAnsConnect* other) {
  if (other != this) {
    std::swap(svcid_, other->svcid_);
    std::swap(gameid_, other->gameid_);
    std::swap(status_, other->status_);
    std::swap(ip_, other->ip_);
    std::swap(port_, other->port_);
    std::swap(passwd_, other->passwd_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UAnsConnect::GetTypeName() const {
  return "UAnsConnect";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

UReqNotice::UReqNotice()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UReqNotice::InitAsDefaultInstance() {
}

UReqNotice::UReqNotice(const UReqNotice& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UReqNotice::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UReqNotice::~UReqNotice() {
  SharedDtor();
}

void UReqNotice::SharedDtor() {
  if (this != default_instance_) {
  }
}

void UReqNotice::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UReqNotice& UReqNotice::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

UReqNotice* UReqNotice::default_instance_ = NULL;

UReqNotice* UReqNotice::New() const {
  return new UReqNotice;
}

void UReqNotice::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UReqNotice::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
  }
  return true;
#undef DO_
}

void UReqNotice::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
}

int UReqNotice::ByteSize() const {
  int total_size = 0;
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UReqNotice::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UReqNotice*>(&from));
}

void UReqNotice::MergeFrom(const UReqNotice& from) {
  GOOGLE_CHECK_NE(&from, this);
}

void UReqNotice::CopyFrom(const UReqNotice& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UReqNotice::IsInitialized() const {
  
  return true;
}

void UReqNotice::Swap(UReqNotice* other) {
  if (other != this) {
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UReqNotice::GetTypeName() const {
  return "UReqNotice";
}


// ===================================================================

#ifndef _MSC_VER
const int UAnsNotice::kNoticesFieldNumber;
#endif  // !_MSC_VER

UAnsNotice::UAnsNotice()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UAnsNotice::InitAsDefaultInstance() {
}

UAnsNotice::UAnsNotice(const UAnsNotice& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UAnsNotice::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UAnsNotice::~UAnsNotice() {
  SharedDtor();
}

void UAnsNotice::SharedDtor() {
  if (this != default_instance_) {
  }
}

void UAnsNotice::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UAnsNotice& UAnsNotice::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

UAnsNotice* UAnsNotice::default_instance_ = NULL;

UAnsNotice* UAnsNotice::New() const {
  return new UAnsNotice;
}

void UAnsNotice::Clear() {
  notices_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UAnsNotice::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Notice notices = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_notices:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_notices()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_notices;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UAnsNotice::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .Notice notices = 1;
  for (int i = 0; i < this->notices_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->notices(i), output);
  }
  
}

int UAnsNotice::ByteSize() const {
  int total_size = 0;
  
  // repeated .Notice notices = 1;
  total_size += 1 * this->notices_size();
  for (int i = 0; i < this->notices_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->notices(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UAnsNotice::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UAnsNotice*>(&from));
}

void UAnsNotice::MergeFrom(const UAnsNotice& from) {
  GOOGLE_CHECK_NE(&from, this);
  notices_.MergeFrom(from.notices_);
}

void UAnsNotice::CopyFrom(const UAnsNotice& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UAnsNotice::IsInitialized() const {
  
  for (int i = 0; i < notices_size(); i++) {
    if (!this->notices(i).IsInitialized()) return false;
  }
  return true;
}

void UAnsNotice::Swap(UAnsNotice* other) {
  if (other != this) {
    notices_.Swap(&other->notices_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UAnsNotice::GetTypeName() const {
  return "UAnsNotice";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

UReqChannel::UReqChannel()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UReqChannel::InitAsDefaultInstance() {
}

UReqChannel::UReqChannel(const UReqChannel& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UReqChannel::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UReqChannel::~UReqChannel() {
  SharedDtor();
}

void UReqChannel::SharedDtor() {
  if (this != default_instance_) {
  }
}

void UReqChannel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UReqChannel& UReqChannel::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

UReqChannel* UReqChannel::default_instance_ = NULL;

UReqChannel* UReqChannel::New() const {
  return new UReqChannel;
}

void UReqChannel::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UReqChannel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
  }
  return true;
#undef DO_
}

void UReqChannel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
}

int UReqChannel::ByteSize() const {
  int total_size = 0;
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UReqChannel::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UReqChannel*>(&from));
}

void UReqChannel::MergeFrom(const UReqChannel& from) {
  GOOGLE_CHECK_NE(&from, this);
}

void UReqChannel::CopyFrom(const UReqChannel& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UReqChannel::IsInitialized() const {
  
  return true;
}

void UReqChannel::Swap(UReqChannel* other) {
  if (other != this) {
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UReqChannel::GetTypeName() const {
  return "UReqChannel";
}


// ===================================================================

#ifndef _MSC_VER
const int UAnsChannel::kChannelInfoFieldNumber;
#endif  // !_MSC_VER

UAnsChannel::UAnsChannel()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UAnsChannel::InitAsDefaultInstance() {
}

UAnsChannel::UAnsChannel(const UAnsChannel& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UAnsChannel::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UAnsChannel::~UAnsChannel() {
  SharedDtor();
}

void UAnsChannel::SharedDtor() {
  if (this != default_instance_) {
  }
}

void UAnsChannel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UAnsChannel& UAnsChannel::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

UAnsChannel* UAnsChannel::default_instance_ = NULL;

UAnsChannel* UAnsChannel::New() const {
  return new UAnsChannel;
}

void UAnsChannel::Clear() {
  channelinfo_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UAnsChannel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Desc channelInfo = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_channelInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_channelinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_channelInfo;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UAnsChannel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .Desc channelInfo = 1;
  for (int i = 0; i < this->channelinfo_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->channelinfo(i), output);
  }
  
}

int UAnsChannel::ByteSize() const {
  int total_size = 0;
  
  // repeated .Desc channelInfo = 1;
  total_size += 1 * this->channelinfo_size();
  for (int i = 0; i < this->channelinfo_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->channelinfo(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UAnsChannel::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UAnsChannel*>(&from));
}

void UAnsChannel::MergeFrom(const UAnsChannel& from) {
  GOOGLE_CHECK_NE(&from, this);
  channelinfo_.MergeFrom(from.channelinfo_);
}

void UAnsChannel::CopyFrom(const UAnsChannel& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UAnsChannel::IsInitialized() const {
  
  for (int i = 0; i < channelinfo_size(); i++) {
    if (!this->channelinfo(i).IsInitialized()) return false;
  }
  return true;
}

void UAnsChannel::Swap(UAnsChannel* other) {
  if (other != this) {
    channelinfo_.Swap(&other->channelinfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UAnsChannel::GetTypeName() const {
  return "UAnsChannel";
}


// ===================================================================

#ifndef _MSC_VER
const int UErrChannel::kErrorFieldNumber;
#endif  // !_MSC_VER

UErrChannel::UErrChannel()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UErrChannel::InitAsDefaultInstance() {
  error_ = const_cast< ::Error*>(&::Error::default_instance());
}

UErrChannel::UErrChannel(const UErrChannel& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UErrChannel::SharedCtor() {
  _cached_size_ = 0;
  error_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UErrChannel::~UErrChannel() {
  SharedDtor();
}

void UErrChannel::SharedDtor() {
  if (this != default_instance_) {
    delete error_;
  }
}

void UErrChannel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UErrChannel& UErrChannel::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

UErrChannel* UErrChannel::default_instance_ = NULL;

UErrChannel* UErrChannel::New() const {
  return new UErrChannel;
}

void UErrChannel::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_error()) {
      if (error_ != NULL) error_->::Error::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UErrChannel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Error error = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_error()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UErrChannel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .Error error = 1;
  if (has_error()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->error(), output);
  }
  
}

int UErrChannel::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .Error error = 1;
    if (has_error()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->error());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UErrChannel::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UErrChannel*>(&from));
}

void UErrChannel::MergeFrom(const UErrChannel& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_error()) {
      mutable_error()->::Error::MergeFrom(from.error());
    }
  }
}

void UErrChannel::CopyFrom(const UErrChannel& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UErrChannel::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_error()) {
    if (!this->error().IsInitialized()) return false;
  }
  return true;
}

void UErrChannel::Swap(UErrChannel* other) {
  if (other != this) {
    std::swap(error_, other->error_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UErrChannel::GetTypeName() const {
  return "UErrChannel";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

UReqStore::UReqStore()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UReqStore::InitAsDefaultInstance() {
}

UReqStore::UReqStore(const UReqStore& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UReqStore::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UReqStore::~UReqStore() {
  SharedDtor();
}

void UReqStore::SharedDtor() {
  if (this != default_instance_) {
  }
}

void UReqStore::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UReqStore& UReqStore::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

UReqStore* UReqStore::default_instance_ = NULL;

UReqStore* UReqStore::New() const {
  return new UReqStore;
}

void UReqStore::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UReqStore::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
  }
  return true;
#undef DO_
}

void UReqStore::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
}

int UReqStore::ByteSize() const {
  int total_size = 0;
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UReqStore::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UReqStore*>(&from));
}

void UReqStore::MergeFrom(const UReqStore& from) {
  GOOGLE_CHECK_NE(&from, this);
}

void UReqStore::CopyFrom(const UReqStore& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UReqStore::IsInitialized() const {
  
  return true;
}

void UReqStore::Swap(UReqStore* other) {
  if (other != this) {
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UReqStore::GetTypeName() const {
  return "UReqStore";
}


// ===================================================================

#ifndef _MSC_VER
const int UAnsStore::kItemInfoFieldNumber;
#endif  // !_MSC_VER

UAnsStore::UAnsStore()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UAnsStore::InitAsDefaultInstance() {
}

UAnsStore::UAnsStore(const UAnsStore& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UAnsStore::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UAnsStore::~UAnsStore() {
  SharedDtor();
}

void UAnsStore::SharedDtor() {
  if (this != default_instance_) {
  }
}

void UAnsStore::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UAnsStore& UAnsStore::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

UAnsStore* UAnsStore::default_instance_ = NULL;

UAnsStore* UAnsStore::New() const {
  return new UAnsStore;
}

void UAnsStore::Clear() {
  iteminfo_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UAnsStore::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Desc itemInfo = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_itemInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_iteminfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_itemInfo;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UAnsStore::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .Desc itemInfo = 1;
  for (int i = 0; i < this->iteminfo_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->iteminfo(i), output);
  }
  
}

int UAnsStore::ByteSize() const {
  int total_size = 0;
  
  // repeated .Desc itemInfo = 1;
  total_size += 1 * this->iteminfo_size();
  for (int i = 0; i < this->iteminfo_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->iteminfo(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UAnsStore::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UAnsStore*>(&from));
}

void UAnsStore::MergeFrom(const UAnsStore& from) {
  GOOGLE_CHECK_NE(&from, this);
  iteminfo_.MergeFrom(from.iteminfo_);
}

void UAnsStore::CopyFrom(const UAnsStore& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UAnsStore::IsInitialized() const {
  
  for (int i = 0; i < iteminfo_size(); i++) {
    if (!this->iteminfo(i).IsInitialized()) return false;
  }
  return true;
}

void UAnsStore::Swap(UAnsStore* other) {
  if (other != this) {
    iteminfo_.Swap(&other->iteminfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UAnsStore::GetTypeName() const {
  return "UAnsStore";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

UReqInfo::UReqInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UReqInfo::InitAsDefaultInstance() {
}

UReqInfo::UReqInfo(const UReqInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UReqInfo::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UReqInfo::~UReqInfo() {
  SharedDtor();
}

void UReqInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void UReqInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UReqInfo& UReqInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

UReqInfo* UReqInfo::default_instance_ = NULL;

UReqInfo* UReqInfo::New() const {
  return new UReqInfo;
}

void UReqInfo::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UReqInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
  }
  return true;
#undef DO_
}

void UReqInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
}

int UReqInfo::ByteSize() const {
  int total_size = 0;
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UReqInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UReqInfo*>(&from));
}

void UReqInfo::MergeFrom(const UReqInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
}

void UReqInfo::CopyFrom(const UReqInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UReqInfo::IsInitialized() const {
  
  return true;
}

void UReqInfo::Swap(UReqInfo* other) {
  if (other != this) {
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UReqInfo::GetTypeName() const {
  return "UReqInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int UAnsInfo::kGameInfoFieldNumber;
#endif  // !_MSC_VER

UAnsInfo::UAnsInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UAnsInfo::InitAsDefaultInstance() {
  gameinfo_ = const_cast< ::GameInfo*>(&::GameInfo::default_instance());
}

UAnsInfo::UAnsInfo(const UAnsInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UAnsInfo::SharedCtor() {
  _cached_size_ = 0;
  gameinfo_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UAnsInfo::~UAnsInfo() {
  SharedDtor();
}

void UAnsInfo::SharedDtor() {
  if (this != default_instance_) {
    delete gameinfo_;
  }
}

void UAnsInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UAnsInfo& UAnsInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

UAnsInfo* UAnsInfo::default_instance_ = NULL;

UAnsInfo* UAnsInfo::New() const {
  return new UAnsInfo;
}

void UAnsInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_gameinfo()) {
      if (gameinfo_ != NULL) gameinfo_->::GameInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UAnsInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .GameInfo gameInfo = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_gameinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UAnsInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .GameInfo gameInfo = 1;
  if (has_gameinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->gameinfo(), output);
  }
  
}

int UAnsInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .GameInfo gameInfo = 1;
    if (has_gameinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->gameinfo());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UAnsInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UAnsInfo*>(&from));
}

void UAnsInfo::MergeFrom(const UAnsInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_gameinfo()) {
      mutable_gameinfo()->::GameInfo::MergeFrom(from.gameinfo());
    }
  }
}

void UAnsInfo::CopyFrom(const UAnsInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UAnsInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_gameinfo()) {
    if (!this->gameinfo().IsInitialized()) return false;
  }
  return true;
}

void UAnsInfo::Swap(UAnsInfo* other) {
  if (other != this) {
    std::swap(gameinfo_, other->gameinfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UAnsInfo::GetTypeName() const {
  return "UAnsInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int UReqAutoJoin::kCategoryIDFieldNumber;
const int UReqAutoJoin::kChannelIDFieldNumber;
#endif  // !_MSC_VER

UReqAutoJoin::UReqAutoJoin()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UReqAutoJoin::InitAsDefaultInstance() {
}

UReqAutoJoin::UReqAutoJoin(const UReqAutoJoin& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UReqAutoJoin::SharedCtor() {
  _cached_size_ = 0;
  categoryid_ = 0;
  channelid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UReqAutoJoin::~UReqAutoJoin() {
  SharedDtor();
}

void UReqAutoJoin::SharedDtor() {
  if (this != default_instance_) {
  }
}

void UReqAutoJoin::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UReqAutoJoin& UReqAutoJoin::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

UReqAutoJoin* UReqAutoJoin::default_instance_ = NULL;

UReqAutoJoin* UReqAutoJoin::New() const {
  return new UReqAutoJoin;
}

void UReqAutoJoin::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    categoryid_ = 0;
    channelid_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UReqAutoJoin::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 categoryID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &categoryid_)));
          set_has_categoryid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_channelID;
        break;
      }
      
      // required int32 channelID = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_channelID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &channelid_)));
          set_has_channelid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UReqAutoJoin::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 categoryID = 1;
  if (has_categoryid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->categoryid(), output);
  }
  
  // required int32 channelID = 2;
  if (has_channelid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->channelid(), output);
  }
  
}

int UReqAutoJoin::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 categoryID = 1;
    if (has_categoryid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->categoryid());
    }
    
    // required int32 channelID = 2;
    if (has_channelid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->channelid());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UReqAutoJoin::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UReqAutoJoin*>(&from));
}

void UReqAutoJoin::MergeFrom(const UReqAutoJoin& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_categoryid()) {
      set_categoryid(from.categoryid());
    }
    if (from.has_channelid()) {
      set_channelid(from.channelid());
    }
  }
}

void UReqAutoJoin::CopyFrom(const UReqAutoJoin& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UReqAutoJoin::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void UReqAutoJoin::Swap(UReqAutoJoin* other) {
  if (other != this) {
    std::swap(categoryid_, other->categoryid_);
    std::swap(channelid_, other->channelid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UReqAutoJoin::GetTypeName() const {
  return "UReqAutoJoin";
}


// ===================================================================

#ifndef _MSC_VER
const int UAnsAutoJoin::kGameRoomInfoFieldNumber;
#endif  // !_MSC_VER

UAnsAutoJoin::UAnsAutoJoin()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UAnsAutoJoin::InitAsDefaultInstance() {
  gameroominfo_ = const_cast< ::GameRoomInfo*>(&::GameRoomInfo::default_instance());
}

UAnsAutoJoin::UAnsAutoJoin(const UAnsAutoJoin& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UAnsAutoJoin::SharedCtor() {
  _cached_size_ = 0;
  gameroominfo_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UAnsAutoJoin::~UAnsAutoJoin() {
  SharedDtor();
}

void UAnsAutoJoin::SharedDtor() {
  if (this != default_instance_) {
    delete gameroominfo_;
  }
}

void UAnsAutoJoin::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UAnsAutoJoin& UAnsAutoJoin::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

UAnsAutoJoin* UAnsAutoJoin::default_instance_ = NULL;

UAnsAutoJoin* UAnsAutoJoin::New() const {
  return new UAnsAutoJoin;
}

void UAnsAutoJoin::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_gameroominfo()) {
      if (gameroominfo_ != NULL) gameroominfo_->::GameRoomInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UAnsAutoJoin::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .GameRoomInfo gameRoomInfo = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_gameroominfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UAnsAutoJoin::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .GameRoomInfo gameRoomInfo = 1;
  if (has_gameroominfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->gameroominfo(), output);
  }
  
}

int UAnsAutoJoin::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .GameRoomInfo gameRoomInfo = 1;
    if (has_gameroominfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->gameroominfo());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UAnsAutoJoin::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UAnsAutoJoin*>(&from));
}

void UAnsAutoJoin::MergeFrom(const UAnsAutoJoin& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_gameroominfo()) {
      mutable_gameroominfo()->::GameRoomInfo::MergeFrom(from.gameroominfo());
    }
  }
}

void UAnsAutoJoin::CopyFrom(const UAnsAutoJoin& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UAnsAutoJoin::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_gameroominfo()) {
    if (!this->gameroominfo().IsInitialized()) return false;
  }
  return true;
}

void UAnsAutoJoin::Swap(UAnsAutoJoin* other) {
  if (other != this) {
    std::swap(gameroominfo_, other->gameroominfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UAnsAutoJoin::GetTypeName() const {
  return "UAnsAutoJoin";
}


// ===================================================================

#ifndef _MSC_VER
const int UReqLeaveGame::kGameIDFieldNumber;
const int UReqLeaveGame::kKickFieldNumber;
#endif  // !_MSC_VER

UReqLeaveGame::UReqLeaveGame()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UReqLeaveGame::InitAsDefaultInstance() {
}

UReqLeaveGame::UReqLeaveGame(const UReqLeaveGame& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UReqLeaveGame::SharedCtor() {
  _cached_size_ = 0;
  gameid_ = 0;
  kick_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UReqLeaveGame::~UReqLeaveGame() {
  SharedDtor();
}

void UReqLeaveGame::SharedDtor() {
  if (this != default_instance_) {
  }
}

void UReqLeaveGame::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UReqLeaveGame& UReqLeaveGame::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

UReqLeaveGame* UReqLeaveGame::default_instance_ = NULL;

UReqLeaveGame* UReqLeaveGame::New() const {
  return new UReqLeaveGame;
}

void UReqLeaveGame::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    gameid_ = 0;
    kick_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UReqLeaveGame::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 gameID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &gameid_)));
          set_has_gameid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_kick;
        break;
      }
      
      // required bool kick = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_kick:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &kick_)));
          set_has_kick();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UReqLeaveGame::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 gameID = 1;
  if (has_gameid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->gameid(), output);
  }
  
  // required bool kick = 2;
  if (has_kick()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->kick(), output);
  }
  
}

int UReqLeaveGame::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 gameID = 1;
    if (has_gameid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->gameid());
    }
    
    // required bool kick = 2;
    if (has_kick()) {
      total_size += 1 + 1;
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UReqLeaveGame::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UReqLeaveGame*>(&from));
}

void UReqLeaveGame::MergeFrom(const UReqLeaveGame& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_gameid()) {
      set_gameid(from.gameid());
    }
    if (from.has_kick()) {
      set_kick(from.kick());
    }
  }
}

void UReqLeaveGame::CopyFrom(const UReqLeaveGame& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UReqLeaveGame::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void UReqLeaveGame::Swap(UReqLeaveGame* other) {
  if (other != this) {
    std::swap(gameid_, other->gameid_);
    std::swap(kick_, other->kick_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UReqLeaveGame::GetTypeName() const {
  return "UReqLeaveGame";
}


// ===================================================================

bool UAnsLeaveGame_KICK_TYPE_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const UAnsLeaveGame_KICK_TYPE UAnsLeaveGame::EXIT_RESERVATION;
const UAnsLeaveGame_KICK_TYPE UAnsLeaveGame::LIMITMONEY;
const UAnsLeaveGame_KICK_TYPE UAnsLeaveGame::ALLIN;
const UAnsLeaveGame_KICK_TYPE UAnsLeaveGame::SYSTEM_ERROR;
const UAnsLeaveGame_KICK_TYPE UAnsLeaveGame::KICK_ZERO;
const UAnsLeaveGame_KICK_TYPE UAnsLeaveGame::KICK_TYPE_MIN;
const UAnsLeaveGame_KICK_TYPE UAnsLeaveGame::KICK_TYPE_MAX;
const int UAnsLeaveGame::KICK_TYPE_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int UAnsLeaveGame::kGameIDFieldNumber;
const int UAnsLeaveGame::kNTypeFieldNumber;
#endif  // !_MSC_VER

UAnsLeaveGame::UAnsLeaveGame()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UAnsLeaveGame::InitAsDefaultInstance() {
}

UAnsLeaveGame::UAnsLeaveGame(const UAnsLeaveGame& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UAnsLeaveGame::SharedCtor() {
  _cached_size_ = 0;
  gameid_ = 0;
  ntype_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UAnsLeaveGame::~UAnsLeaveGame() {
  SharedDtor();
}

void UAnsLeaveGame::SharedDtor() {
  if (this != default_instance_) {
  }
}

void UAnsLeaveGame::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UAnsLeaveGame& UAnsLeaveGame::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

UAnsLeaveGame* UAnsLeaveGame::default_instance_ = NULL;

UAnsLeaveGame* UAnsLeaveGame::New() const {
  return new UAnsLeaveGame;
}

void UAnsLeaveGame::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    gameid_ = 0;
    ntype_ = 1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UAnsLeaveGame::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 gameID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &gameid_)));
          set_has_gameid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_nType;
        break;
      }
      
      // required .UAnsLeaveGame.KICK_TYPE nType = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_nType:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::UAnsLeaveGame_KICK_TYPE_IsValid(value)) {
            set_ntype(static_cast< ::UAnsLeaveGame_KICK_TYPE >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UAnsLeaveGame::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 gameID = 1;
  if (has_gameid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->gameid(), output);
  }
  
  // required .UAnsLeaveGame.KICK_TYPE nType = 2;
  if (has_ntype()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->ntype(), output);
  }
  
}

int UAnsLeaveGame::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 gameID = 1;
    if (has_gameid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->gameid());
    }
    
    // required .UAnsLeaveGame.KICK_TYPE nType = 2;
    if (has_ntype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->ntype());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UAnsLeaveGame::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UAnsLeaveGame*>(&from));
}

void UAnsLeaveGame::MergeFrom(const UAnsLeaveGame& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_gameid()) {
      set_gameid(from.gameid());
    }
    if (from.has_ntype()) {
      set_ntype(from.ntype());
    }
  }
}

void UAnsLeaveGame::CopyFrom(const UAnsLeaveGame& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UAnsLeaveGame::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void UAnsLeaveGame::Swap(UAnsLeaveGame* other) {
  if (other != this) {
    std::swap(gameid_, other->gameid_);
    std::swap(ntype_, other->ntype_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UAnsLeaveGame::GetTypeName() const {
  return "UAnsLeaveGame";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

UReqClose::UReqClose()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UReqClose::InitAsDefaultInstance() {
}

UReqClose::UReqClose(const UReqClose& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UReqClose::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UReqClose::~UReqClose() {
  SharedDtor();
}

void UReqClose::SharedDtor() {
  if (this != default_instance_) {
  }
}

void UReqClose::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UReqClose& UReqClose::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

UReqClose* UReqClose::default_instance_ = NULL;

UReqClose* UReqClose::New() const {
  return new UReqClose;
}

void UReqClose::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UReqClose::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
  }
  return true;
#undef DO_
}

void UReqClose::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
}

int UReqClose::ByteSize() const {
  int total_size = 0;
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UReqClose::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UReqClose*>(&from));
}

void UReqClose::MergeFrom(const UReqClose& from) {
  GOOGLE_CHECK_NE(&from, this);
}

void UReqClose::CopyFrom(const UReqClose& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UReqClose::IsInitialized() const {
  
  return true;
}

void UReqClose::Swap(UReqClose* other) {
  if (other != this) {
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UReqClose::GetTypeName() const {
  return "UReqClose";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

UAnsClose::UAnsClose()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UAnsClose::InitAsDefaultInstance() {
}

UAnsClose::UAnsClose(const UAnsClose& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UAnsClose::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UAnsClose::~UAnsClose() {
  SharedDtor();
}

void UAnsClose::SharedDtor() {
  if (this != default_instance_) {
  }
}

void UAnsClose::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UAnsClose& UAnsClose::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

UAnsClose* UAnsClose::default_instance_ = NULL;

UAnsClose* UAnsClose::New() const {
  return new UAnsClose;
}

void UAnsClose::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UAnsClose::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
  }
  return true;
#undef DO_
}

void UAnsClose::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
}

int UAnsClose::ByteSize() const {
  int total_size = 0;
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UAnsClose::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UAnsClose*>(&from));
}

void UAnsClose::MergeFrom(const UAnsClose& from) {
  GOOGLE_CHECK_NE(&from, this);
}

void UAnsClose::CopyFrom(const UAnsClose& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UAnsClose::IsInitialized() const {
  
  return true;
}

void UAnsClose::Swap(UAnsClose* other) {
  if (other != this) {
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UAnsClose::GetTypeName() const {
  return "UAnsClose";
}


// ===================================================================

#ifndef _MSC_VER
const int UReqPing::kSeqFieldNumber;
#endif  // !_MSC_VER

UReqPing::UReqPing()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UReqPing::InitAsDefaultInstance() {
}

UReqPing::UReqPing(const UReqPing& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UReqPing::SharedCtor() {
  _cached_size_ = 0;
  seq_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UReqPing::~UReqPing() {
  SharedDtor();
}

void UReqPing::SharedDtor() {
  if (this != default_instance_) {
  }
}

void UReqPing::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UReqPing& UReqPing::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

UReqPing* UReqPing::default_instance_ = NULL;

UReqPing* UReqPing::New() const {
  return new UReqPing;
}

void UReqPing::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    seq_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UReqPing::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 seq = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &seq_)));
          set_has_seq();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UReqPing::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 seq = 1;
  if (has_seq()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->seq(), output);
  }
  
}

int UReqPing::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 seq = 1;
    if (has_seq()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->seq());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UReqPing::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UReqPing*>(&from));
}

void UReqPing::MergeFrom(const UReqPing& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_seq()) {
      set_seq(from.seq());
    }
  }
}

void UReqPing::CopyFrom(const UReqPing& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UReqPing::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void UReqPing::Swap(UReqPing* other) {
  if (other != this) {
    std::swap(seq_, other->seq_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UReqPing::GetTypeName() const {
  return "UReqPing";
}


// ===================================================================

#ifndef _MSC_VER
const int UAnsPong::kSeqFieldNumber;
#endif  // !_MSC_VER

UAnsPong::UAnsPong()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UAnsPong::InitAsDefaultInstance() {
}

UAnsPong::UAnsPong(const UAnsPong& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UAnsPong::SharedCtor() {
  _cached_size_ = 0;
  seq_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UAnsPong::~UAnsPong() {
  SharedDtor();
}

void UAnsPong::SharedDtor() {
  if (this != default_instance_) {
  }
}

void UAnsPong::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UAnsPong& UAnsPong::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

UAnsPong* UAnsPong::default_instance_ = NULL;

UAnsPong* UAnsPong::New() const {
  return new UAnsPong;
}

void UAnsPong::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    seq_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UAnsPong::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 seq = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &seq_)));
          set_has_seq();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UAnsPong::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 seq = 1;
  if (has_seq()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->seq(), output);
  }
  
}

int UAnsPong::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 seq = 1;
    if (has_seq()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->seq());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UAnsPong::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UAnsPong*>(&from));
}

void UAnsPong::MergeFrom(const UAnsPong& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_seq()) {
      set_seq(from.seq());
    }
  }
}

void UAnsPong::CopyFrom(const UAnsPong& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UAnsPong::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void UAnsPong::Swap(UAnsPong* other) {
  if (other != this) {
    std::swap(seq_, other->seq_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UAnsPong::GetTypeName() const {
  return "UAnsPong";
}


// ===================================================================

#ifndef _MSC_VER
const int UReqPlug::kGameIDFieldNumber;
const int UReqPlug::kPasswdFieldNumber;
#endif  // !_MSC_VER

UReqPlug::UReqPlug()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UReqPlug::InitAsDefaultInstance() {
}

UReqPlug::UReqPlug(const UReqPlug& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UReqPlug::SharedCtor() {
  _cached_size_ = 0;
  gameid_ = 0;
  passwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UReqPlug::~UReqPlug() {
  SharedDtor();
}

void UReqPlug::SharedDtor() {
  if (passwd_ != &::google::protobuf::internal::kEmptyString) {
    delete passwd_;
  }
  if (this != default_instance_) {
  }
}

void UReqPlug::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UReqPlug& UReqPlug::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

UReqPlug* UReqPlug::default_instance_ = NULL;

UReqPlug* UReqPlug::New() const {
  return new UReqPlug;
}

void UReqPlug::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    gameid_ = 0;
    if (has_passwd()) {
      if (passwd_ != &::google::protobuf::internal::kEmptyString) {
        passwd_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UReqPlug::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 gameID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &gameid_)));
          set_has_gameid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_passwd;
        break;
      }
      
      // required string passwd = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_passwd:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_passwd()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UReqPlug::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 gameID = 1;
  if (has_gameid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->gameid(), output);
  }
  
  // required string passwd = 2;
  if (has_passwd()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->passwd(), output);
  }
  
}

int UReqPlug::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 gameID = 1;
    if (has_gameid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->gameid());
    }
    
    // required string passwd = 2;
    if (has_passwd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->passwd());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UReqPlug::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UReqPlug*>(&from));
}

void UReqPlug::MergeFrom(const UReqPlug& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_gameid()) {
      set_gameid(from.gameid());
    }
    if (from.has_passwd()) {
      set_passwd(from.passwd());
    }
  }
}

void UReqPlug::CopyFrom(const UReqPlug& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UReqPlug::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void UReqPlug::Swap(UReqPlug* other) {
  if (other != this) {
    std::swap(gameid_, other->gameid_);
    std::swap(passwd_, other->passwd_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UReqPlug::GetTypeName() const {
  return "UReqPlug";
}


// ===================================================================

#ifndef _MSC_VER
const int UAnsPlug::kGameIDFieldNumber;
#endif  // !_MSC_VER

UAnsPlug::UAnsPlug()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UAnsPlug::InitAsDefaultInstance() {
}

UAnsPlug::UAnsPlug(const UAnsPlug& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UAnsPlug::SharedCtor() {
  _cached_size_ = 0;
  gameid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UAnsPlug::~UAnsPlug() {
  SharedDtor();
}

void UAnsPlug::SharedDtor() {
  if (this != default_instance_) {
  }
}

void UAnsPlug::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UAnsPlug& UAnsPlug::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

UAnsPlug* UAnsPlug::default_instance_ = NULL;

UAnsPlug* UAnsPlug::New() const {
  return new UAnsPlug;
}

void UAnsPlug::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    gameid_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UAnsPlug::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 gameID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &gameid_)));
          set_has_gameid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UAnsPlug::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 gameID = 1;
  if (has_gameid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->gameid(), output);
  }
  
}

int UAnsPlug::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 gameID = 1;
    if (has_gameid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->gameid());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UAnsPlug::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UAnsPlug*>(&from));
}

void UAnsPlug::MergeFrom(const UAnsPlug& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_gameid()) {
      set_gameid(from.gameid());
    }
  }
}

void UAnsPlug::CopyFrom(const UAnsPlug& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UAnsPlug::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void UAnsPlug::Swap(UAnsPlug* other) {
  if (other != this) {
    std::swap(gameid_, other->gameid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UAnsPlug::GetTypeName() const {
  return "UAnsPlug";
}


// ===================================================================

bool UReqProtocol_Type_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const UReqProtocol_Type UReqProtocol::NONE;
const UReqProtocol_Type UReqProtocol::UREQCONNECT;
const UReqProtocol_Type UReqProtocol::UREQCHANNEL;
const UReqProtocol_Type UReqProtocol::UREQSTORE;
const UReqProtocol_Type UReqProtocol::UREQINFO;
const UReqProtocol_Type UReqProtocol::UREQAUTOJOIN;
const UReqProtocol_Type UReqProtocol::UREQLEAVEGAME;
const UReqProtocol_Type UReqProtocol::UREQCLOSE;
const UReqProtocol_Type UReqProtocol::UREQPING;
const UReqProtocol_Type UReqProtocol::UREQPLUG;
const UReqProtocol_Type UReqProtocol::GLREQGAMEPROTOCOL;
const UReqProtocol_Type UReqProtocol::UREQDB;
const UReqProtocol_Type UReqProtocol::UREQNOTICE;
const UReqProtocol_Type UReqProtocol::Type_MIN;
const UReqProtocol_Type UReqProtocol::Type_MAX;
const int UReqProtocol::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int UReqProtocol::kTypeFieldNumber;
const int UReqProtocol::kReqConnectFieldNumber;
const int UReqProtocol::kReqChannelFieldNumber;
const int UReqProtocol::kReqStoreFieldNumber;
const int UReqProtocol::kReqInfoFieldNumber;
const int UReqProtocol::kReqAutoJoinFieldNumber;
const int UReqProtocol::kReqLeaveGameFieldNumber;
const int UReqProtocol::kReqCloseFieldNumber;
const int UReqProtocol::kReqPingFieldNumber;
const int UReqProtocol::kReqPlugFieldNumber;
const int UReqProtocol::kReqGameProtocolFieldNumber;
const int UReqProtocol::kReqDBFieldNumber;
const int UReqProtocol::kReqNoticeFieldNumber;
#endif  // !_MSC_VER

UReqProtocol::UReqProtocol()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UReqProtocol::InitAsDefaultInstance() {
  reqconnect_ = const_cast< ::UReqConnect*>(&::UReqConnect::default_instance());
  reqchannel_ = const_cast< ::UReqChannel*>(&::UReqChannel::default_instance());
  reqstore_ = const_cast< ::UReqStore*>(&::UReqStore::default_instance());
  reqinfo_ = const_cast< ::UReqInfo*>(&::UReqInfo::default_instance());
  reqautojoin_ = const_cast< ::UReqAutoJoin*>(&::UReqAutoJoin::default_instance());
  reqleavegame_ = const_cast< ::UReqLeaveGame*>(&::UReqLeaveGame::default_instance());
  reqclose_ = const_cast< ::UReqClose*>(&::UReqClose::default_instance());
  reqping_ = const_cast< ::UReqPing*>(&::UReqPing::default_instance());
  reqplug_ = const_cast< ::UReqPlug*>(&::UReqPlug::default_instance());
  reqgameprotocol_ = const_cast< ::GLReqGameProtocol*>(&::GLReqGameProtocol::default_instance());
  reqdb_ = const_cast< ::ReqDB*>(&::ReqDB::default_instance());
  reqnotice_ = const_cast< ::UReqNotice*>(&::UReqNotice::default_instance());
}

UReqProtocol::UReqProtocol(const UReqProtocol& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UReqProtocol::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  reqconnect_ = NULL;
  reqchannel_ = NULL;
  reqstore_ = NULL;
  reqinfo_ = NULL;
  reqautojoin_ = NULL;
  reqleavegame_ = NULL;
  reqclose_ = NULL;
  reqping_ = NULL;
  reqplug_ = NULL;
  reqgameprotocol_ = NULL;
  reqdb_ = NULL;
  reqnotice_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UReqProtocol::~UReqProtocol() {
  SharedDtor();
}

void UReqProtocol::SharedDtor() {
  if (this != default_instance_) {
    delete reqconnect_;
    delete reqchannel_;
    delete reqstore_;
    delete reqinfo_;
    delete reqautojoin_;
    delete reqleavegame_;
    delete reqclose_;
    delete reqping_;
    delete reqplug_;
    delete reqgameprotocol_;
    delete reqdb_;
    delete reqnotice_;
  }
}

void UReqProtocol::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UReqProtocol& UReqProtocol::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

UReqProtocol* UReqProtocol::default_instance_ = NULL;

UReqProtocol* UReqProtocol::New() const {
  return new UReqProtocol;
}

void UReqProtocol::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 1;
    if (has_reqconnect()) {
      if (reqconnect_ != NULL) reqconnect_->::UReqConnect::Clear();
    }
    if (has_reqchannel()) {
      if (reqchannel_ != NULL) reqchannel_->::UReqChannel::Clear();
    }
    if (has_reqstore()) {
      if (reqstore_ != NULL) reqstore_->::UReqStore::Clear();
    }
    if (has_reqinfo()) {
      if (reqinfo_ != NULL) reqinfo_->::UReqInfo::Clear();
    }
    if (has_reqautojoin()) {
      if (reqautojoin_ != NULL) reqautojoin_->::UReqAutoJoin::Clear();
    }
    if (has_reqleavegame()) {
      if (reqleavegame_ != NULL) reqleavegame_->::UReqLeaveGame::Clear();
    }
    if (has_reqclose()) {
      if (reqclose_ != NULL) reqclose_->::UReqClose::Clear();
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_reqping()) {
      if (reqping_ != NULL) reqping_->::UReqPing::Clear();
    }
    if (has_reqplug()) {
      if (reqplug_ != NULL) reqplug_->::UReqPlug::Clear();
    }
    if (has_reqgameprotocol()) {
      if (reqgameprotocol_ != NULL) reqgameprotocol_->::GLReqGameProtocol::Clear();
    }
    if (has_reqdb()) {
      if (reqdb_ != NULL) reqdb_->::ReqDB::Clear();
    }
    if (has_reqnotice()) {
      if (reqnotice_ != NULL) reqnotice_->::UReqNotice::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UReqProtocol::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .UReqProtocol.Type type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::UReqProtocol_Type_IsValid(value)) {
            set_type(static_cast< ::UReqProtocol_Type >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_reqConnect;
        break;
      }
      
      // optional .UReqConnect reqConnect = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reqConnect:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reqconnect()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_reqChannel;
        break;
      }
      
      // optional .UReqChannel reqChannel = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reqChannel:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reqchannel()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_reqStore;
        break;
      }
      
      // optional .UReqStore reqStore = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reqStore:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reqstore()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_reqInfo;
        break;
      }
      
      // optional .UReqInfo reqInfo = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reqInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reqinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_reqAutoJoin;
        break;
      }
      
      // optional .UReqAutoJoin reqAutoJoin = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reqAutoJoin:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reqautojoin()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_reqLeaveGame;
        break;
      }
      
      // optional .UReqLeaveGame reqLeaveGame = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reqLeaveGame:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reqleavegame()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_reqClose;
        break;
      }
      
      // optional .UReqClose reqClose = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reqClose:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reqclose()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_reqPing;
        break;
      }
      
      // optional .UReqPing reqPing = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reqPing:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reqping()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_reqPlug;
        break;
      }
      
      // optional .UReqPlug reqPlug = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reqPlug:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reqplug()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_reqGameProtocol;
        break;
      }
      
      // optional .GLReqGameProtocol reqGameProtocol = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reqGameProtocol:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reqgameprotocol()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(98)) goto parse_reqDB;
        break;
      }
      
      // optional .ReqDB reqDB = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reqDB:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reqdb()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(106)) goto parse_reqNotice;
        break;
      }
      
      // optional .UReqNotice reqNotice = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reqNotice:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reqnotice()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UReqProtocol::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .UReqProtocol.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }
  
  // optional .UReqConnect reqConnect = 2;
  if (has_reqconnect()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->reqconnect(), output);
  }
  
  // optional .UReqChannel reqChannel = 3;
  if (has_reqchannel()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->reqchannel(), output);
  }
  
  // optional .UReqStore reqStore = 4;
  if (has_reqstore()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->reqstore(), output);
  }
  
  // optional .UReqInfo reqInfo = 5;
  if (has_reqinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->reqinfo(), output);
  }
  
  // optional .UReqAutoJoin reqAutoJoin = 6;
  if (has_reqautojoin()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->reqautojoin(), output);
  }
  
  // optional .UReqLeaveGame reqLeaveGame = 7;
  if (has_reqleavegame()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, this->reqleavegame(), output);
  }
  
  // optional .UReqClose reqClose = 8;
  if (has_reqclose()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, this->reqclose(), output);
  }
  
  // optional .UReqPing reqPing = 9;
  if (has_reqping()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      9, this->reqping(), output);
  }
  
  // optional .UReqPlug reqPlug = 10;
  if (has_reqplug()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      10, this->reqplug(), output);
  }
  
  // optional .GLReqGameProtocol reqGameProtocol = 11;
  if (has_reqgameprotocol()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      11, this->reqgameprotocol(), output);
  }
  
  // optional .ReqDB reqDB = 12;
  if (has_reqdb()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      12, this->reqdb(), output);
  }
  
  // optional .UReqNotice reqNotice = 13;
  if (has_reqnotice()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      13, this->reqnotice(), output);
  }
  
}

int UReqProtocol::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .UReqProtocol.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }
    
    // optional .UReqConnect reqConnect = 2;
    if (has_reqconnect()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->reqconnect());
    }
    
    // optional .UReqChannel reqChannel = 3;
    if (has_reqchannel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->reqchannel());
    }
    
    // optional .UReqStore reqStore = 4;
    if (has_reqstore()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->reqstore());
    }
    
    // optional .UReqInfo reqInfo = 5;
    if (has_reqinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->reqinfo());
    }
    
    // optional .UReqAutoJoin reqAutoJoin = 6;
    if (has_reqautojoin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->reqautojoin());
    }
    
    // optional .UReqLeaveGame reqLeaveGame = 7;
    if (has_reqleavegame()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->reqleavegame());
    }
    
    // optional .UReqClose reqClose = 8;
    if (has_reqclose()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->reqclose());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .UReqPing reqPing = 9;
    if (has_reqping()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->reqping());
    }
    
    // optional .UReqPlug reqPlug = 10;
    if (has_reqplug()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->reqplug());
    }
    
    // optional .GLReqGameProtocol reqGameProtocol = 11;
    if (has_reqgameprotocol()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->reqgameprotocol());
    }
    
    // optional .ReqDB reqDB = 12;
    if (has_reqdb()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->reqdb());
    }
    
    // optional .UReqNotice reqNotice = 13;
    if (has_reqnotice()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->reqnotice());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UReqProtocol::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UReqProtocol*>(&from));
}

void UReqProtocol::MergeFrom(const UReqProtocol& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_reqconnect()) {
      mutable_reqconnect()->::UReqConnect::MergeFrom(from.reqconnect());
    }
    if (from.has_reqchannel()) {
      mutable_reqchannel()->::UReqChannel::MergeFrom(from.reqchannel());
    }
    if (from.has_reqstore()) {
      mutable_reqstore()->::UReqStore::MergeFrom(from.reqstore());
    }
    if (from.has_reqinfo()) {
      mutable_reqinfo()->::UReqInfo::MergeFrom(from.reqinfo());
    }
    if (from.has_reqautojoin()) {
      mutable_reqautojoin()->::UReqAutoJoin::MergeFrom(from.reqautojoin());
    }
    if (from.has_reqleavegame()) {
      mutable_reqleavegame()->::UReqLeaveGame::MergeFrom(from.reqleavegame());
    }
    if (from.has_reqclose()) {
      mutable_reqclose()->::UReqClose::MergeFrom(from.reqclose());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_reqping()) {
      mutable_reqping()->::UReqPing::MergeFrom(from.reqping());
    }
    if (from.has_reqplug()) {
      mutable_reqplug()->::UReqPlug::MergeFrom(from.reqplug());
    }
    if (from.has_reqgameprotocol()) {
      mutable_reqgameprotocol()->::GLReqGameProtocol::MergeFrom(from.reqgameprotocol());
    }
    if (from.has_reqdb()) {
      mutable_reqdb()->::ReqDB::MergeFrom(from.reqdb());
    }
    if (from.has_reqnotice()) {
      mutable_reqnotice()->::UReqNotice::MergeFrom(from.reqnotice());
    }
  }
}

void UReqProtocol::CopyFrom(const UReqProtocol& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UReqProtocol::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_reqconnect()) {
    if (!this->reqconnect().IsInitialized()) return false;
  }
  if (has_reqautojoin()) {
    if (!this->reqautojoin().IsInitialized()) return false;
  }
  if (has_reqleavegame()) {
    if (!this->reqleavegame().IsInitialized()) return false;
  }
  if (has_reqping()) {
    if (!this->reqping().IsInitialized()) return false;
  }
  if (has_reqplug()) {
    if (!this->reqplug().IsInitialized()) return false;
  }
  if (has_reqgameprotocol()) {
    if (!this->reqgameprotocol().IsInitialized()) return false;
  }
  if (has_reqdb()) {
    if (!this->reqdb().IsInitialized()) return false;
  }
  return true;
}

void UReqProtocol::Swap(UReqProtocol* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(reqconnect_, other->reqconnect_);
    std::swap(reqchannel_, other->reqchannel_);
    std::swap(reqstore_, other->reqstore_);
    std::swap(reqinfo_, other->reqinfo_);
    std::swap(reqautojoin_, other->reqautojoin_);
    std::swap(reqleavegame_, other->reqleavegame_);
    std::swap(reqclose_, other->reqclose_);
    std::swap(reqping_, other->reqping_);
    std::swap(reqplug_, other->reqplug_);
    std::swap(reqgameprotocol_, other->reqgameprotocol_);
    std::swap(reqdb_, other->reqdb_);
    std::swap(reqnotice_, other->reqnotice_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UReqProtocol::GetTypeName() const {
  return "UReqProtocol";
}


// ===================================================================

bool UAnsProtocol_Type_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const UAnsProtocol_Type UAnsProtocol::NONE;
const UAnsProtocol_Type UAnsProtocol::UANSCONNECT;
const UAnsProtocol_Type UAnsProtocol::UANSCHANNEL;
const UAnsProtocol_Type UAnsProtocol::UANSSTORE;
const UAnsProtocol_Type UAnsProtocol::UANSINFO;
const UAnsProtocol_Type UAnsProtocol::UANSAUTOJOIN;
const UAnsProtocol_Type UAnsProtocol::UANSLEAVEGAME;
const UAnsProtocol_Type UAnsProtocol::UANSCLOSE;
const UAnsProtocol_Type UAnsProtocol::UANSPONG;
const UAnsProtocol_Type UAnsProtocol::UANSPLUG;
const UAnsProtocol_Type UAnsProtocol::GLANSGAMEPROTOCOL;
const UAnsProtocol_Type UAnsProtocol::UANSDB;
const UAnsProtocol_Type UAnsProtocol::UANSNOTICE;
const UAnsProtocol_Type UAnsProtocol::UERROR;
const UAnsProtocol_Type UAnsProtocol::Type_MIN;
const UAnsProtocol_Type UAnsProtocol::Type_MAX;
const int UAnsProtocol::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int UAnsProtocol::kTypeFieldNumber;
const int UAnsProtocol::kAnsConnectFieldNumber;
const int UAnsProtocol::kAnsChannelFieldNumber;
const int UAnsProtocol::kAnsStoreFieldNumber;
const int UAnsProtocol::kAnsInfoFieldNumber;
const int UAnsProtocol::kAnsAutoJoinFieldNumber;
const int UAnsProtocol::kAnsLeaveGameFieldNumber;
const int UAnsProtocol::kAnsCloseFieldNumber;
const int UAnsProtocol::kAnsPongFieldNumber;
const int UAnsProtocol::kAnsPlugFieldNumber;
const int UAnsProtocol::kAnsGameProtocolFieldNumber;
const int UAnsProtocol::kAnsDBFieldNumber;
const int UAnsProtocol::kAnsNoticeFieldNumber;
const int UAnsProtocol::kAnsErrorFieldNumber;
#endif  // !_MSC_VER

UAnsProtocol::UAnsProtocol()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UAnsProtocol::InitAsDefaultInstance() {
  ansconnect_ = const_cast< ::UAnsConnect*>(&::UAnsConnect::default_instance());
  anschannel_ = const_cast< ::UAnsChannel*>(&::UAnsChannel::default_instance());
  ansstore_ = const_cast< ::UAnsStore*>(&::UAnsStore::default_instance());
  ansinfo_ = const_cast< ::UAnsInfo*>(&::UAnsInfo::default_instance());
  ansautojoin_ = const_cast< ::UAnsAutoJoin*>(&::UAnsAutoJoin::default_instance());
  ansleavegame_ = const_cast< ::UAnsLeaveGame*>(&::UAnsLeaveGame::default_instance());
  ansclose_ = const_cast< ::UAnsClose*>(&::UAnsClose::default_instance());
  anspong_ = const_cast< ::UAnsPong*>(&::UAnsPong::default_instance());
  ansplug_ = const_cast< ::UAnsPlug*>(&::UAnsPlug::default_instance());
  ansgameprotocol_ = const_cast< ::GLAnsGameProtocol*>(&::GLAnsGameProtocol::default_instance());
  ansdb_ = const_cast< ::AnsDB*>(&::AnsDB::default_instance());
  ansnotice_ = const_cast< ::UAnsNotice*>(&::UAnsNotice::default_instance());
  anserror_ = const_cast< ::UError*>(&::UError::default_instance());
}

UAnsProtocol::UAnsProtocol(const UAnsProtocol& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UAnsProtocol::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  ansconnect_ = NULL;
  anschannel_ = NULL;
  ansstore_ = NULL;
  ansinfo_ = NULL;
  ansautojoin_ = NULL;
  ansleavegame_ = NULL;
  ansclose_ = NULL;
  anspong_ = NULL;
  ansplug_ = NULL;
  ansgameprotocol_ = NULL;
  ansdb_ = NULL;
  ansnotice_ = NULL;
  anserror_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UAnsProtocol::~UAnsProtocol() {
  SharedDtor();
}

void UAnsProtocol::SharedDtor() {
  if (this != default_instance_) {
    delete ansconnect_;
    delete anschannel_;
    delete ansstore_;
    delete ansinfo_;
    delete ansautojoin_;
    delete ansleavegame_;
    delete ansclose_;
    delete anspong_;
    delete ansplug_;
    delete ansgameprotocol_;
    delete ansdb_;
    delete ansnotice_;
    delete anserror_;
  }
}

void UAnsProtocol::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UAnsProtocol& UAnsProtocol::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ug_2eproto();  return *default_instance_;
}

UAnsProtocol* UAnsProtocol::default_instance_ = NULL;

UAnsProtocol* UAnsProtocol::New() const {
  return new UAnsProtocol;
}

void UAnsProtocol::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 1;
    if (has_ansconnect()) {
      if (ansconnect_ != NULL) ansconnect_->::UAnsConnect::Clear();
    }
    if (has_anschannel()) {
      if (anschannel_ != NULL) anschannel_->::UAnsChannel::Clear();
    }
    if (has_ansstore()) {
      if (ansstore_ != NULL) ansstore_->::UAnsStore::Clear();
    }
    if (has_ansinfo()) {
      if (ansinfo_ != NULL) ansinfo_->::UAnsInfo::Clear();
    }
    if (has_ansautojoin()) {
      if (ansautojoin_ != NULL) ansautojoin_->::UAnsAutoJoin::Clear();
    }
    if (has_ansleavegame()) {
      if (ansleavegame_ != NULL) ansleavegame_->::UAnsLeaveGame::Clear();
    }
    if (has_ansclose()) {
      if (ansclose_ != NULL) ansclose_->::UAnsClose::Clear();
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_anspong()) {
      if (anspong_ != NULL) anspong_->::UAnsPong::Clear();
    }
    if (has_ansplug()) {
      if (ansplug_ != NULL) ansplug_->::UAnsPlug::Clear();
    }
    if (has_ansgameprotocol()) {
      if (ansgameprotocol_ != NULL) ansgameprotocol_->::GLAnsGameProtocol::Clear();
    }
    if (has_ansdb()) {
      if (ansdb_ != NULL) ansdb_->::AnsDB::Clear();
    }
    if (has_ansnotice()) {
      if (ansnotice_ != NULL) ansnotice_->::UAnsNotice::Clear();
    }
    if (has_anserror()) {
      if (anserror_ != NULL) anserror_->::UError::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UAnsProtocol::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .UAnsProtocol.Type type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::UAnsProtocol_Type_IsValid(value)) {
            set_type(static_cast< ::UAnsProtocol_Type >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_ansConnect;
        break;
      }
      
      // optional .UAnsConnect ansConnect = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ansConnect:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ansconnect()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_ansChannel;
        break;
      }
      
      // optional .UAnsChannel ansChannel = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ansChannel:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_anschannel()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_ansStore;
        break;
      }
      
      // optional .UAnsStore ansStore = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ansStore:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ansstore()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_ansInfo;
        break;
      }
      
      // optional .UAnsInfo ansInfo = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ansInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ansinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_ansAutoJoin;
        break;
      }
      
      // optional .UAnsAutoJoin ansAutoJoin = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ansAutoJoin:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ansautojoin()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_ansLeaveGame;
        break;
      }
      
      // optional .UAnsLeaveGame ansLeaveGame = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ansLeaveGame:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ansleavegame()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_ansClose;
        break;
      }
      
      // optional .UAnsClose ansClose = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ansClose:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ansclose()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_ansPong;
        break;
      }
      
      // optional .UAnsPong ansPong = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ansPong:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_anspong()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_ansPlug;
        break;
      }
      
      // optional .UAnsPlug ansPlug = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ansPlug:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ansplug()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_ansGameProtocol;
        break;
      }
      
      // optional .GLAnsGameProtocol ansGameProtocol = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ansGameProtocol:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ansgameprotocol()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(98)) goto parse_ansDB;
        break;
      }
      
      // optional .AnsDB ansDB = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ansDB:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ansdb()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(106)) goto parse_ansNotice;
        break;
      }
      
      // optional .UAnsNotice ansNotice = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ansNotice:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ansnotice()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(114)) goto parse_ansError;
        break;
      }
      
      // optional .UError ansError = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ansError:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_anserror()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UAnsProtocol::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .UAnsProtocol.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }
  
  // optional .UAnsConnect ansConnect = 2;
  if (has_ansconnect()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->ansconnect(), output);
  }
  
  // optional .UAnsChannel ansChannel = 3;
  if (has_anschannel()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->anschannel(), output);
  }
  
  // optional .UAnsStore ansStore = 4;
  if (has_ansstore()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->ansstore(), output);
  }
  
  // optional .UAnsInfo ansInfo = 5;
  if (has_ansinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->ansinfo(), output);
  }
  
  // optional .UAnsAutoJoin ansAutoJoin = 6;
  if (has_ansautojoin()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->ansautojoin(), output);
  }
  
  // optional .UAnsLeaveGame ansLeaveGame = 7;
  if (has_ansleavegame()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, this->ansleavegame(), output);
  }
  
  // optional .UAnsClose ansClose = 8;
  if (has_ansclose()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, this->ansclose(), output);
  }
  
  // optional .UAnsPong ansPong = 9;
  if (has_anspong()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      9, this->anspong(), output);
  }
  
  // optional .UAnsPlug ansPlug = 10;
  if (has_ansplug()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      10, this->ansplug(), output);
  }
  
  // optional .GLAnsGameProtocol ansGameProtocol = 11;
  if (has_ansgameprotocol()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      11, this->ansgameprotocol(), output);
  }
  
  // optional .AnsDB ansDB = 12;
  if (has_ansdb()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      12, this->ansdb(), output);
  }
  
  // optional .UAnsNotice ansNotice = 13;
  if (has_ansnotice()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      13, this->ansnotice(), output);
  }
  
  // optional .UError ansError = 14;
  if (has_anserror()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      14, this->anserror(), output);
  }
  
}

int UAnsProtocol::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .UAnsProtocol.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }
    
    // optional .UAnsConnect ansConnect = 2;
    if (has_ansconnect()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ansconnect());
    }
    
    // optional .UAnsChannel ansChannel = 3;
    if (has_anschannel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->anschannel());
    }
    
    // optional .UAnsStore ansStore = 4;
    if (has_ansstore()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ansstore());
    }
    
    // optional .UAnsInfo ansInfo = 5;
    if (has_ansinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ansinfo());
    }
    
    // optional .UAnsAutoJoin ansAutoJoin = 6;
    if (has_ansautojoin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ansautojoin());
    }
    
    // optional .UAnsLeaveGame ansLeaveGame = 7;
    if (has_ansleavegame()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ansleavegame());
    }
    
    // optional .UAnsClose ansClose = 8;
    if (has_ansclose()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ansclose());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .UAnsPong ansPong = 9;
    if (has_anspong()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->anspong());
    }
    
    // optional .UAnsPlug ansPlug = 10;
    if (has_ansplug()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ansplug());
    }
    
    // optional .GLAnsGameProtocol ansGameProtocol = 11;
    if (has_ansgameprotocol()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ansgameprotocol());
    }
    
    // optional .AnsDB ansDB = 12;
    if (has_ansdb()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ansdb());
    }
    
    // optional .UAnsNotice ansNotice = 13;
    if (has_ansnotice()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ansnotice());
    }
    
    // optional .UError ansError = 14;
    if (has_anserror()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->anserror());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UAnsProtocol::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UAnsProtocol*>(&from));
}

void UAnsProtocol::MergeFrom(const UAnsProtocol& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_ansconnect()) {
      mutable_ansconnect()->::UAnsConnect::MergeFrom(from.ansconnect());
    }
    if (from.has_anschannel()) {
      mutable_anschannel()->::UAnsChannel::MergeFrom(from.anschannel());
    }
    if (from.has_ansstore()) {
      mutable_ansstore()->::UAnsStore::MergeFrom(from.ansstore());
    }
    if (from.has_ansinfo()) {
      mutable_ansinfo()->::UAnsInfo::MergeFrom(from.ansinfo());
    }
    if (from.has_ansautojoin()) {
      mutable_ansautojoin()->::UAnsAutoJoin::MergeFrom(from.ansautojoin());
    }
    if (from.has_ansleavegame()) {
      mutable_ansleavegame()->::UAnsLeaveGame::MergeFrom(from.ansleavegame());
    }
    if (from.has_ansclose()) {
      mutable_ansclose()->::UAnsClose::MergeFrom(from.ansclose());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_anspong()) {
      mutable_anspong()->::UAnsPong::MergeFrom(from.anspong());
    }
    if (from.has_ansplug()) {
      mutable_ansplug()->::UAnsPlug::MergeFrom(from.ansplug());
    }
    if (from.has_ansgameprotocol()) {
      mutable_ansgameprotocol()->::GLAnsGameProtocol::MergeFrom(from.ansgameprotocol());
    }
    if (from.has_ansdb()) {
      mutable_ansdb()->::AnsDB::MergeFrom(from.ansdb());
    }
    if (from.has_ansnotice()) {
      mutable_ansnotice()->::UAnsNotice::MergeFrom(from.ansnotice());
    }
    if (from.has_anserror()) {
      mutable_anserror()->::UError::MergeFrom(from.anserror());
    }
  }
}

void UAnsProtocol::CopyFrom(const UAnsProtocol& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UAnsProtocol::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_ansconnect()) {
    if (!this->ansconnect().IsInitialized()) return false;
  }
  if (has_anschannel()) {
    if (!this->anschannel().IsInitialized()) return false;
  }
  if (has_ansstore()) {
    if (!this->ansstore().IsInitialized()) return false;
  }
  if (has_ansinfo()) {
    if (!this->ansinfo().IsInitialized()) return false;
  }
  if (has_ansautojoin()) {
    if (!this->ansautojoin().IsInitialized()) return false;
  }
  if (has_ansleavegame()) {
    if (!this->ansleavegame().IsInitialized()) return false;
  }
  if (has_anspong()) {
    if (!this->anspong().IsInitialized()) return false;
  }
  if (has_ansplug()) {
    if (!this->ansplug().IsInitialized()) return false;
  }
  if (has_ansgameprotocol()) {
    if (!this->ansgameprotocol().IsInitialized()) return false;
  }
  if (has_ansdb()) {
    if (!this->ansdb().IsInitialized()) return false;
  }
  if (has_ansnotice()) {
    if (!this->ansnotice().IsInitialized()) return false;
  }
  if (has_anserror()) {
    if (!this->anserror().IsInitialized()) return false;
  }
  return true;
}

void UAnsProtocol::Swap(UAnsProtocol* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(ansconnect_, other->ansconnect_);
    std::swap(anschannel_, other->anschannel_);
    std::swap(ansstore_, other->ansstore_);
    std::swap(ansinfo_, other->ansinfo_);
    std::swap(ansautojoin_, other->ansautojoin_);
    std::swap(ansleavegame_, other->ansleavegame_);
    std::swap(ansclose_, other->ansclose_);
    std::swap(anspong_, other->anspong_);
    std::swap(ansplug_, other->ansplug_);
    std::swap(ansgameprotocol_, other->ansgameprotocol_);
    std::swap(ansdb_, other->ansdb_);
    std::swap(ansnotice_, other->ansnotice_);
    std::swap(anserror_, other->anserror_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UAnsProtocol::GetTypeName() const {
  return "UAnsProtocol";
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
