// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ug.proto

#ifndef PROTOBUF_ug_2eproto__INCLUDED
#define PROTOBUF_ug_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "db.pb.h"
#include "gameLogic.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ug_2eproto();
void protobuf_AssignDesc_ug_2eproto();
void protobuf_ShutdownFile_ug_2eproto();

class Version;
class Error;
class Desc;
class Notice;
class UError;
class UReqConnect;
class UAnsConnect;
class UReqNotice;
class UAnsNotice;
class UReqChannel;
class UAnsChannel;
class UErrChannel;
class UReqStore;
class UAnsStore;
class UReqInfo;
class UAnsInfo;
class UReqAutoJoin;
class UAnsAutoJoin;
class UReqLeaveGame;
class UAnsLeaveGame;
class UReqClose;
class UAnsClose;
class UReqPing;
class UAnsPong;
class UReqPlug;
class UAnsPlug;
class UReqProtocol;
class UAnsProtocol;

enum UError_EErrorType {
  UError_EErrorType_EET_VERSION_INCORRECT = 1,
  UError_EErrorType_EET_DATABASE = 2,
  UError_EErrorType_EET_INTERNAL = 3,
  UError_EErrorType_EET_ALREADY_LOGGED = 4,
  UError_EErrorType_EET_NOT_LOGGED = 5,
  UError_EErrorType_EET_ALREADY_PLAYING = 6,
  UError_EErrorType_EET_NOT_PLAYING = 7,
  UError_EErrorType_EET_CANT_PLUG_GS = 8,
  UError_EErrorType_EET_INVALID_VALUE = 9,
  UError_EErrorType_EET_TIME_OUT = 10,
  UError_EErrorType_EET_UNDEFINE = 11,
  UError_EErrorType_EET_MAX_REFILL = 12,
  UError_EErrorType_EET_OVER_USER = 13
};
bool UError_EErrorType_IsValid(int value);
const UError_EErrorType UError_EErrorType_EErrorType_MIN = UError_EErrorType_EET_VERSION_INCORRECT;
const UError_EErrorType UError_EErrorType_EErrorType_MAX = UError_EErrorType_EET_OVER_USER;
const int UError_EErrorType_EErrorType_ARRAYSIZE = UError_EErrorType_EErrorType_MAX + 1;

enum UAnsLeaveGame_KICK_TYPE {
  UAnsLeaveGame_KICK_TYPE_EXIT_RESERVATION = 1,
  UAnsLeaveGame_KICK_TYPE_LIMITMONEY = 2,
  UAnsLeaveGame_KICK_TYPE_ALLIN = 3,
  UAnsLeaveGame_KICK_TYPE_SYSTEM_ERROR = 4,
  UAnsLeaveGame_KICK_TYPE_KICK_ZERO = 5
};
bool UAnsLeaveGame_KICK_TYPE_IsValid(int value);
const UAnsLeaveGame_KICK_TYPE UAnsLeaveGame_KICK_TYPE_KICK_TYPE_MIN = UAnsLeaveGame_KICK_TYPE_EXIT_RESERVATION;
const UAnsLeaveGame_KICK_TYPE UAnsLeaveGame_KICK_TYPE_KICK_TYPE_MAX = UAnsLeaveGame_KICK_TYPE_KICK_ZERO;
const int UAnsLeaveGame_KICK_TYPE_KICK_TYPE_ARRAYSIZE = UAnsLeaveGame_KICK_TYPE_KICK_TYPE_MAX + 1;

enum UReqProtocol_Type {
  UReqProtocol_Type_NONE = 1,
  UReqProtocol_Type_UREQCONNECT = 2,
  UReqProtocol_Type_UREQCHANNEL = 3,
  UReqProtocol_Type_UREQSTORE = 4,
  UReqProtocol_Type_UREQINFO = 5,
  UReqProtocol_Type_UREQAUTOJOIN = 6,
  UReqProtocol_Type_UREQLEAVEGAME = 7,
  UReqProtocol_Type_UREQCLOSE = 8,
  UReqProtocol_Type_UREQPING = 9,
  UReqProtocol_Type_UREQPLUG = 10,
  UReqProtocol_Type_GLREQGAMEPROTOCOL = 11,
  UReqProtocol_Type_UREQDB = 12,
  UReqProtocol_Type_UREQNOTICE = 13
};
bool UReqProtocol_Type_IsValid(int value);
const UReqProtocol_Type UReqProtocol_Type_Type_MIN = UReqProtocol_Type_NONE;
const UReqProtocol_Type UReqProtocol_Type_Type_MAX = UReqProtocol_Type_UREQNOTICE;
const int UReqProtocol_Type_Type_ARRAYSIZE = UReqProtocol_Type_Type_MAX + 1;

enum UAnsProtocol_Type {
  UAnsProtocol_Type_NONE = 1,
  UAnsProtocol_Type_UANSCONNECT = 2,
  UAnsProtocol_Type_UANSCHANNEL = 3,
  UAnsProtocol_Type_UANSSTORE = 4,
  UAnsProtocol_Type_UANSINFO = 5,
  UAnsProtocol_Type_UANSAUTOJOIN = 6,
  UAnsProtocol_Type_UANSLEAVEGAME = 7,
  UAnsProtocol_Type_UANSCLOSE = 8,
  UAnsProtocol_Type_UANSPONG = 9,
  UAnsProtocol_Type_UANSPLUG = 10,
  UAnsProtocol_Type_GLANSGAMEPROTOCOL = 11,
  UAnsProtocol_Type_UANSDB = 12,
  UAnsProtocol_Type_UANSNOTICE = 13,
  UAnsProtocol_Type_UERROR = 14
};
bool UAnsProtocol_Type_IsValid(int value);
const UAnsProtocol_Type UAnsProtocol_Type_Type_MIN = UAnsProtocol_Type_NONE;
const UAnsProtocol_Type UAnsProtocol_Type_Type_MAX = UAnsProtocol_Type_UERROR;
const int UAnsProtocol_Type_Type_ARRAYSIZE = UAnsProtocol_Type_Type_MAX + 1;

// ===================================================================

class Version : public ::google::protobuf::MessageLite {
 public:
  Version();
  virtual ~Version();
  
  Version(const Version& from);
  
  inline Version& operator=(const Version& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Version& default_instance();
  
  void Swap(Version* other);
  
  // implements Message ----------------------------------------------
  
  Version* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Version& from);
  void MergeFrom(const Version& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 major = 1;
  inline bool has_major() const;
  inline void clear_major();
  static const int kMajorFieldNumber = 1;
  inline ::google::protobuf::int32 major() const;
  inline void set_major(::google::protobuf::int32 value);
  
  // required int32 minor = 2;
  inline bool has_minor() const;
  inline void clear_minor();
  static const int kMinorFieldNumber = 2;
  inline ::google::protobuf::int32 minor() const;
  inline void set_minor(::google::protobuf::int32 value);
  
  // required int32 sub = 3;
  inline bool has_sub() const;
  inline void clear_sub();
  static const int kSubFieldNumber = 3;
  inline ::google::protobuf::int32 sub() const;
  inline void set_sub(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:Version)
 private:
  inline void set_has_major();
  inline void clear_has_major();
  inline void set_has_minor();
  inline void clear_has_minor();
  inline void set_has_sub();
  inline void clear_has_sub();
  
  ::google::protobuf::int32 major_;
  ::google::protobuf::int32 minor_;
  ::google::protobuf::int32 sub_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_ug_2eproto();
  friend void protobuf_AssignDesc_ug_2eproto();
  friend void protobuf_ShutdownFile_ug_2eproto();
  
  void InitAsDefaultInstance();
  static Version* default_instance_;
};
// -------------------------------------------------------------------

class Error : public ::google::protobuf::MessageLite {
 public:
  Error();
  virtual ~Error();
  
  Error(const Error& from);
  
  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Error& default_instance();
  
  void Swap(Error* other);
  
  // implements Message ----------------------------------------------
  
  Error* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Error& from);
  void MergeFrom(const Error& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 errorCode = 1;
  inline bool has_errorcode() const;
  inline void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::int32 errorcode() const;
  inline void set_errorcode(::google::protobuf::int32 value);
  
  // required string errorInfo = 2;
  inline bool has_errorinfo() const;
  inline void clear_errorinfo();
  static const int kErrorInfoFieldNumber = 2;
  inline const ::std::string& errorinfo() const;
  inline void set_errorinfo(const ::std::string& value);
  inline void set_errorinfo(const char* value);
  inline void set_errorinfo(const char* value, size_t size);
  inline ::std::string* mutable_errorinfo();
  inline ::std::string* release_errorinfo();
  
  // required int32 reqMode = 3;
  inline bool has_reqmode() const;
  inline void clear_reqmode();
  static const int kReqModeFieldNumber = 3;
  inline ::google::protobuf::int32 reqmode() const;
  inline void set_reqmode(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:Error)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_errorinfo();
  inline void clear_has_errorinfo();
  inline void set_has_reqmode();
  inline void clear_has_reqmode();
  
  ::std::string* errorinfo_;
  ::google::protobuf::int32 errorcode_;
  ::google::protobuf::int32 reqmode_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_ug_2eproto();
  friend void protobuf_AssignDesc_ug_2eproto();
  friend void protobuf_ShutdownFile_ug_2eproto();
  
  void InitAsDefaultInstance();
  static Error* default_instance_;
};
// -------------------------------------------------------------------

class Desc : public ::google::protobuf::MessageLite {
 public:
  Desc();
  virtual ~Desc();
  
  Desc(const Desc& from);
  
  inline Desc& operator=(const Desc& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Desc& default_instance();
  
  void Swap(Desc* other);
  
  // implements Message ----------------------------------------------
  
  Desc* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Desc& from);
  void MergeFrom(const Desc& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // required string desc = 2;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 2;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  
  // @@protoc_insertion_point(class_scope:Desc)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_desc();
  inline void clear_has_desc();
  
  ::std::string* desc_;
  ::google::protobuf::int32 id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ug_2eproto();
  friend void protobuf_AssignDesc_ug_2eproto();
  friend void protobuf_ShutdownFile_ug_2eproto();
  
  void InitAsDefaultInstance();
  static Desc* default_instance_;
};
// -------------------------------------------------------------------

class Notice : public ::google::protobuf::MessageLite {
 public:
  Notice();
  virtual ~Notice();
  
  Notice(const Notice& from);
  
  inline Notice& operator=(const Notice& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Notice& default_instance();
  
  void Swap(Notice* other);
  
  // implements Message ----------------------------------------------
  
  Notice* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Notice& from);
  void MergeFrom(const Notice& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool popup = 1;
  inline bool has_popup() const;
  inline void clear_popup();
  static const int kPopupFieldNumber = 1;
  inline bool popup() const;
  inline void set_popup(bool value);
  
  // required int32 srl = 2;
  inline bool has_srl() const;
  inline void clear_srl();
  static const int kSrlFieldNumber = 2;
  inline ::google::protobuf::int32 srl() const;
  inline void set_srl(::google::protobuf::int32 value);
  
  // required string notice = 3;
  inline bool has_notice() const;
  inline void clear_notice();
  static const int kNoticeFieldNumber = 3;
  inline const ::std::string& notice() const;
  inline void set_notice(const ::std::string& value);
  inline void set_notice(const char* value);
  inline void set_notice(const char* value, size_t size);
  inline ::std::string* mutable_notice();
  inline ::std::string* release_notice();
  
  // @@protoc_insertion_point(class_scope:Notice)
 private:
  inline void set_has_popup();
  inline void clear_has_popup();
  inline void set_has_srl();
  inline void clear_has_srl();
  inline void set_has_notice();
  inline void clear_has_notice();
  
  bool popup_;
  ::google::protobuf::int32 srl_;
  ::std::string* notice_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_ug_2eproto();
  friend void protobuf_AssignDesc_ug_2eproto();
  friend void protobuf_ShutdownFile_ug_2eproto();
  
  void InitAsDefaultInstance();
  static Notice* default_instance_;
};
// -------------------------------------------------------------------

class UError : public ::google::protobuf::MessageLite {
 public:
  UError();
  virtual ~UError();
  
  UError(const UError& from);
  
  inline UError& operator=(const UError& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const UError& default_instance();
  
  void Swap(UError* other);
  
  // implements Message ----------------------------------------------
  
  UError* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UError& from);
  void MergeFrom(const UError& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef UError_EErrorType EErrorType;
  static const EErrorType EET_VERSION_INCORRECT = UError_EErrorType_EET_VERSION_INCORRECT;
  static const EErrorType EET_DATABASE = UError_EErrorType_EET_DATABASE;
  static const EErrorType EET_INTERNAL = UError_EErrorType_EET_INTERNAL;
  static const EErrorType EET_ALREADY_LOGGED = UError_EErrorType_EET_ALREADY_LOGGED;
  static const EErrorType EET_NOT_LOGGED = UError_EErrorType_EET_NOT_LOGGED;
  static const EErrorType EET_ALREADY_PLAYING = UError_EErrorType_EET_ALREADY_PLAYING;
  static const EErrorType EET_NOT_PLAYING = UError_EErrorType_EET_NOT_PLAYING;
  static const EErrorType EET_CANT_PLUG_GS = UError_EErrorType_EET_CANT_PLUG_GS;
  static const EErrorType EET_INVALID_VALUE = UError_EErrorType_EET_INVALID_VALUE;
  static const EErrorType EET_TIME_OUT = UError_EErrorType_EET_TIME_OUT;
  static const EErrorType EET_UNDEFINE = UError_EErrorType_EET_UNDEFINE;
  static const EErrorType EET_MAX_REFILL = UError_EErrorType_EET_MAX_REFILL;
  static const EErrorType EET_OVER_USER = UError_EErrorType_EET_OVER_USER;
  static inline bool EErrorType_IsValid(int value) {
    return UError_EErrorType_IsValid(value);
  }
  static const EErrorType EErrorType_MIN =
    UError_EErrorType_EErrorType_MIN;
  static const EErrorType EErrorType_MAX =
    UError_EErrorType_EErrorType_MAX;
  static const int EErrorType_ARRAYSIZE =
    UError_EErrorType_EErrorType_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required .Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::Error& error() const;
  inline ::Error* mutable_error();
  inline ::Error* release_error();
  
  // @@protoc_insertion_point(class_scope:UError)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::Error* error_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ug_2eproto();
  friend void protobuf_AssignDesc_ug_2eproto();
  friend void protobuf_ShutdownFile_ug_2eproto();
  
  void InitAsDefaultInstance();
  static UError* default_instance_;
};
// -------------------------------------------------------------------

class UReqConnect : public ::google::protobuf::MessageLite {
 public:
  UReqConnect();
  virtual ~UReqConnect();
  
  UReqConnect(const UReqConnect& from);
  
  inline UReqConnect& operator=(const UReqConnect& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const UReqConnect& default_instance();
  
  void Swap(UReqConnect* other);
  
  // implements Message ----------------------------------------------
  
  UReqConnect* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UReqConnect& from);
  void MergeFrom(const UReqConnect& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 svcID = 1;
  inline bool has_svcid() const;
  inline void clear_svcid();
  static const int kSvcIDFieldNumber = 1;
  inline ::google::protobuf::int32 svcid() const;
  inline void set_svcid(::google::protobuf::int32 value);
  
  // required int32 gameID = 2;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 2;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 lastCloseTime = 3;
  inline bool has_lastclosetime() const;
  inline void clear_lastclosetime();
  static const int kLastCloseTimeFieldNumber = 3;
  inline ::google::protobuf::int32 lastclosetime() const;
  inline void set_lastclosetime(::google::protobuf::int32 value);
  
  // required .Version programVer = 4;
  inline bool has_programver() const;
  inline void clear_programver();
  static const int kProgramVerFieldNumber = 4;
  inline const ::Version& programver() const;
  inline ::Version* mutable_programver();
  inline ::Version* release_programver();
  
  // required .Version protoVer = 5;
  inline bool has_protover() const;
  inline void clear_protover();
  static const int kProtoVerFieldNumber = 5;
  inline const ::Version& protover() const;
  inline ::Version* mutable_protover();
  inline ::Version* release_protover();
  
  // required .MemberInfo memberInfo = 6;
  inline bool has_memberinfo() const;
  inline void clear_memberinfo();
  static const int kMemberInfoFieldNumber = 6;
  inline const ::MemberInfo& memberinfo() const;
  inline ::MemberInfo* mutable_memberinfo();
  inline ::MemberInfo* release_memberinfo();
  
  // @@protoc_insertion_point(class_scope:UReqConnect)
 private:
  inline void set_has_svcid();
  inline void clear_has_svcid();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_lastclosetime();
  inline void clear_has_lastclosetime();
  inline void set_has_programver();
  inline void clear_has_programver();
  inline void set_has_protover();
  inline void clear_has_protover();
  inline void set_has_memberinfo();
  inline void clear_has_memberinfo();
  
  ::google::protobuf::int32 svcid_;
  ::google::protobuf::int32 gameid_;
  ::Version* programver_;
  ::Version* protover_;
  ::MemberInfo* memberinfo_;
  ::google::protobuf::int32 lastclosetime_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_ug_2eproto();
  friend void protobuf_AssignDesc_ug_2eproto();
  friend void protobuf_ShutdownFile_ug_2eproto();
  
  void InitAsDefaultInstance();
  static UReqConnect* default_instance_;
};
// -------------------------------------------------------------------

class UAnsConnect : public ::google::protobuf::MessageLite {
 public:
  UAnsConnect();
  virtual ~UAnsConnect();
  
  UAnsConnect(const UAnsConnect& from);
  
  inline UAnsConnect& operator=(const UAnsConnect& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const UAnsConnect& default_instance();
  
  void Swap(UAnsConnect* other);
  
  // implements Message ----------------------------------------------
  
  UAnsConnect* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UAnsConnect& from);
  void MergeFrom(const UAnsConnect& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 svcID = 1;
  inline bool has_svcid() const;
  inline void clear_svcid();
  static const int kSvcIDFieldNumber = 1;
  inline ::google::protobuf::int32 svcid() const;
  inline void set_svcid(::google::protobuf::int32 value);
  
  // required int32 gameID = 2;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 2;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);
  
  // required string ip = 4;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 4;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  
  // required int32 port = 5;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 5;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);
  
  // required string passwd = 6;
  inline bool has_passwd() const;
  inline void clear_passwd();
  static const int kPasswdFieldNumber = 6;
  inline const ::std::string& passwd() const;
  inline void set_passwd(const ::std::string& value);
  inline void set_passwd(const char* value);
  inline void set_passwd(const char* value, size_t size);
  inline ::std::string* mutable_passwd();
  inline ::std::string* release_passwd();
  
  // @@protoc_insertion_point(class_scope:UAnsConnect)
 private:
  inline void set_has_svcid();
  inline void clear_has_svcid();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_passwd();
  inline void clear_has_passwd();
  
  ::google::protobuf::int32 svcid_;
  ::google::protobuf::int32 gameid_;
  ::std::string* ip_;
  ::google::protobuf::int32 status_;
  ::google::protobuf::int32 port_;
  ::std::string* passwd_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_ug_2eproto();
  friend void protobuf_AssignDesc_ug_2eproto();
  friend void protobuf_ShutdownFile_ug_2eproto();
  
  void InitAsDefaultInstance();
  static UAnsConnect* default_instance_;
};
// -------------------------------------------------------------------

class UReqNotice : public ::google::protobuf::MessageLite {
 public:
  UReqNotice();
  virtual ~UReqNotice();
  
  UReqNotice(const UReqNotice& from);
  
  inline UReqNotice& operator=(const UReqNotice& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const UReqNotice& default_instance();
  
  void Swap(UReqNotice* other);
  
  // implements Message ----------------------------------------------
  
  UReqNotice* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UReqNotice& from);
  void MergeFrom(const UReqNotice& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:UReqNotice)
 private:
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_ug_2eproto();
  friend void protobuf_AssignDesc_ug_2eproto();
  friend void protobuf_ShutdownFile_ug_2eproto();
  
  void InitAsDefaultInstance();
  static UReqNotice* default_instance_;
};
// -------------------------------------------------------------------

class UAnsNotice : public ::google::protobuf::MessageLite {
 public:
  UAnsNotice();
  virtual ~UAnsNotice();
  
  UAnsNotice(const UAnsNotice& from);
  
  inline UAnsNotice& operator=(const UAnsNotice& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const UAnsNotice& default_instance();
  
  void Swap(UAnsNotice* other);
  
  // implements Message ----------------------------------------------
  
  UAnsNotice* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UAnsNotice& from);
  void MergeFrom(const UAnsNotice& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .Notice notices = 1;
  inline int notices_size() const;
  inline void clear_notices();
  static const int kNoticesFieldNumber = 1;
  inline const ::Notice& notices(int index) const;
  inline ::Notice* mutable_notices(int index);
  inline ::Notice* add_notices();
  inline const ::google::protobuf::RepeatedPtrField< ::Notice >&
      notices() const;
  inline ::google::protobuf::RepeatedPtrField< ::Notice >*
      mutable_notices();
  
  // @@protoc_insertion_point(class_scope:UAnsNotice)
 private:
  
  ::google::protobuf::RepeatedPtrField< ::Notice > notices_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ug_2eproto();
  friend void protobuf_AssignDesc_ug_2eproto();
  friend void protobuf_ShutdownFile_ug_2eproto();
  
  void InitAsDefaultInstance();
  static UAnsNotice* default_instance_;
};
// -------------------------------------------------------------------

class UReqChannel : public ::google::protobuf::MessageLite {
 public:
  UReqChannel();
  virtual ~UReqChannel();
  
  UReqChannel(const UReqChannel& from);
  
  inline UReqChannel& operator=(const UReqChannel& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const UReqChannel& default_instance();
  
  void Swap(UReqChannel* other);
  
  // implements Message ----------------------------------------------
  
  UReqChannel* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UReqChannel& from);
  void MergeFrom(const UReqChannel& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:UReqChannel)
 private:
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_ug_2eproto();
  friend void protobuf_AssignDesc_ug_2eproto();
  friend void protobuf_ShutdownFile_ug_2eproto();
  
  void InitAsDefaultInstance();
  static UReqChannel* default_instance_;
};
// -------------------------------------------------------------------

class UAnsChannel : public ::google::protobuf::MessageLite {
 public:
  UAnsChannel();
  virtual ~UAnsChannel();
  
  UAnsChannel(const UAnsChannel& from);
  
  inline UAnsChannel& operator=(const UAnsChannel& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const UAnsChannel& default_instance();
  
  void Swap(UAnsChannel* other);
  
  // implements Message ----------------------------------------------
  
  UAnsChannel* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UAnsChannel& from);
  void MergeFrom(const UAnsChannel& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .Desc channelInfo = 1;
  inline int channelinfo_size() const;
  inline void clear_channelinfo();
  static const int kChannelInfoFieldNumber = 1;
  inline const ::Desc& channelinfo(int index) const;
  inline ::Desc* mutable_channelinfo(int index);
  inline ::Desc* add_channelinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::Desc >&
      channelinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::Desc >*
      mutable_channelinfo();
  
  // @@protoc_insertion_point(class_scope:UAnsChannel)
 private:
  
  ::google::protobuf::RepeatedPtrField< ::Desc > channelinfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ug_2eproto();
  friend void protobuf_AssignDesc_ug_2eproto();
  friend void protobuf_ShutdownFile_ug_2eproto();
  
  void InitAsDefaultInstance();
  static UAnsChannel* default_instance_;
};
// -------------------------------------------------------------------

class UErrChannel : public ::google::protobuf::MessageLite {
 public:
  UErrChannel();
  virtual ~UErrChannel();
  
  UErrChannel(const UErrChannel& from);
  
  inline UErrChannel& operator=(const UErrChannel& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const UErrChannel& default_instance();
  
  void Swap(UErrChannel* other);
  
  // implements Message ----------------------------------------------
  
  UErrChannel* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UErrChannel& from);
  void MergeFrom(const UErrChannel& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::Error& error() const;
  inline ::Error* mutable_error();
  inline ::Error* release_error();
  
  // @@protoc_insertion_point(class_scope:UErrChannel)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::Error* error_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ug_2eproto();
  friend void protobuf_AssignDesc_ug_2eproto();
  friend void protobuf_ShutdownFile_ug_2eproto();
  
  void InitAsDefaultInstance();
  static UErrChannel* default_instance_;
};
// -------------------------------------------------------------------

class UReqStore : public ::google::protobuf::MessageLite {
 public:
  UReqStore();
  virtual ~UReqStore();
  
  UReqStore(const UReqStore& from);
  
  inline UReqStore& operator=(const UReqStore& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const UReqStore& default_instance();
  
  void Swap(UReqStore* other);
  
  // implements Message ----------------------------------------------
  
  UReqStore* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UReqStore& from);
  void MergeFrom(const UReqStore& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:UReqStore)
 private:
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_ug_2eproto();
  friend void protobuf_AssignDesc_ug_2eproto();
  friend void protobuf_ShutdownFile_ug_2eproto();
  
  void InitAsDefaultInstance();
  static UReqStore* default_instance_;
};
// -------------------------------------------------------------------

class UAnsStore : public ::google::protobuf::MessageLite {
 public:
  UAnsStore();
  virtual ~UAnsStore();
  
  UAnsStore(const UAnsStore& from);
  
  inline UAnsStore& operator=(const UAnsStore& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const UAnsStore& default_instance();
  
  void Swap(UAnsStore* other);
  
  // implements Message ----------------------------------------------
  
  UAnsStore* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UAnsStore& from);
  void MergeFrom(const UAnsStore& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .Desc itemInfo = 1;
  inline int iteminfo_size() const;
  inline void clear_iteminfo();
  static const int kItemInfoFieldNumber = 1;
  inline const ::Desc& iteminfo(int index) const;
  inline ::Desc* mutable_iteminfo(int index);
  inline ::Desc* add_iteminfo();
  inline const ::google::protobuf::RepeatedPtrField< ::Desc >&
      iteminfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::Desc >*
      mutable_iteminfo();
  
  // @@protoc_insertion_point(class_scope:UAnsStore)
 private:
  
  ::google::protobuf::RepeatedPtrField< ::Desc > iteminfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ug_2eproto();
  friend void protobuf_AssignDesc_ug_2eproto();
  friend void protobuf_ShutdownFile_ug_2eproto();
  
  void InitAsDefaultInstance();
  static UAnsStore* default_instance_;
};
// -------------------------------------------------------------------

class UReqInfo : public ::google::protobuf::MessageLite {
 public:
  UReqInfo();
  virtual ~UReqInfo();
  
  UReqInfo(const UReqInfo& from);
  
  inline UReqInfo& operator=(const UReqInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const UReqInfo& default_instance();
  
  void Swap(UReqInfo* other);
  
  // implements Message ----------------------------------------------
  
  UReqInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UReqInfo& from);
  void MergeFrom(const UReqInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:UReqInfo)
 private:
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_ug_2eproto();
  friend void protobuf_AssignDesc_ug_2eproto();
  friend void protobuf_ShutdownFile_ug_2eproto();
  
  void InitAsDefaultInstance();
  static UReqInfo* default_instance_;
};
// -------------------------------------------------------------------

class UAnsInfo : public ::google::protobuf::MessageLite {
 public:
  UAnsInfo();
  virtual ~UAnsInfo();
  
  UAnsInfo(const UAnsInfo& from);
  
  inline UAnsInfo& operator=(const UAnsInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const UAnsInfo& default_instance();
  
  void Swap(UAnsInfo* other);
  
  // implements Message ----------------------------------------------
  
  UAnsInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UAnsInfo& from);
  void MergeFrom(const UAnsInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .GameInfo gameInfo = 1;
  inline bool has_gameinfo() const;
  inline void clear_gameinfo();
  static const int kGameInfoFieldNumber = 1;
  inline const ::GameInfo& gameinfo() const;
  inline ::GameInfo* mutable_gameinfo();
  inline ::GameInfo* release_gameinfo();
  
  // @@protoc_insertion_point(class_scope:UAnsInfo)
 private:
  inline void set_has_gameinfo();
  inline void clear_has_gameinfo();
  
  ::GameInfo* gameinfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ug_2eproto();
  friend void protobuf_AssignDesc_ug_2eproto();
  friend void protobuf_ShutdownFile_ug_2eproto();
  
  void InitAsDefaultInstance();
  static UAnsInfo* default_instance_;
};
// -------------------------------------------------------------------

class UReqAutoJoin : public ::google::protobuf::MessageLite {
 public:
  UReqAutoJoin();
  virtual ~UReqAutoJoin();
  
  UReqAutoJoin(const UReqAutoJoin& from);
  
  inline UReqAutoJoin& operator=(const UReqAutoJoin& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const UReqAutoJoin& default_instance();
  
  void Swap(UReqAutoJoin* other);
  
  // implements Message ----------------------------------------------
  
  UReqAutoJoin* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UReqAutoJoin& from);
  void MergeFrom(const UReqAutoJoin& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 categoryID = 1;
  inline bool has_categoryid() const;
  inline void clear_categoryid();
  static const int kCategoryIDFieldNumber = 1;
  inline ::google::protobuf::int32 categoryid() const;
  inline void set_categoryid(::google::protobuf::int32 value);
  
  // required int32 channelID = 2;
  inline bool has_channelid() const;
  inline void clear_channelid();
  static const int kChannelIDFieldNumber = 2;
  inline ::google::protobuf::int32 channelid() const;
  inline void set_channelid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:UReqAutoJoin)
 private:
  inline void set_has_categoryid();
  inline void clear_has_categoryid();
  inline void set_has_channelid();
  inline void clear_has_channelid();
  
  ::google::protobuf::int32 categoryid_;
  ::google::protobuf::int32 channelid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ug_2eproto();
  friend void protobuf_AssignDesc_ug_2eproto();
  friend void protobuf_ShutdownFile_ug_2eproto();
  
  void InitAsDefaultInstance();
  static UReqAutoJoin* default_instance_;
};
// -------------------------------------------------------------------

class UAnsAutoJoin : public ::google::protobuf::MessageLite {
 public:
  UAnsAutoJoin();
  virtual ~UAnsAutoJoin();
  
  UAnsAutoJoin(const UAnsAutoJoin& from);
  
  inline UAnsAutoJoin& operator=(const UAnsAutoJoin& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const UAnsAutoJoin& default_instance();
  
  void Swap(UAnsAutoJoin* other);
  
  // implements Message ----------------------------------------------
  
  UAnsAutoJoin* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UAnsAutoJoin& from);
  void MergeFrom(const UAnsAutoJoin& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .GameRoomInfo gameRoomInfo = 1;
  inline bool has_gameroominfo() const;
  inline void clear_gameroominfo();
  static const int kGameRoomInfoFieldNumber = 1;
  inline const ::GameRoomInfo& gameroominfo() const;
  inline ::GameRoomInfo* mutable_gameroominfo();
  inline ::GameRoomInfo* release_gameroominfo();
  
  // @@protoc_insertion_point(class_scope:UAnsAutoJoin)
 private:
  inline void set_has_gameroominfo();
  inline void clear_has_gameroominfo();
  
  ::GameRoomInfo* gameroominfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ug_2eproto();
  friend void protobuf_AssignDesc_ug_2eproto();
  friend void protobuf_ShutdownFile_ug_2eproto();
  
  void InitAsDefaultInstance();
  static UAnsAutoJoin* default_instance_;
};
// -------------------------------------------------------------------

class UReqLeaveGame : public ::google::protobuf::MessageLite {
 public:
  UReqLeaveGame();
  virtual ~UReqLeaveGame();
  
  UReqLeaveGame(const UReqLeaveGame& from);
  
  inline UReqLeaveGame& operator=(const UReqLeaveGame& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const UReqLeaveGame& default_instance();
  
  void Swap(UReqLeaveGame* other);
  
  // implements Message ----------------------------------------------
  
  UReqLeaveGame* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UReqLeaveGame& from);
  void MergeFrom(const UReqLeaveGame& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required bool kick = 2;
  inline bool has_kick() const;
  inline void clear_kick();
  static const int kKickFieldNumber = 2;
  inline bool kick() const;
  inline void set_kick(bool value);
  
  // @@protoc_insertion_point(class_scope:UReqLeaveGame)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_kick();
  inline void clear_has_kick();
  
  ::google::protobuf::int32 gameid_;
  bool kick_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ug_2eproto();
  friend void protobuf_AssignDesc_ug_2eproto();
  friend void protobuf_ShutdownFile_ug_2eproto();
  
  void InitAsDefaultInstance();
  static UReqLeaveGame* default_instance_;
};
// -------------------------------------------------------------------

class UAnsLeaveGame : public ::google::protobuf::MessageLite {
 public:
  UAnsLeaveGame();
  virtual ~UAnsLeaveGame();
  
  UAnsLeaveGame(const UAnsLeaveGame& from);
  
  inline UAnsLeaveGame& operator=(const UAnsLeaveGame& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const UAnsLeaveGame& default_instance();
  
  void Swap(UAnsLeaveGame* other);
  
  // implements Message ----------------------------------------------
  
  UAnsLeaveGame* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UAnsLeaveGame& from);
  void MergeFrom(const UAnsLeaveGame& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef UAnsLeaveGame_KICK_TYPE KICK_TYPE;
  static const KICK_TYPE EXIT_RESERVATION = UAnsLeaveGame_KICK_TYPE_EXIT_RESERVATION;
  static const KICK_TYPE LIMITMONEY = UAnsLeaveGame_KICK_TYPE_LIMITMONEY;
  static const KICK_TYPE ALLIN = UAnsLeaveGame_KICK_TYPE_ALLIN;
  static const KICK_TYPE SYSTEM_ERROR = UAnsLeaveGame_KICK_TYPE_SYSTEM_ERROR;
  static const KICK_TYPE KICK_ZERO = UAnsLeaveGame_KICK_TYPE_KICK_ZERO;
  static inline bool KICK_TYPE_IsValid(int value) {
    return UAnsLeaveGame_KICK_TYPE_IsValid(value);
  }
  static const KICK_TYPE KICK_TYPE_MIN =
    UAnsLeaveGame_KICK_TYPE_KICK_TYPE_MIN;
  static const KICK_TYPE KICK_TYPE_MAX =
    UAnsLeaveGame_KICK_TYPE_KICK_TYPE_MAX;
  static const int KICK_TYPE_ARRAYSIZE =
    UAnsLeaveGame_KICK_TYPE_KICK_TYPE_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required .UAnsLeaveGame.KICK_TYPE nType = 2;
  inline bool has_ntype() const;
  inline void clear_ntype();
  static const int kNTypeFieldNumber = 2;
  inline ::UAnsLeaveGame_KICK_TYPE ntype() const;
  inline void set_ntype(::UAnsLeaveGame_KICK_TYPE value);
  
  // @@protoc_insertion_point(class_scope:UAnsLeaveGame)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_ntype();
  inline void clear_has_ntype();
  
  ::google::protobuf::int32 gameid_;
  int ntype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ug_2eproto();
  friend void protobuf_AssignDesc_ug_2eproto();
  friend void protobuf_ShutdownFile_ug_2eproto();
  
  void InitAsDefaultInstance();
  static UAnsLeaveGame* default_instance_;
};
// -------------------------------------------------------------------

class UReqClose : public ::google::protobuf::MessageLite {
 public:
  UReqClose();
  virtual ~UReqClose();
  
  UReqClose(const UReqClose& from);
  
  inline UReqClose& operator=(const UReqClose& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const UReqClose& default_instance();
  
  void Swap(UReqClose* other);
  
  // implements Message ----------------------------------------------
  
  UReqClose* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UReqClose& from);
  void MergeFrom(const UReqClose& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:UReqClose)
 private:
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_ug_2eproto();
  friend void protobuf_AssignDesc_ug_2eproto();
  friend void protobuf_ShutdownFile_ug_2eproto();
  
  void InitAsDefaultInstance();
  static UReqClose* default_instance_;
};
// -------------------------------------------------------------------

class UAnsClose : public ::google::protobuf::MessageLite {
 public:
  UAnsClose();
  virtual ~UAnsClose();
  
  UAnsClose(const UAnsClose& from);
  
  inline UAnsClose& operator=(const UAnsClose& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const UAnsClose& default_instance();
  
  void Swap(UAnsClose* other);
  
  // implements Message ----------------------------------------------
  
  UAnsClose* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UAnsClose& from);
  void MergeFrom(const UAnsClose& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:UAnsClose)
 private:
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_ug_2eproto();
  friend void protobuf_AssignDesc_ug_2eproto();
  friend void protobuf_ShutdownFile_ug_2eproto();
  
  void InitAsDefaultInstance();
  static UAnsClose* default_instance_;
};
// -------------------------------------------------------------------

class UReqPing : public ::google::protobuf::MessageLite {
 public:
  UReqPing();
  virtual ~UReqPing();
  
  UReqPing(const UReqPing& from);
  
  inline UReqPing& operator=(const UReqPing& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const UReqPing& default_instance();
  
  void Swap(UReqPing* other);
  
  // implements Message ----------------------------------------------
  
  UReqPing* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UReqPing& from);
  void MergeFrom(const UReqPing& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 seq = 1;
  inline bool has_seq() const;
  inline void clear_seq();
  static const int kSeqFieldNumber = 1;
  inline ::google::protobuf::int32 seq() const;
  inline void set_seq(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:UReqPing)
 private:
  inline void set_has_seq();
  inline void clear_has_seq();
  
  ::google::protobuf::int32 seq_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ug_2eproto();
  friend void protobuf_AssignDesc_ug_2eproto();
  friend void protobuf_ShutdownFile_ug_2eproto();
  
  void InitAsDefaultInstance();
  static UReqPing* default_instance_;
};
// -------------------------------------------------------------------

class UAnsPong : public ::google::protobuf::MessageLite {
 public:
  UAnsPong();
  virtual ~UAnsPong();
  
  UAnsPong(const UAnsPong& from);
  
  inline UAnsPong& operator=(const UAnsPong& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const UAnsPong& default_instance();
  
  void Swap(UAnsPong* other);
  
  // implements Message ----------------------------------------------
  
  UAnsPong* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UAnsPong& from);
  void MergeFrom(const UAnsPong& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 seq = 1;
  inline bool has_seq() const;
  inline void clear_seq();
  static const int kSeqFieldNumber = 1;
  inline ::google::protobuf::int32 seq() const;
  inline void set_seq(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:UAnsPong)
 private:
  inline void set_has_seq();
  inline void clear_has_seq();
  
  ::google::protobuf::int32 seq_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ug_2eproto();
  friend void protobuf_AssignDesc_ug_2eproto();
  friend void protobuf_ShutdownFile_ug_2eproto();
  
  void InitAsDefaultInstance();
  static UAnsPong* default_instance_;
};
// -------------------------------------------------------------------

class UReqPlug : public ::google::protobuf::MessageLite {
 public:
  UReqPlug();
  virtual ~UReqPlug();
  
  UReqPlug(const UReqPlug& from);
  
  inline UReqPlug& operator=(const UReqPlug& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const UReqPlug& default_instance();
  
  void Swap(UReqPlug* other);
  
  // implements Message ----------------------------------------------
  
  UReqPlug* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UReqPlug& from);
  void MergeFrom(const UReqPlug& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required string passwd = 2;
  inline bool has_passwd() const;
  inline void clear_passwd();
  static const int kPasswdFieldNumber = 2;
  inline const ::std::string& passwd() const;
  inline void set_passwd(const ::std::string& value);
  inline void set_passwd(const char* value);
  inline void set_passwd(const char* value, size_t size);
  inline ::std::string* mutable_passwd();
  inline ::std::string* release_passwd();
  
  // @@protoc_insertion_point(class_scope:UReqPlug)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_passwd();
  inline void clear_has_passwd();
  
  ::std::string* passwd_;
  ::google::protobuf::int32 gameid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ug_2eproto();
  friend void protobuf_AssignDesc_ug_2eproto();
  friend void protobuf_ShutdownFile_ug_2eproto();
  
  void InitAsDefaultInstance();
  static UReqPlug* default_instance_;
};
// -------------------------------------------------------------------

class UAnsPlug : public ::google::protobuf::MessageLite {
 public:
  UAnsPlug();
  virtual ~UAnsPlug();
  
  UAnsPlug(const UAnsPlug& from);
  
  inline UAnsPlug& operator=(const UAnsPlug& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const UAnsPlug& default_instance();
  
  void Swap(UAnsPlug* other);
  
  // implements Message ----------------------------------------------
  
  UAnsPlug* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UAnsPlug& from);
  void MergeFrom(const UAnsPlug& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:UAnsPlug)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  
  ::google::protobuf::int32 gameid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ug_2eproto();
  friend void protobuf_AssignDesc_ug_2eproto();
  friend void protobuf_ShutdownFile_ug_2eproto();
  
  void InitAsDefaultInstance();
  static UAnsPlug* default_instance_;
};
// -------------------------------------------------------------------

class UReqProtocol : public ::google::protobuf::MessageLite {
 public:
  UReqProtocol();
  virtual ~UReqProtocol();
  
  UReqProtocol(const UReqProtocol& from);
  
  inline UReqProtocol& operator=(const UReqProtocol& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const UReqProtocol& default_instance();
  
  void Swap(UReqProtocol* other);
  
  // implements Message ----------------------------------------------
  
  UReqProtocol* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UReqProtocol& from);
  void MergeFrom(const UReqProtocol& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef UReqProtocol_Type Type;
  static const Type NONE = UReqProtocol_Type_NONE;
  static const Type UREQCONNECT = UReqProtocol_Type_UREQCONNECT;
  static const Type UREQCHANNEL = UReqProtocol_Type_UREQCHANNEL;
  static const Type UREQSTORE = UReqProtocol_Type_UREQSTORE;
  static const Type UREQINFO = UReqProtocol_Type_UREQINFO;
  static const Type UREQAUTOJOIN = UReqProtocol_Type_UREQAUTOJOIN;
  static const Type UREQLEAVEGAME = UReqProtocol_Type_UREQLEAVEGAME;
  static const Type UREQCLOSE = UReqProtocol_Type_UREQCLOSE;
  static const Type UREQPING = UReqProtocol_Type_UREQPING;
  static const Type UREQPLUG = UReqProtocol_Type_UREQPLUG;
  static const Type GLREQGAMEPROTOCOL = UReqProtocol_Type_GLREQGAMEPROTOCOL;
  static const Type UREQDB = UReqProtocol_Type_UREQDB;
  static const Type UREQNOTICE = UReqProtocol_Type_UREQNOTICE;
  static inline bool Type_IsValid(int value) {
    return UReqProtocol_Type_IsValid(value);
  }
  static const Type Type_MIN =
    UReqProtocol_Type_Type_MIN;
  static const Type Type_MAX =
    UReqProtocol_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    UReqProtocol_Type_Type_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required .UReqProtocol.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::UReqProtocol_Type type() const;
  inline void set_type(::UReqProtocol_Type value);
  
  // optional .UReqConnect reqConnect = 2;
  inline bool has_reqconnect() const;
  inline void clear_reqconnect();
  static const int kReqConnectFieldNumber = 2;
  inline const ::UReqConnect& reqconnect() const;
  inline ::UReqConnect* mutable_reqconnect();
  inline ::UReqConnect* release_reqconnect();
  
  // optional .UReqChannel reqChannel = 3;
  inline bool has_reqchannel() const;
  inline void clear_reqchannel();
  static const int kReqChannelFieldNumber = 3;
  inline const ::UReqChannel& reqchannel() const;
  inline ::UReqChannel* mutable_reqchannel();
  inline ::UReqChannel* release_reqchannel();
  
  // optional .UReqStore reqStore = 4;
  inline bool has_reqstore() const;
  inline void clear_reqstore();
  static const int kReqStoreFieldNumber = 4;
  inline const ::UReqStore& reqstore() const;
  inline ::UReqStore* mutable_reqstore();
  inline ::UReqStore* release_reqstore();
  
  // optional .UReqInfo reqInfo = 5;
  inline bool has_reqinfo() const;
  inline void clear_reqinfo();
  static const int kReqInfoFieldNumber = 5;
  inline const ::UReqInfo& reqinfo() const;
  inline ::UReqInfo* mutable_reqinfo();
  inline ::UReqInfo* release_reqinfo();
  
  // optional .UReqAutoJoin reqAutoJoin = 6;
  inline bool has_reqautojoin() const;
  inline void clear_reqautojoin();
  static const int kReqAutoJoinFieldNumber = 6;
  inline const ::UReqAutoJoin& reqautojoin() const;
  inline ::UReqAutoJoin* mutable_reqautojoin();
  inline ::UReqAutoJoin* release_reqautojoin();
  
  // optional .UReqLeaveGame reqLeaveGame = 7;
  inline bool has_reqleavegame() const;
  inline void clear_reqleavegame();
  static const int kReqLeaveGameFieldNumber = 7;
  inline const ::UReqLeaveGame& reqleavegame() const;
  inline ::UReqLeaveGame* mutable_reqleavegame();
  inline ::UReqLeaveGame* release_reqleavegame();
  
  // optional .UReqClose reqClose = 8;
  inline bool has_reqclose() const;
  inline void clear_reqclose();
  static const int kReqCloseFieldNumber = 8;
  inline const ::UReqClose& reqclose() const;
  inline ::UReqClose* mutable_reqclose();
  inline ::UReqClose* release_reqclose();
  
  // optional .UReqPing reqPing = 9;
  inline bool has_reqping() const;
  inline void clear_reqping();
  static const int kReqPingFieldNumber = 9;
  inline const ::UReqPing& reqping() const;
  inline ::UReqPing* mutable_reqping();
  inline ::UReqPing* release_reqping();
  
  // optional .UReqPlug reqPlug = 10;
  inline bool has_reqplug() const;
  inline void clear_reqplug();
  static const int kReqPlugFieldNumber = 10;
  inline const ::UReqPlug& reqplug() const;
  inline ::UReqPlug* mutable_reqplug();
  inline ::UReqPlug* release_reqplug();
  
  // optional .GLReqGameProtocol reqGameProtocol = 11;
  inline bool has_reqgameprotocol() const;
  inline void clear_reqgameprotocol();
  static const int kReqGameProtocolFieldNumber = 11;
  inline const ::GLReqGameProtocol& reqgameprotocol() const;
  inline ::GLReqGameProtocol* mutable_reqgameprotocol();
  inline ::GLReqGameProtocol* release_reqgameprotocol();
  
  // optional .ReqDB reqDB = 12;
  inline bool has_reqdb() const;
  inline void clear_reqdb();
  static const int kReqDBFieldNumber = 12;
  inline const ::ReqDB& reqdb() const;
  inline ::ReqDB* mutable_reqdb();
  inline ::ReqDB* release_reqdb();
  
  // optional .UReqNotice reqNotice = 13;
  inline bool has_reqnotice() const;
  inline void clear_reqnotice();
  static const int kReqNoticeFieldNumber = 13;
  inline const ::UReqNotice& reqnotice() const;
  inline ::UReqNotice* mutable_reqnotice();
  inline ::UReqNotice* release_reqnotice();
  
  // @@protoc_insertion_point(class_scope:UReqProtocol)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_reqconnect();
  inline void clear_has_reqconnect();
  inline void set_has_reqchannel();
  inline void clear_has_reqchannel();
  inline void set_has_reqstore();
  inline void clear_has_reqstore();
  inline void set_has_reqinfo();
  inline void clear_has_reqinfo();
  inline void set_has_reqautojoin();
  inline void clear_has_reqautojoin();
  inline void set_has_reqleavegame();
  inline void clear_has_reqleavegame();
  inline void set_has_reqclose();
  inline void clear_has_reqclose();
  inline void set_has_reqping();
  inline void clear_has_reqping();
  inline void set_has_reqplug();
  inline void clear_has_reqplug();
  inline void set_has_reqgameprotocol();
  inline void clear_has_reqgameprotocol();
  inline void set_has_reqdb();
  inline void clear_has_reqdb();
  inline void set_has_reqnotice();
  inline void clear_has_reqnotice();
  
  ::UReqConnect* reqconnect_;
  ::UReqChannel* reqchannel_;
  ::UReqStore* reqstore_;
  ::UReqInfo* reqinfo_;
  ::UReqAutoJoin* reqautojoin_;
  ::UReqLeaveGame* reqleavegame_;
  ::UReqClose* reqclose_;
  ::UReqPing* reqping_;
  ::UReqPlug* reqplug_;
  ::GLReqGameProtocol* reqgameprotocol_;
  ::ReqDB* reqdb_;
  ::UReqNotice* reqnotice_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];
  
  friend void  protobuf_AddDesc_ug_2eproto();
  friend void protobuf_AssignDesc_ug_2eproto();
  friend void protobuf_ShutdownFile_ug_2eproto();
  
  void InitAsDefaultInstance();
  static UReqProtocol* default_instance_;
};
// -------------------------------------------------------------------

class UAnsProtocol : public ::google::protobuf::MessageLite {
 public:
  UAnsProtocol();
  virtual ~UAnsProtocol();
  
  UAnsProtocol(const UAnsProtocol& from);
  
  inline UAnsProtocol& operator=(const UAnsProtocol& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const UAnsProtocol& default_instance();
  
  void Swap(UAnsProtocol* other);
  
  // implements Message ----------------------------------------------
  
  UAnsProtocol* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UAnsProtocol& from);
  void MergeFrom(const UAnsProtocol& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef UAnsProtocol_Type Type;
  static const Type NONE = UAnsProtocol_Type_NONE;
  static const Type UANSCONNECT = UAnsProtocol_Type_UANSCONNECT;
  static const Type UANSCHANNEL = UAnsProtocol_Type_UANSCHANNEL;
  static const Type UANSSTORE = UAnsProtocol_Type_UANSSTORE;
  static const Type UANSINFO = UAnsProtocol_Type_UANSINFO;
  static const Type UANSAUTOJOIN = UAnsProtocol_Type_UANSAUTOJOIN;
  static const Type UANSLEAVEGAME = UAnsProtocol_Type_UANSLEAVEGAME;
  static const Type UANSCLOSE = UAnsProtocol_Type_UANSCLOSE;
  static const Type UANSPONG = UAnsProtocol_Type_UANSPONG;
  static const Type UANSPLUG = UAnsProtocol_Type_UANSPLUG;
  static const Type GLANSGAMEPROTOCOL = UAnsProtocol_Type_GLANSGAMEPROTOCOL;
  static const Type UANSDB = UAnsProtocol_Type_UANSDB;
  static const Type UANSNOTICE = UAnsProtocol_Type_UANSNOTICE;
  static const Type UERROR = UAnsProtocol_Type_UERROR;
  static inline bool Type_IsValid(int value) {
    return UAnsProtocol_Type_IsValid(value);
  }
  static const Type Type_MIN =
    UAnsProtocol_Type_Type_MIN;
  static const Type Type_MAX =
    UAnsProtocol_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    UAnsProtocol_Type_Type_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required .UAnsProtocol.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::UAnsProtocol_Type type() const;
  inline void set_type(::UAnsProtocol_Type value);
  
  // optional .UAnsConnect ansConnect = 2;
  inline bool has_ansconnect() const;
  inline void clear_ansconnect();
  static const int kAnsConnectFieldNumber = 2;
  inline const ::UAnsConnect& ansconnect() const;
  inline ::UAnsConnect* mutable_ansconnect();
  inline ::UAnsConnect* release_ansconnect();
  
  // optional .UAnsChannel ansChannel = 3;
  inline bool has_anschannel() const;
  inline void clear_anschannel();
  static const int kAnsChannelFieldNumber = 3;
  inline const ::UAnsChannel& anschannel() const;
  inline ::UAnsChannel* mutable_anschannel();
  inline ::UAnsChannel* release_anschannel();
  
  // optional .UAnsStore ansStore = 4;
  inline bool has_ansstore() const;
  inline void clear_ansstore();
  static const int kAnsStoreFieldNumber = 4;
  inline const ::UAnsStore& ansstore() const;
  inline ::UAnsStore* mutable_ansstore();
  inline ::UAnsStore* release_ansstore();
  
  // optional .UAnsInfo ansInfo = 5;
  inline bool has_ansinfo() const;
  inline void clear_ansinfo();
  static const int kAnsInfoFieldNumber = 5;
  inline const ::UAnsInfo& ansinfo() const;
  inline ::UAnsInfo* mutable_ansinfo();
  inline ::UAnsInfo* release_ansinfo();
  
  // optional .UAnsAutoJoin ansAutoJoin = 6;
  inline bool has_ansautojoin() const;
  inline void clear_ansautojoin();
  static const int kAnsAutoJoinFieldNumber = 6;
  inline const ::UAnsAutoJoin& ansautojoin() const;
  inline ::UAnsAutoJoin* mutable_ansautojoin();
  inline ::UAnsAutoJoin* release_ansautojoin();
  
  // optional .UAnsLeaveGame ansLeaveGame = 7;
  inline bool has_ansleavegame() const;
  inline void clear_ansleavegame();
  static const int kAnsLeaveGameFieldNumber = 7;
  inline const ::UAnsLeaveGame& ansleavegame() const;
  inline ::UAnsLeaveGame* mutable_ansleavegame();
  inline ::UAnsLeaveGame* release_ansleavegame();
  
  // optional .UAnsClose ansClose = 8;
  inline bool has_ansclose() const;
  inline void clear_ansclose();
  static const int kAnsCloseFieldNumber = 8;
  inline const ::UAnsClose& ansclose() const;
  inline ::UAnsClose* mutable_ansclose();
  inline ::UAnsClose* release_ansclose();
  
  // optional .UAnsPong ansPong = 9;
  inline bool has_anspong() const;
  inline void clear_anspong();
  static const int kAnsPongFieldNumber = 9;
  inline const ::UAnsPong& anspong() const;
  inline ::UAnsPong* mutable_anspong();
  inline ::UAnsPong* release_anspong();
  
  // optional .UAnsPlug ansPlug = 10;
  inline bool has_ansplug() const;
  inline void clear_ansplug();
  static const int kAnsPlugFieldNumber = 10;
  inline const ::UAnsPlug& ansplug() const;
  inline ::UAnsPlug* mutable_ansplug();
  inline ::UAnsPlug* release_ansplug();
  
  // optional .GLAnsGameProtocol ansGameProtocol = 11;
  inline bool has_ansgameprotocol() const;
  inline void clear_ansgameprotocol();
  static const int kAnsGameProtocolFieldNumber = 11;
  inline const ::GLAnsGameProtocol& ansgameprotocol() const;
  inline ::GLAnsGameProtocol* mutable_ansgameprotocol();
  inline ::GLAnsGameProtocol* release_ansgameprotocol();
  
  // optional .AnsDB ansDB = 12;
  inline bool has_ansdb() const;
  inline void clear_ansdb();
  static const int kAnsDBFieldNumber = 12;
  inline const ::AnsDB& ansdb() const;
  inline ::AnsDB* mutable_ansdb();
  inline ::AnsDB* release_ansdb();
  
  // optional .UAnsNotice ansNotice = 13;
  inline bool has_ansnotice() const;
  inline void clear_ansnotice();
  static const int kAnsNoticeFieldNumber = 13;
  inline const ::UAnsNotice& ansnotice() const;
  inline ::UAnsNotice* mutable_ansnotice();
  inline ::UAnsNotice* release_ansnotice();
  
  // optional .UError ansError = 14;
  inline bool has_anserror() const;
  inline void clear_anserror();
  static const int kAnsErrorFieldNumber = 14;
  inline const ::UError& anserror() const;
  inline ::UError* mutable_anserror();
  inline ::UError* release_anserror();
  
  // @@protoc_insertion_point(class_scope:UAnsProtocol)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_ansconnect();
  inline void clear_has_ansconnect();
  inline void set_has_anschannel();
  inline void clear_has_anschannel();
  inline void set_has_ansstore();
  inline void clear_has_ansstore();
  inline void set_has_ansinfo();
  inline void clear_has_ansinfo();
  inline void set_has_ansautojoin();
  inline void clear_has_ansautojoin();
  inline void set_has_ansleavegame();
  inline void clear_has_ansleavegame();
  inline void set_has_ansclose();
  inline void clear_has_ansclose();
  inline void set_has_anspong();
  inline void clear_has_anspong();
  inline void set_has_ansplug();
  inline void clear_has_ansplug();
  inline void set_has_ansgameprotocol();
  inline void clear_has_ansgameprotocol();
  inline void set_has_ansdb();
  inline void clear_has_ansdb();
  inline void set_has_ansnotice();
  inline void clear_has_ansnotice();
  inline void set_has_anserror();
  inline void clear_has_anserror();
  
  ::UAnsConnect* ansconnect_;
  ::UAnsChannel* anschannel_;
  ::UAnsStore* ansstore_;
  ::UAnsInfo* ansinfo_;
  ::UAnsAutoJoin* ansautojoin_;
  ::UAnsLeaveGame* ansleavegame_;
  ::UAnsClose* ansclose_;
  ::UAnsPong* anspong_;
  ::UAnsPlug* ansplug_;
  ::GLAnsGameProtocol* ansgameprotocol_;
  ::AnsDB* ansdb_;
  ::UAnsNotice* ansnotice_;
  ::UError* anserror_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];
  
  friend void  protobuf_AddDesc_ug_2eproto();
  friend void protobuf_AssignDesc_ug_2eproto();
  friend void protobuf_ShutdownFile_ug_2eproto();
  
  void InitAsDefaultInstance();
  static UAnsProtocol* default_instance_;
};
// ===================================================================


// ===================================================================

// Version

// required int32 major = 1;
inline bool Version::has_major() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Version::set_has_major() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Version::clear_has_major() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Version::clear_major() {
  major_ = 0;
  clear_has_major();
}
inline ::google::protobuf::int32 Version::major() const {
  return major_;
}
inline void Version::set_major(::google::protobuf::int32 value) {
  set_has_major();
  major_ = value;
}

// required int32 minor = 2;
inline bool Version::has_minor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Version::set_has_minor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Version::clear_has_minor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Version::clear_minor() {
  minor_ = 0;
  clear_has_minor();
}
inline ::google::protobuf::int32 Version::minor() const {
  return minor_;
}
inline void Version::set_minor(::google::protobuf::int32 value) {
  set_has_minor();
  minor_ = value;
}

// required int32 sub = 3;
inline bool Version::has_sub() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Version::set_has_sub() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Version::clear_has_sub() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Version::clear_sub() {
  sub_ = 0;
  clear_has_sub();
}
inline ::google::protobuf::int32 Version::sub() const {
  return sub_;
}
inline void Version::set_sub(::google::protobuf::int32 value) {
  set_has_sub();
  sub_ = value;
}

// -------------------------------------------------------------------

// Error

// required int32 errorCode = 1;
inline bool Error::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Error::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Error::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Error::clear_errorcode() {
  errorcode_ = 0;
  clear_has_errorcode();
}
inline ::google::protobuf::int32 Error::errorcode() const {
  return errorcode_;
}
inline void Error::set_errorcode(::google::protobuf::int32 value) {
  set_has_errorcode();
  errorcode_ = value;
}

// required string errorInfo = 2;
inline bool Error::has_errorinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Error::set_has_errorinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Error::clear_has_errorinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Error::clear_errorinfo() {
  if (errorinfo_ != &::google::protobuf::internal::kEmptyString) {
    errorinfo_->clear();
  }
  clear_has_errorinfo();
}
inline const ::std::string& Error::errorinfo() const {
  return *errorinfo_;
}
inline void Error::set_errorinfo(const ::std::string& value) {
  set_has_errorinfo();
  if (errorinfo_ == &::google::protobuf::internal::kEmptyString) {
    errorinfo_ = new ::std::string;
  }
  errorinfo_->assign(value);
}
inline void Error::set_errorinfo(const char* value) {
  set_has_errorinfo();
  if (errorinfo_ == &::google::protobuf::internal::kEmptyString) {
    errorinfo_ = new ::std::string;
  }
  errorinfo_->assign(value);
}
inline void Error::set_errorinfo(const char* value, size_t size) {
  set_has_errorinfo();
  if (errorinfo_ == &::google::protobuf::internal::kEmptyString) {
    errorinfo_ = new ::std::string;
  }
  errorinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Error::mutable_errorinfo() {
  set_has_errorinfo();
  if (errorinfo_ == &::google::protobuf::internal::kEmptyString) {
    errorinfo_ = new ::std::string;
  }
  return errorinfo_;
}
inline ::std::string* Error::release_errorinfo() {
  clear_has_errorinfo();
  if (errorinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = errorinfo_;
    errorinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 reqMode = 3;
inline bool Error::has_reqmode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Error::set_has_reqmode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Error::clear_has_reqmode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Error::clear_reqmode() {
  reqmode_ = 0;
  clear_has_reqmode();
}
inline ::google::protobuf::int32 Error::reqmode() const {
  return reqmode_;
}
inline void Error::set_reqmode(::google::protobuf::int32 value) {
  set_has_reqmode();
  reqmode_ = value;
}

// -------------------------------------------------------------------

// Desc

// required int32 id = 1;
inline bool Desc::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Desc::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Desc::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Desc::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Desc::id() const {
  return id_;
}
inline void Desc::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required string desc = 2;
inline bool Desc::has_desc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Desc::set_has_desc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Desc::clear_has_desc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Desc::clear_desc() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& Desc::desc() const {
  return *desc_;
}
inline void Desc::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void Desc::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void Desc::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Desc::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  return desc_;
}
inline ::std::string* Desc::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Notice

// required bool popup = 1;
inline bool Notice::has_popup() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Notice::set_has_popup() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Notice::clear_has_popup() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Notice::clear_popup() {
  popup_ = false;
  clear_has_popup();
}
inline bool Notice::popup() const {
  return popup_;
}
inline void Notice::set_popup(bool value) {
  set_has_popup();
  popup_ = value;
}

// required int32 srl = 2;
inline bool Notice::has_srl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Notice::set_has_srl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Notice::clear_has_srl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Notice::clear_srl() {
  srl_ = 0;
  clear_has_srl();
}
inline ::google::protobuf::int32 Notice::srl() const {
  return srl_;
}
inline void Notice::set_srl(::google::protobuf::int32 value) {
  set_has_srl();
  srl_ = value;
}

// required string notice = 3;
inline bool Notice::has_notice() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Notice::set_has_notice() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Notice::clear_has_notice() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Notice::clear_notice() {
  if (notice_ != &::google::protobuf::internal::kEmptyString) {
    notice_->clear();
  }
  clear_has_notice();
}
inline const ::std::string& Notice::notice() const {
  return *notice_;
}
inline void Notice::set_notice(const ::std::string& value) {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  notice_->assign(value);
}
inline void Notice::set_notice(const char* value) {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  notice_->assign(value);
}
inline void Notice::set_notice(const char* value, size_t size) {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  notice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Notice::mutable_notice() {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  return notice_;
}
inline ::std::string* Notice::release_notice() {
  clear_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = notice_;
    notice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// UError

// required .Error error = 1;
inline bool UError::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UError::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UError::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UError::clear_error() {
  if (error_ != NULL) error_->::Error::Clear();
  clear_has_error();
}
inline const ::Error& UError::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::Error* UError::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::Error;
  return error_;
}
inline ::Error* UError::release_error() {
  clear_has_error();
  ::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// UReqConnect

// required int32 svcID = 1;
inline bool UReqConnect::has_svcid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UReqConnect::set_has_svcid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UReqConnect::clear_has_svcid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UReqConnect::clear_svcid() {
  svcid_ = 0;
  clear_has_svcid();
}
inline ::google::protobuf::int32 UReqConnect::svcid() const {
  return svcid_;
}
inline void UReqConnect::set_svcid(::google::protobuf::int32 value) {
  set_has_svcid();
  svcid_ = value;
}

// required int32 gameID = 2;
inline bool UReqConnect::has_gameid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UReqConnect::set_has_gameid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UReqConnect::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UReqConnect::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 UReqConnect::gameid() const {
  return gameid_;
}
inline void UReqConnect::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 lastCloseTime = 3;
inline bool UReqConnect::has_lastclosetime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UReqConnect::set_has_lastclosetime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UReqConnect::clear_has_lastclosetime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UReqConnect::clear_lastclosetime() {
  lastclosetime_ = 0;
  clear_has_lastclosetime();
}
inline ::google::protobuf::int32 UReqConnect::lastclosetime() const {
  return lastclosetime_;
}
inline void UReqConnect::set_lastclosetime(::google::protobuf::int32 value) {
  set_has_lastclosetime();
  lastclosetime_ = value;
}

// required .Version programVer = 4;
inline bool UReqConnect::has_programver() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UReqConnect::set_has_programver() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UReqConnect::clear_has_programver() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UReqConnect::clear_programver() {
  if (programver_ != NULL) programver_->::Version::Clear();
  clear_has_programver();
}
inline const ::Version& UReqConnect::programver() const {
  return programver_ != NULL ? *programver_ : *default_instance_->programver_;
}
inline ::Version* UReqConnect::mutable_programver() {
  set_has_programver();
  if (programver_ == NULL) programver_ = new ::Version;
  return programver_;
}
inline ::Version* UReqConnect::release_programver() {
  clear_has_programver();
  ::Version* temp = programver_;
  programver_ = NULL;
  return temp;
}

// required .Version protoVer = 5;
inline bool UReqConnect::has_protover() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UReqConnect::set_has_protover() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UReqConnect::clear_has_protover() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UReqConnect::clear_protover() {
  if (protover_ != NULL) protover_->::Version::Clear();
  clear_has_protover();
}
inline const ::Version& UReqConnect::protover() const {
  return protover_ != NULL ? *protover_ : *default_instance_->protover_;
}
inline ::Version* UReqConnect::mutable_protover() {
  set_has_protover();
  if (protover_ == NULL) protover_ = new ::Version;
  return protover_;
}
inline ::Version* UReqConnect::release_protover() {
  clear_has_protover();
  ::Version* temp = protover_;
  protover_ = NULL;
  return temp;
}

// required .MemberInfo memberInfo = 6;
inline bool UReqConnect::has_memberinfo() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UReqConnect::set_has_memberinfo() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UReqConnect::clear_has_memberinfo() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UReqConnect::clear_memberinfo() {
  if (memberinfo_ != NULL) memberinfo_->::MemberInfo::Clear();
  clear_has_memberinfo();
}
inline const ::MemberInfo& UReqConnect::memberinfo() const {
  return memberinfo_ != NULL ? *memberinfo_ : *default_instance_->memberinfo_;
}
inline ::MemberInfo* UReqConnect::mutable_memberinfo() {
  set_has_memberinfo();
  if (memberinfo_ == NULL) memberinfo_ = new ::MemberInfo;
  return memberinfo_;
}
inline ::MemberInfo* UReqConnect::release_memberinfo() {
  clear_has_memberinfo();
  ::MemberInfo* temp = memberinfo_;
  memberinfo_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// UAnsConnect

// required int32 svcID = 1;
inline bool UAnsConnect::has_svcid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UAnsConnect::set_has_svcid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UAnsConnect::clear_has_svcid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UAnsConnect::clear_svcid() {
  svcid_ = 0;
  clear_has_svcid();
}
inline ::google::protobuf::int32 UAnsConnect::svcid() const {
  return svcid_;
}
inline void UAnsConnect::set_svcid(::google::protobuf::int32 value) {
  set_has_svcid();
  svcid_ = value;
}

// required int32 gameID = 2;
inline bool UAnsConnect::has_gameid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UAnsConnect::set_has_gameid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UAnsConnect::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UAnsConnect::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 UAnsConnect::gameid() const {
  return gameid_;
}
inline void UAnsConnect::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 status = 3;
inline bool UAnsConnect::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UAnsConnect::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UAnsConnect::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UAnsConnect::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 UAnsConnect::status() const {
  return status_;
}
inline void UAnsConnect::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// required string ip = 4;
inline bool UAnsConnect::has_ip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UAnsConnect::set_has_ip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UAnsConnect::clear_has_ip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UAnsConnect::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& UAnsConnect::ip() const {
  return *ip_;
}
inline void UAnsConnect::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void UAnsConnect::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void UAnsConnect::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UAnsConnect::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* UAnsConnect::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 port = 5;
inline bool UAnsConnect::has_port() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UAnsConnect::set_has_port() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UAnsConnect::clear_has_port() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UAnsConnect::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 UAnsConnect::port() const {
  return port_;
}
inline void UAnsConnect::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// required string passwd = 6;
inline bool UAnsConnect::has_passwd() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UAnsConnect::set_has_passwd() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UAnsConnect::clear_has_passwd() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UAnsConnect::clear_passwd() {
  if (passwd_ != &::google::protobuf::internal::kEmptyString) {
    passwd_->clear();
  }
  clear_has_passwd();
}
inline const ::std::string& UAnsConnect::passwd() const {
  return *passwd_;
}
inline void UAnsConnect::set_passwd(const ::std::string& value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void UAnsConnect::set_passwd(const char* value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void UAnsConnect::set_passwd(const char* value, size_t size) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UAnsConnect::mutable_passwd() {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  return passwd_;
}
inline ::std::string* UAnsConnect::release_passwd() {
  clear_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = passwd_;
    passwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// UReqNotice

// -------------------------------------------------------------------

// UAnsNotice

// repeated .Notice notices = 1;
inline int UAnsNotice::notices_size() const {
  return notices_.size();
}
inline void UAnsNotice::clear_notices() {
  notices_.Clear();
}
inline const ::Notice& UAnsNotice::notices(int index) const {
  return notices_.Get(index);
}
inline ::Notice* UAnsNotice::mutable_notices(int index) {
  return notices_.Mutable(index);
}
inline ::Notice* UAnsNotice::add_notices() {
  return notices_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Notice >&
UAnsNotice::notices() const {
  return notices_;
}
inline ::google::protobuf::RepeatedPtrField< ::Notice >*
UAnsNotice::mutable_notices() {
  return &notices_;
}

// -------------------------------------------------------------------

// UReqChannel

// -------------------------------------------------------------------

// UAnsChannel

// repeated .Desc channelInfo = 1;
inline int UAnsChannel::channelinfo_size() const {
  return channelinfo_.size();
}
inline void UAnsChannel::clear_channelinfo() {
  channelinfo_.Clear();
}
inline const ::Desc& UAnsChannel::channelinfo(int index) const {
  return channelinfo_.Get(index);
}
inline ::Desc* UAnsChannel::mutable_channelinfo(int index) {
  return channelinfo_.Mutable(index);
}
inline ::Desc* UAnsChannel::add_channelinfo() {
  return channelinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Desc >&
UAnsChannel::channelinfo() const {
  return channelinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::Desc >*
UAnsChannel::mutable_channelinfo() {
  return &channelinfo_;
}

// -------------------------------------------------------------------

// UErrChannel

// required .Error error = 1;
inline bool UErrChannel::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UErrChannel::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UErrChannel::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UErrChannel::clear_error() {
  if (error_ != NULL) error_->::Error::Clear();
  clear_has_error();
}
inline const ::Error& UErrChannel::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::Error* UErrChannel::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::Error;
  return error_;
}
inline ::Error* UErrChannel::release_error() {
  clear_has_error();
  ::Error* temp = error_;
  error_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// UReqStore

// -------------------------------------------------------------------

// UAnsStore

// repeated .Desc itemInfo = 1;
inline int UAnsStore::iteminfo_size() const {
  return iteminfo_.size();
}
inline void UAnsStore::clear_iteminfo() {
  iteminfo_.Clear();
}
inline const ::Desc& UAnsStore::iteminfo(int index) const {
  return iteminfo_.Get(index);
}
inline ::Desc* UAnsStore::mutable_iteminfo(int index) {
  return iteminfo_.Mutable(index);
}
inline ::Desc* UAnsStore::add_iteminfo() {
  return iteminfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Desc >&
UAnsStore::iteminfo() const {
  return iteminfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::Desc >*
UAnsStore::mutable_iteminfo() {
  return &iteminfo_;
}

// -------------------------------------------------------------------

// UReqInfo

// -------------------------------------------------------------------

// UAnsInfo

// required .GameInfo gameInfo = 1;
inline bool UAnsInfo::has_gameinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UAnsInfo::set_has_gameinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UAnsInfo::clear_has_gameinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UAnsInfo::clear_gameinfo() {
  if (gameinfo_ != NULL) gameinfo_->::GameInfo::Clear();
  clear_has_gameinfo();
}
inline const ::GameInfo& UAnsInfo::gameinfo() const {
  return gameinfo_ != NULL ? *gameinfo_ : *default_instance_->gameinfo_;
}
inline ::GameInfo* UAnsInfo::mutable_gameinfo() {
  set_has_gameinfo();
  if (gameinfo_ == NULL) gameinfo_ = new ::GameInfo;
  return gameinfo_;
}
inline ::GameInfo* UAnsInfo::release_gameinfo() {
  clear_has_gameinfo();
  ::GameInfo* temp = gameinfo_;
  gameinfo_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// UReqAutoJoin

// required int32 categoryID = 1;
inline bool UReqAutoJoin::has_categoryid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UReqAutoJoin::set_has_categoryid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UReqAutoJoin::clear_has_categoryid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UReqAutoJoin::clear_categoryid() {
  categoryid_ = 0;
  clear_has_categoryid();
}
inline ::google::protobuf::int32 UReqAutoJoin::categoryid() const {
  return categoryid_;
}
inline void UReqAutoJoin::set_categoryid(::google::protobuf::int32 value) {
  set_has_categoryid();
  categoryid_ = value;
}

// required int32 channelID = 2;
inline bool UReqAutoJoin::has_channelid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UReqAutoJoin::set_has_channelid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UReqAutoJoin::clear_has_channelid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UReqAutoJoin::clear_channelid() {
  channelid_ = 0;
  clear_has_channelid();
}
inline ::google::protobuf::int32 UReqAutoJoin::channelid() const {
  return channelid_;
}
inline void UReqAutoJoin::set_channelid(::google::protobuf::int32 value) {
  set_has_channelid();
  channelid_ = value;
}

// -------------------------------------------------------------------

// UAnsAutoJoin

// required .GameRoomInfo gameRoomInfo = 1;
inline bool UAnsAutoJoin::has_gameroominfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UAnsAutoJoin::set_has_gameroominfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UAnsAutoJoin::clear_has_gameroominfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UAnsAutoJoin::clear_gameroominfo() {
  if (gameroominfo_ != NULL) gameroominfo_->::GameRoomInfo::Clear();
  clear_has_gameroominfo();
}
inline const ::GameRoomInfo& UAnsAutoJoin::gameroominfo() const {
  return gameroominfo_ != NULL ? *gameroominfo_ : *default_instance_->gameroominfo_;
}
inline ::GameRoomInfo* UAnsAutoJoin::mutable_gameroominfo() {
  set_has_gameroominfo();
  if (gameroominfo_ == NULL) gameroominfo_ = new ::GameRoomInfo;
  return gameroominfo_;
}
inline ::GameRoomInfo* UAnsAutoJoin::release_gameroominfo() {
  clear_has_gameroominfo();
  ::GameRoomInfo* temp = gameroominfo_;
  gameroominfo_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// UReqLeaveGame

// required int32 gameID = 1;
inline bool UReqLeaveGame::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UReqLeaveGame::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UReqLeaveGame::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UReqLeaveGame::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 UReqLeaveGame::gameid() const {
  return gameid_;
}
inline void UReqLeaveGame::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required bool kick = 2;
inline bool UReqLeaveGame::has_kick() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UReqLeaveGame::set_has_kick() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UReqLeaveGame::clear_has_kick() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UReqLeaveGame::clear_kick() {
  kick_ = false;
  clear_has_kick();
}
inline bool UReqLeaveGame::kick() const {
  return kick_;
}
inline void UReqLeaveGame::set_kick(bool value) {
  set_has_kick();
  kick_ = value;
}

// -------------------------------------------------------------------

// UAnsLeaveGame

// required int32 gameID = 1;
inline bool UAnsLeaveGame::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UAnsLeaveGame::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UAnsLeaveGame::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UAnsLeaveGame::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 UAnsLeaveGame::gameid() const {
  return gameid_;
}
inline void UAnsLeaveGame::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required .UAnsLeaveGame.KICK_TYPE nType = 2;
inline bool UAnsLeaveGame::has_ntype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UAnsLeaveGame::set_has_ntype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UAnsLeaveGame::clear_has_ntype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UAnsLeaveGame::clear_ntype() {
  ntype_ = 1;
  clear_has_ntype();
}
inline ::UAnsLeaveGame_KICK_TYPE UAnsLeaveGame::ntype() const {
  return static_cast< ::UAnsLeaveGame_KICK_TYPE >(ntype_);
}
inline void UAnsLeaveGame::set_ntype(::UAnsLeaveGame_KICK_TYPE value) {
  GOOGLE_DCHECK(::UAnsLeaveGame_KICK_TYPE_IsValid(value));
  set_has_ntype();
  ntype_ = value;
}

// -------------------------------------------------------------------

// UReqClose

// -------------------------------------------------------------------

// UAnsClose

// -------------------------------------------------------------------

// UReqPing

// required int32 seq = 1;
inline bool UReqPing::has_seq() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UReqPing::set_has_seq() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UReqPing::clear_has_seq() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UReqPing::clear_seq() {
  seq_ = 0;
  clear_has_seq();
}
inline ::google::protobuf::int32 UReqPing::seq() const {
  return seq_;
}
inline void UReqPing::set_seq(::google::protobuf::int32 value) {
  set_has_seq();
  seq_ = value;
}

// -------------------------------------------------------------------

// UAnsPong

// required int32 seq = 1;
inline bool UAnsPong::has_seq() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UAnsPong::set_has_seq() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UAnsPong::clear_has_seq() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UAnsPong::clear_seq() {
  seq_ = 0;
  clear_has_seq();
}
inline ::google::protobuf::int32 UAnsPong::seq() const {
  return seq_;
}
inline void UAnsPong::set_seq(::google::protobuf::int32 value) {
  set_has_seq();
  seq_ = value;
}

// -------------------------------------------------------------------

// UReqPlug

// required int32 gameID = 1;
inline bool UReqPlug::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UReqPlug::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UReqPlug::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UReqPlug::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 UReqPlug::gameid() const {
  return gameid_;
}
inline void UReqPlug::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required string passwd = 2;
inline bool UReqPlug::has_passwd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UReqPlug::set_has_passwd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UReqPlug::clear_has_passwd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UReqPlug::clear_passwd() {
  if (passwd_ != &::google::protobuf::internal::kEmptyString) {
    passwd_->clear();
  }
  clear_has_passwd();
}
inline const ::std::string& UReqPlug::passwd() const {
  return *passwd_;
}
inline void UReqPlug::set_passwd(const ::std::string& value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void UReqPlug::set_passwd(const char* value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void UReqPlug::set_passwd(const char* value, size_t size) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UReqPlug::mutable_passwd() {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  return passwd_;
}
inline ::std::string* UReqPlug::release_passwd() {
  clear_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = passwd_;
    passwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// UAnsPlug

// required int32 gameID = 1;
inline bool UAnsPlug::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UAnsPlug::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UAnsPlug::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UAnsPlug::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 UAnsPlug::gameid() const {
  return gameid_;
}
inline void UAnsPlug::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// -------------------------------------------------------------------

// UReqProtocol

// required .UReqProtocol.Type type = 1;
inline bool UReqProtocol::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UReqProtocol::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UReqProtocol::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UReqProtocol::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::UReqProtocol_Type UReqProtocol::type() const {
  return static_cast< ::UReqProtocol_Type >(type_);
}
inline void UReqProtocol::set_type(::UReqProtocol_Type value) {
  GOOGLE_DCHECK(::UReqProtocol_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .UReqConnect reqConnect = 2;
inline bool UReqProtocol::has_reqconnect() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UReqProtocol::set_has_reqconnect() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UReqProtocol::clear_has_reqconnect() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UReqProtocol::clear_reqconnect() {
  if (reqconnect_ != NULL) reqconnect_->::UReqConnect::Clear();
  clear_has_reqconnect();
}
inline const ::UReqConnect& UReqProtocol::reqconnect() const {
  return reqconnect_ != NULL ? *reqconnect_ : *default_instance_->reqconnect_;
}
inline ::UReqConnect* UReqProtocol::mutable_reqconnect() {
  set_has_reqconnect();
  if (reqconnect_ == NULL) reqconnect_ = new ::UReqConnect;
  return reqconnect_;
}
inline ::UReqConnect* UReqProtocol::release_reqconnect() {
  clear_has_reqconnect();
  ::UReqConnect* temp = reqconnect_;
  reqconnect_ = NULL;
  return temp;
}

// optional .UReqChannel reqChannel = 3;
inline bool UReqProtocol::has_reqchannel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UReqProtocol::set_has_reqchannel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UReqProtocol::clear_has_reqchannel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UReqProtocol::clear_reqchannel() {
  if (reqchannel_ != NULL) reqchannel_->::UReqChannel::Clear();
  clear_has_reqchannel();
}
inline const ::UReqChannel& UReqProtocol::reqchannel() const {
  return reqchannel_ != NULL ? *reqchannel_ : *default_instance_->reqchannel_;
}
inline ::UReqChannel* UReqProtocol::mutable_reqchannel() {
  set_has_reqchannel();
  if (reqchannel_ == NULL) reqchannel_ = new ::UReqChannel;
  return reqchannel_;
}
inline ::UReqChannel* UReqProtocol::release_reqchannel() {
  clear_has_reqchannel();
  ::UReqChannel* temp = reqchannel_;
  reqchannel_ = NULL;
  return temp;
}

// optional .UReqStore reqStore = 4;
inline bool UReqProtocol::has_reqstore() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UReqProtocol::set_has_reqstore() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UReqProtocol::clear_has_reqstore() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UReqProtocol::clear_reqstore() {
  if (reqstore_ != NULL) reqstore_->::UReqStore::Clear();
  clear_has_reqstore();
}
inline const ::UReqStore& UReqProtocol::reqstore() const {
  return reqstore_ != NULL ? *reqstore_ : *default_instance_->reqstore_;
}
inline ::UReqStore* UReqProtocol::mutable_reqstore() {
  set_has_reqstore();
  if (reqstore_ == NULL) reqstore_ = new ::UReqStore;
  return reqstore_;
}
inline ::UReqStore* UReqProtocol::release_reqstore() {
  clear_has_reqstore();
  ::UReqStore* temp = reqstore_;
  reqstore_ = NULL;
  return temp;
}

// optional .UReqInfo reqInfo = 5;
inline bool UReqProtocol::has_reqinfo() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UReqProtocol::set_has_reqinfo() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UReqProtocol::clear_has_reqinfo() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UReqProtocol::clear_reqinfo() {
  if (reqinfo_ != NULL) reqinfo_->::UReqInfo::Clear();
  clear_has_reqinfo();
}
inline const ::UReqInfo& UReqProtocol::reqinfo() const {
  return reqinfo_ != NULL ? *reqinfo_ : *default_instance_->reqinfo_;
}
inline ::UReqInfo* UReqProtocol::mutable_reqinfo() {
  set_has_reqinfo();
  if (reqinfo_ == NULL) reqinfo_ = new ::UReqInfo;
  return reqinfo_;
}
inline ::UReqInfo* UReqProtocol::release_reqinfo() {
  clear_has_reqinfo();
  ::UReqInfo* temp = reqinfo_;
  reqinfo_ = NULL;
  return temp;
}

// optional .UReqAutoJoin reqAutoJoin = 6;
inline bool UReqProtocol::has_reqautojoin() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UReqProtocol::set_has_reqautojoin() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UReqProtocol::clear_has_reqautojoin() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UReqProtocol::clear_reqautojoin() {
  if (reqautojoin_ != NULL) reqautojoin_->::UReqAutoJoin::Clear();
  clear_has_reqautojoin();
}
inline const ::UReqAutoJoin& UReqProtocol::reqautojoin() const {
  return reqautojoin_ != NULL ? *reqautojoin_ : *default_instance_->reqautojoin_;
}
inline ::UReqAutoJoin* UReqProtocol::mutable_reqautojoin() {
  set_has_reqautojoin();
  if (reqautojoin_ == NULL) reqautojoin_ = new ::UReqAutoJoin;
  return reqautojoin_;
}
inline ::UReqAutoJoin* UReqProtocol::release_reqautojoin() {
  clear_has_reqautojoin();
  ::UReqAutoJoin* temp = reqautojoin_;
  reqautojoin_ = NULL;
  return temp;
}

// optional .UReqLeaveGame reqLeaveGame = 7;
inline bool UReqProtocol::has_reqleavegame() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UReqProtocol::set_has_reqleavegame() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UReqProtocol::clear_has_reqleavegame() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UReqProtocol::clear_reqleavegame() {
  if (reqleavegame_ != NULL) reqleavegame_->::UReqLeaveGame::Clear();
  clear_has_reqleavegame();
}
inline const ::UReqLeaveGame& UReqProtocol::reqleavegame() const {
  return reqleavegame_ != NULL ? *reqleavegame_ : *default_instance_->reqleavegame_;
}
inline ::UReqLeaveGame* UReqProtocol::mutable_reqleavegame() {
  set_has_reqleavegame();
  if (reqleavegame_ == NULL) reqleavegame_ = new ::UReqLeaveGame;
  return reqleavegame_;
}
inline ::UReqLeaveGame* UReqProtocol::release_reqleavegame() {
  clear_has_reqleavegame();
  ::UReqLeaveGame* temp = reqleavegame_;
  reqleavegame_ = NULL;
  return temp;
}

// optional .UReqClose reqClose = 8;
inline bool UReqProtocol::has_reqclose() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UReqProtocol::set_has_reqclose() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UReqProtocol::clear_has_reqclose() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UReqProtocol::clear_reqclose() {
  if (reqclose_ != NULL) reqclose_->::UReqClose::Clear();
  clear_has_reqclose();
}
inline const ::UReqClose& UReqProtocol::reqclose() const {
  return reqclose_ != NULL ? *reqclose_ : *default_instance_->reqclose_;
}
inline ::UReqClose* UReqProtocol::mutable_reqclose() {
  set_has_reqclose();
  if (reqclose_ == NULL) reqclose_ = new ::UReqClose;
  return reqclose_;
}
inline ::UReqClose* UReqProtocol::release_reqclose() {
  clear_has_reqclose();
  ::UReqClose* temp = reqclose_;
  reqclose_ = NULL;
  return temp;
}

// optional .UReqPing reqPing = 9;
inline bool UReqProtocol::has_reqping() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UReqProtocol::set_has_reqping() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UReqProtocol::clear_has_reqping() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UReqProtocol::clear_reqping() {
  if (reqping_ != NULL) reqping_->::UReqPing::Clear();
  clear_has_reqping();
}
inline const ::UReqPing& UReqProtocol::reqping() const {
  return reqping_ != NULL ? *reqping_ : *default_instance_->reqping_;
}
inline ::UReqPing* UReqProtocol::mutable_reqping() {
  set_has_reqping();
  if (reqping_ == NULL) reqping_ = new ::UReqPing;
  return reqping_;
}
inline ::UReqPing* UReqProtocol::release_reqping() {
  clear_has_reqping();
  ::UReqPing* temp = reqping_;
  reqping_ = NULL;
  return temp;
}

// optional .UReqPlug reqPlug = 10;
inline bool UReqProtocol::has_reqplug() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UReqProtocol::set_has_reqplug() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UReqProtocol::clear_has_reqplug() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UReqProtocol::clear_reqplug() {
  if (reqplug_ != NULL) reqplug_->::UReqPlug::Clear();
  clear_has_reqplug();
}
inline const ::UReqPlug& UReqProtocol::reqplug() const {
  return reqplug_ != NULL ? *reqplug_ : *default_instance_->reqplug_;
}
inline ::UReqPlug* UReqProtocol::mutable_reqplug() {
  set_has_reqplug();
  if (reqplug_ == NULL) reqplug_ = new ::UReqPlug;
  return reqplug_;
}
inline ::UReqPlug* UReqProtocol::release_reqplug() {
  clear_has_reqplug();
  ::UReqPlug* temp = reqplug_;
  reqplug_ = NULL;
  return temp;
}

// optional .GLReqGameProtocol reqGameProtocol = 11;
inline bool UReqProtocol::has_reqgameprotocol() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UReqProtocol::set_has_reqgameprotocol() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UReqProtocol::clear_has_reqgameprotocol() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UReqProtocol::clear_reqgameprotocol() {
  if (reqgameprotocol_ != NULL) reqgameprotocol_->::GLReqGameProtocol::Clear();
  clear_has_reqgameprotocol();
}
inline const ::GLReqGameProtocol& UReqProtocol::reqgameprotocol() const {
  return reqgameprotocol_ != NULL ? *reqgameprotocol_ : *default_instance_->reqgameprotocol_;
}
inline ::GLReqGameProtocol* UReqProtocol::mutable_reqgameprotocol() {
  set_has_reqgameprotocol();
  if (reqgameprotocol_ == NULL) reqgameprotocol_ = new ::GLReqGameProtocol;
  return reqgameprotocol_;
}
inline ::GLReqGameProtocol* UReqProtocol::release_reqgameprotocol() {
  clear_has_reqgameprotocol();
  ::GLReqGameProtocol* temp = reqgameprotocol_;
  reqgameprotocol_ = NULL;
  return temp;
}

// optional .ReqDB reqDB = 12;
inline bool UReqProtocol::has_reqdb() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void UReqProtocol::set_has_reqdb() {
  _has_bits_[0] |= 0x00000800u;
}
inline void UReqProtocol::clear_has_reqdb() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void UReqProtocol::clear_reqdb() {
  if (reqdb_ != NULL) reqdb_->::ReqDB::Clear();
  clear_has_reqdb();
}
inline const ::ReqDB& UReqProtocol::reqdb() const {
  return reqdb_ != NULL ? *reqdb_ : *default_instance_->reqdb_;
}
inline ::ReqDB* UReqProtocol::mutable_reqdb() {
  set_has_reqdb();
  if (reqdb_ == NULL) reqdb_ = new ::ReqDB;
  return reqdb_;
}
inline ::ReqDB* UReqProtocol::release_reqdb() {
  clear_has_reqdb();
  ::ReqDB* temp = reqdb_;
  reqdb_ = NULL;
  return temp;
}

// optional .UReqNotice reqNotice = 13;
inline bool UReqProtocol::has_reqnotice() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void UReqProtocol::set_has_reqnotice() {
  _has_bits_[0] |= 0x00001000u;
}
inline void UReqProtocol::clear_has_reqnotice() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void UReqProtocol::clear_reqnotice() {
  if (reqnotice_ != NULL) reqnotice_->::UReqNotice::Clear();
  clear_has_reqnotice();
}
inline const ::UReqNotice& UReqProtocol::reqnotice() const {
  return reqnotice_ != NULL ? *reqnotice_ : *default_instance_->reqnotice_;
}
inline ::UReqNotice* UReqProtocol::mutable_reqnotice() {
  set_has_reqnotice();
  if (reqnotice_ == NULL) reqnotice_ = new ::UReqNotice;
  return reqnotice_;
}
inline ::UReqNotice* UReqProtocol::release_reqnotice() {
  clear_has_reqnotice();
  ::UReqNotice* temp = reqnotice_;
  reqnotice_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// UAnsProtocol

// required .UAnsProtocol.Type type = 1;
inline bool UAnsProtocol::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UAnsProtocol::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UAnsProtocol::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UAnsProtocol::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::UAnsProtocol_Type UAnsProtocol::type() const {
  return static_cast< ::UAnsProtocol_Type >(type_);
}
inline void UAnsProtocol::set_type(::UAnsProtocol_Type value) {
  GOOGLE_DCHECK(::UAnsProtocol_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .UAnsConnect ansConnect = 2;
inline bool UAnsProtocol::has_ansconnect() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UAnsProtocol::set_has_ansconnect() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UAnsProtocol::clear_has_ansconnect() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UAnsProtocol::clear_ansconnect() {
  if (ansconnect_ != NULL) ansconnect_->::UAnsConnect::Clear();
  clear_has_ansconnect();
}
inline const ::UAnsConnect& UAnsProtocol::ansconnect() const {
  return ansconnect_ != NULL ? *ansconnect_ : *default_instance_->ansconnect_;
}
inline ::UAnsConnect* UAnsProtocol::mutable_ansconnect() {
  set_has_ansconnect();
  if (ansconnect_ == NULL) ansconnect_ = new ::UAnsConnect;
  return ansconnect_;
}
inline ::UAnsConnect* UAnsProtocol::release_ansconnect() {
  clear_has_ansconnect();
  ::UAnsConnect* temp = ansconnect_;
  ansconnect_ = NULL;
  return temp;
}

// optional .UAnsChannel ansChannel = 3;
inline bool UAnsProtocol::has_anschannel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UAnsProtocol::set_has_anschannel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UAnsProtocol::clear_has_anschannel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UAnsProtocol::clear_anschannel() {
  if (anschannel_ != NULL) anschannel_->::UAnsChannel::Clear();
  clear_has_anschannel();
}
inline const ::UAnsChannel& UAnsProtocol::anschannel() const {
  return anschannel_ != NULL ? *anschannel_ : *default_instance_->anschannel_;
}
inline ::UAnsChannel* UAnsProtocol::mutable_anschannel() {
  set_has_anschannel();
  if (anschannel_ == NULL) anschannel_ = new ::UAnsChannel;
  return anschannel_;
}
inline ::UAnsChannel* UAnsProtocol::release_anschannel() {
  clear_has_anschannel();
  ::UAnsChannel* temp = anschannel_;
  anschannel_ = NULL;
  return temp;
}

// optional .UAnsStore ansStore = 4;
inline bool UAnsProtocol::has_ansstore() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UAnsProtocol::set_has_ansstore() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UAnsProtocol::clear_has_ansstore() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UAnsProtocol::clear_ansstore() {
  if (ansstore_ != NULL) ansstore_->::UAnsStore::Clear();
  clear_has_ansstore();
}
inline const ::UAnsStore& UAnsProtocol::ansstore() const {
  return ansstore_ != NULL ? *ansstore_ : *default_instance_->ansstore_;
}
inline ::UAnsStore* UAnsProtocol::mutable_ansstore() {
  set_has_ansstore();
  if (ansstore_ == NULL) ansstore_ = new ::UAnsStore;
  return ansstore_;
}
inline ::UAnsStore* UAnsProtocol::release_ansstore() {
  clear_has_ansstore();
  ::UAnsStore* temp = ansstore_;
  ansstore_ = NULL;
  return temp;
}

// optional .UAnsInfo ansInfo = 5;
inline bool UAnsProtocol::has_ansinfo() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UAnsProtocol::set_has_ansinfo() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UAnsProtocol::clear_has_ansinfo() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UAnsProtocol::clear_ansinfo() {
  if (ansinfo_ != NULL) ansinfo_->::UAnsInfo::Clear();
  clear_has_ansinfo();
}
inline const ::UAnsInfo& UAnsProtocol::ansinfo() const {
  return ansinfo_ != NULL ? *ansinfo_ : *default_instance_->ansinfo_;
}
inline ::UAnsInfo* UAnsProtocol::mutable_ansinfo() {
  set_has_ansinfo();
  if (ansinfo_ == NULL) ansinfo_ = new ::UAnsInfo;
  return ansinfo_;
}
inline ::UAnsInfo* UAnsProtocol::release_ansinfo() {
  clear_has_ansinfo();
  ::UAnsInfo* temp = ansinfo_;
  ansinfo_ = NULL;
  return temp;
}

// optional .UAnsAutoJoin ansAutoJoin = 6;
inline bool UAnsProtocol::has_ansautojoin() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UAnsProtocol::set_has_ansautojoin() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UAnsProtocol::clear_has_ansautojoin() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UAnsProtocol::clear_ansautojoin() {
  if (ansautojoin_ != NULL) ansautojoin_->::UAnsAutoJoin::Clear();
  clear_has_ansautojoin();
}
inline const ::UAnsAutoJoin& UAnsProtocol::ansautojoin() const {
  return ansautojoin_ != NULL ? *ansautojoin_ : *default_instance_->ansautojoin_;
}
inline ::UAnsAutoJoin* UAnsProtocol::mutable_ansautojoin() {
  set_has_ansautojoin();
  if (ansautojoin_ == NULL) ansautojoin_ = new ::UAnsAutoJoin;
  return ansautojoin_;
}
inline ::UAnsAutoJoin* UAnsProtocol::release_ansautojoin() {
  clear_has_ansautojoin();
  ::UAnsAutoJoin* temp = ansautojoin_;
  ansautojoin_ = NULL;
  return temp;
}

// optional .UAnsLeaveGame ansLeaveGame = 7;
inline bool UAnsProtocol::has_ansleavegame() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UAnsProtocol::set_has_ansleavegame() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UAnsProtocol::clear_has_ansleavegame() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UAnsProtocol::clear_ansleavegame() {
  if (ansleavegame_ != NULL) ansleavegame_->::UAnsLeaveGame::Clear();
  clear_has_ansleavegame();
}
inline const ::UAnsLeaveGame& UAnsProtocol::ansleavegame() const {
  return ansleavegame_ != NULL ? *ansleavegame_ : *default_instance_->ansleavegame_;
}
inline ::UAnsLeaveGame* UAnsProtocol::mutable_ansleavegame() {
  set_has_ansleavegame();
  if (ansleavegame_ == NULL) ansleavegame_ = new ::UAnsLeaveGame;
  return ansleavegame_;
}
inline ::UAnsLeaveGame* UAnsProtocol::release_ansleavegame() {
  clear_has_ansleavegame();
  ::UAnsLeaveGame* temp = ansleavegame_;
  ansleavegame_ = NULL;
  return temp;
}

// optional .UAnsClose ansClose = 8;
inline bool UAnsProtocol::has_ansclose() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UAnsProtocol::set_has_ansclose() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UAnsProtocol::clear_has_ansclose() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UAnsProtocol::clear_ansclose() {
  if (ansclose_ != NULL) ansclose_->::UAnsClose::Clear();
  clear_has_ansclose();
}
inline const ::UAnsClose& UAnsProtocol::ansclose() const {
  return ansclose_ != NULL ? *ansclose_ : *default_instance_->ansclose_;
}
inline ::UAnsClose* UAnsProtocol::mutable_ansclose() {
  set_has_ansclose();
  if (ansclose_ == NULL) ansclose_ = new ::UAnsClose;
  return ansclose_;
}
inline ::UAnsClose* UAnsProtocol::release_ansclose() {
  clear_has_ansclose();
  ::UAnsClose* temp = ansclose_;
  ansclose_ = NULL;
  return temp;
}

// optional .UAnsPong ansPong = 9;
inline bool UAnsProtocol::has_anspong() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UAnsProtocol::set_has_anspong() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UAnsProtocol::clear_has_anspong() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UAnsProtocol::clear_anspong() {
  if (anspong_ != NULL) anspong_->::UAnsPong::Clear();
  clear_has_anspong();
}
inline const ::UAnsPong& UAnsProtocol::anspong() const {
  return anspong_ != NULL ? *anspong_ : *default_instance_->anspong_;
}
inline ::UAnsPong* UAnsProtocol::mutable_anspong() {
  set_has_anspong();
  if (anspong_ == NULL) anspong_ = new ::UAnsPong;
  return anspong_;
}
inline ::UAnsPong* UAnsProtocol::release_anspong() {
  clear_has_anspong();
  ::UAnsPong* temp = anspong_;
  anspong_ = NULL;
  return temp;
}

// optional .UAnsPlug ansPlug = 10;
inline bool UAnsProtocol::has_ansplug() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UAnsProtocol::set_has_ansplug() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UAnsProtocol::clear_has_ansplug() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UAnsProtocol::clear_ansplug() {
  if (ansplug_ != NULL) ansplug_->::UAnsPlug::Clear();
  clear_has_ansplug();
}
inline const ::UAnsPlug& UAnsProtocol::ansplug() const {
  return ansplug_ != NULL ? *ansplug_ : *default_instance_->ansplug_;
}
inline ::UAnsPlug* UAnsProtocol::mutable_ansplug() {
  set_has_ansplug();
  if (ansplug_ == NULL) ansplug_ = new ::UAnsPlug;
  return ansplug_;
}
inline ::UAnsPlug* UAnsProtocol::release_ansplug() {
  clear_has_ansplug();
  ::UAnsPlug* temp = ansplug_;
  ansplug_ = NULL;
  return temp;
}

// optional .GLAnsGameProtocol ansGameProtocol = 11;
inline bool UAnsProtocol::has_ansgameprotocol() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UAnsProtocol::set_has_ansgameprotocol() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UAnsProtocol::clear_has_ansgameprotocol() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UAnsProtocol::clear_ansgameprotocol() {
  if (ansgameprotocol_ != NULL) ansgameprotocol_->::GLAnsGameProtocol::Clear();
  clear_has_ansgameprotocol();
}
inline const ::GLAnsGameProtocol& UAnsProtocol::ansgameprotocol() const {
  return ansgameprotocol_ != NULL ? *ansgameprotocol_ : *default_instance_->ansgameprotocol_;
}
inline ::GLAnsGameProtocol* UAnsProtocol::mutable_ansgameprotocol() {
  set_has_ansgameprotocol();
  if (ansgameprotocol_ == NULL) ansgameprotocol_ = new ::GLAnsGameProtocol;
  return ansgameprotocol_;
}
inline ::GLAnsGameProtocol* UAnsProtocol::release_ansgameprotocol() {
  clear_has_ansgameprotocol();
  ::GLAnsGameProtocol* temp = ansgameprotocol_;
  ansgameprotocol_ = NULL;
  return temp;
}

// optional .AnsDB ansDB = 12;
inline bool UAnsProtocol::has_ansdb() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void UAnsProtocol::set_has_ansdb() {
  _has_bits_[0] |= 0x00000800u;
}
inline void UAnsProtocol::clear_has_ansdb() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void UAnsProtocol::clear_ansdb() {
  if (ansdb_ != NULL) ansdb_->::AnsDB::Clear();
  clear_has_ansdb();
}
inline const ::AnsDB& UAnsProtocol::ansdb() const {
  return ansdb_ != NULL ? *ansdb_ : *default_instance_->ansdb_;
}
inline ::AnsDB* UAnsProtocol::mutable_ansdb() {
  set_has_ansdb();
  if (ansdb_ == NULL) ansdb_ = new ::AnsDB;
  return ansdb_;
}
inline ::AnsDB* UAnsProtocol::release_ansdb() {
  clear_has_ansdb();
  ::AnsDB* temp = ansdb_;
  ansdb_ = NULL;
  return temp;
}

// optional .UAnsNotice ansNotice = 13;
inline bool UAnsProtocol::has_ansnotice() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void UAnsProtocol::set_has_ansnotice() {
  _has_bits_[0] |= 0x00001000u;
}
inline void UAnsProtocol::clear_has_ansnotice() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void UAnsProtocol::clear_ansnotice() {
  if (ansnotice_ != NULL) ansnotice_->::UAnsNotice::Clear();
  clear_has_ansnotice();
}
inline const ::UAnsNotice& UAnsProtocol::ansnotice() const {
  return ansnotice_ != NULL ? *ansnotice_ : *default_instance_->ansnotice_;
}
inline ::UAnsNotice* UAnsProtocol::mutable_ansnotice() {
  set_has_ansnotice();
  if (ansnotice_ == NULL) ansnotice_ = new ::UAnsNotice;
  return ansnotice_;
}
inline ::UAnsNotice* UAnsProtocol::release_ansnotice() {
  clear_has_ansnotice();
  ::UAnsNotice* temp = ansnotice_;
  ansnotice_ = NULL;
  return temp;
}

// optional .UError ansError = 14;
inline bool UAnsProtocol::has_anserror() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void UAnsProtocol::set_has_anserror() {
  _has_bits_[0] |= 0x00002000u;
}
inline void UAnsProtocol::clear_has_anserror() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void UAnsProtocol::clear_anserror() {
  if (anserror_ != NULL) anserror_->::UError::Clear();
  clear_has_anserror();
}
inline const ::UError& UAnsProtocol::anserror() const {
  return anserror_ != NULL ? *anserror_ : *default_instance_->anserror_;
}
inline ::UError* UAnsProtocol::mutable_anserror() {
  set_has_anserror();
  if (anserror_ == NULL) anserror_ = new ::UError;
  return anserror_;
}
inline ::UError* UAnsProtocol::release_anserror() {
  clear_has_anserror();
  ::UError* temp = anserror_;
  anserror_ = NULL;
  return temp;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ug_2eproto__INCLUDED
