// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gameLogic.proto

#ifndef PROTOBUF_gameLogic_2eproto__INCLUDED
#define PROTOBUF_gameLogic_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_gameLogic_2eproto();
void protobuf_AssignDesc_gameLogic_2eproto();
void protobuf_ShutdownFile_gameLogic_2eproto();

class GameUserInfo;
class GameRoomInfo;
class GameInfo;
class MemberInfo;
class s_req_game_test_packet;
class s_req_send_cmd;
class GLReqGameProtocol;
class s_ans_game_test_packet;
class GLAnsGameProtocol;

enum GLReqGameProtocol_Type {
  GLReqGameProtocol_Type_NONE = 1,
  GLReqGameProtocol_Type_req_game_test_packet = 2,
  GLReqGameProtocol_Type_req_send_cmd = 3
};
bool GLReqGameProtocol_Type_IsValid(int value);
const GLReqGameProtocol_Type GLReqGameProtocol_Type_Type_MIN = GLReqGameProtocol_Type_NONE;
const GLReqGameProtocol_Type GLReqGameProtocol_Type_Type_MAX = GLReqGameProtocol_Type_req_send_cmd;
const int GLReqGameProtocol_Type_Type_ARRAYSIZE = GLReqGameProtocol_Type_Type_MAX + 1;

enum GLAnsGameProtocol_Type {
  GLAnsGameProtocol_Type_NONE = 1,
  GLAnsGameProtocol_Type_ans_game_test_packet = 2
};
bool GLAnsGameProtocol_Type_IsValid(int value);
const GLAnsGameProtocol_Type GLAnsGameProtocol_Type_Type_MIN = GLAnsGameProtocol_Type_NONE;
const GLAnsGameProtocol_Type GLAnsGameProtocol_Type_Type_MAX = GLAnsGameProtocol_Type_ans_game_test_packet;
const int GLAnsGameProtocol_Type_Type_ARRAYSIZE = GLAnsGameProtocol_Type_Type_MAX + 1;

// ===================================================================

class GameUserInfo : public ::google::protobuf::MessageLite {
 public:
  GameUserInfo();
  virtual ~GameUserInfo();
  
  GameUserInfo(const GameUserInfo& from);
  
  inline GameUserInfo& operator=(const GameUserInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GameUserInfo& default_instance();
  
  void Swap(GameUserInfo* other);
  
  // implements Message ----------------------------------------------
  
  GameUserInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GameUserInfo& from);
  void MergeFrom(const GameUserInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .GameInfo gameInfo = 1;
  inline bool has_gameinfo() const;
  inline void clear_gameinfo();
  static const int kGameInfoFieldNumber = 1;
  inline const ::GameInfo& gameinfo() const;
  inline ::GameInfo* mutable_gameinfo();
  inline ::GameInfo* release_gameinfo();
  
  // required .MemberInfo memberInfo = 2;
  inline bool has_memberinfo() const;
  inline void clear_memberinfo();
  static const int kMemberInfoFieldNumber = 2;
  inline const ::MemberInfo& memberinfo() const;
  inline ::MemberInfo* mutable_memberinfo();
  inline ::MemberInfo* release_memberinfo();
  
  // @@protoc_insertion_point(class_scope:GameUserInfo)
 private:
  inline void set_has_gameinfo();
  inline void clear_has_gameinfo();
  inline void set_has_memberinfo();
  inline void clear_has_memberinfo();
  
  ::GameInfo* gameinfo_;
  ::MemberInfo* memberinfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GameUserInfo* default_instance_;
};
// -------------------------------------------------------------------

class GameRoomInfo : public ::google::protobuf::MessageLite {
 public:
  GameRoomInfo();
  virtual ~GameRoomInfo();
  
  GameRoomInfo(const GameRoomInfo& from);
  
  inline GameRoomInfo& operator=(const GameRoomInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GameRoomInfo& default_instance();
  
  void Swap(GameRoomInfo* other);
  
  // implements Message ----------------------------------------------
  
  GameRoomInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GameRoomInfo& from);
  void MergeFrom(const GameRoomInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 roomID = 1;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIDFieldNumber = 1;
  inline ::google::protobuf::int32 roomid() const;
  inline void set_roomid(::google::protobuf::int32 value);
  
  // required int32 pointMoney = 2;
  inline bool has_pointmoney() const;
  inline void clear_pointmoney();
  static const int kPointMoneyFieldNumber = 2;
  inline ::google::protobuf::int32 pointmoney() const;
  inline void set_pointmoney(::google::protobuf::int32 value);
  
  // repeated .GameUserInfo gameUserInfo = 3;
  inline int gameuserinfo_size() const;
  inline void clear_gameuserinfo();
  static const int kGameUserInfoFieldNumber = 3;
  inline const ::GameUserInfo& gameuserinfo(int index) const;
  inline ::GameUserInfo* mutable_gameuserinfo(int index);
  inline ::GameUserInfo* add_gameuserinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::GameUserInfo >&
      gameuserinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::GameUserInfo >*
      mutable_gameuserinfo();
  
  // @@protoc_insertion_point(class_scope:GameRoomInfo)
 private:
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_pointmoney();
  inline void clear_has_pointmoney();
  
  ::google::protobuf::int32 roomid_;
  ::google::protobuf::int32 pointmoney_;
  ::google::protobuf::RepeatedPtrField< ::GameUserInfo > gameuserinfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GameRoomInfo* default_instance_;
};
// -------------------------------------------------------------------

class GameInfo : public ::google::protobuf::MessageLite {
 public:
  GameInfo();
  virtual ~GameInfo();
  
  GameInfo(const GameInfo& from);
  
  inline GameInfo& operator=(const GameInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GameInfo& default_instance();
  
  void Swap(GameInfo* other);
  
  // implements Message ----------------------------------------------
  
  GameInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GameInfo& from);
  void MergeFrom(const GameInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // required string level = 3;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 3;
  inline const ::std::string& level() const;
  inline void set_level(const ::std::string& value);
  inline void set_level(const char* value);
  inline void set_level(const char* value, size_t size);
  inline ::std::string* mutable_level();
  inline ::std::string* release_level();
  
  // required string money = 4;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 4;
  inline const ::std::string& money() const;
  inline void set_money(const ::std::string& value);
  inline void set_money(const char* value);
  inline void set_money(const char* value, size_t size);
  inline ::std::string* mutable_money();
  inline ::std::string* release_money();
  
  // required int32 winCnt = 5;
  inline bool has_wincnt() const;
  inline void clear_wincnt();
  static const int kWinCntFieldNumber = 5;
  inline ::google::protobuf::int32 wincnt() const;
  inline void set_wincnt(::google::protobuf::int32 value);
  
  // required int32 loseCnt = 6;
  inline bool has_losecnt() const;
  inline void clear_losecnt();
  static const int kLoseCntFieldNumber = 6;
  inline ::google::protobuf::int32 losecnt() const;
  inline void set_losecnt(::google::protobuf::int32 value);
  
  // required int32 allInCnt = 7;
  inline bool has_allincnt() const;
  inline void clear_allincnt();
  static const int kAllInCntFieldNumber = 7;
  inline ::google::protobuf::int32 allincnt() const;
  inline void set_allincnt(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:GameInfo)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_wincnt();
  inline void clear_has_wincnt();
  inline void set_has_losecnt();
  inline void clear_has_losecnt();
  inline void set_has_allincnt();
  inline void clear_has_allincnt();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  ::std::string* level_;
  ::std::string* money_;
  ::google::protobuf::int32 wincnt_;
  ::google::protobuf::int32 losecnt_;
  ::google::protobuf::int32 allincnt_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GameInfo* default_instance_;
};
// -------------------------------------------------------------------

class MemberInfo : public ::google::protobuf::MessageLite {
 public:
  MemberInfo();
  virtual ~MemberInfo();
  
  MemberInfo(const MemberInfo& from);
  
  inline MemberInfo& operator=(const MemberInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const MemberInfo& default_instance();
  
  void Swap(MemberInfo* other);
  
  // implements Message ----------------------------------------------
  
  MemberInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MemberInfo& from);
  void MergeFrom(const MemberInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required string avatarUrl = 2;
  inline bool has_avatarurl() const;
  inline void clear_avatarurl();
  static const int kAvatarUrlFieldNumber = 2;
  inline const ::std::string& avatarurl() const;
  inline void set_avatarurl(const ::std::string& value);
  inline void set_avatarurl(const char* value);
  inline void set_avatarurl(const char* value, size_t size);
  inline ::std::string* mutable_avatarurl();
  inline ::std::string* release_avatarurl();
  
  // required string nickName = 3;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNickNameFieldNumber = 3;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  
  // @@protoc_insertion_point(class_scope:MemberInfo)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_avatarurl();
  inline void clear_has_avatarurl();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  
  ::std::string* avatarurl_;
  ::std::string* nickname_;
  ::google::protobuf::int32 gameid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static MemberInfo* default_instance_;
};
// -------------------------------------------------------------------

class s_req_game_test_packet : public ::google::protobuf::MessageLite {
 public:
  s_req_game_test_packet();
  virtual ~s_req_game_test_packet();
  
  s_req_game_test_packet(const s_req_game_test_packet& from);
  
  inline s_req_game_test_packet& operator=(const s_req_game_test_packet& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_req_game_test_packet& default_instance();
  
  void Swap(s_req_game_test_packet* other);
  
  // implements Message ----------------------------------------------
  
  s_req_game_test_packet* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_req_game_test_packet& from);
  void MergeFrom(const s_req_game_test_packet& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 test_int = 2;
  inline bool has_test_int() const;
  inline void clear_test_int();
  static const int kTestIntFieldNumber = 2;
  inline ::google::protobuf::int32 test_int() const;
  inline void set_test_int(::google::protobuf::int32 value);
  
  // required string test_string = 3;
  inline bool has_test_string() const;
  inline void clear_test_string();
  static const int kTestStringFieldNumber = 3;
  inline const ::std::string& test_string() const;
  inline void set_test_string(const ::std::string& value);
  inline void set_test_string(const char* value);
  inline void set_test_string(const char* value, size_t size);
  inline ::std::string* mutable_test_string();
  inline ::std::string* release_test_string();
  
  // @@protoc_insertion_point(class_scope:s_req_game_test_packet)
 private:
  inline void set_has_test_int();
  inline void clear_has_test_int();
  inline void set_has_test_string();
  inline void clear_has_test_string();
  
  ::std::string* test_string_;
  ::google::protobuf::int32 test_int_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_req_game_test_packet* default_instance_;
};
// -------------------------------------------------------------------

class s_req_send_cmd : public ::google::protobuf::MessageLite {
 public:
  s_req_send_cmd();
  virtual ~s_req_send_cmd();
  
  s_req_send_cmd(const s_req_send_cmd& from);
  
  inline s_req_send_cmd& operator=(const s_req_send_cmd& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_req_send_cmd& default_instance();
  
  void Swap(s_req_send_cmd* other);
  
  // implements Message ----------------------------------------------
  
  s_req_send_cmd* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_req_send_cmd& from);
  void MergeFrom(const s_req_send_cmd& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 cmd_type = 2;
  inline bool has_cmd_type() const;
  inline void clear_cmd_type();
  static const int kCmdTypeFieldNumber = 2;
  inline ::google::protobuf::int32 cmd_type() const;
  inline void set_cmd_type(::google::protobuf::int32 value);
  
  // required string cmd = 3;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 3;
  inline const ::std::string& cmd() const;
  inline void set_cmd(const ::std::string& value);
  inline void set_cmd(const char* value);
  inline void set_cmd(const char* value, size_t size);
  inline ::std::string* mutable_cmd();
  inline ::std::string* release_cmd();
  
  // @@protoc_insertion_point(class_scope:s_req_send_cmd)
 private:
  inline void set_has_cmd_type();
  inline void clear_has_cmd_type();
  inline void set_has_cmd();
  inline void clear_has_cmd();
  
  ::std::string* cmd_;
  ::google::protobuf::int32 cmd_type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_req_send_cmd* default_instance_;
};
// -------------------------------------------------------------------

class GLReqGameProtocol : public ::google::protobuf::MessageLite {
 public:
  GLReqGameProtocol();
  virtual ~GLReqGameProtocol();
  
  GLReqGameProtocol(const GLReqGameProtocol& from);
  
  inline GLReqGameProtocol& operator=(const GLReqGameProtocol& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLReqGameProtocol& default_instance();
  
  void Swap(GLReqGameProtocol* other);
  
  // implements Message ----------------------------------------------
  
  GLReqGameProtocol* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLReqGameProtocol& from);
  void MergeFrom(const GLReqGameProtocol& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef GLReqGameProtocol_Type Type;
  static const Type NONE = GLReqGameProtocol_Type_NONE;
  static const Type req_game_test_packet = GLReqGameProtocol_Type_req_game_test_packet;
  static const Type req_send_cmd = GLReqGameProtocol_Type_req_send_cmd;
  static inline bool Type_IsValid(int value) {
    return GLReqGameProtocol_Type_IsValid(value);
  }
  static const Type Type_MIN =
    GLReqGameProtocol_Type_Type_MIN;
  static const Type Type_MAX =
    GLReqGameProtocol_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    GLReqGameProtocol_Type_Type_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required .GLReqGameProtocol.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::GLReqGameProtocol_Type type() const;
  inline void set_type(::GLReqGameProtocol_Type value);
  
  // optional .s_req_game_test_packet m_req_game_test_packet = 2;
  inline bool has_m_req_game_test_packet() const;
  inline void clear_m_req_game_test_packet();
  static const int kMReqGameTestPacketFieldNumber = 2;
  inline const ::s_req_game_test_packet& m_req_game_test_packet() const;
  inline ::s_req_game_test_packet* mutable_m_req_game_test_packet();
  inline ::s_req_game_test_packet* release_m_req_game_test_packet();
  
  // optional .s_req_send_cmd m_req_send_cmd = 3;
  inline bool has_m_req_send_cmd() const;
  inline void clear_m_req_send_cmd();
  static const int kMReqSendCmdFieldNumber = 3;
  inline const ::s_req_send_cmd& m_req_send_cmd() const;
  inline ::s_req_send_cmd* mutable_m_req_send_cmd();
  inline ::s_req_send_cmd* release_m_req_send_cmd();
  
  // @@protoc_insertion_point(class_scope:GLReqGameProtocol)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_m_req_game_test_packet();
  inline void clear_has_m_req_game_test_packet();
  inline void set_has_m_req_send_cmd();
  inline void clear_has_m_req_send_cmd();
  
  ::s_req_game_test_packet* m_req_game_test_packet_;
  ::s_req_send_cmd* m_req_send_cmd_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLReqGameProtocol* default_instance_;
};
// -------------------------------------------------------------------

class s_ans_game_test_packet : public ::google::protobuf::MessageLite {
 public:
  s_ans_game_test_packet();
  virtual ~s_ans_game_test_packet();
  
  s_ans_game_test_packet(const s_ans_game_test_packet& from);
  
  inline s_ans_game_test_packet& operator=(const s_ans_game_test_packet& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const s_ans_game_test_packet& default_instance();
  
  void Swap(s_ans_game_test_packet* other);
  
  // implements Message ----------------------------------------------
  
  s_ans_game_test_packet* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const s_ans_game_test_packet& from);
  void MergeFrom(const s_ans_game_test_packet& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 test_int = 2;
  inline bool has_test_int() const;
  inline void clear_test_int();
  static const int kTestIntFieldNumber = 2;
  inline ::google::protobuf::int32 test_int() const;
  inline void set_test_int(::google::protobuf::int32 value);
  
  // required string test_string = 3;
  inline bool has_test_string() const;
  inline void clear_test_string();
  static const int kTestStringFieldNumber = 3;
  inline const ::std::string& test_string() const;
  inline void set_test_string(const ::std::string& value);
  inline void set_test_string(const char* value);
  inline void set_test_string(const char* value, size_t size);
  inline ::std::string* mutable_test_string();
  inline ::std::string* release_test_string();
  
  // @@protoc_insertion_point(class_scope:s_ans_game_test_packet)
 private:
  inline void set_has_test_int();
  inline void clear_has_test_int();
  inline void set_has_test_string();
  inline void clear_has_test_string();
  
  ::std::string* test_string_;
  ::google::protobuf::int32 test_int_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static s_ans_game_test_packet* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameProtocol : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameProtocol();
  virtual ~GLAnsGameProtocol();
  
  GLAnsGameProtocol(const GLAnsGameProtocol& from);
  
  inline GLAnsGameProtocol& operator=(const GLAnsGameProtocol& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameProtocol& default_instance();
  
  void Swap(GLAnsGameProtocol* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameProtocol* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameProtocol& from);
  void MergeFrom(const GLAnsGameProtocol& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef GLAnsGameProtocol_Type Type;
  static const Type NONE = GLAnsGameProtocol_Type_NONE;
  static const Type ans_game_test_packet = GLAnsGameProtocol_Type_ans_game_test_packet;
  static inline bool Type_IsValid(int value) {
    return GLAnsGameProtocol_Type_IsValid(value);
  }
  static const Type Type_MIN =
    GLAnsGameProtocol_Type_Type_MIN;
  static const Type Type_MAX =
    GLAnsGameProtocol_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    GLAnsGameProtocol_Type_Type_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required .GLAnsGameProtocol.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::GLAnsGameProtocol_Type type() const;
  inline void set_type(::GLAnsGameProtocol_Type value);
  
  // optional .s_ans_game_test_packet m_ans_game_test_packet = 2;
  inline bool has_m_ans_game_test_packet() const;
  inline void clear_m_ans_game_test_packet();
  static const int kMAnsGameTestPacketFieldNumber = 2;
  inline const ::s_ans_game_test_packet& m_ans_game_test_packet() const;
  inline ::s_ans_game_test_packet* mutable_m_ans_game_test_packet();
  inline ::s_ans_game_test_packet* release_m_ans_game_test_packet();
  
  // @@protoc_insertion_point(class_scope:GLAnsGameProtocol)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_m_ans_game_test_packet();
  inline void clear_has_m_ans_game_test_packet();
  
  ::s_ans_game_test_packet* m_ans_game_test_packet_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameProtocol* default_instance_;
};
// ===================================================================


// ===================================================================

// GameUserInfo

// required .GameInfo gameInfo = 1;
inline bool GameUserInfo::has_gameinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameUserInfo::set_has_gameinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameUserInfo::clear_has_gameinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameUserInfo::clear_gameinfo() {
  if (gameinfo_ != NULL) gameinfo_->::GameInfo::Clear();
  clear_has_gameinfo();
}
inline const ::GameInfo& GameUserInfo::gameinfo() const {
  return gameinfo_ != NULL ? *gameinfo_ : *default_instance_->gameinfo_;
}
inline ::GameInfo* GameUserInfo::mutable_gameinfo() {
  set_has_gameinfo();
  if (gameinfo_ == NULL) gameinfo_ = new ::GameInfo;
  return gameinfo_;
}
inline ::GameInfo* GameUserInfo::release_gameinfo() {
  clear_has_gameinfo();
  ::GameInfo* temp = gameinfo_;
  gameinfo_ = NULL;
  return temp;
}

// required .MemberInfo memberInfo = 2;
inline bool GameUserInfo::has_memberinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameUserInfo::set_has_memberinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameUserInfo::clear_has_memberinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameUserInfo::clear_memberinfo() {
  if (memberinfo_ != NULL) memberinfo_->::MemberInfo::Clear();
  clear_has_memberinfo();
}
inline const ::MemberInfo& GameUserInfo::memberinfo() const {
  return memberinfo_ != NULL ? *memberinfo_ : *default_instance_->memberinfo_;
}
inline ::MemberInfo* GameUserInfo::mutable_memberinfo() {
  set_has_memberinfo();
  if (memberinfo_ == NULL) memberinfo_ = new ::MemberInfo;
  return memberinfo_;
}
inline ::MemberInfo* GameUserInfo::release_memberinfo() {
  clear_has_memberinfo();
  ::MemberInfo* temp = memberinfo_;
  memberinfo_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// GameRoomInfo

// required int32 roomID = 1;
inline bool GameRoomInfo::has_roomid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameRoomInfo::set_has_roomid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameRoomInfo::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameRoomInfo::clear_roomid() {
  roomid_ = 0;
  clear_has_roomid();
}
inline ::google::protobuf::int32 GameRoomInfo::roomid() const {
  return roomid_;
}
inline void GameRoomInfo::set_roomid(::google::protobuf::int32 value) {
  set_has_roomid();
  roomid_ = value;
}

// required int32 pointMoney = 2;
inline bool GameRoomInfo::has_pointmoney() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameRoomInfo::set_has_pointmoney() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameRoomInfo::clear_has_pointmoney() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameRoomInfo::clear_pointmoney() {
  pointmoney_ = 0;
  clear_has_pointmoney();
}
inline ::google::protobuf::int32 GameRoomInfo::pointmoney() const {
  return pointmoney_;
}
inline void GameRoomInfo::set_pointmoney(::google::protobuf::int32 value) {
  set_has_pointmoney();
  pointmoney_ = value;
}

// repeated .GameUserInfo gameUserInfo = 3;
inline int GameRoomInfo::gameuserinfo_size() const {
  return gameuserinfo_.size();
}
inline void GameRoomInfo::clear_gameuserinfo() {
  gameuserinfo_.Clear();
}
inline const ::GameUserInfo& GameRoomInfo::gameuserinfo(int index) const {
  return gameuserinfo_.Get(index);
}
inline ::GameUserInfo* GameRoomInfo::mutable_gameuserinfo(int index) {
  return gameuserinfo_.Mutable(index);
}
inline ::GameUserInfo* GameRoomInfo::add_gameuserinfo() {
  return gameuserinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::GameUserInfo >&
GameRoomInfo::gameuserinfo() const {
  return gameuserinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::GameUserInfo >*
GameRoomInfo::mutable_gameuserinfo() {
  return &gameuserinfo_;
}

// -------------------------------------------------------------------

// GameInfo

// required int32 gameID = 1;
inline bool GameInfo::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameInfo::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameInfo::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameInfo::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GameInfo::gameid() const {
  return gameid_;
}
inline void GameInfo::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GameInfo::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameInfo::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameInfo::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameInfo::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GameInfo::gameindex() const {
  return gameindex_;
}
inline void GameInfo::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// required string level = 3;
inline bool GameInfo::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameInfo::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameInfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameInfo::clear_level() {
  if (level_ != &::google::protobuf::internal::kEmptyString) {
    level_->clear();
  }
  clear_has_level();
}
inline const ::std::string& GameInfo::level() const {
  return *level_;
}
inline void GameInfo::set_level(const ::std::string& value) {
  set_has_level();
  if (level_ == &::google::protobuf::internal::kEmptyString) {
    level_ = new ::std::string;
  }
  level_->assign(value);
}
inline void GameInfo::set_level(const char* value) {
  set_has_level();
  if (level_ == &::google::protobuf::internal::kEmptyString) {
    level_ = new ::std::string;
  }
  level_->assign(value);
}
inline void GameInfo::set_level(const char* value, size_t size) {
  set_has_level();
  if (level_ == &::google::protobuf::internal::kEmptyString) {
    level_ = new ::std::string;
  }
  level_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameInfo::mutable_level() {
  set_has_level();
  if (level_ == &::google::protobuf::internal::kEmptyString) {
    level_ = new ::std::string;
  }
  return level_;
}
inline ::std::string* GameInfo::release_level() {
  clear_has_level();
  if (level_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = level_;
    level_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string money = 4;
inline bool GameInfo::has_money() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameInfo::set_has_money() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameInfo::clear_has_money() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameInfo::clear_money() {
  if (money_ != &::google::protobuf::internal::kEmptyString) {
    money_->clear();
  }
  clear_has_money();
}
inline const ::std::string& GameInfo::money() const {
  return *money_;
}
inline void GameInfo::set_money(const ::std::string& value) {
  set_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    money_ = new ::std::string;
  }
  money_->assign(value);
}
inline void GameInfo::set_money(const char* value) {
  set_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    money_ = new ::std::string;
  }
  money_->assign(value);
}
inline void GameInfo::set_money(const char* value, size_t size) {
  set_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    money_ = new ::std::string;
  }
  money_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameInfo::mutable_money() {
  set_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    money_ = new ::std::string;
  }
  return money_;
}
inline ::std::string* GameInfo::release_money() {
  clear_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = money_;
    money_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 winCnt = 5;
inline bool GameInfo::has_wincnt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameInfo::set_has_wincnt() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameInfo::clear_has_wincnt() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameInfo::clear_wincnt() {
  wincnt_ = 0;
  clear_has_wincnt();
}
inline ::google::protobuf::int32 GameInfo::wincnt() const {
  return wincnt_;
}
inline void GameInfo::set_wincnt(::google::protobuf::int32 value) {
  set_has_wincnt();
  wincnt_ = value;
}

// required int32 loseCnt = 6;
inline bool GameInfo::has_losecnt() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GameInfo::set_has_losecnt() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GameInfo::clear_has_losecnt() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GameInfo::clear_losecnt() {
  losecnt_ = 0;
  clear_has_losecnt();
}
inline ::google::protobuf::int32 GameInfo::losecnt() const {
  return losecnt_;
}
inline void GameInfo::set_losecnt(::google::protobuf::int32 value) {
  set_has_losecnt();
  losecnt_ = value;
}

// required int32 allInCnt = 7;
inline bool GameInfo::has_allincnt() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GameInfo::set_has_allincnt() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GameInfo::clear_has_allincnt() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GameInfo::clear_allincnt() {
  allincnt_ = 0;
  clear_has_allincnt();
}
inline ::google::protobuf::int32 GameInfo::allincnt() const {
  return allincnt_;
}
inline void GameInfo::set_allincnt(::google::protobuf::int32 value) {
  set_has_allincnt();
  allincnt_ = value;
}

// -------------------------------------------------------------------

// MemberInfo

// required int32 gameID = 1;
inline bool MemberInfo::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MemberInfo::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MemberInfo::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MemberInfo::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 MemberInfo::gameid() const {
  return gameid_;
}
inline void MemberInfo::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required string avatarUrl = 2;
inline bool MemberInfo::has_avatarurl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MemberInfo::set_has_avatarurl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MemberInfo::clear_has_avatarurl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MemberInfo::clear_avatarurl() {
  if (avatarurl_ != &::google::protobuf::internal::kEmptyString) {
    avatarurl_->clear();
  }
  clear_has_avatarurl();
}
inline const ::std::string& MemberInfo::avatarurl() const {
  return *avatarurl_;
}
inline void MemberInfo::set_avatarurl(const ::std::string& value) {
  set_has_avatarurl();
  if (avatarurl_ == &::google::protobuf::internal::kEmptyString) {
    avatarurl_ = new ::std::string;
  }
  avatarurl_->assign(value);
}
inline void MemberInfo::set_avatarurl(const char* value) {
  set_has_avatarurl();
  if (avatarurl_ == &::google::protobuf::internal::kEmptyString) {
    avatarurl_ = new ::std::string;
  }
  avatarurl_->assign(value);
}
inline void MemberInfo::set_avatarurl(const char* value, size_t size) {
  set_has_avatarurl();
  if (avatarurl_ == &::google::protobuf::internal::kEmptyString) {
    avatarurl_ = new ::std::string;
  }
  avatarurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MemberInfo::mutable_avatarurl() {
  set_has_avatarurl();
  if (avatarurl_ == &::google::protobuf::internal::kEmptyString) {
    avatarurl_ = new ::std::string;
  }
  return avatarurl_;
}
inline ::std::string* MemberInfo::release_avatarurl() {
  clear_has_avatarurl();
  if (avatarurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = avatarurl_;
    avatarurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string nickName = 3;
inline bool MemberInfo::has_nickname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MemberInfo::set_has_nickname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MemberInfo::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MemberInfo::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& MemberInfo::nickname() const {
  return *nickname_;
}
inline void MemberInfo::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void MemberInfo::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void MemberInfo::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MemberInfo::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* MemberInfo::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// s_req_game_test_packet

// required int32 test_int = 2;
inline bool s_req_game_test_packet::has_test_int() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_req_game_test_packet::set_has_test_int() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_req_game_test_packet::clear_has_test_int() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_req_game_test_packet::clear_test_int() {
  test_int_ = 0;
  clear_has_test_int();
}
inline ::google::protobuf::int32 s_req_game_test_packet::test_int() const {
  return test_int_;
}
inline void s_req_game_test_packet::set_test_int(::google::protobuf::int32 value) {
  set_has_test_int();
  test_int_ = value;
}

// required string test_string = 3;
inline bool s_req_game_test_packet::has_test_string() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void s_req_game_test_packet::set_has_test_string() {
  _has_bits_[0] |= 0x00000002u;
}
inline void s_req_game_test_packet::clear_has_test_string() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void s_req_game_test_packet::clear_test_string() {
  if (test_string_ != &::google::protobuf::internal::kEmptyString) {
    test_string_->clear();
  }
  clear_has_test_string();
}
inline const ::std::string& s_req_game_test_packet::test_string() const {
  return *test_string_;
}
inline void s_req_game_test_packet::set_test_string(const ::std::string& value) {
  set_has_test_string();
  if (test_string_ == &::google::protobuf::internal::kEmptyString) {
    test_string_ = new ::std::string;
  }
  test_string_->assign(value);
}
inline void s_req_game_test_packet::set_test_string(const char* value) {
  set_has_test_string();
  if (test_string_ == &::google::protobuf::internal::kEmptyString) {
    test_string_ = new ::std::string;
  }
  test_string_->assign(value);
}
inline void s_req_game_test_packet::set_test_string(const char* value, size_t size) {
  set_has_test_string();
  if (test_string_ == &::google::protobuf::internal::kEmptyString) {
    test_string_ = new ::std::string;
  }
  test_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* s_req_game_test_packet::mutable_test_string() {
  set_has_test_string();
  if (test_string_ == &::google::protobuf::internal::kEmptyString) {
    test_string_ = new ::std::string;
  }
  return test_string_;
}
inline ::std::string* s_req_game_test_packet::release_test_string() {
  clear_has_test_string();
  if (test_string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = test_string_;
    test_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// s_req_send_cmd

// required int32 cmd_type = 2;
inline bool s_req_send_cmd::has_cmd_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_req_send_cmd::set_has_cmd_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_req_send_cmd::clear_has_cmd_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_req_send_cmd::clear_cmd_type() {
  cmd_type_ = 0;
  clear_has_cmd_type();
}
inline ::google::protobuf::int32 s_req_send_cmd::cmd_type() const {
  return cmd_type_;
}
inline void s_req_send_cmd::set_cmd_type(::google::protobuf::int32 value) {
  set_has_cmd_type();
  cmd_type_ = value;
}

// required string cmd = 3;
inline bool s_req_send_cmd::has_cmd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void s_req_send_cmd::set_has_cmd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void s_req_send_cmd::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void s_req_send_cmd::clear_cmd() {
  if (cmd_ != &::google::protobuf::internal::kEmptyString) {
    cmd_->clear();
  }
  clear_has_cmd();
}
inline const ::std::string& s_req_send_cmd::cmd() const {
  return *cmd_;
}
inline void s_req_send_cmd::set_cmd(const ::std::string& value) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(value);
}
inline void s_req_send_cmd::set_cmd(const char* value) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(value);
}
inline void s_req_send_cmd::set_cmd(const char* value, size_t size) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* s_req_send_cmd::mutable_cmd() {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  return cmd_;
}
inline ::std::string* s_req_send_cmd::release_cmd() {
  clear_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cmd_;
    cmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GLReqGameProtocol

// required .GLReqGameProtocol.Type type = 1;
inline bool GLReqGameProtocol::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLReqGameProtocol::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLReqGameProtocol::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLReqGameProtocol::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::GLReqGameProtocol_Type GLReqGameProtocol::type() const {
  return static_cast< ::GLReqGameProtocol_Type >(type_);
}
inline void GLReqGameProtocol::set_type(::GLReqGameProtocol_Type value) {
  GOOGLE_DCHECK(::GLReqGameProtocol_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .s_req_game_test_packet m_req_game_test_packet = 2;
inline bool GLReqGameProtocol::has_m_req_game_test_packet() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLReqGameProtocol::set_has_m_req_game_test_packet() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLReqGameProtocol::clear_has_m_req_game_test_packet() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLReqGameProtocol::clear_m_req_game_test_packet() {
  if (m_req_game_test_packet_ != NULL) m_req_game_test_packet_->::s_req_game_test_packet::Clear();
  clear_has_m_req_game_test_packet();
}
inline const ::s_req_game_test_packet& GLReqGameProtocol::m_req_game_test_packet() const {
  return m_req_game_test_packet_ != NULL ? *m_req_game_test_packet_ : *default_instance_->m_req_game_test_packet_;
}
inline ::s_req_game_test_packet* GLReqGameProtocol::mutable_m_req_game_test_packet() {
  set_has_m_req_game_test_packet();
  if (m_req_game_test_packet_ == NULL) m_req_game_test_packet_ = new ::s_req_game_test_packet;
  return m_req_game_test_packet_;
}
inline ::s_req_game_test_packet* GLReqGameProtocol::release_m_req_game_test_packet() {
  clear_has_m_req_game_test_packet();
  ::s_req_game_test_packet* temp = m_req_game_test_packet_;
  m_req_game_test_packet_ = NULL;
  return temp;
}

// optional .s_req_send_cmd m_req_send_cmd = 3;
inline bool GLReqGameProtocol::has_m_req_send_cmd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GLReqGameProtocol::set_has_m_req_send_cmd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GLReqGameProtocol::clear_has_m_req_send_cmd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GLReqGameProtocol::clear_m_req_send_cmd() {
  if (m_req_send_cmd_ != NULL) m_req_send_cmd_->::s_req_send_cmd::Clear();
  clear_has_m_req_send_cmd();
}
inline const ::s_req_send_cmd& GLReqGameProtocol::m_req_send_cmd() const {
  return m_req_send_cmd_ != NULL ? *m_req_send_cmd_ : *default_instance_->m_req_send_cmd_;
}
inline ::s_req_send_cmd* GLReqGameProtocol::mutable_m_req_send_cmd() {
  set_has_m_req_send_cmd();
  if (m_req_send_cmd_ == NULL) m_req_send_cmd_ = new ::s_req_send_cmd;
  return m_req_send_cmd_;
}
inline ::s_req_send_cmd* GLReqGameProtocol::release_m_req_send_cmd() {
  clear_has_m_req_send_cmd();
  ::s_req_send_cmd* temp = m_req_send_cmd_;
  m_req_send_cmd_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// s_ans_game_test_packet

// required int32 test_int = 2;
inline bool s_ans_game_test_packet::has_test_int() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void s_ans_game_test_packet::set_has_test_int() {
  _has_bits_[0] |= 0x00000001u;
}
inline void s_ans_game_test_packet::clear_has_test_int() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void s_ans_game_test_packet::clear_test_int() {
  test_int_ = 0;
  clear_has_test_int();
}
inline ::google::protobuf::int32 s_ans_game_test_packet::test_int() const {
  return test_int_;
}
inline void s_ans_game_test_packet::set_test_int(::google::protobuf::int32 value) {
  set_has_test_int();
  test_int_ = value;
}

// required string test_string = 3;
inline bool s_ans_game_test_packet::has_test_string() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void s_ans_game_test_packet::set_has_test_string() {
  _has_bits_[0] |= 0x00000002u;
}
inline void s_ans_game_test_packet::clear_has_test_string() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void s_ans_game_test_packet::clear_test_string() {
  if (test_string_ != &::google::protobuf::internal::kEmptyString) {
    test_string_->clear();
  }
  clear_has_test_string();
}
inline const ::std::string& s_ans_game_test_packet::test_string() const {
  return *test_string_;
}
inline void s_ans_game_test_packet::set_test_string(const ::std::string& value) {
  set_has_test_string();
  if (test_string_ == &::google::protobuf::internal::kEmptyString) {
    test_string_ = new ::std::string;
  }
  test_string_->assign(value);
}
inline void s_ans_game_test_packet::set_test_string(const char* value) {
  set_has_test_string();
  if (test_string_ == &::google::protobuf::internal::kEmptyString) {
    test_string_ = new ::std::string;
  }
  test_string_->assign(value);
}
inline void s_ans_game_test_packet::set_test_string(const char* value, size_t size) {
  set_has_test_string();
  if (test_string_ == &::google::protobuf::internal::kEmptyString) {
    test_string_ = new ::std::string;
  }
  test_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* s_ans_game_test_packet::mutable_test_string() {
  set_has_test_string();
  if (test_string_ == &::google::protobuf::internal::kEmptyString) {
    test_string_ = new ::std::string;
  }
  return test_string_;
}
inline ::std::string* s_ans_game_test_packet::release_test_string() {
  clear_has_test_string();
  if (test_string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = test_string_;
    test_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GLAnsGameProtocol

// required .GLAnsGameProtocol.Type type = 1;
inline bool GLAnsGameProtocol::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameProtocol::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameProtocol::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameProtocol::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::GLAnsGameProtocol_Type GLAnsGameProtocol::type() const {
  return static_cast< ::GLAnsGameProtocol_Type >(type_);
}
inline void GLAnsGameProtocol::set_type(::GLAnsGameProtocol_Type value) {
  GOOGLE_DCHECK(::GLAnsGameProtocol_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .s_ans_game_test_packet m_ans_game_test_packet = 2;
inline bool GLAnsGameProtocol::has_m_ans_game_test_packet() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameProtocol::set_has_m_ans_game_test_packet() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameProtocol::clear_has_m_ans_game_test_packet() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameProtocol::clear_m_ans_game_test_packet() {
  if (m_ans_game_test_packet_ != NULL) m_ans_game_test_packet_->::s_ans_game_test_packet::Clear();
  clear_has_m_ans_game_test_packet();
}
inline const ::s_ans_game_test_packet& GLAnsGameProtocol::m_ans_game_test_packet() const {
  return m_ans_game_test_packet_ != NULL ? *m_ans_game_test_packet_ : *default_instance_->m_ans_game_test_packet_;
}
inline ::s_ans_game_test_packet* GLAnsGameProtocol::mutable_m_ans_game_test_packet() {
  set_has_m_ans_game_test_packet();
  if (m_ans_game_test_packet_ == NULL) m_ans_game_test_packet_ = new ::s_ans_game_test_packet;
  return m_ans_game_test_packet_;
}
inline ::s_ans_game_test_packet* GLAnsGameProtocol::release_m_ans_game_test_packet() {
  clear_has_m_ans_game_test_packet();
  ::s_ans_game_test_packet* temp = m_ans_game_test_packet_;
  m_ans_game_test_packet_ = NULL;
  return temp;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_gameLogic_2eproto__INCLUDED
