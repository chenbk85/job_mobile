// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: game.proto

#ifndef PROTOBUF_game_2eproto__INCLUDED
#define PROTOBUF_game_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "db.pb.h"
#include "gameLogic.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_game_2eproto();
void protobuf_AssignDesc_game_2eproto();
void protobuf_ShutdownFile_game_2eproto();

class GReqGameEnter;
class GAnsGameEnter;
class GReqGameLeave;
class GAnsGameLeave;
class GReqDetach;
class GAnsDetach;
class GReqPlug;
class GAnsPlug;
class GError;
class GErrPlug;
class GAnsUserUpdate;
class GReqProtocol;
class GAnsProtocol;

enum GAnsGameLeave_KICK_TYPE {
  GAnsGameLeave_KICK_TYPE_EXIT_RESERVATION = 1,
  GAnsGameLeave_KICK_TYPE_LIMITMONEY = 2,
  GAnsGameLeave_KICK_TYPE_ALLIN = 3,
  GAnsGameLeave_KICK_TYPE_SYSTEM_ERROR = 4,
  GAnsGameLeave_KICK_TYPE_KICK_ZERO = 5
};
bool GAnsGameLeave_KICK_TYPE_IsValid(int value);
const GAnsGameLeave_KICK_TYPE GAnsGameLeave_KICK_TYPE_KICK_TYPE_MIN = GAnsGameLeave_KICK_TYPE_EXIT_RESERVATION;
const GAnsGameLeave_KICK_TYPE GAnsGameLeave_KICK_TYPE_KICK_TYPE_MAX = GAnsGameLeave_KICK_TYPE_KICK_ZERO;
const int GAnsGameLeave_KICK_TYPE_KICK_TYPE_ARRAYSIZE = GAnsGameLeave_KICK_TYPE_KICK_TYPE_MAX + 1;

enum GReqProtocol_Type {
  GReqProtocol_Type_NONE = 1,
  GReqProtocol_Type_GREQGAMEENTER = 2,
  GReqProtocol_Type_GREQGAMELEAVE = 3,
  GReqProtocol_Type_GREQDETACH = 4,
  GReqProtocol_Type_GREQPLUG = 5,
  GReqProtocol_Type_GLREQGAMEPROTOCOL = 6,
  GReqProtocol_Type_GDBANS = 7
};
bool GReqProtocol_Type_IsValid(int value);
const GReqProtocol_Type GReqProtocol_Type_Type_MIN = GReqProtocol_Type_NONE;
const GReqProtocol_Type GReqProtocol_Type_Type_MAX = GReqProtocol_Type_GDBANS;
const int GReqProtocol_Type_Type_ARRAYSIZE = GReqProtocol_Type_Type_MAX + 1;

enum GAnsProtocol_Type {
  GAnsProtocol_Type_NONE = 1,
  GAnsProtocol_Type_GANSGAMEENTER = 2,
  GAnsProtocol_Type_GANSGAMELEAVE = 3,
  GAnsProtocol_Type_GANSDETACH = 4,
  GAnsProtocol_Type_GANSPLUG = 5,
  GAnsProtocol_Type_GERRPLUG = 6,
  GAnsProtocol_Type_GLANSGAMEPROTOCOL = 7,
  GAnsProtocol_Type_GDBREQ = 8,
  GAnsProtocol_Type_GANSUSERUPDATE = 9
};
bool GAnsProtocol_Type_IsValid(int value);
const GAnsProtocol_Type GAnsProtocol_Type_Type_MIN = GAnsProtocol_Type_NONE;
const GAnsProtocol_Type GAnsProtocol_Type_Type_MAX = GAnsProtocol_Type_GANSUSERUPDATE;
const int GAnsProtocol_Type_Type_ARRAYSIZE = GAnsProtocol_Type_Type_MAX + 1;

// ===================================================================

class GReqGameEnter : public ::google::protobuf::MessageLite {
 public:
  GReqGameEnter();
  virtual ~GReqGameEnter();
  
  GReqGameEnter(const GReqGameEnter& from);
  
  inline GReqGameEnter& operator=(const GReqGameEnter& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GReqGameEnter& default_instance();
  
  void Swap(GReqGameEnter* other);
  
  // implements Message ----------------------------------------------
  
  GReqGameEnter* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GReqGameEnter& from);
  void MergeFrom(const GReqGameEnter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 categoryID = 1;
  inline bool has_categoryid() const;
  inline void clear_categoryid();
  static const int kCategoryIDFieldNumber = 1;
  inline ::google::protobuf::int32 categoryid() const;
  inline void set_categoryid(::google::protobuf::int32 value);
  
  // required int32 channelID = 2;
  inline bool has_channelid() const;
  inline void clear_channelid();
  static const int kChannelIDFieldNumber = 2;
  inline ::google::protobuf::int32 channelid() const;
  inline void set_channelid(::google::protobuf::int32 value);
  
  // required int32 roomID = 3;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIDFieldNumber = 3;
  inline ::google::protobuf::int32 roomid() const;
  inline void set_roomid(::google::protobuf::int32 value);
  
  // required .GameUserInfo gameUserInfo = 4;
  inline bool has_gameuserinfo() const;
  inline void clear_gameuserinfo();
  static const int kGameUserInfoFieldNumber = 4;
  inline const ::GameUserInfo& gameuserinfo() const;
  inline ::GameUserInfo* mutable_gameuserinfo();
  inline ::GameUserInfo* release_gameuserinfo();
  
  // @@protoc_insertion_point(class_scope:GReqGameEnter)
 private:
  inline void set_has_categoryid();
  inline void clear_has_categoryid();
  inline void set_has_channelid();
  inline void clear_has_channelid();
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_gameuserinfo();
  inline void clear_has_gameuserinfo();
  
  ::google::protobuf::int32 categoryid_;
  ::google::protobuf::int32 channelid_;
  ::GameUserInfo* gameuserinfo_;
  ::google::protobuf::int32 roomid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();
  
  void InitAsDefaultInstance();
  static GReqGameEnter* default_instance_;
};
// -------------------------------------------------------------------

class GAnsGameEnter : public ::google::protobuf::MessageLite {
 public:
  GAnsGameEnter();
  virtual ~GAnsGameEnter();
  
  GAnsGameEnter(const GAnsGameEnter& from);
  
  inline GAnsGameEnter& operator=(const GAnsGameEnter& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GAnsGameEnter& default_instance();
  
  void Swap(GAnsGameEnter* other);
  
  // implements Message ----------------------------------------------
  
  GAnsGameEnter* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GAnsGameEnter& from);
  void MergeFrom(const GAnsGameEnter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .GameRoomInfo gameRoomInfo = 1;
  inline bool has_gameroominfo() const;
  inline void clear_gameroominfo();
  static const int kGameRoomInfoFieldNumber = 1;
  inline const ::GameRoomInfo& gameroominfo() const;
  inline ::GameRoomInfo* mutable_gameroominfo();
  inline ::GameRoomInfo* release_gameroominfo();
  
  // @@protoc_insertion_point(class_scope:GAnsGameEnter)
 private:
  inline void set_has_gameroominfo();
  inline void clear_has_gameroominfo();
  
  ::GameRoomInfo* gameroominfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();
  
  void InitAsDefaultInstance();
  static GAnsGameEnter* default_instance_;
};
// -------------------------------------------------------------------

class GReqGameLeave : public ::google::protobuf::MessageLite {
 public:
  GReqGameLeave();
  virtual ~GReqGameLeave();
  
  GReqGameLeave(const GReqGameLeave& from);
  
  inline GReqGameLeave& operator=(const GReqGameLeave& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GReqGameLeave& default_instance();
  
  void Swap(GReqGameLeave* other);
  
  // implements Message ----------------------------------------------
  
  GReqGameLeave* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GReqGameLeave& from);
  void MergeFrom(const GReqGameLeave& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required bool kick = 2;
  inline bool has_kick() const;
  inline void clear_kick();
  static const int kKickFieldNumber = 2;
  inline bool kick() const;
  inline void set_kick(bool value);
  
  // @@protoc_insertion_point(class_scope:GReqGameLeave)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_kick();
  inline void clear_has_kick();
  
  ::google::protobuf::int32 gameid_;
  bool kick_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();
  
  void InitAsDefaultInstance();
  static GReqGameLeave* default_instance_;
};
// -------------------------------------------------------------------

class GAnsGameLeave : public ::google::protobuf::MessageLite {
 public:
  GAnsGameLeave();
  virtual ~GAnsGameLeave();
  
  GAnsGameLeave(const GAnsGameLeave& from);
  
  inline GAnsGameLeave& operator=(const GAnsGameLeave& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GAnsGameLeave& default_instance();
  
  void Swap(GAnsGameLeave* other);
  
  // implements Message ----------------------------------------------
  
  GAnsGameLeave* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GAnsGameLeave& from);
  void MergeFrom(const GAnsGameLeave& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef GAnsGameLeave_KICK_TYPE KICK_TYPE;
  static const KICK_TYPE EXIT_RESERVATION = GAnsGameLeave_KICK_TYPE_EXIT_RESERVATION;
  static const KICK_TYPE LIMITMONEY = GAnsGameLeave_KICK_TYPE_LIMITMONEY;
  static const KICK_TYPE ALLIN = GAnsGameLeave_KICK_TYPE_ALLIN;
  static const KICK_TYPE SYSTEM_ERROR = GAnsGameLeave_KICK_TYPE_SYSTEM_ERROR;
  static const KICK_TYPE KICK_ZERO = GAnsGameLeave_KICK_TYPE_KICK_ZERO;
  static inline bool KICK_TYPE_IsValid(int value) {
    return GAnsGameLeave_KICK_TYPE_IsValid(value);
  }
  static const KICK_TYPE KICK_TYPE_MIN =
    GAnsGameLeave_KICK_TYPE_KICK_TYPE_MIN;
  static const KICK_TYPE KICK_TYPE_MAX =
    GAnsGameLeave_KICK_TYPE_KICK_TYPE_MAX;
  static const int KICK_TYPE_ARRAYSIZE =
    GAnsGameLeave_KICK_TYPE_KICK_TYPE_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required .GAnsGameLeave.KICK_TYPE nType = 2;
  inline bool has_ntype() const;
  inline void clear_ntype();
  static const int kNTypeFieldNumber = 2;
  inline ::GAnsGameLeave_KICK_TYPE ntype() const;
  inline void set_ntype(::GAnsGameLeave_KICK_TYPE value);
  
  // @@protoc_insertion_point(class_scope:GAnsGameLeave)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_ntype();
  inline void clear_has_ntype();
  
  ::google::protobuf::int32 gameid_;
  int ntype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();
  
  void InitAsDefaultInstance();
  static GAnsGameLeave* default_instance_;
};
// -------------------------------------------------------------------

class GReqDetach : public ::google::protobuf::MessageLite {
 public:
  GReqDetach();
  virtual ~GReqDetach();
  
  GReqDetach(const GReqDetach& from);
  
  inline GReqDetach& operator=(const GReqDetach& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GReqDetach& default_instance();
  
  void Swap(GReqDetach* other);
  
  // implements Message ----------------------------------------------
  
  GReqDetach* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GReqDetach& from);
  void MergeFrom(const GReqDetach& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:GReqDetach)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  
  ::google::protobuf::int32 gameid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();
  
  void InitAsDefaultInstance();
  static GReqDetach* default_instance_;
};
// -------------------------------------------------------------------

class GAnsDetach : public ::google::protobuf::MessageLite {
 public:
  GAnsDetach();
  virtual ~GAnsDetach();
  
  GAnsDetach(const GAnsDetach& from);
  
  inline GAnsDetach& operator=(const GAnsDetach& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GAnsDetach& default_instance();
  
  void Swap(GAnsDetach* other);
  
  // implements Message ----------------------------------------------
  
  GAnsDetach* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GAnsDetach& from);
  void MergeFrom(const GAnsDetach& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:GAnsDetach)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  
  ::google::protobuf::int32 gameid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();
  
  void InitAsDefaultInstance();
  static GAnsDetach* default_instance_;
};
// -------------------------------------------------------------------

class GReqPlug : public ::google::protobuf::MessageLite {
 public:
  GReqPlug();
  virtual ~GReqPlug();
  
  GReqPlug(const GReqPlug& from);
  
  inline GReqPlug& operator=(const GReqPlug& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GReqPlug& default_instance();
  
  void Swap(GReqPlug* other);
  
  // implements Message ----------------------------------------------
  
  GReqPlug* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GReqPlug& from);
  void MergeFrom(const GReqPlug& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:GReqPlug)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  
  ::google::protobuf::int32 gameid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();
  
  void InitAsDefaultInstance();
  static GReqPlug* default_instance_;
};
// -------------------------------------------------------------------

class GAnsPlug : public ::google::protobuf::MessageLite {
 public:
  GAnsPlug();
  virtual ~GAnsPlug();
  
  GAnsPlug(const GAnsPlug& from);
  
  inline GAnsPlug& operator=(const GAnsPlug& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GAnsPlug& default_instance();
  
  void Swap(GAnsPlug* other);
  
  // implements Message ----------------------------------------------
  
  GAnsPlug* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GAnsPlug& from);
  void MergeFrom(const GAnsPlug& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:GAnsPlug)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  
  ::google::protobuf::int32 gameid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();
  
  void InitAsDefaultInstance();
  static GAnsPlug* default_instance_;
};
// -------------------------------------------------------------------

class GError : public ::google::protobuf::MessageLite {
 public:
  GError();
  virtual ~GError();
  
  GError(const GError& from);
  
  inline GError& operator=(const GError& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GError& default_instance();
  
  void Swap(GError* other);
  
  // implements Message ----------------------------------------------
  
  GError* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GError& from);
  void MergeFrom(const GError& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 errorCode = 1;
  inline bool has_errorcode() const;
  inline void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::int32 errorcode() const;
  inline void set_errorcode(::google::protobuf::int32 value);
  
  // required string errorInfo = 2;
  inline bool has_errorinfo() const;
  inline void clear_errorinfo();
  static const int kErrorInfoFieldNumber = 2;
  inline const ::std::string& errorinfo() const;
  inline void set_errorinfo(const ::std::string& value);
  inline void set_errorinfo(const char* value);
  inline void set_errorinfo(const char* value, size_t size);
  inline ::std::string* mutable_errorinfo();
  inline ::std::string* release_errorinfo();
  
  // @@protoc_insertion_point(class_scope:GError)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_errorinfo();
  inline void clear_has_errorinfo();
  
  ::std::string* errorinfo_;
  ::google::protobuf::int32 errorcode_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();
  
  void InitAsDefaultInstance();
  static GError* default_instance_;
};
// -------------------------------------------------------------------

class GErrPlug : public ::google::protobuf::MessageLite {
 public:
  GErrPlug();
  virtual ~GErrPlug();
  
  GErrPlug(const GErrPlug& from);
  
  inline GErrPlug& operator=(const GErrPlug& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GErrPlug& default_instance();
  
  void Swap(GErrPlug* other);
  
  // implements Message ----------------------------------------------
  
  GErrPlug* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GErrPlug& from);
  void MergeFrom(const GErrPlug& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .GError error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::GError& error() const;
  inline ::GError* mutable_error();
  inline ::GError* release_error();
  
  // @@protoc_insertion_point(class_scope:GErrPlug)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::GError* error_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();
  
  void InitAsDefaultInstance();
  static GErrPlug* default_instance_;
};
// -------------------------------------------------------------------

class GAnsUserUpdate : public ::google::protobuf::MessageLite {
 public:
  GAnsUserUpdate();
  virtual ~GAnsUserUpdate();
  
  GAnsUserUpdate(const GAnsUserUpdate& from);
  
  inline GAnsUserUpdate& operator=(const GAnsUserUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GAnsUserUpdate& default_instance();
  
  void Swap(GAnsUserUpdate* other);
  
  // implements Message ----------------------------------------------
  
  GAnsUserUpdate* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GAnsUserUpdate& from);
  void MergeFrom(const GAnsUserUpdate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // required bytes updateInfo = 2;
  inline bool has_updateinfo() const;
  inline void clear_updateinfo();
  static const int kUpdateInfoFieldNumber = 2;
  inline const ::std::string& updateinfo() const;
  inline void set_updateinfo(const ::std::string& value);
  inline void set_updateinfo(const char* value);
  inline void set_updateinfo(const void* value, size_t size);
  inline ::std::string* mutable_updateinfo();
  inline ::std::string* release_updateinfo();
  
  // @@protoc_insertion_point(class_scope:GAnsUserUpdate)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_updateinfo();
  inline void clear_has_updateinfo();
  
  ::std::string* updateinfo_;
  ::google::protobuf::int32 type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();
  
  void InitAsDefaultInstance();
  static GAnsUserUpdate* default_instance_;
};
// -------------------------------------------------------------------

class GReqProtocol : public ::google::protobuf::MessageLite {
 public:
  GReqProtocol();
  virtual ~GReqProtocol();
  
  GReqProtocol(const GReqProtocol& from);
  
  inline GReqProtocol& operator=(const GReqProtocol& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GReqProtocol& default_instance();
  
  void Swap(GReqProtocol* other);
  
  // implements Message ----------------------------------------------
  
  GReqProtocol* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GReqProtocol& from);
  void MergeFrom(const GReqProtocol& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef GReqProtocol_Type Type;
  static const Type NONE = GReqProtocol_Type_NONE;
  static const Type GREQGAMEENTER = GReqProtocol_Type_GREQGAMEENTER;
  static const Type GREQGAMELEAVE = GReqProtocol_Type_GREQGAMELEAVE;
  static const Type GREQDETACH = GReqProtocol_Type_GREQDETACH;
  static const Type GREQPLUG = GReqProtocol_Type_GREQPLUG;
  static const Type GLREQGAMEPROTOCOL = GReqProtocol_Type_GLREQGAMEPROTOCOL;
  static const Type GDBANS = GReqProtocol_Type_GDBANS;
  static inline bool Type_IsValid(int value) {
    return GReqProtocol_Type_IsValid(value);
  }
  static const Type Type_MIN =
    GReqProtocol_Type_Type_MIN;
  static const Type Type_MAX =
    GReqProtocol_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    GReqProtocol_Type_Type_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required .GReqProtocol.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::GReqProtocol_Type type() const;
  inline void set_type(::GReqProtocol_Type value);
  
  // optional .GReqGameEnter reqGameEnter = 2;
  inline bool has_reqgameenter() const;
  inline void clear_reqgameenter();
  static const int kReqGameEnterFieldNumber = 2;
  inline const ::GReqGameEnter& reqgameenter() const;
  inline ::GReqGameEnter* mutable_reqgameenter();
  inline ::GReqGameEnter* release_reqgameenter();
  
  // optional .GReqGameLeave reqGameLeave = 3;
  inline bool has_reqgameleave() const;
  inline void clear_reqgameleave();
  static const int kReqGameLeaveFieldNumber = 3;
  inline const ::GReqGameLeave& reqgameleave() const;
  inline ::GReqGameLeave* mutable_reqgameleave();
  inline ::GReqGameLeave* release_reqgameleave();
  
  // optional .GReqDetach reqDetach = 4;
  inline bool has_reqdetach() const;
  inline void clear_reqdetach();
  static const int kReqDetachFieldNumber = 4;
  inline const ::GReqDetach& reqdetach() const;
  inline ::GReqDetach* mutable_reqdetach();
  inline ::GReqDetach* release_reqdetach();
  
  // optional .GReqPlug reqPlug = 5;
  inline bool has_reqplug() const;
  inline void clear_reqplug();
  static const int kReqPlugFieldNumber = 5;
  inline const ::GReqPlug& reqplug() const;
  inline ::GReqPlug* mutable_reqplug();
  inline ::GReqPlug* release_reqplug();
  
  // optional .GLReqGameProtocol reqGameProtocol = 6;
  inline bool has_reqgameprotocol() const;
  inline void clear_reqgameprotocol();
  static const int kReqGameProtocolFieldNumber = 6;
  inline const ::GLReqGameProtocol& reqgameprotocol() const;
  inline ::GLReqGameProtocol* mutable_reqgameprotocol();
  inline ::GLReqGameProtocol* release_reqgameprotocol();
  
  // optional .AnsDB ansDB = 7;
  inline bool has_ansdb() const;
  inline void clear_ansdb();
  static const int kAnsDBFieldNumber = 7;
  inline const ::AnsDB& ansdb() const;
  inline ::AnsDB* mutable_ansdb();
  inline ::AnsDB* release_ansdb();
  
  // @@protoc_insertion_point(class_scope:GReqProtocol)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_reqgameenter();
  inline void clear_has_reqgameenter();
  inline void set_has_reqgameleave();
  inline void clear_has_reqgameleave();
  inline void set_has_reqdetach();
  inline void clear_has_reqdetach();
  inline void set_has_reqplug();
  inline void clear_has_reqplug();
  inline void set_has_reqgameprotocol();
  inline void clear_has_reqgameprotocol();
  inline void set_has_ansdb();
  inline void clear_has_ansdb();
  
  ::GReqGameEnter* reqgameenter_;
  ::GReqGameLeave* reqgameleave_;
  ::GReqDetach* reqdetach_;
  ::GReqPlug* reqplug_;
  ::GLReqGameProtocol* reqgameprotocol_;
  ::AnsDB* ansdb_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();
  
  void InitAsDefaultInstance();
  static GReqProtocol* default_instance_;
};
// -------------------------------------------------------------------

class GAnsProtocol : public ::google::protobuf::MessageLite {
 public:
  GAnsProtocol();
  virtual ~GAnsProtocol();
  
  GAnsProtocol(const GAnsProtocol& from);
  
  inline GAnsProtocol& operator=(const GAnsProtocol& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GAnsProtocol& default_instance();
  
  void Swap(GAnsProtocol* other);
  
  // implements Message ----------------------------------------------
  
  GAnsProtocol* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GAnsProtocol& from);
  void MergeFrom(const GAnsProtocol& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef GAnsProtocol_Type Type;
  static const Type NONE = GAnsProtocol_Type_NONE;
  static const Type GANSGAMEENTER = GAnsProtocol_Type_GANSGAMEENTER;
  static const Type GANSGAMELEAVE = GAnsProtocol_Type_GANSGAMELEAVE;
  static const Type GANSDETACH = GAnsProtocol_Type_GANSDETACH;
  static const Type GANSPLUG = GAnsProtocol_Type_GANSPLUG;
  static const Type GERRPLUG = GAnsProtocol_Type_GERRPLUG;
  static const Type GLANSGAMEPROTOCOL = GAnsProtocol_Type_GLANSGAMEPROTOCOL;
  static const Type GDBREQ = GAnsProtocol_Type_GDBREQ;
  static const Type GANSUSERUPDATE = GAnsProtocol_Type_GANSUSERUPDATE;
  static inline bool Type_IsValid(int value) {
    return GAnsProtocol_Type_IsValid(value);
  }
  static const Type Type_MIN =
    GAnsProtocol_Type_Type_MIN;
  static const Type Type_MAX =
    GAnsProtocol_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    GAnsProtocol_Type_Type_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required .GAnsProtocol.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::GAnsProtocol_Type type() const;
  inline void set_type(::GAnsProtocol_Type value);
  
  // optional .GAnsGameEnter ansGameEnter = 2;
  inline bool has_ansgameenter() const;
  inline void clear_ansgameenter();
  static const int kAnsGameEnterFieldNumber = 2;
  inline const ::GAnsGameEnter& ansgameenter() const;
  inline ::GAnsGameEnter* mutable_ansgameenter();
  inline ::GAnsGameEnter* release_ansgameenter();
  
  // optional .GAnsGameLeave ansGameLeave = 3;
  inline bool has_ansgameleave() const;
  inline void clear_ansgameleave();
  static const int kAnsGameLeaveFieldNumber = 3;
  inline const ::GAnsGameLeave& ansgameleave() const;
  inline ::GAnsGameLeave* mutable_ansgameleave();
  inline ::GAnsGameLeave* release_ansgameleave();
  
  // optional .GAnsDetach ansDetach = 4;
  inline bool has_ansdetach() const;
  inline void clear_ansdetach();
  static const int kAnsDetachFieldNumber = 4;
  inline const ::GAnsDetach& ansdetach() const;
  inline ::GAnsDetach* mutable_ansdetach();
  inline ::GAnsDetach* release_ansdetach();
  
  // optional .GAnsPlug ansPlug = 5;
  inline bool has_ansplug() const;
  inline void clear_ansplug();
  static const int kAnsPlugFieldNumber = 5;
  inline const ::GAnsPlug& ansplug() const;
  inline ::GAnsPlug* mutable_ansplug();
  inline ::GAnsPlug* release_ansplug();
  
  // optional .GErrPlug ansErr = 6;
  inline bool has_anserr() const;
  inline void clear_anserr();
  static const int kAnsErrFieldNumber = 6;
  inline const ::GErrPlug& anserr() const;
  inline ::GErrPlug* mutable_anserr();
  inline ::GErrPlug* release_anserr();
  
  // optional .GLAnsGameProtocol ansGameProtocol = 7;
  inline bool has_ansgameprotocol() const;
  inline void clear_ansgameprotocol();
  static const int kAnsGameProtocolFieldNumber = 7;
  inline const ::GLAnsGameProtocol& ansgameprotocol() const;
  inline ::GLAnsGameProtocol* mutable_ansgameprotocol();
  inline ::GLAnsGameProtocol* release_ansgameprotocol();
  
  // optional .ReqDB reqDB = 8;
  inline bool has_reqdb() const;
  inline void clear_reqdb();
  static const int kReqDBFieldNumber = 8;
  inline const ::ReqDB& reqdb() const;
  inline ::ReqDB* mutable_reqdb();
  inline ::ReqDB* release_reqdb();
  
  // optional .GAnsUserUpdate ansUpdate = 9;
  inline bool has_ansupdate() const;
  inline void clear_ansupdate();
  static const int kAnsUpdateFieldNumber = 9;
  inline const ::GAnsUserUpdate& ansupdate() const;
  inline ::GAnsUserUpdate* mutable_ansupdate();
  inline ::GAnsUserUpdate* release_ansupdate();
  
  // @@protoc_insertion_point(class_scope:GAnsProtocol)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_ansgameenter();
  inline void clear_has_ansgameenter();
  inline void set_has_ansgameleave();
  inline void clear_has_ansgameleave();
  inline void set_has_ansdetach();
  inline void clear_has_ansdetach();
  inline void set_has_ansplug();
  inline void clear_has_ansplug();
  inline void set_has_anserr();
  inline void clear_has_anserr();
  inline void set_has_ansgameprotocol();
  inline void clear_has_ansgameprotocol();
  inline void set_has_reqdb();
  inline void clear_has_reqdb();
  inline void set_has_ansupdate();
  inline void clear_has_ansupdate();
  
  ::GAnsGameEnter* ansgameenter_;
  ::GAnsGameLeave* ansgameleave_;
  ::GAnsDetach* ansdetach_;
  ::GAnsPlug* ansplug_;
  ::GErrPlug* anserr_;
  ::GLAnsGameProtocol* ansgameprotocol_;
  ::ReqDB* reqdb_;
  ::GAnsUserUpdate* ansupdate_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();
  
  void InitAsDefaultInstance();
  static GAnsProtocol* default_instance_;
};
// ===================================================================


// ===================================================================

// GReqGameEnter

// required int32 categoryID = 1;
inline bool GReqGameEnter::has_categoryid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GReqGameEnter::set_has_categoryid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GReqGameEnter::clear_has_categoryid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GReqGameEnter::clear_categoryid() {
  categoryid_ = 0;
  clear_has_categoryid();
}
inline ::google::protobuf::int32 GReqGameEnter::categoryid() const {
  return categoryid_;
}
inline void GReqGameEnter::set_categoryid(::google::protobuf::int32 value) {
  set_has_categoryid();
  categoryid_ = value;
}

// required int32 channelID = 2;
inline bool GReqGameEnter::has_channelid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GReqGameEnter::set_has_channelid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GReqGameEnter::clear_has_channelid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GReqGameEnter::clear_channelid() {
  channelid_ = 0;
  clear_has_channelid();
}
inline ::google::protobuf::int32 GReqGameEnter::channelid() const {
  return channelid_;
}
inline void GReqGameEnter::set_channelid(::google::protobuf::int32 value) {
  set_has_channelid();
  channelid_ = value;
}

// required int32 roomID = 3;
inline bool GReqGameEnter::has_roomid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GReqGameEnter::set_has_roomid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GReqGameEnter::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GReqGameEnter::clear_roomid() {
  roomid_ = 0;
  clear_has_roomid();
}
inline ::google::protobuf::int32 GReqGameEnter::roomid() const {
  return roomid_;
}
inline void GReqGameEnter::set_roomid(::google::protobuf::int32 value) {
  set_has_roomid();
  roomid_ = value;
}

// required .GameUserInfo gameUserInfo = 4;
inline bool GReqGameEnter::has_gameuserinfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GReqGameEnter::set_has_gameuserinfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GReqGameEnter::clear_has_gameuserinfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GReqGameEnter::clear_gameuserinfo() {
  if (gameuserinfo_ != NULL) gameuserinfo_->::GameUserInfo::Clear();
  clear_has_gameuserinfo();
}
inline const ::GameUserInfo& GReqGameEnter::gameuserinfo() const {
  return gameuserinfo_ != NULL ? *gameuserinfo_ : *default_instance_->gameuserinfo_;
}
inline ::GameUserInfo* GReqGameEnter::mutable_gameuserinfo() {
  set_has_gameuserinfo();
  if (gameuserinfo_ == NULL) gameuserinfo_ = new ::GameUserInfo;
  return gameuserinfo_;
}
inline ::GameUserInfo* GReqGameEnter::release_gameuserinfo() {
  clear_has_gameuserinfo();
  ::GameUserInfo* temp = gameuserinfo_;
  gameuserinfo_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// GAnsGameEnter

// required .GameRoomInfo gameRoomInfo = 1;
inline bool GAnsGameEnter::has_gameroominfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GAnsGameEnter::set_has_gameroominfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GAnsGameEnter::clear_has_gameroominfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GAnsGameEnter::clear_gameroominfo() {
  if (gameroominfo_ != NULL) gameroominfo_->::GameRoomInfo::Clear();
  clear_has_gameroominfo();
}
inline const ::GameRoomInfo& GAnsGameEnter::gameroominfo() const {
  return gameroominfo_ != NULL ? *gameroominfo_ : *default_instance_->gameroominfo_;
}
inline ::GameRoomInfo* GAnsGameEnter::mutable_gameroominfo() {
  set_has_gameroominfo();
  if (gameroominfo_ == NULL) gameroominfo_ = new ::GameRoomInfo;
  return gameroominfo_;
}
inline ::GameRoomInfo* GAnsGameEnter::release_gameroominfo() {
  clear_has_gameroominfo();
  ::GameRoomInfo* temp = gameroominfo_;
  gameroominfo_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// GReqGameLeave

// required int32 gameID = 1;
inline bool GReqGameLeave::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GReqGameLeave::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GReqGameLeave::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GReqGameLeave::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GReqGameLeave::gameid() const {
  return gameid_;
}
inline void GReqGameLeave::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required bool kick = 2;
inline bool GReqGameLeave::has_kick() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GReqGameLeave::set_has_kick() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GReqGameLeave::clear_has_kick() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GReqGameLeave::clear_kick() {
  kick_ = false;
  clear_has_kick();
}
inline bool GReqGameLeave::kick() const {
  return kick_;
}
inline void GReqGameLeave::set_kick(bool value) {
  set_has_kick();
  kick_ = value;
}

// -------------------------------------------------------------------

// GAnsGameLeave

// required int32 gameID = 1;
inline bool GAnsGameLeave::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GAnsGameLeave::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GAnsGameLeave::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GAnsGameLeave::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GAnsGameLeave::gameid() const {
  return gameid_;
}
inline void GAnsGameLeave::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required .GAnsGameLeave.KICK_TYPE nType = 2;
inline bool GAnsGameLeave::has_ntype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GAnsGameLeave::set_has_ntype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GAnsGameLeave::clear_has_ntype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GAnsGameLeave::clear_ntype() {
  ntype_ = 1;
  clear_has_ntype();
}
inline ::GAnsGameLeave_KICK_TYPE GAnsGameLeave::ntype() const {
  return static_cast< ::GAnsGameLeave_KICK_TYPE >(ntype_);
}
inline void GAnsGameLeave::set_ntype(::GAnsGameLeave_KICK_TYPE value) {
  GOOGLE_DCHECK(::GAnsGameLeave_KICK_TYPE_IsValid(value));
  set_has_ntype();
  ntype_ = value;
}

// -------------------------------------------------------------------

// GReqDetach

// required int32 gameID = 1;
inline bool GReqDetach::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GReqDetach::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GReqDetach::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GReqDetach::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GReqDetach::gameid() const {
  return gameid_;
}
inline void GReqDetach::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// -------------------------------------------------------------------

// GAnsDetach

// required int32 gameID = 1;
inline bool GAnsDetach::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GAnsDetach::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GAnsDetach::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GAnsDetach::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GAnsDetach::gameid() const {
  return gameid_;
}
inline void GAnsDetach::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// -------------------------------------------------------------------

// GReqPlug

// required int32 gameID = 1;
inline bool GReqPlug::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GReqPlug::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GReqPlug::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GReqPlug::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GReqPlug::gameid() const {
  return gameid_;
}
inline void GReqPlug::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// -------------------------------------------------------------------

// GAnsPlug

// required int32 gameID = 1;
inline bool GAnsPlug::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GAnsPlug::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GAnsPlug::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GAnsPlug::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GAnsPlug::gameid() const {
  return gameid_;
}
inline void GAnsPlug::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// -------------------------------------------------------------------

// GError

// required int32 errorCode = 1;
inline bool GError::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GError::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GError::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GError::clear_errorcode() {
  errorcode_ = 0;
  clear_has_errorcode();
}
inline ::google::protobuf::int32 GError::errorcode() const {
  return errorcode_;
}
inline void GError::set_errorcode(::google::protobuf::int32 value) {
  set_has_errorcode();
  errorcode_ = value;
}

// required string errorInfo = 2;
inline bool GError::has_errorinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GError::set_has_errorinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GError::clear_has_errorinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GError::clear_errorinfo() {
  if (errorinfo_ != &::google::protobuf::internal::kEmptyString) {
    errorinfo_->clear();
  }
  clear_has_errorinfo();
}
inline const ::std::string& GError::errorinfo() const {
  return *errorinfo_;
}
inline void GError::set_errorinfo(const ::std::string& value) {
  set_has_errorinfo();
  if (errorinfo_ == &::google::protobuf::internal::kEmptyString) {
    errorinfo_ = new ::std::string;
  }
  errorinfo_->assign(value);
}
inline void GError::set_errorinfo(const char* value) {
  set_has_errorinfo();
  if (errorinfo_ == &::google::protobuf::internal::kEmptyString) {
    errorinfo_ = new ::std::string;
  }
  errorinfo_->assign(value);
}
inline void GError::set_errorinfo(const char* value, size_t size) {
  set_has_errorinfo();
  if (errorinfo_ == &::google::protobuf::internal::kEmptyString) {
    errorinfo_ = new ::std::string;
  }
  errorinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GError::mutable_errorinfo() {
  set_has_errorinfo();
  if (errorinfo_ == &::google::protobuf::internal::kEmptyString) {
    errorinfo_ = new ::std::string;
  }
  return errorinfo_;
}
inline ::std::string* GError::release_errorinfo() {
  clear_has_errorinfo();
  if (errorinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = errorinfo_;
    errorinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GErrPlug

// required .GError error = 1;
inline bool GErrPlug::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GErrPlug::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GErrPlug::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GErrPlug::clear_error() {
  if (error_ != NULL) error_->::GError::Clear();
  clear_has_error();
}
inline const ::GError& GErrPlug::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::GError* GErrPlug::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::GError;
  return error_;
}
inline ::GError* GErrPlug::release_error() {
  clear_has_error();
  ::GError* temp = error_;
  error_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// GAnsUserUpdate

// required int32 type = 1;
inline bool GAnsUserUpdate::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GAnsUserUpdate::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GAnsUserUpdate::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GAnsUserUpdate::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 GAnsUserUpdate::type() const {
  return type_;
}
inline void GAnsUserUpdate::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required bytes updateInfo = 2;
inline bool GAnsUserUpdate::has_updateinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GAnsUserUpdate::set_has_updateinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GAnsUserUpdate::clear_has_updateinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GAnsUserUpdate::clear_updateinfo() {
  if (updateinfo_ != &::google::protobuf::internal::kEmptyString) {
    updateinfo_->clear();
  }
  clear_has_updateinfo();
}
inline const ::std::string& GAnsUserUpdate::updateinfo() const {
  return *updateinfo_;
}
inline void GAnsUserUpdate::set_updateinfo(const ::std::string& value) {
  set_has_updateinfo();
  if (updateinfo_ == &::google::protobuf::internal::kEmptyString) {
    updateinfo_ = new ::std::string;
  }
  updateinfo_->assign(value);
}
inline void GAnsUserUpdate::set_updateinfo(const char* value) {
  set_has_updateinfo();
  if (updateinfo_ == &::google::protobuf::internal::kEmptyString) {
    updateinfo_ = new ::std::string;
  }
  updateinfo_->assign(value);
}
inline void GAnsUserUpdate::set_updateinfo(const void* value, size_t size) {
  set_has_updateinfo();
  if (updateinfo_ == &::google::protobuf::internal::kEmptyString) {
    updateinfo_ = new ::std::string;
  }
  updateinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GAnsUserUpdate::mutable_updateinfo() {
  set_has_updateinfo();
  if (updateinfo_ == &::google::protobuf::internal::kEmptyString) {
    updateinfo_ = new ::std::string;
  }
  return updateinfo_;
}
inline ::std::string* GAnsUserUpdate::release_updateinfo() {
  clear_has_updateinfo();
  if (updateinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = updateinfo_;
    updateinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GReqProtocol

// required .GReqProtocol.Type type = 1;
inline bool GReqProtocol::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GReqProtocol::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GReqProtocol::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GReqProtocol::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::GReqProtocol_Type GReqProtocol::type() const {
  return static_cast< ::GReqProtocol_Type >(type_);
}
inline void GReqProtocol::set_type(::GReqProtocol_Type value) {
  GOOGLE_DCHECK(::GReqProtocol_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .GReqGameEnter reqGameEnter = 2;
inline bool GReqProtocol::has_reqgameenter() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GReqProtocol::set_has_reqgameenter() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GReqProtocol::clear_has_reqgameenter() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GReqProtocol::clear_reqgameenter() {
  if (reqgameenter_ != NULL) reqgameenter_->::GReqGameEnter::Clear();
  clear_has_reqgameenter();
}
inline const ::GReqGameEnter& GReqProtocol::reqgameenter() const {
  return reqgameenter_ != NULL ? *reqgameenter_ : *default_instance_->reqgameenter_;
}
inline ::GReqGameEnter* GReqProtocol::mutable_reqgameenter() {
  set_has_reqgameenter();
  if (reqgameenter_ == NULL) reqgameenter_ = new ::GReqGameEnter;
  return reqgameenter_;
}
inline ::GReqGameEnter* GReqProtocol::release_reqgameenter() {
  clear_has_reqgameenter();
  ::GReqGameEnter* temp = reqgameenter_;
  reqgameenter_ = NULL;
  return temp;
}

// optional .GReqGameLeave reqGameLeave = 3;
inline bool GReqProtocol::has_reqgameleave() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GReqProtocol::set_has_reqgameleave() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GReqProtocol::clear_has_reqgameleave() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GReqProtocol::clear_reqgameleave() {
  if (reqgameleave_ != NULL) reqgameleave_->::GReqGameLeave::Clear();
  clear_has_reqgameleave();
}
inline const ::GReqGameLeave& GReqProtocol::reqgameleave() const {
  return reqgameleave_ != NULL ? *reqgameleave_ : *default_instance_->reqgameleave_;
}
inline ::GReqGameLeave* GReqProtocol::mutable_reqgameleave() {
  set_has_reqgameleave();
  if (reqgameleave_ == NULL) reqgameleave_ = new ::GReqGameLeave;
  return reqgameleave_;
}
inline ::GReqGameLeave* GReqProtocol::release_reqgameleave() {
  clear_has_reqgameleave();
  ::GReqGameLeave* temp = reqgameleave_;
  reqgameleave_ = NULL;
  return temp;
}

// optional .GReqDetach reqDetach = 4;
inline bool GReqProtocol::has_reqdetach() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GReqProtocol::set_has_reqdetach() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GReqProtocol::clear_has_reqdetach() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GReqProtocol::clear_reqdetach() {
  if (reqdetach_ != NULL) reqdetach_->::GReqDetach::Clear();
  clear_has_reqdetach();
}
inline const ::GReqDetach& GReqProtocol::reqdetach() const {
  return reqdetach_ != NULL ? *reqdetach_ : *default_instance_->reqdetach_;
}
inline ::GReqDetach* GReqProtocol::mutable_reqdetach() {
  set_has_reqdetach();
  if (reqdetach_ == NULL) reqdetach_ = new ::GReqDetach;
  return reqdetach_;
}
inline ::GReqDetach* GReqProtocol::release_reqdetach() {
  clear_has_reqdetach();
  ::GReqDetach* temp = reqdetach_;
  reqdetach_ = NULL;
  return temp;
}

// optional .GReqPlug reqPlug = 5;
inline bool GReqProtocol::has_reqplug() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GReqProtocol::set_has_reqplug() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GReqProtocol::clear_has_reqplug() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GReqProtocol::clear_reqplug() {
  if (reqplug_ != NULL) reqplug_->::GReqPlug::Clear();
  clear_has_reqplug();
}
inline const ::GReqPlug& GReqProtocol::reqplug() const {
  return reqplug_ != NULL ? *reqplug_ : *default_instance_->reqplug_;
}
inline ::GReqPlug* GReqProtocol::mutable_reqplug() {
  set_has_reqplug();
  if (reqplug_ == NULL) reqplug_ = new ::GReqPlug;
  return reqplug_;
}
inline ::GReqPlug* GReqProtocol::release_reqplug() {
  clear_has_reqplug();
  ::GReqPlug* temp = reqplug_;
  reqplug_ = NULL;
  return temp;
}

// optional .GLReqGameProtocol reqGameProtocol = 6;
inline bool GReqProtocol::has_reqgameprotocol() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GReqProtocol::set_has_reqgameprotocol() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GReqProtocol::clear_has_reqgameprotocol() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GReqProtocol::clear_reqgameprotocol() {
  if (reqgameprotocol_ != NULL) reqgameprotocol_->::GLReqGameProtocol::Clear();
  clear_has_reqgameprotocol();
}
inline const ::GLReqGameProtocol& GReqProtocol::reqgameprotocol() const {
  return reqgameprotocol_ != NULL ? *reqgameprotocol_ : *default_instance_->reqgameprotocol_;
}
inline ::GLReqGameProtocol* GReqProtocol::mutable_reqgameprotocol() {
  set_has_reqgameprotocol();
  if (reqgameprotocol_ == NULL) reqgameprotocol_ = new ::GLReqGameProtocol;
  return reqgameprotocol_;
}
inline ::GLReqGameProtocol* GReqProtocol::release_reqgameprotocol() {
  clear_has_reqgameprotocol();
  ::GLReqGameProtocol* temp = reqgameprotocol_;
  reqgameprotocol_ = NULL;
  return temp;
}

// optional .AnsDB ansDB = 7;
inline bool GReqProtocol::has_ansdb() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GReqProtocol::set_has_ansdb() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GReqProtocol::clear_has_ansdb() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GReqProtocol::clear_ansdb() {
  if (ansdb_ != NULL) ansdb_->::AnsDB::Clear();
  clear_has_ansdb();
}
inline const ::AnsDB& GReqProtocol::ansdb() const {
  return ansdb_ != NULL ? *ansdb_ : *default_instance_->ansdb_;
}
inline ::AnsDB* GReqProtocol::mutable_ansdb() {
  set_has_ansdb();
  if (ansdb_ == NULL) ansdb_ = new ::AnsDB;
  return ansdb_;
}
inline ::AnsDB* GReqProtocol::release_ansdb() {
  clear_has_ansdb();
  ::AnsDB* temp = ansdb_;
  ansdb_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// GAnsProtocol

// required .GAnsProtocol.Type type = 1;
inline bool GAnsProtocol::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GAnsProtocol::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GAnsProtocol::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GAnsProtocol::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::GAnsProtocol_Type GAnsProtocol::type() const {
  return static_cast< ::GAnsProtocol_Type >(type_);
}
inline void GAnsProtocol::set_type(::GAnsProtocol_Type value) {
  GOOGLE_DCHECK(::GAnsProtocol_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .GAnsGameEnter ansGameEnter = 2;
inline bool GAnsProtocol::has_ansgameenter() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GAnsProtocol::set_has_ansgameenter() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GAnsProtocol::clear_has_ansgameenter() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GAnsProtocol::clear_ansgameenter() {
  if (ansgameenter_ != NULL) ansgameenter_->::GAnsGameEnter::Clear();
  clear_has_ansgameenter();
}
inline const ::GAnsGameEnter& GAnsProtocol::ansgameenter() const {
  return ansgameenter_ != NULL ? *ansgameenter_ : *default_instance_->ansgameenter_;
}
inline ::GAnsGameEnter* GAnsProtocol::mutable_ansgameenter() {
  set_has_ansgameenter();
  if (ansgameenter_ == NULL) ansgameenter_ = new ::GAnsGameEnter;
  return ansgameenter_;
}
inline ::GAnsGameEnter* GAnsProtocol::release_ansgameenter() {
  clear_has_ansgameenter();
  ::GAnsGameEnter* temp = ansgameenter_;
  ansgameenter_ = NULL;
  return temp;
}

// optional .GAnsGameLeave ansGameLeave = 3;
inline bool GAnsProtocol::has_ansgameleave() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GAnsProtocol::set_has_ansgameleave() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GAnsProtocol::clear_has_ansgameleave() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GAnsProtocol::clear_ansgameleave() {
  if (ansgameleave_ != NULL) ansgameleave_->::GAnsGameLeave::Clear();
  clear_has_ansgameleave();
}
inline const ::GAnsGameLeave& GAnsProtocol::ansgameleave() const {
  return ansgameleave_ != NULL ? *ansgameleave_ : *default_instance_->ansgameleave_;
}
inline ::GAnsGameLeave* GAnsProtocol::mutable_ansgameleave() {
  set_has_ansgameleave();
  if (ansgameleave_ == NULL) ansgameleave_ = new ::GAnsGameLeave;
  return ansgameleave_;
}
inline ::GAnsGameLeave* GAnsProtocol::release_ansgameleave() {
  clear_has_ansgameleave();
  ::GAnsGameLeave* temp = ansgameleave_;
  ansgameleave_ = NULL;
  return temp;
}

// optional .GAnsDetach ansDetach = 4;
inline bool GAnsProtocol::has_ansdetach() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GAnsProtocol::set_has_ansdetach() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GAnsProtocol::clear_has_ansdetach() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GAnsProtocol::clear_ansdetach() {
  if (ansdetach_ != NULL) ansdetach_->::GAnsDetach::Clear();
  clear_has_ansdetach();
}
inline const ::GAnsDetach& GAnsProtocol::ansdetach() const {
  return ansdetach_ != NULL ? *ansdetach_ : *default_instance_->ansdetach_;
}
inline ::GAnsDetach* GAnsProtocol::mutable_ansdetach() {
  set_has_ansdetach();
  if (ansdetach_ == NULL) ansdetach_ = new ::GAnsDetach;
  return ansdetach_;
}
inline ::GAnsDetach* GAnsProtocol::release_ansdetach() {
  clear_has_ansdetach();
  ::GAnsDetach* temp = ansdetach_;
  ansdetach_ = NULL;
  return temp;
}

// optional .GAnsPlug ansPlug = 5;
inline bool GAnsProtocol::has_ansplug() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GAnsProtocol::set_has_ansplug() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GAnsProtocol::clear_has_ansplug() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GAnsProtocol::clear_ansplug() {
  if (ansplug_ != NULL) ansplug_->::GAnsPlug::Clear();
  clear_has_ansplug();
}
inline const ::GAnsPlug& GAnsProtocol::ansplug() const {
  return ansplug_ != NULL ? *ansplug_ : *default_instance_->ansplug_;
}
inline ::GAnsPlug* GAnsProtocol::mutable_ansplug() {
  set_has_ansplug();
  if (ansplug_ == NULL) ansplug_ = new ::GAnsPlug;
  return ansplug_;
}
inline ::GAnsPlug* GAnsProtocol::release_ansplug() {
  clear_has_ansplug();
  ::GAnsPlug* temp = ansplug_;
  ansplug_ = NULL;
  return temp;
}

// optional .GErrPlug ansErr = 6;
inline bool GAnsProtocol::has_anserr() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GAnsProtocol::set_has_anserr() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GAnsProtocol::clear_has_anserr() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GAnsProtocol::clear_anserr() {
  if (anserr_ != NULL) anserr_->::GErrPlug::Clear();
  clear_has_anserr();
}
inline const ::GErrPlug& GAnsProtocol::anserr() const {
  return anserr_ != NULL ? *anserr_ : *default_instance_->anserr_;
}
inline ::GErrPlug* GAnsProtocol::mutable_anserr() {
  set_has_anserr();
  if (anserr_ == NULL) anserr_ = new ::GErrPlug;
  return anserr_;
}
inline ::GErrPlug* GAnsProtocol::release_anserr() {
  clear_has_anserr();
  ::GErrPlug* temp = anserr_;
  anserr_ = NULL;
  return temp;
}

// optional .GLAnsGameProtocol ansGameProtocol = 7;
inline bool GAnsProtocol::has_ansgameprotocol() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GAnsProtocol::set_has_ansgameprotocol() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GAnsProtocol::clear_has_ansgameprotocol() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GAnsProtocol::clear_ansgameprotocol() {
  if (ansgameprotocol_ != NULL) ansgameprotocol_->::GLAnsGameProtocol::Clear();
  clear_has_ansgameprotocol();
}
inline const ::GLAnsGameProtocol& GAnsProtocol::ansgameprotocol() const {
  return ansgameprotocol_ != NULL ? *ansgameprotocol_ : *default_instance_->ansgameprotocol_;
}
inline ::GLAnsGameProtocol* GAnsProtocol::mutable_ansgameprotocol() {
  set_has_ansgameprotocol();
  if (ansgameprotocol_ == NULL) ansgameprotocol_ = new ::GLAnsGameProtocol;
  return ansgameprotocol_;
}
inline ::GLAnsGameProtocol* GAnsProtocol::release_ansgameprotocol() {
  clear_has_ansgameprotocol();
  ::GLAnsGameProtocol* temp = ansgameprotocol_;
  ansgameprotocol_ = NULL;
  return temp;
}

// optional .ReqDB reqDB = 8;
inline bool GAnsProtocol::has_reqdb() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GAnsProtocol::set_has_reqdb() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GAnsProtocol::clear_has_reqdb() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GAnsProtocol::clear_reqdb() {
  if (reqdb_ != NULL) reqdb_->::ReqDB::Clear();
  clear_has_reqdb();
}
inline const ::ReqDB& GAnsProtocol::reqdb() const {
  return reqdb_ != NULL ? *reqdb_ : *default_instance_->reqdb_;
}
inline ::ReqDB* GAnsProtocol::mutable_reqdb() {
  set_has_reqdb();
  if (reqdb_ == NULL) reqdb_ = new ::ReqDB;
  return reqdb_;
}
inline ::ReqDB* GAnsProtocol::release_reqdb() {
  clear_has_reqdb();
  ::ReqDB* temp = reqdb_;
  reqdb_ = NULL;
  return temp;
}

// optional .GAnsUserUpdate ansUpdate = 9;
inline bool GAnsProtocol::has_ansupdate() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GAnsProtocol::set_has_ansupdate() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GAnsProtocol::clear_has_ansupdate() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GAnsProtocol::clear_ansupdate() {
  if (ansupdate_ != NULL) ansupdate_->::GAnsUserUpdate::Clear();
  clear_has_ansupdate();
}
inline const ::GAnsUserUpdate& GAnsProtocol::ansupdate() const {
  return ansupdate_ != NULL ? *ansupdate_ : *default_instance_->ansupdate_;
}
inline ::GAnsUserUpdate* GAnsProtocol::mutable_ansupdate() {
  set_has_ansupdate();
  if (ansupdate_ == NULL) ansupdate_ = new ::GAnsUserUpdate;
  return ansupdate_;
}
inline ::GAnsUserUpdate* GAnsProtocol::release_ansupdate() {
  clear_has_ansupdate();
  ::GAnsUserUpdate* temp = ansupdate_;
  ansupdate_ = NULL;
  return temp;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_game_2eproto__INCLUDED
