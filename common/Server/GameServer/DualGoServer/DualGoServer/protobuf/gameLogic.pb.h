// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gameLogic.proto

#ifndef PROTOBUF_gameLogic_2eproto__INCLUDED
#define PROTOBUF_gameLogic_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_gameLogic_2eproto();
void protobuf_AssignDesc_gameLogic_2eproto();
void protobuf_ShutdownFile_gameLogic_2eproto();

class GameUserInfo;
class GameRoomInfo;
class GameInfo;
class MoneyInfo;
class GameUpdateInfo;
class SafeEventMoneyUpdate;
class RefillMoneyUpdate;
class MissionDBInfo;
class MemberInfo;
class GLAnsGameRelayInfo;
class GLReqGameInitGameTan;
class GLAnsGameStartReady;
class GLAnsGameResetReady;
class GLAnsGameStart;
class GLAnsGameReset;
class GLAnsGameNotiSun;
class GLReqGameSelectSun;
class GLAnsGameSelectSun;
class GLAnsGameNotiSelectSun;
class GLAnsGameSharing;
class GLAnsGameNagari;
class GLAnsGameChongTong;
class GLAnsGameSelectCard;
class GLAnsGameBonus;
class GLAnsGameTakePee;
class GLAnsGameBbuck;
class GLAnsGameSeriseBbuck;
class GLAnsGameBbuckEat;
class GLAnsGameBomb;
class GLAnsGamePan;
class GLAnsGameDadak;
class GLAnsGameJjok;
class GLAnsGameUpset;
class GLAnsGameAllEatUp;
class GLAnsGameNotiTurn;
class GLAnsGameMoveTen;
class GLAnsGameMoveTenAns;
class GLAnsGameChoiceCard;
class GLAnsGameShake;
class GLAnsGameShakeAns;
class GLAnsGameShakeCount;
class GLAnsGameCapType;
class GLAnsGameGodori;
class GLAnsGameKusa;
class GLAnsGameRed;
class GLAnsGameBlue;
class GLAnsGameBak;
class GLAnsGameBakFail;
class GLAnsGameNotiMission;
class GLAnsGameNotiMissionCard;
class GLAnsGameMissionState;
class GLAnsGameGostop;
class GLAnsGameGostopAns;
class GLAnsGameStopAns;
class GLAnsGameResult;
class GLAnsGameNotiPoint;
class GLAnsGameEnd;
class GLAnsGameKick;
class GLAnsGameEmoti;
class GLAnsGameInit;
class GLAnsGameAutoPlay;
class GLAnsExitReservation;
class GLReqGameReady;
class GLReqResetReady;
class GLReqGameInitGame;
class GLReqGameReset;
class GLReqGameStart;
class GLReqGameSelectSunCard;
class GLReqGameSelectCard;
class GLReqGameAskGoStopAns;
class GLReqGameAskShakeAns;
class GLReqGameChoiceCardAns;
class GLReqGameMoveTen;
class GLReqGameChongTong;
class GLReqGameEnd;
class GLReqResultOk;
class GLReqGameAutoPlay;
class GLReqGameEmoti;
class GLReqExitReservation;
class GLReqRelayInfo;
class G_REQ_GAME_TEST_PACKET;
class GLAnsGameProtocol;
class GLReqGameProtocol;

enum MissionDBInfo_EVENT_TYPE {
  MissionDBInfo_EVENT_TYPE_EVENT_MISSION = 1,
  MissionDBInfo_EVENT_TYPE_EVENT_SERISEBBUCK = 2
};
bool MissionDBInfo_EVENT_TYPE_IsValid(int value);
const MissionDBInfo_EVENT_TYPE MissionDBInfo_EVENT_TYPE_EVENT_TYPE_MIN = MissionDBInfo_EVENT_TYPE_EVENT_MISSION;
const MissionDBInfo_EVENT_TYPE MissionDBInfo_EVENT_TYPE_EVENT_TYPE_MAX = MissionDBInfo_EVENT_TYPE_EVENT_SERISEBBUCK;
const int MissionDBInfo_EVENT_TYPE_EVENT_TYPE_ARRAYSIZE = MissionDBInfo_EVENT_TYPE_EVENT_TYPE_MAX + 1;

enum GLAnsGameRelayInfo_JOKBO_STATE {
  GLAnsGameRelayInfo_JOKBO_STATE_JOKBO_WARNNING = 1,
  GLAnsGameRelayInfo_JOKBO_STATE_JOKBO_COMPLETE = 2,
  GLAnsGameRelayInfo_JOKBO_STATE_JOKBO_FAIL = 3,
  GLAnsGameRelayInfo_JOKBO_STATE_JOKBO_ZERO = 4
};
bool GLAnsGameRelayInfo_JOKBO_STATE_IsValid(int value);
const GLAnsGameRelayInfo_JOKBO_STATE GLAnsGameRelayInfo_JOKBO_STATE_JOKBO_STATE_MIN = GLAnsGameRelayInfo_JOKBO_STATE_JOKBO_WARNNING;
const GLAnsGameRelayInfo_JOKBO_STATE GLAnsGameRelayInfo_JOKBO_STATE_JOKBO_STATE_MAX = GLAnsGameRelayInfo_JOKBO_STATE_JOKBO_ZERO;
const int GLAnsGameRelayInfo_JOKBO_STATE_JOKBO_STATE_ARRAYSIZE = GLAnsGameRelayInfo_JOKBO_STATE_JOKBO_STATE_MAX + 1;

enum GLAnsGameRelayInfo_MISSION_TYPE {
  GLAnsGameRelayInfo_MISSION_TYPE_CARD = 1,
  GLAnsGameRelayInfo_MISSION_TYPE_NONE = 2,
  GLAnsGameRelayInfo_MISSION_TYPE_UNCONDITION = 3,
  GLAnsGameRelayInfo_MISSION_TYPE_TWOBBUCK = 4,
  GLAnsGameRelayInfo_MISSION_TYPE_MISSION_ZERO = 5
};
bool GLAnsGameRelayInfo_MISSION_TYPE_IsValid(int value);
const GLAnsGameRelayInfo_MISSION_TYPE GLAnsGameRelayInfo_MISSION_TYPE_MISSION_TYPE_MIN = GLAnsGameRelayInfo_MISSION_TYPE_CARD;
const GLAnsGameRelayInfo_MISSION_TYPE GLAnsGameRelayInfo_MISSION_TYPE_MISSION_TYPE_MAX = GLAnsGameRelayInfo_MISSION_TYPE_MISSION_ZERO;
const int GLAnsGameRelayInfo_MISSION_TYPE_MISSION_TYPE_ARRAYSIZE = GLAnsGameRelayInfo_MISSION_TYPE_MISSION_TYPE_MAX + 1;

enum GLAnsGameRelayInfo_MISSION_STATE {
  GLAnsGameRelayInfo_MISSION_STATE_FAIL = 1,
  GLAnsGameRelayInfo_MISSION_STATE_SUCCESS = 2,
  GLAnsGameRelayInfo_MISSION_STATE_STATE_ZERO = 3
};
bool GLAnsGameRelayInfo_MISSION_STATE_IsValid(int value);
const GLAnsGameRelayInfo_MISSION_STATE GLAnsGameRelayInfo_MISSION_STATE_MISSION_STATE_MIN = GLAnsGameRelayInfo_MISSION_STATE_FAIL;
const GLAnsGameRelayInfo_MISSION_STATE GLAnsGameRelayInfo_MISSION_STATE_MISSION_STATE_MAX = GLAnsGameRelayInfo_MISSION_STATE_STATE_ZERO;
const int GLAnsGameRelayInfo_MISSION_STATE_MISSION_STATE_ARRAYSIZE = GLAnsGameRelayInfo_MISSION_STATE_MISSION_STATE_MAX + 1;

enum GLAnsGameNagari_NAGARI_TYPE {
  GLAnsGameNagari_NAGARI_TYPE_CHONGTONG_NAGARI = 1,
  GLAnsGameNagari_NAGARI_TYPE_CHONGTONG_DOUBLE = 2,
  GLAnsGameNagari_NAGARI_TYPE_NAGARI_ZERO = 3
};
bool GLAnsGameNagari_NAGARI_TYPE_IsValid(int value);
const GLAnsGameNagari_NAGARI_TYPE GLAnsGameNagari_NAGARI_TYPE_NAGARI_TYPE_MIN = GLAnsGameNagari_NAGARI_TYPE_CHONGTONG_NAGARI;
const GLAnsGameNagari_NAGARI_TYPE GLAnsGameNagari_NAGARI_TYPE_NAGARI_TYPE_MAX = GLAnsGameNagari_NAGARI_TYPE_NAGARI_ZERO;
const int GLAnsGameNagari_NAGARI_TYPE_NAGARI_TYPE_ARRAYSIZE = GLAnsGameNagari_NAGARI_TYPE_NAGARI_TYPE_MAX + 1;

enum GLAnsGameBbuckEat_CARD_TYPE {
  GLAnsGameBbuckEat_CARD_TYPE_JANUARY = 1,
  GLAnsGameBbuckEat_CARD_TYPE_FEBUARY = 2,
  GLAnsGameBbuckEat_CARD_TYPE_MARCH = 3,
  GLAnsGameBbuckEat_CARD_TYPE_APRIL = 4,
  GLAnsGameBbuckEat_CARD_TYPE_MAY = 5,
  GLAnsGameBbuckEat_CARD_TYPE_JUNE = 6,
  GLAnsGameBbuckEat_CARD_TYPE_JULY = 7,
  GLAnsGameBbuckEat_CARD_TYPE_AUGUST = 8,
  GLAnsGameBbuckEat_CARD_TYPE_SEPTEMBER = 9,
  GLAnsGameBbuckEat_CARD_TYPE_OCTOBER = 10,
  GLAnsGameBbuckEat_CARD_TYPE_NOVEMBER = 11,
  GLAnsGameBbuckEat_CARD_TYPE_DECEMBER = 12,
  GLAnsGameBbuckEat_CARD_TYPE_CARDTYPE_ZERO = 13
};
bool GLAnsGameBbuckEat_CARD_TYPE_IsValid(int value);
const GLAnsGameBbuckEat_CARD_TYPE GLAnsGameBbuckEat_CARD_TYPE_CARD_TYPE_MIN = GLAnsGameBbuckEat_CARD_TYPE_JANUARY;
const GLAnsGameBbuckEat_CARD_TYPE GLAnsGameBbuckEat_CARD_TYPE_CARD_TYPE_MAX = GLAnsGameBbuckEat_CARD_TYPE_CARDTYPE_ZERO;
const int GLAnsGameBbuckEat_CARD_TYPE_CARD_TYPE_ARRAYSIZE = GLAnsGameBbuckEat_CARD_TYPE_CARD_TYPE_MAX + 1;

enum GLAnsGameBbuckEat_BBUCK_TYPE {
  GLAnsGameBbuckEat_BBUCK_TYPE_SELF_BBUCK = 1,
  GLAnsGameBbuckEat_BBUCK_TYPE_YOU_BBUCK = 2,
  GLAnsGameBbuckEat_BBUCK_TYPE_BBUCK_ZERO = 3
};
bool GLAnsGameBbuckEat_BBUCK_TYPE_IsValid(int value);
const GLAnsGameBbuckEat_BBUCK_TYPE GLAnsGameBbuckEat_BBUCK_TYPE_BBUCK_TYPE_MIN = GLAnsGameBbuckEat_BBUCK_TYPE_SELF_BBUCK;
const GLAnsGameBbuckEat_BBUCK_TYPE GLAnsGameBbuckEat_BBUCK_TYPE_BBUCK_TYPE_MAX = GLAnsGameBbuckEat_BBUCK_TYPE_BBUCK_ZERO;
const int GLAnsGameBbuckEat_BBUCK_TYPE_BBUCK_TYPE_ARRAYSIZE = GLAnsGameBbuckEat_BBUCK_TYPE_BBUCK_TYPE_MAX + 1;

enum GLAnsGameBomb_CARD_TYPE {
  GLAnsGameBomb_CARD_TYPE_JANUARY = 1,
  GLAnsGameBomb_CARD_TYPE_FEBUARY = 2,
  GLAnsGameBomb_CARD_TYPE_MARCH = 3,
  GLAnsGameBomb_CARD_TYPE_APRIL = 4,
  GLAnsGameBomb_CARD_TYPE_MAY = 5,
  GLAnsGameBomb_CARD_TYPE_JUNE = 6,
  GLAnsGameBomb_CARD_TYPE_JULY = 7,
  GLAnsGameBomb_CARD_TYPE_AUGUST = 8,
  GLAnsGameBomb_CARD_TYPE_SEPTEMBER = 9,
  GLAnsGameBomb_CARD_TYPE_OCTOBER = 10,
  GLAnsGameBomb_CARD_TYPE_NOVEMBER = 11,
  GLAnsGameBomb_CARD_TYPE_DECEMBER = 12,
  GLAnsGameBomb_CARD_TYPE_CARDTYPE_ZERO = 13
};
bool GLAnsGameBomb_CARD_TYPE_IsValid(int value);
const GLAnsGameBomb_CARD_TYPE GLAnsGameBomb_CARD_TYPE_CARD_TYPE_MIN = GLAnsGameBomb_CARD_TYPE_JANUARY;
const GLAnsGameBomb_CARD_TYPE GLAnsGameBomb_CARD_TYPE_CARD_TYPE_MAX = GLAnsGameBomb_CARD_TYPE_CARDTYPE_ZERO;
const int GLAnsGameBomb_CARD_TYPE_CARD_TYPE_ARRAYSIZE = GLAnsGameBomb_CARD_TYPE_CARD_TYPE_MAX + 1;

enum GLAnsGameDadak_CARD_TYPE {
  GLAnsGameDadak_CARD_TYPE_JANUARY = 1,
  GLAnsGameDadak_CARD_TYPE_FEBUARY = 2,
  GLAnsGameDadak_CARD_TYPE_MARCH = 3,
  GLAnsGameDadak_CARD_TYPE_APRIL = 4,
  GLAnsGameDadak_CARD_TYPE_MAY = 5,
  GLAnsGameDadak_CARD_TYPE_JUNE = 6,
  GLAnsGameDadak_CARD_TYPE_JULY = 7,
  GLAnsGameDadak_CARD_TYPE_AUGUST = 8,
  GLAnsGameDadak_CARD_TYPE_SEPTEMBER = 9,
  GLAnsGameDadak_CARD_TYPE_OCTOBER = 10,
  GLAnsGameDadak_CARD_TYPE_NOVEMBER = 11,
  GLAnsGameDadak_CARD_TYPE_DECEMBER = 12,
  GLAnsGameDadak_CARD_TYPE_CARDTYPE_ZERO = 13
};
bool GLAnsGameDadak_CARD_TYPE_IsValid(int value);
const GLAnsGameDadak_CARD_TYPE GLAnsGameDadak_CARD_TYPE_CARD_TYPE_MIN = GLAnsGameDadak_CARD_TYPE_JANUARY;
const GLAnsGameDadak_CARD_TYPE GLAnsGameDadak_CARD_TYPE_CARD_TYPE_MAX = GLAnsGameDadak_CARD_TYPE_CARDTYPE_ZERO;
const int GLAnsGameDadak_CARD_TYPE_CARD_TYPE_ARRAYSIZE = GLAnsGameDadak_CARD_TYPE_CARD_TYPE_MAX + 1;

enum GLAnsGameJjok_CARD_TYPE {
  GLAnsGameJjok_CARD_TYPE_JANUARY = 1,
  GLAnsGameJjok_CARD_TYPE_FEBUARY = 2,
  GLAnsGameJjok_CARD_TYPE_MARCH = 3,
  GLAnsGameJjok_CARD_TYPE_APRIL = 4,
  GLAnsGameJjok_CARD_TYPE_MAY = 5,
  GLAnsGameJjok_CARD_TYPE_JUNE = 6,
  GLAnsGameJjok_CARD_TYPE_JULY = 7,
  GLAnsGameJjok_CARD_TYPE_AUGUST = 8,
  GLAnsGameJjok_CARD_TYPE_SEPTEMBER = 9,
  GLAnsGameJjok_CARD_TYPE_OCTOBER = 10,
  GLAnsGameJjok_CARD_TYPE_NOVEMBER = 11,
  GLAnsGameJjok_CARD_TYPE_DECEMBER = 12,
  GLAnsGameJjok_CARD_TYPE_CARDTYPE_ZERO = 13
};
bool GLAnsGameJjok_CARD_TYPE_IsValid(int value);
const GLAnsGameJjok_CARD_TYPE GLAnsGameJjok_CARD_TYPE_CARD_TYPE_MIN = GLAnsGameJjok_CARD_TYPE_JANUARY;
const GLAnsGameJjok_CARD_TYPE GLAnsGameJjok_CARD_TYPE_CARD_TYPE_MAX = GLAnsGameJjok_CARD_TYPE_CARDTYPE_ZERO;
const int GLAnsGameJjok_CARD_TYPE_CARD_TYPE_ARRAYSIZE = GLAnsGameJjok_CARD_TYPE_CARD_TYPE_MAX + 1;

enum GLAnsGameChoiceCard_Type {
  GLAnsGameChoiceCard_Type_SELECT = 1,
  GLAnsGameChoiceCard_Type_UPSET = 2
};
bool GLAnsGameChoiceCard_Type_IsValid(int value);
const GLAnsGameChoiceCard_Type GLAnsGameChoiceCard_Type_Type_MIN = GLAnsGameChoiceCard_Type_SELECT;
const GLAnsGameChoiceCard_Type GLAnsGameChoiceCard_Type_Type_MAX = GLAnsGameChoiceCard_Type_UPSET;
const int GLAnsGameChoiceCard_Type_Type_ARRAYSIZE = GLAnsGameChoiceCard_Type_Type_MAX + 1;

enum GLAnsGameCapType_CAP_TYPE {
  GLAnsGameCapType_CAP_TYPE_CAP_THREE = 1,
  GLAnsGameCapType_CAP_TYPE_CAP_DEC = 2,
  GLAnsGameCapType_CAP_TYPE_CAP_FOUR = 3,
  GLAnsGameCapType_CAP_TYPE_CAP_FIVE = 4,
  GLAnsGameCapType_CAP_TYPE_CAP_ZERO = 5
};
bool GLAnsGameCapType_CAP_TYPE_IsValid(int value);
const GLAnsGameCapType_CAP_TYPE GLAnsGameCapType_CAP_TYPE_CAP_TYPE_MIN = GLAnsGameCapType_CAP_TYPE_CAP_THREE;
const GLAnsGameCapType_CAP_TYPE GLAnsGameCapType_CAP_TYPE_CAP_TYPE_MAX = GLAnsGameCapType_CAP_TYPE_CAP_ZERO;
const int GLAnsGameCapType_CAP_TYPE_CAP_TYPE_ARRAYSIZE = GLAnsGameCapType_CAP_TYPE_CAP_TYPE_MAX + 1;

enum GLAnsGameGodori_JOKBO_STATE {
  GLAnsGameGodori_JOKBO_STATE_JOKBO_WARNNING = 1,
  GLAnsGameGodori_JOKBO_STATE_JOKBO_COMPLETE = 2,
  GLAnsGameGodori_JOKBO_STATE_JOKBO_FAIL = 3,
  GLAnsGameGodori_JOKBO_STATE_JOKBO_ZERO = 4
};
bool GLAnsGameGodori_JOKBO_STATE_IsValid(int value);
const GLAnsGameGodori_JOKBO_STATE GLAnsGameGodori_JOKBO_STATE_JOKBO_STATE_MIN = GLAnsGameGodori_JOKBO_STATE_JOKBO_WARNNING;
const GLAnsGameGodori_JOKBO_STATE GLAnsGameGodori_JOKBO_STATE_JOKBO_STATE_MAX = GLAnsGameGodori_JOKBO_STATE_JOKBO_ZERO;
const int GLAnsGameGodori_JOKBO_STATE_JOKBO_STATE_ARRAYSIZE = GLAnsGameGodori_JOKBO_STATE_JOKBO_STATE_MAX + 1;

enum GLAnsGameKusa_JOKBO_STATE {
  GLAnsGameKusa_JOKBO_STATE_JOKBO_WARNNING = 1,
  GLAnsGameKusa_JOKBO_STATE_JOKBO_COMPLETE = 2,
  GLAnsGameKusa_JOKBO_STATE_JOKBO_FAIL = 3,
  GLAnsGameKusa_JOKBO_STATE_JOKBO_ZERO = 4
};
bool GLAnsGameKusa_JOKBO_STATE_IsValid(int value);
const GLAnsGameKusa_JOKBO_STATE GLAnsGameKusa_JOKBO_STATE_JOKBO_STATE_MIN = GLAnsGameKusa_JOKBO_STATE_JOKBO_WARNNING;
const GLAnsGameKusa_JOKBO_STATE GLAnsGameKusa_JOKBO_STATE_JOKBO_STATE_MAX = GLAnsGameKusa_JOKBO_STATE_JOKBO_ZERO;
const int GLAnsGameKusa_JOKBO_STATE_JOKBO_STATE_ARRAYSIZE = GLAnsGameKusa_JOKBO_STATE_JOKBO_STATE_MAX + 1;

enum GLAnsGameRed_JOKBO_STATE {
  GLAnsGameRed_JOKBO_STATE_JOKBO_WARNNING = 1,
  GLAnsGameRed_JOKBO_STATE_JOKBO_COMPLETE = 2,
  GLAnsGameRed_JOKBO_STATE_JOKBO_FAIL = 3,
  GLAnsGameRed_JOKBO_STATE_JOKBO_ZERO = 4
};
bool GLAnsGameRed_JOKBO_STATE_IsValid(int value);
const GLAnsGameRed_JOKBO_STATE GLAnsGameRed_JOKBO_STATE_JOKBO_STATE_MIN = GLAnsGameRed_JOKBO_STATE_JOKBO_WARNNING;
const GLAnsGameRed_JOKBO_STATE GLAnsGameRed_JOKBO_STATE_JOKBO_STATE_MAX = GLAnsGameRed_JOKBO_STATE_JOKBO_ZERO;
const int GLAnsGameRed_JOKBO_STATE_JOKBO_STATE_ARRAYSIZE = GLAnsGameRed_JOKBO_STATE_JOKBO_STATE_MAX + 1;

enum GLAnsGameBlue_JOKBO_STATE {
  GLAnsGameBlue_JOKBO_STATE_JOKBO_WARNNING = 1,
  GLAnsGameBlue_JOKBO_STATE_JOKBO_COMPLETE = 2,
  GLAnsGameBlue_JOKBO_STATE_JOKBO_FAIL = 3,
  GLAnsGameBlue_JOKBO_STATE_JOKBO_ZERO = 4
};
bool GLAnsGameBlue_JOKBO_STATE_IsValid(int value);
const GLAnsGameBlue_JOKBO_STATE GLAnsGameBlue_JOKBO_STATE_JOKBO_STATE_MIN = GLAnsGameBlue_JOKBO_STATE_JOKBO_WARNNING;
const GLAnsGameBlue_JOKBO_STATE GLAnsGameBlue_JOKBO_STATE_JOKBO_STATE_MAX = GLAnsGameBlue_JOKBO_STATE_JOKBO_ZERO;
const int GLAnsGameBlue_JOKBO_STATE_JOKBO_STATE_ARRAYSIZE = GLAnsGameBlue_JOKBO_STATE_JOKBO_STATE_MAX + 1;

enum GLAnsGameBak_BAK_TYPE {
  GLAnsGameBak_BAK_TYPE_CAPBAK = 1,
  GLAnsGameBak_BAK_TYPE_ONEBAK = 2,
  GLAnsGameBak_BAK_TYPE_GOBAK = 3,
  GLAnsGameBak_BAK_TYPE_MUNGBAK = 4,
  GLAnsGameBak_BAK_TYPE_BAK_CANCEL = 5,
  GLAnsGameBak_BAK_TYPE_BAK_ZERO = 6
};
bool GLAnsGameBak_BAK_TYPE_IsValid(int value);
const GLAnsGameBak_BAK_TYPE GLAnsGameBak_BAK_TYPE_BAK_TYPE_MIN = GLAnsGameBak_BAK_TYPE_CAPBAK;
const GLAnsGameBak_BAK_TYPE GLAnsGameBak_BAK_TYPE_BAK_TYPE_MAX = GLAnsGameBak_BAK_TYPE_BAK_ZERO;
const int GLAnsGameBak_BAK_TYPE_BAK_TYPE_ARRAYSIZE = GLAnsGameBak_BAK_TYPE_BAK_TYPE_MAX + 1;

enum GLAnsGameBakFail_BAK_TYPE {
  GLAnsGameBakFail_BAK_TYPE_CAPBAK = 1,
  GLAnsGameBakFail_BAK_TYPE_ONEBAK = 2,
  GLAnsGameBakFail_BAK_TYPE_GOBAK = 3,
  GLAnsGameBakFail_BAK_TYPE_MUNGBAK = 4,
  GLAnsGameBakFail_BAK_TYPE_BAK_CANCEL = 5,
  GLAnsGameBakFail_BAK_TYPE_BAK_ZERO = 6
};
bool GLAnsGameBakFail_BAK_TYPE_IsValid(int value);
const GLAnsGameBakFail_BAK_TYPE GLAnsGameBakFail_BAK_TYPE_BAK_TYPE_MIN = GLAnsGameBakFail_BAK_TYPE_CAPBAK;
const GLAnsGameBakFail_BAK_TYPE GLAnsGameBakFail_BAK_TYPE_BAK_TYPE_MAX = GLAnsGameBakFail_BAK_TYPE_BAK_ZERO;
const int GLAnsGameBakFail_BAK_TYPE_BAK_TYPE_ARRAYSIZE = GLAnsGameBakFail_BAK_TYPE_BAK_TYPE_MAX + 1;

enum GLAnsGameNotiMission_MISSION_TYPE {
  GLAnsGameNotiMission_MISSION_TYPE_CARD = 1,
  GLAnsGameNotiMission_MISSION_TYPE_NONE = 2,
  GLAnsGameNotiMission_MISSION_TYPE_UNCONDITION = 3,
  GLAnsGameNotiMission_MISSION_TYPE_TWOBBUCK = 4,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_38 = 5,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_13 = 6,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_18 = 7,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_ali_15 = 8,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_ali_16 = 9,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_ali_25 = 10,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_ali_26 = 11,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_doksa_113 = 12,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_doksa_114 = 13,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_doksa_213 = 14,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_doksa_214 = 15,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_kubbing_133 = 16,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_kubbing_134 = 17,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_kubbing_233 = 18,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_kubbing_234 = 19,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_jangbbing_137 = 20,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_jangbbing_138 = 21,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_jangbbing_237 = 22,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_jangbbing_238 = 23,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_jangsa_3713 = 24,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_jangsa_3814 = 25,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_jangsa_3714 = 26,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_jangsa_3813 = 27,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_seroulk_1321 = 28,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_seroulk_1422 = 29,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_seroulk_1322 = 30,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_seroulk_1421 = 31,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_47 = 32,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_37 = 33,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_THREE_godori = 34,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_THREE_blue = 35,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_THREE_red = 36,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_THREE_cho = 37,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_THREE_1_3_8 = 38,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_THREE_1_11_12 = 39,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_THREE_3_8_12 = 40,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_THREE_1_3_11 = 41,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_THREE_8_11_12 = 42,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_MONTH_1 = 43,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_MONTH_2 = 44,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_MONTH_3 = 45,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_MONTH_4 = 46,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_MONTH_5 = 47,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_MONTH_6 = 48,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_MONTH_7 = 49,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_MONTH_8 = 50,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_MONTH_9 = 51,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_MONTH_10 = 52,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_MONTH_11 = 53,
  GLAnsGameNotiMission_MISSION_TYPE_kMI_MONTH_12 = 54,
  GLAnsGameNotiMission_MISSION_TYPE_MISSION_ZERO = 55
};
bool GLAnsGameNotiMission_MISSION_TYPE_IsValid(int value);
const GLAnsGameNotiMission_MISSION_TYPE GLAnsGameNotiMission_MISSION_TYPE_MISSION_TYPE_MIN = GLAnsGameNotiMission_MISSION_TYPE_CARD;
const GLAnsGameNotiMission_MISSION_TYPE GLAnsGameNotiMission_MISSION_TYPE_MISSION_TYPE_MAX = GLAnsGameNotiMission_MISSION_TYPE_MISSION_ZERO;
const int GLAnsGameNotiMission_MISSION_TYPE_MISSION_TYPE_ARRAYSIZE = GLAnsGameNotiMission_MISSION_TYPE_MISSION_TYPE_MAX + 1;

enum GLAnsGameMissionState_MISSION_STATE {
  GLAnsGameMissionState_MISSION_STATE_FAIL = 1,
  GLAnsGameMissionState_MISSION_STATE_SUCCESS = 2,
  GLAnsGameMissionState_MISSION_STATE_STATE_ZERO = 3
};
bool GLAnsGameMissionState_MISSION_STATE_IsValid(int value);
const GLAnsGameMissionState_MISSION_STATE GLAnsGameMissionState_MISSION_STATE_MISSION_STATE_MIN = GLAnsGameMissionState_MISSION_STATE_FAIL;
const GLAnsGameMissionState_MISSION_STATE GLAnsGameMissionState_MISSION_STATE_MISSION_STATE_MAX = GLAnsGameMissionState_MISSION_STATE_STATE_ZERO;
const int GLAnsGameMissionState_MISSION_STATE_MISSION_STATE_ARRAYSIZE = GLAnsGameMissionState_MISSION_STATE_MISSION_STATE_MAX + 1;

enum GLAnsGameResult_GAME_RESULT_TYPE {
  GLAnsGameResult_GAME_RESULT_TYPE_RESULT_NORMAL = 1,
  GLAnsGameResult_GAME_RESULT_TYPE_RESULT_3BBUK = 2,
  GLAnsGameResult_GAME_RESULT_TYPE_RESULT_CHONGTONG = 3,
  GLAnsGameResult_GAME_RESULT_TYPE_RESULT_NAGARI = 4,
  GLAnsGameResult_GAME_RESULT_TYPE_RESULT_ZERO = 5
};
bool GLAnsGameResult_GAME_RESULT_TYPE_IsValid(int value);
const GLAnsGameResult_GAME_RESULT_TYPE GLAnsGameResult_GAME_RESULT_TYPE_GAME_RESULT_TYPE_MIN = GLAnsGameResult_GAME_RESULT_TYPE_RESULT_NORMAL;
const GLAnsGameResult_GAME_RESULT_TYPE GLAnsGameResult_GAME_RESULT_TYPE_GAME_RESULT_TYPE_MAX = GLAnsGameResult_GAME_RESULT_TYPE_RESULT_ZERO;
const int GLAnsGameResult_GAME_RESULT_TYPE_GAME_RESULT_TYPE_ARRAYSIZE = GLAnsGameResult_GAME_RESULT_TYPE_GAME_RESULT_TYPE_MAX + 1;

enum GLAnsGameKick_KICK_TYPE {
  GLAnsGameKick_KICK_TYPE_EXIT_RESERVATION = 1,
  GLAnsGameKick_KICK_TYPE_LIMITMONEY = 2,
  GLAnsGameKick_KICK_TYPE_ALLIN = 3,
  GLAnsGameKick_KICK_TYPE_KICK_ZERO = 4
};
bool GLAnsGameKick_KICK_TYPE_IsValid(int value);
const GLAnsGameKick_KICK_TYPE GLAnsGameKick_KICK_TYPE_KICK_TYPE_MIN = GLAnsGameKick_KICK_TYPE_EXIT_RESERVATION;
const GLAnsGameKick_KICK_TYPE GLAnsGameKick_KICK_TYPE_KICK_TYPE_MAX = GLAnsGameKick_KICK_TYPE_KICK_ZERO;
const int GLAnsGameKick_KICK_TYPE_KICK_TYPE_ARRAYSIZE = GLAnsGameKick_KICK_TYPE_KICK_TYPE_MAX + 1;

enum GLReqGameChoiceCardAns_Type {
  GLReqGameChoiceCardAns_Type_SELECT = 1,
  GLReqGameChoiceCardAns_Type_UPSET = 2
};
bool GLReqGameChoiceCardAns_Type_IsValid(int value);
const GLReqGameChoiceCardAns_Type GLReqGameChoiceCardAns_Type_Type_MIN = GLReqGameChoiceCardAns_Type_SELECT;
const GLReqGameChoiceCardAns_Type GLReqGameChoiceCardAns_Type_Type_MAX = GLReqGameChoiceCardAns_Type_UPSET;
const int GLReqGameChoiceCardAns_Type_Type_ARRAYSIZE = GLReqGameChoiceCardAns_Type_Type_MAX + 1;

enum GLAnsGameProtocol_Type {
  GLAnsGameProtocol_Type_NONE = 1,
  GLAnsGameProtocol_Type_GAME_STARTREADY = 2,
  GLAnsGameProtocol_Type_GAME_RESETREADY = 3,
  GLAnsGameProtocol_Type_GAME_INIT = 4,
  GLAnsGameProtocol_Type_GAME_START = 5,
  GLAnsGameProtocol_Type_GAME_RESET = 6,
  GLAnsGameProtocol_Type_GAME_NOTISUN = 7,
  GLAnsGameProtocol_Type_GAME_SELECTSUN = 8,
  GLAnsGameProtocol_Type_GAME_NOTISELECTSUN = 9,
  GLAnsGameProtocol_Type_GAME_SHARING = 10,
  GLAnsGameProtocol_Type_GAME_NAGARI = 11,
  GLAnsGameProtocol_Type_GAME_CHONGTONG = 12,
  GLAnsGameProtocol_Type_GAME_SELECTCARD = 13,
  GLAnsGameProtocol_Type_GAME_BONUS = 14,
  GLAnsGameProtocol_Type_GAME_TAKEPEE = 15,
  GLAnsGameProtocol_Type_GAME_BBUCK = 16,
  GLAnsGameProtocol_Type_GAME_SERISEBBUK = 17,
  GLAnsGameProtocol_Type_GAME_BBUCKEAT = 18,
  GLAnsGameProtocol_Type_GAME_BOMB = 19,
  GLAnsGameProtocol_Type_GAME_PAN = 20,
  GLAnsGameProtocol_Type_GAME_DADAK = 21,
  GLAnsGameProtocol_Type_GAME_JJOK = 22,
  GLAnsGameProtocol_Type_GAME_UPSET = 23,
  GLAnsGameProtocol_Type_GAME_ALLEATUP = 24,
  GLAnsGameProtocol_Type_GAME_NOTITURN = 25,
  GLAnsGameProtocol_Type_GAME_MOVETEN = 26,
  GLAnsGameProtocol_Type_GAME_MOVETENANS = 27,
  GLAnsGameProtocol_Type_GAME_CHOICECARD = 28,
  GLAnsGameProtocol_Type_GAME_SHAKE = 29,
  GLAnsGameProtocol_Type_GAME_SHAKEANS = 30,
  GLAnsGameProtocol_Type_GAME_SHAKECOUNT = 31,
  GLAnsGameProtocol_Type_GAME_CAPTYPE = 32,
  GLAnsGameProtocol_Type_GAME_GODORI = 33,
  GLAnsGameProtocol_Type_GAME_KUSA = 34,
  GLAnsGameProtocol_Type_GAME_RED = 35,
  GLAnsGameProtocol_Type_GAME_BLUE = 36,
  GLAnsGameProtocol_Type_GAME_BAK = 37,
  GLAnsGameProtocol_Type_GAME_BAKFAIL = 38,
  GLAnsGameProtocol_Type_GAME_NOTYMISSION = 39,
  GLAnsGameProtocol_Type_GAME_NOTIMISSIONCARD = 40,
  GLAnsGameProtocol_Type_GAME_MISSIONSTATE = 41,
  GLAnsGameProtocol_Type_GAME_GOSTOP = 42,
  GLAnsGameProtocol_Type_GAME_GOSTOPANS = 43,
  GLAnsGameProtocol_Type_GAME_STOPANS = 44,
  GLAnsGameProtocol_Type_GAME_RESULT = 45,
  GLAnsGameProtocol_Type_GAME_NOTIPOINT = 46,
  GLAnsGameProtocol_Type_GAME_END = 47,
  GLAnsGameProtocol_Type_GAME_KICK = 48,
  GLAnsGameProtocol_Type_GAME_EMOTI = 49,
  GLAnsGameProtocol_Type_GAME_AUTOPLAY = 50,
  GLAnsGameProtocol_Type_GAME_RELAYINFO = 51,
  GLAnsGameProtocol_Type_GAME_EXITRESERVATION = 52
};
bool GLAnsGameProtocol_Type_IsValid(int value);
const GLAnsGameProtocol_Type GLAnsGameProtocol_Type_Type_MIN = GLAnsGameProtocol_Type_NONE;
const GLAnsGameProtocol_Type GLAnsGameProtocol_Type_Type_MAX = GLAnsGameProtocol_Type_GAME_EXITRESERVATION;
const int GLAnsGameProtocol_Type_Type_ARRAYSIZE = GLAnsGameProtocol_Type_Type_MAX + 1;

enum GLReqGameProtocol_Type {
  GLReqGameProtocol_Type_NONE = 1,
  GLReqGameProtocol_Type_REQ_GAME_READY = 2,
  GLReqGameProtocol_Type_REQ_GAME_RESETREADY = 3,
  GLReqGameProtocol_Type_REQ_GAME_INITGAME = 4,
  GLReqGameProtocol_Type_REQ_GAME_RESET = 5,
  GLReqGameProtocol_Type_REQ_GAME_START = 6,
  GLReqGameProtocol_Type_REQ_GAME_SELECTSUNCARD = 7,
  GLReqGameProtocol_Type_REQ_GAME_SELECTCARD = 8,
  GLReqGameProtocol_Type_REQ_GAME_ASKGOSTOPANS = 9,
  GLReqGameProtocol_Type_REQ_GAME_ASKSHAKEANS = 10,
  GLReqGameProtocol_Type_REQ_GAME_CHOICECARDANS = 11,
  GLReqGameProtocol_Type_REQ_GAME_MOVETEN = 12,
  GLReqGameProtocol_Type_REQ_GAME_CHONGTONG = 13,
  GLReqGameProtocol_Type_REQ_GAME_END = 14,
  GLReqGameProtocol_Type_REQ_GAME_RESULTOK = 15,
  GLReqGameProtocol_Type_REQ_GAME_AUTOPLAY = 16,
  GLReqGameProtocol_Type_REQ_GAME_EMOTI = 17,
  GLReqGameProtocol_Type_REQ_GAME_EXITRESERVATION = 18,
  GLReqGameProtocol_Type_REQ_GAME_RELAYINFO = 19,
  GLReqGameProtocol_Type_REQ_GAME_INITGAMETAN = 20,
  GLReqGameProtocol_Type_REQ_GAME_TEST_PACKET = 21
};
bool GLReqGameProtocol_Type_IsValid(int value);
const GLReqGameProtocol_Type GLReqGameProtocol_Type_Type_MIN = GLReqGameProtocol_Type_NONE;
const GLReqGameProtocol_Type GLReqGameProtocol_Type_Type_MAX = GLReqGameProtocol_Type_REQ_GAME_TEST_PACKET;
const int GLReqGameProtocol_Type_Type_ARRAYSIZE = GLReqGameProtocol_Type_Type_MAX + 1;

// ===================================================================

class GameUserInfo : public ::google::protobuf::MessageLite {
 public:
  GameUserInfo();
  virtual ~GameUserInfo();
  
  GameUserInfo(const GameUserInfo& from);
  
  inline GameUserInfo& operator=(const GameUserInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GameUserInfo& default_instance();
  
  void Swap(GameUserInfo* other);
  
  // implements Message ----------------------------------------------
  
  GameUserInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GameUserInfo& from);
  void MergeFrom(const GameUserInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .GameInfo gameInfo = 1;
  inline bool has_gameinfo() const;
  inline void clear_gameinfo();
  static const int kGameInfoFieldNumber = 1;
  inline const ::GameInfo& gameinfo() const;
  inline ::GameInfo* mutable_gameinfo();
  inline ::GameInfo* release_gameinfo();
  
  // required .MemberInfo memberInfo = 2;
  inline bool has_memberinfo() const;
  inline void clear_memberinfo();
  static const int kMemberInfoFieldNumber = 2;
  inline const ::MemberInfo& memberinfo() const;
  inline ::MemberInfo* mutable_memberinfo();
  inline ::MemberInfo* release_memberinfo();
  
  // @@protoc_insertion_point(class_scope:GameUserInfo)
 private:
  inline void set_has_gameinfo();
  inline void clear_has_gameinfo();
  inline void set_has_memberinfo();
  inline void clear_has_memberinfo();
  
  ::GameInfo* gameinfo_;
  ::MemberInfo* memberinfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GameUserInfo* default_instance_;
};
// -------------------------------------------------------------------

class GameRoomInfo : public ::google::protobuf::MessageLite {
 public:
  GameRoomInfo();
  virtual ~GameRoomInfo();
  
  GameRoomInfo(const GameRoomInfo& from);
  
  inline GameRoomInfo& operator=(const GameRoomInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GameRoomInfo& default_instance();
  
  void Swap(GameRoomInfo* other);
  
  // implements Message ----------------------------------------------
  
  GameRoomInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GameRoomInfo& from);
  void MergeFrom(const GameRoomInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 roomID = 1;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIDFieldNumber = 1;
  inline ::google::protobuf::int32 roomid() const;
  inline void set_roomid(::google::protobuf::int32 value);
  
  // required int32 pointMoney = 2;
  inline bool has_pointmoney() const;
  inline void clear_pointmoney();
  static const int kPointMoneyFieldNumber = 2;
  inline ::google::protobuf::int32 pointmoney() const;
  inline void set_pointmoney(::google::protobuf::int32 value);
  
  // repeated .GameUserInfo gameUserInfo = 3;
  inline int gameuserinfo_size() const;
  inline void clear_gameuserinfo();
  static const int kGameUserInfoFieldNumber = 3;
  inline const ::GameUserInfo& gameuserinfo(int index) const;
  inline ::GameUserInfo* mutable_gameuserinfo(int index);
  inline ::GameUserInfo* add_gameuserinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::GameUserInfo >&
      gameuserinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::GameUserInfo >*
      mutable_gameuserinfo();
  
  // @@protoc_insertion_point(class_scope:GameRoomInfo)
 private:
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_pointmoney();
  inline void clear_has_pointmoney();
  
  ::google::protobuf::int32 roomid_;
  ::google::protobuf::int32 pointmoney_;
  ::google::protobuf::RepeatedPtrField< ::GameUserInfo > gameuserinfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GameRoomInfo* default_instance_;
};
// -------------------------------------------------------------------

class GameInfo : public ::google::protobuf::MessageLite {
 public:
  GameInfo();
  virtual ~GameInfo();
  
  GameInfo(const GameInfo& from);
  
  inline GameInfo& operator=(const GameInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GameInfo& default_instance();
  
  void Swap(GameInfo* other);
  
  // implements Message ----------------------------------------------
  
  GameInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GameInfo& from);
  void MergeFrom(const GameInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // required int32 level = 3;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 3;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);
  
  // required int32 exp = 4;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 4;
  inline ::google::protobuf::int32 exp() const;
  inline void set_exp(::google::protobuf::int32 value);
  
  // required string money = 5;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 5;
  inline const ::std::string& money() const;
  inline void set_money(const ::std::string& value);
  inline void set_money(const char* value);
  inline void set_money(const char* value, size_t size);
  inline ::std::string* mutable_money();
  inline ::std::string* release_money();
  
  // required int32 winCnt = 6;
  inline bool has_wincnt() const;
  inline void clear_wincnt();
  static const int kWinCntFieldNumber = 6;
  inline ::google::protobuf::int32 wincnt() const;
  inline void set_wincnt(::google::protobuf::int32 value);
  
  // required int32 loseCnt = 7;
  inline bool has_losecnt() const;
  inline void clear_losecnt();
  static const int kLoseCntFieldNumber = 7;
  inline ::google::protobuf::int32 losecnt() const;
  inline void set_losecnt(::google::protobuf::int32 value);
  
  // required int32 allInCnt = 8;
  inline bool has_allincnt() const;
  inline void clear_allincnt();
  static const int kAllInCntFieldNumber = 8;
  inline ::google::protobuf::int32 allincnt() const;
  inline void set_allincnt(::google::protobuf::int32 value);
  
  // required string highMoney = 9;
  inline bool has_highmoney() const;
  inline void clear_highmoney();
  static const int kHighMoneyFieldNumber = 9;
  inline const ::std::string& highmoney() const;
  inline void set_highmoney(const ::std::string& value);
  inline void set_highmoney(const char* value);
  inline void set_highmoney(const char* value, size_t size);
  inline ::std::string* mutable_highmoney();
  inline ::std::string* release_highmoney();
  
  // required int32 highPoint = 10;
  inline bool has_highpoint() const;
  inline void clear_highpoint();
  static const int kHighPointFieldNumber = 10;
  inline ::google::protobuf::int32 highpoint() const;
  inline void set_highpoint(::google::protobuf::int32 value);
  
  // required int32 todayWin = 11;
  inline bool has_todaywin() const;
  inline void clear_todaywin();
  static const int kTodayWinFieldNumber = 11;
  inline ::google::protobuf::int32 todaywin() const;
  inline void set_todaywin(::google::protobuf::int32 value);
  
  // required int32 todayLose = 12;
  inline bool has_todaylose() const;
  inline void clear_todaylose();
  static const int kTodayLoseFieldNumber = 12;
  inline ::google::protobuf::int32 todaylose() const;
  inline void set_todaylose(::google::protobuf::int32 value);
  
  // required int32 todayHighPoint = 13;
  inline bool has_todayhighpoint() const;
  inline void clear_todayhighpoint();
  static const int kTodayHighPointFieldNumber = 13;
  inline ::google::protobuf::int32 todayhighpoint() const;
  inline void set_todayhighpoint(::google::protobuf::int32 value);
  
  // required string todayHighMoney = 14;
  inline bool has_todayhighmoney() const;
  inline void clear_todayhighmoney();
  static const int kTodayHighMoneyFieldNumber = 14;
  inline const ::std::string& todayhighmoney() const;
  inline void set_todayhighmoney(const ::std::string& value);
  inline void set_todayhighmoney(const char* value);
  inline void set_todayhighmoney(const char* value, size_t size);
  inline ::std::string* mutable_todayhighmoney();
  inline ::std::string* release_todayhighmoney();
  
  // required int32 todayAllinCnt = 15;
  inline bool has_todayallincnt() const;
  inline void clear_todayallincnt();
  static const int kTodayAllinCntFieldNumber = 15;
  inline ::google::protobuf::int32 todayallincnt() const;
  inline void set_todayallincnt(::google::protobuf::int32 value);
  
  // required int32 todayRefill = 16;
  inline bool has_todayrefill() const;
  inline void clear_todayrefill();
  static const int kTodayRefillFieldNumber = 16;
  inline ::google::protobuf::int32 todayrefill() const;
  inline void set_todayrefill(::google::protobuf::int32 value);
  
  // required string safeMoney = 17;
  inline bool has_safemoney() const;
  inline void clear_safemoney();
  static const int kSafeMoneyFieldNumber = 17;
  inline const ::std::string& safemoney() const;
  inline void set_safemoney(const ::std::string& value);
  inline void set_safemoney(const char* value);
  inline void set_safemoney(const char* value, size_t size);
  inline ::std::string* mutable_safemoney();
  inline ::std::string* release_safemoney();
  
  // @@protoc_insertion_point(class_scope:GameInfo)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_wincnt();
  inline void clear_has_wincnt();
  inline void set_has_losecnt();
  inline void clear_has_losecnt();
  inline void set_has_allincnt();
  inline void clear_has_allincnt();
  inline void set_has_highmoney();
  inline void clear_has_highmoney();
  inline void set_has_highpoint();
  inline void clear_has_highpoint();
  inline void set_has_todaywin();
  inline void clear_has_todaywin();
  inline void set_has_todaylose();
  inline void clear_has_todaylose();
  inline void set_has_todayhighpoint();
  inline void clear_has_todayhighpoint();
  inline void set_has_todayhighmoney();
  inline void clear_has_todayhighmoney();
  inline void set_has_todayallincnt();
  inline void clear_has_todayallincnt();
  inline void set_has_todayrefill();
  inline void clear_has_todayrefill();
  inline void set_has_safemoney();
  inline void clear_has_safemoney();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 exp_;
  ::std::string* money_;
  ::google::protobuf::int32 wincnt_;
  ::google::protobuf::int32 losecnt_;
  ::std::string* highmoney_;
  ::google::protobuf::int32 allincnt_;
  ::google::protobuf::int32 highpoint_;
  ::google::protobuf::int32 todaywin_;
  ::google::protobuf::int32 todaylose_;
  ::std::string* todayhighmoney_;
  ::google::protobuf::int32 todayhighpoint_;
  ::google::protobuf::int32 todayallincnt_;
  ::std::string* safemoney_;
  ::google::protobuf::int32 todayrefill_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(17 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GameInfo* default_instance_;
};
// -------------------------------------------------------------------

class MoneyInfo : public ::google::protobuf::MessageLite {
 public:
  MoneyInfo();
  virtual ~MoneyInfo();
  
  MoneyInfo(const MoneyInfo& from);
  
  inline MoneyInfo& operator=(const MoneyInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const MoneyInfo& default_instance();
  
  void Swap(MoneyInfo* other);
  
  // implements Message ----------------------------------------------
  
  MoneyInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MoneyInfo& from);
  void MergeFrom(const MoneyInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required string money = 2;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 2;
  inline const ::std::string& money() const;
  inline void set_money(const ::std::string& value);
  inline void set_money(const char* value);
  inline void set_money(const char* value, size_t size);
  inline ::std::string* mutable_money();
  inline ::std::string* release_money();
  
  // @@protoc_insertion_point(class_scope:MoneyInfo)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_money();
  inline void clear_has_money();
  
  ::std::string* money_;
  ::google::protobuf::int32 gameid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static MoneyInfo* default_instance_;
};
// -------------------------------------------------------------------

class GameUpdateInfo : public ::google::protobuf::MessageLite {
 public:
  GameUpdateInfo();
  virtual ~GameUpdateInfo();
  
  GameUpdateInfo(const GameUpdateInfo& from);
  
  inline GameUpdateInfo& operator=(const GameUpdateInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GameUpdateInfo& default_instance();
  
  void Swap(GameUpdateInfo* other);
  
  // implements Message ----------------------------------------------
  
  GameUpdateInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GameUpdateInfo& from);
  void MergeFrom(const GameUpdateInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .GameInfo gameInfo = 1;
  inline int gameinfo_size() const;
  inline void clear_gameinfo();
  static const int kGameInfoFieldNumber = 1;
  inline const ::GameInfo& gameinfo(int index) const;
  inline ::GameInfo* mutable_gameinfo(int index);
  inline ::GameInfo* add_gameinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::GameInfo >&
      gameinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::GameInfo >*
      mutable_gameinfo();
  
  // repeated .MoneyInfo moneyInfo = 2;
  inline int moneyinfo_size() const;
  inline void clear_moneyinfo();
  static const int kMoneyInfoFieldNumber = 2;
  inline const ::MoneyInfo& moneyinfo(int index) const;
  inline ::MoneyInfo* mutable_moneyinfo(int index);
  inline ::MoneyInfo* add_moneyinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::MoneyInfo >&
      moneyinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::MoneyInfo >*
      mutable_moneyinfo();
  
  // @@protoc_insertion_point(class_scope:GameUpdateInfo)
 private:
  
  ::google::protobuf::RepeatedPtrField< ::GameInfo > gameinfo_;
  ::google::protobuf::RepeatedPtrField< ::MoneyInfo > moneyinfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GameUpdateInfo* default_instance_;
};
// -------------------------------------------------------------------

class SafeEventMoneyUpdate : public ::google::protobuf::MessageLite {
 public:
  SafeEventMoneyUpdate();
  virtual ~SafeEventMoneyUpdate();
  
  SafeEventMoneyUpdate(const SafeEventMoneyUpdate& from);
  
  inline SafeEventMoneyUpdate& operator=(const SafeEventMoneyUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const SafeEventMoneyUpdate& default_instance();
  
  void Swap(SafeEventMoneyUpdate* other);
  
  // implements Message ----------------------------------------------
  
  SafeEventMoneyUpdate* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SafeEventMoneyUpdate& from);
  void MergeFrom(const SafeEventMoneyUpdate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string totalMoney = 1;
  inline bool has_totalmoney() const;
  inline void clear_totalmoney();
  static const int kTotalMoneyFieldNumber = 1;
  inline const ::std::string& totalmoney() const;
  inline void set_totalmoney(const ::std::string& value);
  inline void set_totalmoney(const char* value);
  inline void set_totalmoney(const char* value, size_t size);
  inline ::std::string* mutable_totalmoney();
  inline ::std::string* release_totalmoney();
  
  // required string deltaMoney = 2;
  inline bool has_deltamoney() const;
  inline void clear_deltamoney();
  static const int kDeltaMoneyFieldNumber = 2;
  inline const ::std::string& deltamoney() const;
  inline void set_deltamoney(const ::std::string& value);
  inline void set_deltamoney(const char* value);
  inline void set_deltamoney(const char* value, size_t size);
  inline ::std::string* mutable_deltamoney();
  inline ::std::string* release_deltamoney();
  
  // required string dealMoney = 3;
  inline bool has_dealmoney() const;
  inline void clear_dealmoney();
  static const int kDealMoneyFieldNumber = 3;
  inline const ::std::string& dealmoney() const;
  inline void set_dealmoney(const ::std::string& value);
  inline void set_dealmoney(const char* value);
  inline void set_dealmoney(const char* value, size_t size);
  inline ::std::string* mutable_dealmoney();
  inline ::std::string* release_dealmoney();
  
  // @@protoc_insertion_point(class_scope:SafeEventMoneyUpdate)
 private:
  inline void set_has_totalmoney();
  inline void clear_has_totalmoney();
  inline void set_has_deltamoney();
  inline void clear_has_deltamoney();
  inline void set_has_dealmoney();
  inline void clear_has_dealmoney();
  
  ::std::string* totalmoney_;
  ::std::string* deltamoney_;
  ::std::string* dealmoney_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static SafeEventMoneyUpdate* default_instance_;
};
// -------------------------------------------------------------------

class RefillMoneyUpdate : public ::google::protobuf::MessageLite {
 public:
  RefillMoneyUpdate();
  virtual ~RefillMoneyUpdate();
  
  RefillMoneyUpdate(const RefillMoneyUpdate& from);
  
  inline RefillMoneyUpdate& operator=(const RefillMoneyUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const RefillMoneyUpdate& default_instance();
  
  void Swap(RefillMoneyUpdate* other);
  
  // implements Message ----------------------------------------------
  
  RefillMoneyUpdate* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RefillMoneyUpdate& from);
  void MergeFrom(const RefillMoneyUpdate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string totalMoney = 1;
  inline bool has_totalmoney() const;
  inline void clear_totalmoney();
  static const int kTotalMoneyFieldNumber = 1;
  inline const ::std::string& totalmoney() const;
  inline void set_totalmoney(const ::std::string& value);
  inline void set_totalmoney(const char* value);
  inline void set_totalmoney(const char* value, size_t size);
  inline ::std::string* mutable_totalmoney();
  inline ::std::string* release_totalmoney();
  
  // required string refillMoney = 2;
  inline bool has_refillmoney() const;
  inline void clear_refillmoney();
  static const int kRefillMoneyFieldNumber = 2;
  inline const ::std::string& refillmoney() const;
  inline void set_refillmoney(const ::std::string& value);
  inline void set_refillmoney(const char* value);
  inline void set_refillmoney(const char* value, size_t size);
  inline ::std::string* mutable_refillmoney();
  inline ::std::string* release_refillmoney();
  
  // required string bonusMoney = 3;
  inline bool has_bonusmoney() const;
  inline void clear_bonusmoney();
  static const int kBonusMoneyFieldNumber = 3;
  inline const ::std::string& bonusmoney() const;
  inline void set_bonusmoney(const ::std::string& value);
  inline void set_bonusmoney(const char* value);
  inline void set_bonusmoney(const char* value, size_t size);
  inline ::std::string* mutable_bonusmoney();
  inline ::std::string* release_bonusmoney();
  
  // required int32 refillCount = 4;
  inline bool has_refillcount() const;
  inline void clear_refillcount();
  static const int kRefillCountFieldNumber = 4;
  inline ::google::protobuf::int32 refillcount() const;
  inline void set_refillcount(::google::protobuf::int32 value);
  
  // required int32 errorCode = 5;
  inline bool has_errorcode() const;
  inline void clear_errorcode();
  static const int kErrorCodeFieldNumber = 5;
  inline ::google::protobuf::int32 errorcode() const;
  inline void set_errorcode(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:RefillMoneyUpdate)
 private:
  inline void set_has_totalmoney();
  inline void clear_has_totalmoney();
  inline void set_has_refillmoney();
  inline void clear_has_refillmoney();
  inline void set_has_bonusmoney();
  inline void clear_has_bonusmoney();
  inline void set_has_refillcount();
  inline void clear_has_refillcount();
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  
  ::std::string* totalmoney_;
  ::std::string* refillmoney_;
  ::std::string* bonusmoney_;
  ::google::protobuf::int32 refillcount_;
  ::google::protobuf::int32 errorcode_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static RefillMoneyUpdate* default_instance_;
};
// -------------------------------------------------------------------

class MissionDBInfo : public ::google::protobuf::MessageLite {
 public:
  MissionDBInfo();
  virtual ~MissionDBInfo();
  
  MissionDBInfo(const MissionDBInfo& from);
  
  inline MissionDBInfo& operator=(const MissionDBInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const MissionDBInfo& default_instance();
  
  void Swap(MissionDBInfo* other);
  
  // implements Message ----------------------------------------------
  
  MissionDBInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MissionDBInfo& from);
  void MergeFrom(const MissionDBInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef MissionDBInfo_EVENT_TYPE EVENT_TYPE;
  static const EVENT_TYPE EVENT_MISSION = MissionDBInfo_EVENT_TYPE_EVENT_MISSION;
  static const EVENT_TYPE EVENT_SERISEBBUCK = MissionDBInfo_EVENT_TYPE_EVENT_SERISEBBUCK;
  static inline bool EVENT_TYPE_IsValid(int value) {
    return MissionDBInfo_EVENT_TYPE_IsValid(value);
  }
  static const EVENT_TYPE EVENT_TYPE_MIN =
    MissionDBInfo_EVENT_TYPE_EVENT_TYPE_MIN;
  static const EVENT_TYPE EVENT_TYPE_MAX =
    MissionDBInfo_EVENT_TYPE_EVENT_TYPE_MAX;
  static const int EVENT_TYPE_ARRAYSIZE =
    MissionDBInfo_EVENT_TYPE_EVENT_TYPE_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required string totalMoney = 2;
  inline bool has_totalmoney() const;
  inline void clear_totalmoney();
  static const int kTotalMoneyFieldNumber = 2;
  inline const ::std::string& totalmoney() const;
  inline void set_totalmoney(const ::std::string& value);
  inline void set_totalmoney(const char* value);
  inline void set_totalmoney(const char* value, size_t size);
  inline ::std::string* mutable_totalmoney();
  inline ::std::string* release_totalmoney();
  
  // required .MissionDBInfo.EVENT_TYPE nType = 3;
  inline bool has_ntype() const;
  inline void clear_ntype();
  static const int kNTypeFieldNumber = 3;
  inline ::MissionDBInfo_EVENT_TYPE ntype() const;
  inline void set_ntype(::MissionDBInfo_EVENT_TYPE value);
  
  // @@protoc_insertion_point(class_scope:MissionDBInfo)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_totalmoney();
  inline void clear_has_totalmoney();
  inline void set_has_ntype();
  inline void clear_has_ntype();
  
  ::std::string* totalmoney_;
  ::google::protobuf::int32 gameid_;
  int ntype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static MissionDBInfo* default_instance_;
};
// -------------------------------------------------------------------

class MemberInfo : public ::google::protobuf::MessageLite {
 public:
  MemberInfo();
  virtual ~MemberInfo();
  
  MemberInfo(const MemberInfo& from);
  
  inline MemberInfo& operator=(const MemberInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const MemberInfo& default_instance();
  
  void Swap(MemberInfo* other);
  
  // implements Message ----------------------------------------------
  
  MemberInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MemberInfo& from);
  void MergeFrom(const MemberInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required string avatarUrl = 2;
  inline bool has_avatarurl() const;
  inline void clear_avatarurl();
  static const int kAvatarUrlFieldNumber = 2;
  inline const ::std::string& avatarurl() const;
  inline void set_avatarurl(const ::std::string& value);
  inline void set_avatarurl(const char* value);
  inline void set_avatarurl(const char* value, size_t size);
  inline ::std::string* mutable_avatarurl();
  inline ::std::string* release_avatarurl();
  
  // required string nickName = 3;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNickNameFieldNumber = 3;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  
  // required bool sexOption = 4;
  inline bool has_sexoption() const;
  inline void clear_sexoption();
  static const int kSexOptionFieldNumber = 4;
  inline bool sexoption() const;
  inline void set_sexoption(bool value);
  
  // @@protoc_insertion_point(class_scope:MemberInfo)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_avatarurl();
  inline void clear_has_avatarurl();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_sexoption();
  inline void clear_has_sexoption();
  
  ::std::string* avatarurl_;
  ::google::protobuf::int32 gameid_;
  bool sexoption_;
  ::std::string* nickname_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static MemberInfo* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameRelayInfo : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameRelayInfo();
  virtual ~GLAnsGameRelayInfo();
  
  GLAnsGameRelayInfo(const GLAnsGameRelayInfo& from);
  
  inline GLAnsGameRelayInfo& operator=(const GLAnsGameRelayInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameRelayInfo& default_instance();
  
  void Swap(GLAnsGameRelayInfo* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameRelayInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameRelayInfo& from);
  void MergeFrom(const GLAnsGameRelayInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef GLAnsGameRelayInfo_JOKBO_STATE JOKBO_STATE;
  static const JOKBO_STATE JOKBO_WARNNING = GLAnsGameRelayInfo_JOKBO_STATE_JOKBO_WARNNING;
  static const JOKBO_STATE JOKBO_COMPLETE = GLAnsGameRelayInfo_JOKBO_STATE_JOKBO_COMPLETE;
  static const JOKBO_STATE JOKBO_FAIL = GLAnsGameRelayInfo_JOKBO_STATE_JOKBO_FAIL;
  static const JOKBO_STATE JOKBO_ZERO = GLAnsGameRelayInfo_JOKBO_STATE_JOKBO_ZERO;
  static inline bool JOKBO_STATE_IsValid(int value) {
    return GLAnsGameRelayInfo_JOKBO_STATE_IsValid(value);
  }
  static const JOKBO_STATE JOKBO_STATE_MIN =
    GLAnsGameRelayInfo_JOKBO_STATE_JOKBO_STATE_MIN;
  static const JOKBO_STATE JOKBO_STATE_MAX =
    GLAnsGameRelayInfo_JOKBO_STATE_JOKBO_STATE_MAX;
  static const int JOKBO_STATE_ARRAYSIZE =
    GLAnsGameRelayInfo_JOKBO_STATE_JOKBO_STATE_ARRAYSIZE;
  
  typedef GLAnsGameRelayInfo_MISSION_TYPE MISSION_TYPE;
  static const MISSION_TYPE CARD = GLAnsGameRelayInfo_MISSION_TYPE_CARD;
  static const MISSION_TYPE NONE = GLAnsGameRelayInfo_MISSION_TYPE_NONE;
  static const MISSION_TYPE UNCONDITION = GLAnsGameRelayInfo_MISSION_TYPE_UNCONDITION;
  static const MISSION_TYPE TWOBBUCK = GLAnsGameRelayInfo_MISSION_TYPE_TWOBBUCK;
  static const MISSION_TYPE MISSION_ZERO = GLAnsGameRelayInfo_MISSION_TYPE_MISSION_ZERO;
  static inline bool MISSION_TYPE_IsValid(int value) {
    return GLAnsGameRelayInfo_MISSION_TYPE_IsValid(value);
  }
  static const MISSION_TYPE MISSION_TYPE_MIN =
    GLAnsGameRelayInfo_MISSION_TYPE_MISSION_TYPE_MIN;
  static const MISSION_TYPE MISSION_TYPE_MAX =
    GLAnsGameRelayInfo_MISSION_TYPE_MISSION_TYPE_MAX;
  static const int MISSION_TYPE_ARRAYSIZE =
    GLAnsGameRelayInfo_MISSION_TYPE_MISSION_TYPE_ARRAYSIZE;
  
  typedef GLAnsGameRelayInfo_MISSION_STATE MISSION_STATE;
  static const MISSION_STATE FAIL = GLAnsGameRelayInfo_MISSION_STATE_FAIL;
  static const MISSION_STATE SUCCESS = GLAnsGameRelayInfo_MISSION_STATE_SUCCESS;
  static const MISSION_STATE STATE_ZERO = GLAnsGameRelayInfo_MISSION_STATE_STATE_ZERO;
  static inline bool MISSION_STATE_IsValid(int value) {
    return GLAnsGameRelayInfo_MISSION_STATE_IsValid(value);
  }
  static const MISSION_STATE MISSION_STATE_MIN =
    GLAnsGameRelayInfo_MISSION_STATE_MISSION_STATE_MIN;
  static const MISSION_STATE MISSION_STATE_MAX =
    GLAnsGameRelayInfo_MISSION_STATE_MISSION_STATE_MAX;
  static const int MISSION_STATE_ARRAYSIZE =
    GLAnsGameRelayInfo_MISSION_STATE_MISSION_STATE_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // required .GameUserInfo gameInfo = 3;
  inline bool has_gameinfo() const;
  inline void clear_gameinfo();
  static const int kGameInfoFieldNumber = 3;
  inline const ::GameUserInfo& gameinfo() const;
  inline ::GameUserInfo* mutable_gameinfo();
  inline ::GameUserInfo* release_gameinfo();
  
  // required .GameUserInfo youGameInfo = 4;
  inline bool has_yougameinfo() const;
  inline void clear_yougameinfo();
  static const int kYouGameInfoFieldNumber = 4;
  inline const ::GameUserInfo& yougameinfo() const;
  inline ::GameUserInfo* mutable_yougameinfo();
  inline ::GameUserInfo* release_yougameinfo();
  
  // repeated int32 myHoldCard = 5;
  inline int myholdcard_size() const;
  inline void clear_myholdcard();
  static const int kMyHoldCardFieldNumber = 5;
  inline ::google::protobuf::int32 myholdcard(int index) const;
  inline void set_myholdcard(int index, ::google::protobuf::int32 value);
  inline void add_myholdcard(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      myholdcard() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_myholdcard();
  
  // repeated int32 myHaveCard = 6;
  inline int myhavecard_size() const;
  inline void clear_myhavecard();
  static const int kMyHaveCardFieldNumber = 6;
  inline ::google::protobuf::int32 myhavecard(int index) const;
  inline void set_myhavecard(int index, ::google::protobuf::int32 value);
  inline void add_myhavecard(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      myhavecard() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_myhavecard();
  
  // repeated int32 OpenCard = 7;
  inline int opencard_size() const;
  inline void clear_opencard();
  static const int kOpenCardFieldNumber = 7;
  inline ::google::protobuf::int32 opencard(int index) const;
  inline void set_opencard(int index, ::google::protobuf::int32 value);
  inline void add_opencard(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      opencard() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_opencard();
  
  // required int32 youHoldCount = 8;
  inline bool has_youholdcount() const;
  inline void clear_youholdcount();
  static const int kYouHoldCountFieldNumber = 8;
  inline ::google::protobuf::int32 youholdcount() const;
  inline void set_youholdcount(::google::protobuf::int32 value);
  
  // repeated int32 youHaveCard = 9;
  inline int youhavecard_size() const;
  inline void clear_youhavecard();
  static const int kYouHaveCardFieldNumber = 9;
  inline ::google::protobuf::int32 youhavecard(int index) const;
  inline void set_youhavecard(int index, ::google::protobuf::int32 value);
  inline void add_youhavecard(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      youhavecard() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_youhavecard();
  
  // required .GLAnsGameRelayInfo.JOKBO_STATE myGodoriType = 10;
  inline bool has_mygodoritype() const;
  inline void clear_mygodoritype();
  static const int kMyGodoriTypeFieldNumber = 10;
  inline ::GLAnsGameRelayInfo_JOKBO_STATE mygodoritype() const;
  inline void set_mygodoritype(::GLAnsGameRelayInfo_JOKBO_STATE value);
  
  // required .GLAnsGameRelayInfo.JOKBO_STATE myRedType = 11;
  inline bool has_myredtype() const;
  inline void clear_myredtype();
  static const int kMyRedTypeFieldNumber = 11;
  inline ::GLAnsGameRelayInfo_JOKBO_STATE myredtype() const;
  inline void set_myredtype(::GLAnsGameRelayInfo_JOKBO_STATE value);
  
  // required .GLAnsGameRelayInfo.JOKBO_STATE myBlueType = 12;
  inline bool has_mybluetype() const;
  inline void clear_mybluetype();
  static const int kMyBlueTypeFieldNumber = 12;
  inline ::GLAnsGameRelayInfo_JOKBO_STATE mybluetype() const;
  inline void set_mybluetype(::GLAnsGameRelayInfo_JOKBO_STATE value);
  
  // required .GLAnsGameRelayInfo.JOKBO_STATE myKusaType = 13;
  inline bool has_mykusatype() const;
  inline void clear_mykusatype();
  static const int kMyKusaTypeFieldNumber = 13;
  inline ::GLAnsGameRelayInfo_JOKBO_STATE mykusatype() const;
  inline void set_mykusatype(::GLAnsGameRelayInfo_JOKBO_STATE value);
  
  // required .GLAnsGameRelayInfo.JOKBO_STATE youGodoriType = 14;
  inline bool has_yougodoritype() const;
  inline void clear_yougodoritype();
  static const int kYouGodoriTypeFieldNumber = 14;
  inline ::GLAnsGameRelayInfo_JOKBO_STATE yougodoritype() const;
  inline void set_yougodoritype(::GLAnsGameRelayInfo_JOKBO_STATE value);
  
  // required .GLAnsGameRelayInfo.JOKBO_STATE youRedType = 15;
  inline bool has_youredtype() const;
  inline void clear_youredtype();
  static const int kYouRedTypeFieldNumber = 15;
  inline ::GLAnsGameRelayInfo_JOKBO_STATE youredtype() const;
  inline void set_youredtype(::GLAnsGameRelayInfo_JOKBO_STATE value);
  
  // required .GLAnsGameRelayInfo.JOKBO_STATE youBlueType = 16;
  inline bool has_youbluetype() const;
  inline void clear_youbluetype();
  static const int kYouBlueTypeFieldNumber = 16;
  inline ::GLAnsGameRelayInfo_JOKBO_STATE youbluetype() const;
  inline void set_youbluetype(::GLAnsGameRelayInfo_JOKBO_STATE value);
  
  // required .GLAnsGameRelayInfo.JOKBO_STATE youKusaType = 17;
  inline bool has_youkusatype() const;
  inline void clear_youkusatype();
  static const int kYouKusaTypeFieldNumber = 17;
  inline ::GLAnsGameRelayInfo_JOKBO_STATE youkusatype() const;
  inline void set_youkusatype(::GLAnsGameRelayInfo_JOKBO_STATE value);
  
  // required int32 myPoint = 18;
  inline bool has_mypoint() const;
  inline void clear_mypoint();
  static const int kMyPointFieldNumber = 18;
  inline ::google::protobuf::int32 mypoint() const;
  inline void set_mypoint(::google::protobuf::int32 value);
  
  // required int32 myGoPoint = 19;
  inline bool has_mygopoint() const;
  inline void clear_mygopoint();
  static const int kMyGoPointFieldNumber = 19;
  inline ::google::protobuf::int32 mygopoint() const;
  inline void set_mygopoint(::google::protobuf::int32 value);
  
  // required int32 myShakeCount = 20;
  inline bool has_myshakecount() const;
  inline void clear_myshakecount();
  static const int kMyShakeCountFieldNumber = 20;
  inline ::google::protobuf::int32 myshakecount() const;
  inline void set_myshakecount(::google::protobuf::int32 value);
  
  // required int32 myBuckCount = 21;
  inline bool has_mybuckcount() const;
  inline void clear_mybuckcount();
  static const int kMyBuckCountFieldNumber = 21;
  inline ::google::protobuf::int32 mybuckcount() const;
  inline void set_mybuckcount(::google::protobuf::int32 value);
  
  // required int32 youPoint = 22;
  inline bool has_youpoint() const;
  inline void clear_youpoint();
  static const int kYouPointFieldNumber = 22;
  inline ::google::protobuf::int32 youpoint() const;
  inline void set_youpoint(::google::protobuf::int32 value);
  
  // required int32 youGoPoint = 23;
  inline bool has_yougopoint() const;
  inline void clear_yougopoint();
  static const int kYouGoPointFieldNumber = 23;
  inline ::google::protobuf::int32 yougopoint() const;
  inline void set_yougopoint(::google::protobuf::int32 value);
  
  // required int32 youShakeCount = 24;
  inline bool has_youshakecount() const;
  inline void clear_youshakecount();
  static const int kYouShakeCountFieldNumber = 24;
  inline ::google::protobuf::int32 youshakecount() const;
  inline void set_youshakecount(::google::protobuf::int32 value);
  
  // required int32 youBuckCount = 25;
  inline bool has_youbuckcount() const;
  inline void clear_youbuckcount();
  static const int kYouBuckCountFieldNumber = 25;
  inline ::google::protobuf::int32 youbuckcount() const;
  inline void set_youbuckcount(::google::protobuf::int32 value);
  
  // required int32 gameSun = 26;
  inline bool has_gamesun() const;
  inline void clear_gamesun();
  static const int kGameSunFieldNumber = 26;
  inline ::google::protobuf::int32 gamesun() const;
  inline void set_gamesun(::google::protobuf::int32 value);
  
  // required int32 currenTurn = 27;
  inline bool has_currenturn() const;
  inline void clear_currenturn();
  static const int kCurrenTurnFieldNumber = 27;
  inline ::google::protobuf::int32 currenturn() const;
  inline void set_currenturn(::google::protobuf::int32 value);
  
  // required int32 turnCount = 28;
  inline bool has_turncount() const;
  inline void clear_turncount();
  static const int kTurnCountFieldNumber = 28;
  inline ::google::protobuf::int32 turncount() const;
  inline void set_turncount(::google::protobuf::int32 value);
  
  // required int32 missionMulNum = 29;
  inline bool has_missionmulnum() const;
  inline void clear_missionmulnum();
  static const int kMissionMulNumFieldNumber = 29;
  inline ::google::protobuf::int32 missionmulnum() const;
  inline void set_missionmulnum(::google::protobuf::int32 value);
  
  // repeated int32 missionCard = 30;
  inline int missioncard_size() const;
  inline void clear_missioncard();
  static const int kMissionCardFieldNumber = 30;
  inline ::google::protobuf::int32 missioncard(int index) const;
  inline void set_missioncard(int index, ::google::protobuf::int32 value);
  inline void add_missioncard(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      missioncard() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_missioncard();
  
  // required string missionTitle = 31;
  inline bool has_missiontitle() const;
  inline void clear_missiontitle();
  static const int kMissionTitleFieldNumber = 31;
  inline const ::std::string& missiontitle() const;
  inline void set_missiontitle(const ::std::string& value);
  inline void set_missiontitle(const char* value);
  inline void set_missiontitle(const char* value, size_t size);
  inline ::std::string* mutable_missiontitle();
  inline ::std::string* release_missiontitle();
  
  // required .GLAnsGameRelayInfo.MISSION_TYPE missionType = 32;
  inline bool has_missiontype() const;
  inline void clear_missiontype();
  static const int kMissionTypeFieldNumber = 32;
  inline ::GLAnsGameRelayInfo_MISSION_TYPE missiontype() const;
  inline void set_missiontype(::GLAnsGameRelayInfo_MISSION_TYPE value);
  
  // optional int32 missionUserID = 33;
  inline bool has_missionuserid() const;
  inline void clear_missionuserid();
  static const int kMissionUserIDFieldNumber = 33;
  inline ::google::protobuf::int32 missionuserid() const;
  inline void set_missionuserid(::google::protobuf::int32 value);
  
  // required .GLAnsGameRelayInfo.MISSION_STATE missionStateType = 34;
  inline bool has_missionstatetype() const;
  inline void clear_missionstatetype();
  static const int kMissionStateTypeFieldNumber = 34;
  inline ::GLAnsGameRelayInfo_MISSION_STATE missionstatetype() const;
  inline void set_missionstatetype(::GLAnsGameRelayInfo_MISSION_STATE value);
  
  // repeated int32 missionGetCard = 35;
  inline int missiongetcard_size() const;
  inline void clear_missiongetcard();
  static const int kMissionGetCardFieldNumber = 35;
  inline ::google::protobuf::int32 missiongetcard(int index) const;
  inline void set_missiongetcard(int index, ::google::protobuf::int32 value);
  inline void add_missiongetcard(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      missiongetcard() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_missiongetcard();
  
  // repeated int32 youMissionGetCard = 36;
  inline int youmissiongetcard_size() const;
  inline void clear_youmissiongetcard();
  static const int kYouMissionGetCardFieldNumber = 36;
  inline ::google::protobuf::int32 youmissiongetcard(int index) const;
  inline void set_youmissiongetcard(int index, ::google::protobuf::int32 value);
  inline void add_youmissiongetcard(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      youmissiongetcard() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_youmissiongetcard();
  
  // required bool nineMoved = 37;
  inline bool has_ninemoved() const;
  inline void clear_ninemoved();
  static const int kNineMovedFieldNumber = 37;
  inline bool ninemoved() const;
  inline void set_ninemoved(bool value);
  
  // @@protoc_insertion_point(class_scope:GLAnsGameRelayInfo)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  inline void set_has_gameinfo();
  inline void clear_has_gameinfo();
  inline void set_has_yougameinfo();
  inline void clear_has_yougameinfo();
  inline void set_has_youholdcount();
  inline void clear_has_youholdcount();
  inline void set_has_mygodoritype();
  inline void clear_has_mygodoritype();
  inline void set_has_myredtype();
  inline void clear_has_myredtype();
  inline void set_has_mybluetype();
  inline void clear_has_mybluetype();
  inline void set_has_mykusatype();
  inline void clear_has_mykusatype();
  inline void set_has_yougodoritype();
  inline void clear_has_yougodoritype();
  inline void set_has_youredtype();
  inline void clear_has_youredtype();
  inline void set_has_youbluetype();
  inline void clear_has_youbluetype();
  inline void set_has_youkusatype();
  inline void clear_has_youkusatype();
  inline void set_has_mypoint();
  inline void clear_has_mypoint();
  inline void set_has_mygopoint();
  inline void clear_has_mygopoint();
  inline void set_has_myshakecount();
  inline void clear_has_myshakecount();
  inline void set_has_mybuckcount();
  inline void clear_has_mybuckcount();
  inline void set_has_youpoint();
  inline void clear_has_youpoint();
  inline void set_has_yougopoint();
  inline void clear_has_yougopoint();
  inline void set_has_youshakecount();
  inline void clear_has_youshakecount();
  inline void set_has_youbuckcount();
  inline void clear_has_youbuckcount();
  inline void set_has_gamesun();
  inline void clear_has_gamesun();
  inline void set_has_currenturn();
  inline void clear_has_currenturn();
  inline void set_has_turncount();
  inline void clear_has_turncount();
  inline void set_has_missionmulnum();
  inline void clear_has_missionmulnum();
  inline void set_has_missiontitle();
  inline void clear_has_missiontitle();
  inline void set_has_missiontype();
  inline void clear_has_missiontype();
  inline void set_has_missionuserid();
  inline void clear_has_missionuserid();
  inline void set_has_missionstatetype();
  inline void clear_has_missionstatetype();
  inline void set_has_ninemoved();
  inline void clear_has_ninemoved();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  ::GameUserInfo* gameinfo_;
  ::GameUserInfo* yougameinfo_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > myholdcard_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > myhavecard_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > opencard_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > youhavecard_;
  ::google::protobuf::int32 youholdcount_;
  int mygodoritype_;
  int myredtype_;
  int mybluetype_;
  int mykusatype_;
  int yougodoritype_;
  int youredtype_;
  int youbluetype_;
  int youkusatype_;
  ::google::protobuf::int32 mypoint_;
  ::google::protobuf::int32 mygopoint_;
  ::google::protobuf::int32 myshakecount_;
  ::google::protobuf::int32 mybuckcount_;
  ::google::protobuf::int32 youpoint_;
  ::google::protobuf::int32 yougopoint_;
  ::google::protobuf::int32 youshakecount_;
  ::google::protobuf::int32 youbuckcount_;
  ::google::protobuf::int32 gamesun_;
  ::google::protobuf::int32 currenturn_;
  ::google::protobuf::int32 turncount_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > missioncard_;
  ::google::protobuf::int32 missionmulnum_;
  int missiontype_;
  ::std::string* missiontitle_;
  ::google::protobuf::int32 missionuserid_;
  int missionstatetype_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > missiongetcard_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > youmissiongetcard_;
  bool ninemoved_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(37 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameRelayInfo* default_instance_;
};
// -------------------------------------------------------------------

class GLReqGameInitGameTan : public ::google::protobuf::MessageLite {
 public:
  GLReqGameInitGameTan();
  virtual ~GLReqGameInitGameTan();
  
  GLReqGameInitGameTan(const GLReqGameInitGameTan& from);
  
  inline GLReqGameInitGameTan& operator=(const GLReqGameInitGameTan& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLReqGameInitGameTan& default_instance();
  
  void Swap(GLReqGameInitGameTan* other);
  
  // implements Message ----------------------------------------------
  
  GLReqGameInitGameTan* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLReqGameInitGameTan& from);
  void MergeFrom(const GLReqGameInitGameTan& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 tanType = 2;
  inline bool has_tantype() const;
  inline void clear_tantype();
  static const int kTanTypeFieldNumber = 2;
  inline ::google::protobuf::int32 tantype() const;
  inline void set_tantype(::google::protobuf::int32 value);
  
  // required int32 missionType = 3;
  inline bool has_missiontype() const;
  inline void clear_missiontype();
  static const int kMissionTypeFieldNumber = 3;
  inline ::google::protobuf::int32 missiontype() const;
  inline void set_missiontype(::google::protobuf::int32 value);
  
  // required int32 missionMul = 4;
  inline bool has_missionmul() const;
  inline void clear_missionmul();
  static const int kMissionMulFieldNumber = 4;
  inline ::google::protobuf::int32 missionmul() const;
  inline void set_missionmul(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:GLReqGameInitGameTan)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_tantype();
  inline void clear_has_tantype();
  inline void set_has_missiontype();
  inline void clear_has_missiontype();
  inline void set_has_missionmul();
  inline void clear_has_missionmul();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 tantype_;
  ::google::protobuf::int32 missiontype_;
  ::google::protobuf::int32 missionmul_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLReqGameInitGameTan* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameStartReady : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameStartReady();
  virtual ~GLAnsGameStartReady();
  
  GLAnsGameStartReady(const GLAnsGameStartReady& from);
  
  inline GLAnsGameStartReady& operator=(const GLAnsGameStartReady& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameStartReady& default_instance();
  
  void Swap(GLAnsGameStartReady* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameStartReady* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameStartReady& from);
  void MergeFrom(const GLAnsGameStartReady& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:GLAnsGameStartReady)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameStartReady* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameResetReady : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameResetReady();
  virtual ~GLAnsGameResetReady();
  
  GLAnsGameResetReady(const GLAnsGameResetReady& from);
  
  inline GLAnsGameResetReady& operator=(const GLAnsGameResetReady& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameResetReady& default_instance();
  
  void Swap(GLAnsGameResetReady* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameResetReady* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameResetReady& from);
  void MergeFrom(const GLAnsGameResetReady& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:GLAnsGameResetReady)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameResetReady* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameStart : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameStart();
  virtual ~GLAnsGameStart();
  
  GLAnsGameStart(const GLAnsGameStart& from);
  
  inline GLAnsGameStart& operator=(const GLAnsGameStart& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameStart& default_instance();
  
  void Swap(GLAnsGameStart* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameStart* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameStart& from);
  void MergeFrom(const GLAnsGameStart& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // optional int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:GLAnsGameStart)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameStart* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameReset : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameReset();
  virtual ~GLAnsGameReset();
  
  GLAnsGameReset(const GLAnsGameReset& from);
  
  inline GLAnsGameReset& operator=(const GLAnsGameReset& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameReset& default_instance();
  
  void Swap(GLAnsGameReset* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameReset* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameReset& from);
  void MergeFrom(const GLAnsGameReset& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // optional int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:GLAnsGameReset)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameReset* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameNotiSun : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameNotiSun();
  virtual ~GLAnsGameNotiSun();
  
  GLAnsGameNotiSun(const GLAnsGameNotiSun& from);
  
  inline GLAnsGameNotiSun& operator=(const GLAnsGameNotiSun& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameNotiSun& default_instance();
  
  void Swap(GLAnsGameNotiSun* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameNotiSun* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameNotiSun& from);
  void MergeFrom(const GLAnsGameNotiSun& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:GLAnsGameNotiSun)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameNotiSun* default_instance_;
};
// -------------------------------------------------------------------

class GLReqGameSelectSun : public ::google::protobuf::MessageLite {
 public:
  GLReqGameSelectSun();
  virtual ~GLReqGameSelectSun();
  
  GLReqGameSelectSun(const GLReqGameSelectSun& from);
  
  inline GLReqGameSelectSun& operator=(const GLReqGameSelectSun& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLReqGameSelectSun& default_instance();
  
  void Swap(GLReqGameSelectSun* other);
  
  // implements Message ----------------------------------------------
  
  GLReqGameSelectSun* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLReqGameSelectSun& from);
  void MergeFrom(const GLReqGameSelectSun& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // required int32 selectIndex = 3;
  inline bool has_selectindex() const;
  inline void clear_selectindex();
  static const int kSelectIndexFieldNumber = 3;
  inline ::google::protobuf::int32 selectindex() const;
  inline void set_selectindex(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:GLReqGameSelectSun)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  inline void set_has_selectindex();
  inline void clear_has_selectindex();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  ::google::protobuf::int32 selectindex_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLReqGameSelectSun* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameSelectSun : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameSelectSun();
  virtual ~GLAnsGameSelectSun();
  
  GLAnsGameSelectSun(const GLAnsGameSelectSun& from);
  
  inline GLAnsGameSelectSun& operator=(const GLAnsGameSelectSun& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameSelectSun& default_instance();
  
  void Swap(GLAnsGameSelectSun* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameSelectSun* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameSelectSun& from);
  void MergeFrom(const GLAnsGameSelectSun& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // required int32 selectIndex = 3;
  inline bool has_selectindex() const;
  inline void clear_selectindex();
  static const int kSelectIndexFieldNumber = 3;
  inline ::google::protobuf::int32 selectindex() const;
  inline void set_selectindex(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:GLAnsGameSelectSun)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  inline void set_has_selectindex();
  inline void clear_has_selectindex();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  ::google::protobuf::int32 selectindex_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameSelectSun* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameNotiSelectSun : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameNotiSelectSun();
  virtual ~GLAnsGameNotiSelectSun();
  
  GLAnsGameNotiSelectSun(const GLAnsGameNotiSelectSun& from);
  
  inline GLAnsGameNotiSelectSun& operator=(const GLAnsGameNotiSelectSun& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameNotiSelectSun& default_instance();
  
  void Swap(GLAnsGameNotiSelectSun* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameNotiSelectSun* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameNotiSelectSun& from);
  void MergeFrom(const GLAnsGameNotiSelectSun& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // repeated int32 nCard = 3;
  inline int ncard_size() const;
  inline void clear_ncard();
  static const int kNCardFieldNumber = 3;
  inline ::google::protobuf::int32 ncard(int index) const;
  inline void set_ncard(int index, ::google::protobuf::int32 value);
  inline void add_ncard(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      ncard() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_ncard();
  
  // @@protoc_insertion_point(class_scope:GLAnsGameNotiSelectSun)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > ncard_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameNotiSelectSun* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameSharing : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameSharing();
  virtual ~GLAnsGameSharing();
  
  GLAnsGameSharing(const GLAnsGameSharing& from);
  
  inline GLAnsGameSharing& operator=(const GLAnsGameSharing& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameSharing& default_instance();
  
  void Swap(GLAnsGameSharing* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameSharing* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameSharing& from);
  void MergeFrom(const GLAnsGameSharing& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // repeated int32 lstOpenCard = 3;
  inline int lstopencard_size() const;
  inline void clear_lstopencard();
  static const int kLstOpenCardFieldNumber = 3;
  inline ::google::protobuf::int32 lstopencard(int index) const;
  inline void set_lstopencard(int index, ::google::protobuf::int32 value);
  inline void add_lstopencard(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      lstopencard() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_lstopencard();
  
  // repeated int32 lstHoldCard = 4;
  inline int lstholdcard_size() const;
  inline void clear_lstholdcard();
  static const int kLstHoldCardFieldNumber = 4;
  inline ::google::protobuf::int32 lstholdcard(int index) const;
  inline void set_lstholdcard(int index, ::google::protobuf::int32 value);
  inline void add_lstholdcard(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      lstholdcard() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_lstholdcard();
  
  // @@protoc_insertion_point(class_scope:GLAnsGameSharing)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > lstopencard_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > lstholdcard_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameSharing* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameNagari : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameNagari();
  virtual ~GLAnsGameNagari();
  
  GLAnsGameNagari(const GLAnsGameNagari& from);
  
  inline GLAnsGameNagari& operator=(const GLAnsGameNagari& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameNagari& default_instance();
  
  void Swap(GLAnsGameNagari* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameNagari* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameNagari& from);
  void MergeFrom(const GLAnsGameNagari& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef GLAnsGameNagari_NAGARI_TYPE NAGARI_TYPE;
  static const NAGARI_TYPE CHONGTONG_NAGARI = GLAnsGameNagari_NAGARI_TYPE_CHONGTONG_NAGARI;
  static const NAGARI_TYPE CHONGTONG_DOUBLE = GLAnsGameNagari_NAGARI_TYPE_CHONGTONG_DOUBLE;
  static const NAGARI_TYPE NAGARI_ZERO = GLAnsGameNagari_NAGARI_TYPE_NAGARI_ZERO;
  static inline bool NAGARI_TYPE_IsValid(int value) {
    return GLAnsGameNagari_NAGARI_TYPE_IsValid(value);
  }
  static const NAGARI_TYPE NAGARI_TYPE_MIN =
    GLAnsGameNagari_NAGARI_TYPE_NAGARI_TYPE_MIN;
  static const NAGARI_TYPE NAGARI_TYPE_MAX =
    GLAnsGameNagari_NAGARI_TYPE_NAGARI_TYPE_MAX;
  static const int NAGARI_TYPE_ARRAYSIZE =
    GLAnsGameNagari_NAGARI_TYPE_NAGARI_TYPE_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required .GLAnsGameNagari.NAGARI_TYPE nType = 1;
  inline bool has_ntype() const;
  inline void clear_ntype();
  static const int kNTypeFieldNumber = 1;
  inline ::GLAnsGameNagari_NAGARI_TYPE ntype() const;
  inline void set_ntype(::GLAnsGameNagari_NAGARI_TYPE value);
  
  // repeated int32 lstCard = 3;
  inline int lstcard_size() const;
  inline void clear_lstcard();
  static const int kLstCardFieldNumber = 3;
  inline ::google::protobuf::int32 lstcard(int index) const;
  inline void set_lstcard(int index, ::google::protobuf::int32 value);
  inline void add_lstcard(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      lstcard() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_lstcard();
  
  // @@protoc_insertion_point(class_scope:GLAnsGameNagari)
 private:
  inline void set_has_ntype();
  inline void clear_has_ntype();
  
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > lstcard_;
  int ntype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameNagari* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameChongTong : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameChongTong();
  virtual ~GLAnsGameChongTong();
  
  GLAnsGameChongTong(const GLAnsGameChongTong& from);
  
  inline GLAnsGameChongTong& operator=(const GLAnsGameChongTong& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameChongTong& default_instance();
  
  void Swap(GLAnsGameChongTong* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameChongTong* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameChongTong& from);
  void MergeFrom(const GLAnsGameChongTong& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // repeated int32 lstCard = 3;
  inline int lstcard_size() const;
  inline void clear_lstcard();
  static const int kLstCardFieldNumber = 3;
  inline ::google::protobuf::int32 lstcard(int index) const;
  inline void set_lstcard(int index, ::google::protobuf::int32 value);
  inline void add_lstcard(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      lstcard() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_lstcard();
  
  // @@protoc_insertion_point(class_scope:GLAnsGameChongTong)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > lstcard_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameChongTong* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameSelectCard : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameSelectCard();
  virtual ~GLAnsGameSelectCard();
  
  GLAnsGameSelectCard(const GLAnsGameSelectCard& from);
  
  inline GLAnsGameSelectCard& operator=(const GLAnsGameSelectCard& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameSelectCard& default_instance();
  
  void Swap(GLAnsGameSelectCard* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameSelectCard* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameSelectCard& from);
  void MergeFrom(const GLAnsGameSelectCard& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // repeated int32 lstCard = 3;
  inline int lstcard_size() const;
  inline void clear_lstcard();
  static const int kLstCardFieldNumber = 3;
  inline ::google::protobuf::int32 lstcard(int index) const;
  inline void set_lstcard(int index, ::google::protobuf::int32 value);
  inline void add_lstcard(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      lstcard() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_lstcard();
  
  // @@protoc_insertion_point(class_scope:GLAnsGameSelectCard)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > lstcard_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameSelectCard* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameBonus : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameBonus();
  virtual ~GLAnsGameBonus();
  
  GLAnsGameBonus(const GLAnsGameBonus& from);
  
  inline GLAnsGameBonus& operator=(const GLAnsGameBonus& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameBonus& default_instance();
  
  void Swap(GLAnsGameBonus* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameBonus* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameBonus& from);
  void MergeFrom(const GLAnsGameBonus& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // required int32 nCard = 3;
  inline bool has_ncard() const;
  inline void clear_ncard();
  static const int kNCardFieldNumber = 3;
  inline ::google::protobuf::int32 ncard() const;
  inline void set_ncard(::google::protobuf::int32 value);
  
  // required int32 nCard2 = 4;
  inline bool has_ncard2() const;
  inline void clear_ncard2();
  static const int kNCard2FieldNumber = 4;
  inline ::google::protobuf::int32 ncard2() const;
  inline void set_ncard2(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:GLAnsGameBonus)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  inline void set_has_ncard();
  inline void clear_has_ncard();
  inline void set_has_ncard2();
  inline void clear_has_ncard2();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  ::google::protobuf::int32 ncard_;
  ::google::protobuf::int32 ncard2_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameBonus* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameTakePee : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameTakePee();
  virtual ~GLAnsGameTakePee();
  
  GLAnsGameTakePee(const GLAnsGameTakePee& from);
  
  inline GLAnsGameTakePee& operator=(const GLAnsGameTakePee& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameTakePee& default_instance();
  
  void Swap(GLAnsGameTakePee* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameTakePee* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameTakePee& from);
  void MergeFrom(const GLAnsGameTakePee& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // required int32 nCard = 3;
  inline bool has_ncard() const;
  inline void clear_ncard();
  static const int kNCardFieldNumber = 3;
  inline ::google::protobuf::int32 ncard() const;
  inline void set_ncard(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:GLAnsGameTakePee)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  inline void set_has_ncard();
  inline void clear_has_ncard();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  ::google::protobuf::int32 ncard_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameTakePee* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameBbuck : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameBbuck();
  virtual ~GLAnsGameBbuck();
  
  GLAnsGameBbuck(const GLAnsGameBbuck& from);
  
  inline GLAnsGameBbuck& operator=(const GLAnsGameBbuck& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameBbuck& default_instance();
  
  void Swap(GLAnsGameBbuck* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameBbuck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameBbuck& from);
  void MergeFrom(const GLAnsGameBbuck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // repeated int32 lstCard = 3;
  inline int lstcard_size() const;
  inline void clear_lstcard();
  static const int kLstCardFieldNumber = 3;
  inline ::google::protobuf::int32 lstcard(int index) const;
  inline void set_lstcard(int index, ::google::protobuf::int32 value);
  inline void add_lstcard(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      lstcard() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_lstcard();
  
  // required int32 nCnt = 4;
  inline bool has_ncnt() const;
  inline void clear_ncnt();
  static const int kNCntFieldNumber = 4;
  inline ::google::protobuf::int32 ncnt() const;
  inline void set_ncnt(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:GLAnsGameBbuck)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  inline void set_has_ncnt();
  inline void clear_has_ncnt();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > lstcard_;
  ::google::protobuf::int32 ncnt_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameBbuck* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameSeriseBbuck : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameSeriseBbuck();
  virtual ~GLAnsGameSeriseBbuck();
  
  GLAnsGameSeriseBbuck(const GLAnsGameSeriseBbuck& from);
  
  inline GLAnsGameSeriseBbuck& operator=(const GLAnsGameSeriseBbuck& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameSeriseBbuck& default_instance();
  
  void Swap(GLAnsGameSeriseBbuck* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameSeriseBbuck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameSeriseBbuck& from);
  void MergeFrom(const GLAnsGameSeriseBbuck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // repeated int32 lstCard = 3;
  inline int lstcard_size() const;
  inline void clear_lstcard();
  static const int kLstCardFieldNumber = 3;
  inline ::google::protobuf::int32 lstcard(int index) const;
  inline void set_lstcard(int index, ::google::protobuf::int32 value);
  inline void add_lstcard(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      lstcard() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_lstcard();
  
  // required int32 nCnt = 4;
  inline bool has_ncnt() const;
  inline void clear_ncnt();
  static const int kNCntFieldNumber = 4;
  inline ::google::protobuf::int32 ncnt() const;
  inline void set_ncnt(::google::protobuf::int32 value);
  
  // required string money = 5;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 5;
  inline const ::std::string& money() const;
  inline void set_money(const ::std::string& value);
  inline void set_money(const char* value);
  inline void set_money(const char* value, size_t size);
  inline ::std::string* mutable_money();
  inline ::std::string* release_money();
  
  // @@protoc_insertion_point(class_scope:GLAnsGameSeriseBbuck)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  inline void set_has_ncnt();
  inline void clear_has_ncnt();
  inline void set_has_money();
  inline void clear_has_money();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > lstcard_;
  ::std::string* money_;
  ::google::protobuf::int32 ncnt_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameSeriseBbuck* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameBbuckEat : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameBbuckEat();
  virtual ~GLAnsGameBbuckEat();
  
  GLAnsGameBbuckEat(const GLAnsGameBbuckEat& from);
  
  inline GLAnsGameBbuckEat& operator=(const GLAnsGameBbuckEat& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameBbuckEat& default_instance();
  
  void Swap(GLAnsGameBbuckEat* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameBbuckEat* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameBbuckEat& from);
  void MergeFrom(const GLAnsGameBbuckEat& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef GLAnsGameBbuckEat_CARD_TYPE CARD_TYPE;
  static const CARD_TYPE JANUARY = GLAnsGameBbuckEat_CARD_TYPE_JANUARY;
  static const CARD_TYPE FEBUARY = GLAnsGameBbuckEat_CARD_TYPE_FEBUARY;
  static const CARD_TYPE MARCH = GLAnsGameBbuckEat_CARD_TYPE_MARCH;
  static const CARD_TYPE APRIL = GLAnsGameBbuckEat_CARD_TYPE_APRIL;
  static const CARD_TYPE MAY = GLAnsGameBbuckEat_CARD_TYPE_MAY;
  static const CARD_TYPE JUNE = GLAnsGameBbuckEat_CARD_TYPE_JUNE;
  static const CARD_TYPE JULY = GLAnsGameBbuckEat_CARD_TYPE_JULY;
  static const CARD_TYPE AUGUST = GLAnsGameBbuckEat_CARD_TYPE_AUGUST;
  static const CARD_TYPE SEPTEMBER = GLAnsGameBbuckEat_CARD_TYPE_SEPTEMBER;
  static const CARD_TYPE OCTOBER = GLAnsGameBbuckEat_CARD_TYPE_OCTOBER;
  static const CARD_TYPE NOVEMBER = GLAnsGameBbuckEat_CARD_TYPE_NOVEMBER;
  static const CARD_TYPE DECEMBER = GLAnsGameBbuckEat_CARD_TYPE_DECEMBER;
  static const CARD_TYPE CARDTYPE_ZERO = GLAnsGameBbuckEat_CARD_TYPE_CARDTYPE_ZERO;
  static inline bool CARD_TYPE_IsValid(int value) {
    return GLAnsGameBbuckEat_CARD_TYPE_IsValid(value);
  }
  static const CARD_TYPE CARD_TYPE_MIN =
    GLAnsGameBbuckEat_CARD_TYPE_CARD_TYPE_MIN;
  static const CARD_TYPE CARD_TYPE_MAX =
    GLAnsGameBbuckEat_CARD_TYPE_CARD_TYPE_MAX;
  static const int CARD_TYPE_ARRAYSIZE =
    GLAnsGameBbuckEat_CARD_TYPE_CARD_TYPE_ARRAYSIZE;
  
  typedef GLAnsGameBbuckEat_BBUCK_TYPE BBUCK_TYPE;
  static const BBUCK_TYPE SELF_BBUCK = GLAnsGameBbuckEat_BBUCK_TYPE_SELF_BBUCK;
  static const BBUCK_TYPE YOU_BBUCK = GLAnsGameBbuckEat_BBUCK_TYPE_YOU_BBUCK;
  static const BBUCK_TYPE BBUCK_ZERO = GLAnsGameBbuckEat_BBUCK_TYPE_BBUCK_ZERO;
  static inline bool BBUCK_TYPE_IsValid(int value) {
    return GLAnsGameBbuckEat_BBUCK_TYPE_IsValid(value);
  }
  static const BBUCK_TYPE BBUCK_TYPE_MIN =
    GLAnsGameBbuckEat_BBUCK_TYPE_BBUCK_TYPE_MIN;
  static const BBUCK_TYPE BBUCK_TYPE_MAX =
    GLAnsGameBbuckEat_BBUCK_TYPE_BBUCK_TYPE_MAX;
  static const int BBUCK_TYPE_ARRAYSIZE =
    GLAnsGameBbuckEat_BBUCK_TYPE_BBUCK_TYPE_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // required .GLAnsGameBbuckEat.CARD_TYPE nCardType = 3;
  inline bool has_ncardtype() const;
  inline void clear_ncardtype();
  static const int kNCardTypeFieldNumber = 3;
  inline ::GLAnsGameBbuckEat_CARD_TYPE ncardtype() const;
  inline void set_ncardtype(::GLAnsGameBbuckEat_CARD_TYPE value);
  
  // required .GLAnsGameBbuckEat.BBUCK_TYPE nBBuckType = 4;
  inline bool has_nbbucktype() const;
  inline void clear_nbbucktype();
  static const int kNBBuckTypeFieldNumber = 4;
  inline ::GLAnsGameBbuckEat_BBUCK_TYPE nbbucktype() const;
  inline void set_nbbucktype(::GLAnsGameBbuckEat_BBUCK_TYPE value);
  
  // @@protoc_insertion_point(class_scope:GLAnsGameBbuckEat)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  inline void set_has_ncardtype();
  inline void clear_has_ncardtype();
  inline void set_has_nbbucktype();
  inline void clear_has_nbbucktype();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  int ncardtype_;
  int nbbucktype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameBbuckEat* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameBomb : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameBomb();
  virtual ~GLAnsGameBomb();
  
  GLAnsGameBomb(const GLAnsGameBomb& from);
  
  inline GLAnsGameBomb& operator=(const GLAnsGameBomb& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameBomb& default_instance();
  
  void Swap(GLAnsGameBomb* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameBomb* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameBomb& from);
  void MergeFrom(const GLAnsGameBomb& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef GLAnsGameBomb_CARD_TYPE CARD_TYPE;
  static const CARD_TYPE JANUARY = GLAnsGameBomb_CARD_TYPE_JANUARY;
  static const CARD_TYPE FEBUARY = GLAnsGameBomb_CARD_TYPE_FEBUARY;
  static const CARD_TYPE MARCH = GLAnsGameBomb_CARD_TYPE_MARCH;
  static const CARD_TYPE APRIL = GLAnsGameBomb_CARD_TYPE_APRIL;
  static const CARD_TYPE MAY = GLAnsGameBomb_CARD_TYPE_MAY;
  static const CARD_TYPE JUNE = GLAnsGameBomb_CARD_TYPE_JUNE;
  static const CARD_TYPE JULY = GLAnsGameBomb_CARD_TYPE_JULY;
  static const CARD_TYPE AUGUST = GLAnsGameBomb_CARD_TYPE_AUGUST;
  static const CARD_TYPE SEPTEMBER = GLAnsGameBomb_CARD_TYPE_SEPTEMBER;
  static const CARD_TYPE OCTOBER = GLAnsGameBomb_CARD_TYPE_OCTOBER;
  static const CARD_TYPE NOVEMBER = GLAnsGameBomb_CARD_TYPE_NOVEMBER;
  static const CARD_TYPE DECEMBER = GLAnsGameBomb_CARD_TYPE_DECEMBER;
  static const CARD_TYPE CARDTYPE_ZERO = GLAnsGameBomb_CARD_TYPE_CARDTYPE_ZERO;
  static inline bool CARD_TYPE_IsValid(int value) {
    return GLAnsGameBomb_CARD_TYPE_IsValid(value);
  }
  static const CARD_TYPE CARD_TYPE_MIN =
    GLAnsGameBomb_CARD_TYPE_CARD_TYPE_MIN;
  static const CARD_TYPE CARD_TYPE_MAX =
    GLAnsGameBomb_CARD_TYPE_CARD_TYPE_MAX;
  static const int CARD_TYPE_ARRAYSIZE =
    GLAnsGameBomb_CARD_TYPE_CARD_TYPE_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // required .GLAnsGameBomb.CARD_TYPE nCardType = 3;
  inline bool has_ncardtype() const;
  inline void clear_ncardtype();
  static const int kNCardTypeFieldNumber = 3;
  inline ::GLAnsGameBomb_CARD_TYPE ncardtype() const;
  inline void set_ncardtype(::GLAnsGameBomb_CARD_TYPE value);
  
  // required int32 nCnt = 4;
  inline bool has_ncnt() const;
  inline void clear_ncnt();
  static const int kNCntFieldNumber = 4;
  inline ::google::protobuf::int32 ncnt() const;
  inline void set_ncnt(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:GLAnsGameBomb)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  inline void set_has_ncardtype();
  inline void clear_has_ncardtype();
  inline void set_has_ncnt();
  inline void clear_has_ncnt();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  int ncardtype_;
  ::google::protobuf::int32 ncnt_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameBomb* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGamePan : public ::google::protobuf::MessageLite {
 public:
  GLAnsGamePan();
  virtual ~GLAnsGamePan();
  
  GLAnsGamePan(const GLAnsGamePan& from);
  
  inline GLAnsGamePan& operator=(const GLAnsGamePan& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGamePan& default_instance();
  
  void Swap(GLAnsGamePan* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGamePan* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGamePan& from);
  void MergeFrom(const GLAnsGamePan& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:GLAnsGamePan)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGamePan* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameDadak : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameDadak();
  virtual ~GLAnsGameDadak();
  
  GLAnsGameDadak(const GLAnsGameDadak& from);
  
  inline GLAnsGameDadak& operator=(const GLAnsGameDadak& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameDadak& default_instance();
  
  void Swap(GLAnsGameDadak* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameDadak* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameDadak& from);
  void MergeFrom(const GLAnsGameDadak& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef GLAnsGameDadak_CARD_TYPE CARD_TYPE;
  static const CARD_TYPE JANUARY = GLAnsGameDadak_CARD_TYPE_JANUARY;
  static const CARD_TYPE FEBUARY = GLAnsGameDadak_CARD_TYPE_FEBUARY;
  static const CARD_TYPE MARCH = GLAnsGameDadak_CARD_TYPE_MARCH;
  static const CARD_TYPE APRIL = GLAnsGameDadak_CARD_TYPE_APRIL;
  static const CARD_TYPE MAY = GLAnsGameDadak_CARD_TYPE_MAY;
  static const CARD_TYPE JUNE = GLAnsGameDadak_CARD_TYPE_JUNE;
  static const CARD_TYPE JULY = GLAnsGameDadak_CARD_TYPE_JULY;
  static const CARD_TYPE AUGUST = GLAnsGameDadak_CARD_TYPE_AUGUST;
  static const CARD_TYPE SEPTEMBER = GLAnsGameDadak_CARD_TYPE_SEPTEMBER;
  static const CARD_TYPE OCTOBER = GLAnsGameDadak_CARD_TYPE_OCTOBER;
  static const CARD_TYPE NOVEMBER = GLAnsGameDadak_CARD_TYPE_NOVEMBER;
  static const CARD_TYPE DECEMBER = GLAnsGameDadak_CARD_TYPE_DECEMBER;
  static const CARD_TYPE CARDTYPE_ZERO = GLAnsGameDadak_CARD_TYPE_CARDTYPE_ZERO;
  static inline bool CARD_TYPE_IsValid(int value) {
    return GLAnsGameDadak_CARD_TYPE_IsValid(value);
  }
  static const CARD_TYPE CARD_TYPE_MIN =
    GLAnsGameDadak_CARD_TYPE_CARD_TYPE_MIN;
  static const CARD_TYPE CARD_TYPE_MAX =
    GLAnsGameDadak_CARD_TYPE_CARD_TYPE_MAX;
  static const int CARD_TYPE_ARRAYSIZE =
    GLAnsGameDadak_CARD_TYPE_CARD_TYPE_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // required .GLAnsGameDadak.CARD_TYPE nCardType = 3;
  inline bool has_ncardtype() const;
  inline void clear_ncardtype();
  static const int kNCardTypeFieldNumber = 3;
  inline ::GLAnsGameDadak_CARD_TYPE ncardtype() const;
  inline void set_ncardtype(::GLAnsGameDadak_CARD_TYPE value);
  
  // @@protoc_insertion_point(class_scope:GLAnsGameDadak)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  inline void set_has_ncardtype();
  inline void clear_has_ncardtype();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  int ncardtype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameDadak* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameJjok : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameJjok();
  virtual ~GLAnsGameJjok();
  
  GLAnsGameJjok(const GLAnsGameJjok& from);
  
  inline GLAnsGameJjok& operator=(const GLAnsGameJjok& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameJjok& default_instance();
  
  void Swap(GLAnsGameJjok* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameJjok* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameJjok& from);
  void MergeFrom(const GLAnsGameJjok& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef GLAnsGameJjok_CARD_TYPE CARD_TYPE;
  static const CARD_TYPE JANUARY = GLAnsGameJjok_CARD_TYPE_JANUARY;
  static const CARD_TYPE FEBUARY = GLAnsGameJjok_CARD_TYPE_FEBUARY;
  static const CARD_TYPE MARCH = GLAnsGameJjok_CARD_TYPE_MARCH;
  static const CARD_TYPE APRIL = GLAnsGameJjok_CARD_TYPE_APRIL;
  static const CARD_TYPE MAY = GLAnsGameJjok_CARD_TYPE_MAY;
  static const CARD_TYPE JUNE = GLAnsGameJjok_CARD_TYPE_JUNE;
  static const CARD_TYPE JULY = GLAnsGameJjok_CARD_TYPE_JULY;
  static const CARD_TYPE AUGUST = GLAnsGameJjok_CARD_TYPE_AUGUST;
  static const CARD_TYPE SEPTEMBER = GLAnsGameJjok_CARD_TYPE_SEPTEMBER;
  static const CARD_TYPE OCTOBER = GLAnsGameJjok_CARD_TYPE_OCTOBER;
  static const CARD_TYPE NOVEMBER = GLAnsGameJjok_CARD_TYPE_NOVEMBER;
  static const CARD_TYPE DECEMBER = GLAnsGameJjok_CARD_TYPE_DECEMBER;
  static const CARD_TYPE CARDTYPE_ZERO = GLAnsGameJjok_CARD_TYPE_CARDTYPE_ZERO;
  static inline bool CARD_TYPE_IsValid(int value) {
    return GLAnsGameJjok_CARD_TYPE_IsValid(value);
  }
  static const CARD_TYPE CARD_TYPE_MIN =
    GLAnsGameJjok_CARD_TYPE_CARD_TYPE_MIN;
  static const CARD_TYPE CARD_TYPE_MAX =
    GLAnsGameJjok_CARD_TYPE_CARD_TYPE_MAX;
  static const int CARD_TYPE_ARRAYSIZE =
    GLAnsGameJjok_CARD_TYPE_CARD_TYPE_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // required .GLAnsGameJjok.CARD_TYPE nCardType = 3;
  inline bool has_ncardtype() const;
  inline void clear_ncardtype();
  static const int kNCardTypeFieldNumber = 3;
  inline ::GLAnsGameJjok_CARD_TYPE ncardtype() const;
  inline void set_ncardtype(::GLAnsGameJjok_CARD_TYPE value);
  
  // @@protoc_insertion_point(class_scope:GLAnsGameJjok)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  inline void set_has_ncardtype();
  inline void clear_has_ncardtype();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  int ncardtype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameJjok* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameUpset : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameUpset();
  virtual ~GLAnsGameUpset();
  
  GLAnsGameUpset(const GLAnsGameUpset& from);
  
  inline GLAnsGameUpset& operator=(const GLAnsGameUpset& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameUpset& default_instance();
  
  void Swap(GLAnsGameUpset* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameUpset* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameUpset& from);
  void MergeFrom(const GLAnsGameUpset& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // required int32 nCard = 3;
  inline bool has_ncard() const;
  inline void clear_ncard();
  static const int kNCardFieldNumber = 3;
  inline ::google::protobuf::int32 ncard() const;
  inline void set_ncard(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:GLAnsGameUpset)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  inline void set_has_ncard();
  inline void clear_has_ncard();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  ::google::protobuf::int32 ncard_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameUpset* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameAllEatUp : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameAllEatUp();
  virtual ~GLAnsGameAllEatUp();
  
  GLAnsGameAllEatUp(const GLAnsGameAllEatUp& from);
  
  inline GLAnsGameAllEatUp& operator=(const GLAnsGameAllEatUp& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameAllEatUp& default_instance();
  
  void Swap(GLAnsGameAllEatUp* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameAllEatUp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameAllEatUp& from);
  void MergeFrom(const GLAnsGameAllEatUp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // repeated int32 lstCard = 3;
  inline int lstcard_size() const;
  inline void clear_lstcard();
  static const int kLstCardFieldNumber = 3;
  inline ::google::protobuf::int32 lstcard(int index) const;
  inline void set_lstcard(int index, ::google::protobuf::int32 value);
  inline void add_lstcard(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      lstcard() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_lstcard();
  
  // @@protoc_insertion_point(class_scope:GLAnsGameAllEatUp)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > lstcard_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameAllEatUp* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameNotiTurn : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameNotiTurn();
  virtual ~GLAnsGameNotiTurn();
  
  GLAnsGameNotiTurn(const GLAnsGameNotiTurn& from);
  
  inline GLAnsGameNotiTurn& operator=(const GLAnsGameNotiTurn& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameNotiTurn& default_instance();
  
  void Swap(GLAnsGameNotiTurn* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameNotiTurn* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameNotiTurn& from);
  void MergeFrom(const GLAnsGameNotiTurn& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:GLAnsGameNotiTurn)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameNotiTurn* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameMoveTen : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameMoveTen();
  virtual ~GLAnsGameMoveTen();
  
  GLAnsGameMoveTen(const GLAnsGameMoveTen& from);
  
  inline GLAnsGameMoveTen& operator=(const GLAnsGameMoveTen& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameMoveTen& default_instance();
  
  void Swap(GLAnsGameMoveTen* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameMoveTen* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameMoveTen& from);
  void MergeFrom(const GLAnsGameMoveTen& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:GLAnsGameMoveTen)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameMoveTen* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameMoveTenAns : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameMoveTenAns();
  virtual ~GLAnsGameMoveTenAns();
  
  GLAnsGameMoveTenAns(const GLAnsGameMoveTenAns& from);
  
  inline GLAnsGameMoveTenAns& operator=(const GLAnsGameMoveTenAns& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameMoveTenAns& default_instance();
  
  void Swap(GLAnsGameMoveTenAns* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameMoveTenAns* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameMoveTenAns& from);
  void MergeFrom(const GLAnsGameMoveTenAns& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // required bool bMove = 3;
  inline bool has_bmove() const;
  inline void clear_bmove();
  static const int kBMoveFieldNumber = 3;
  inline bool bmove() const;
  inline void set_bmove(bool value);
  
  // @@protoc_insertion_point(class_scope:GLAnsGameMoveTenAns)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  inline void set_has_bmove();
  inline void clear_has_bmove();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  bool bmove_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameMoveTenAns* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameChoiceCard : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameChoiceCard();
  virtual ~GLAnsGameChoiceCard();
  
  GLAnsGameChoiceCard(const GLAnsGameChoiceCard& from);
  
  inline GLAnsGameChoiceCard& operator=(const GLAnsGameChoiceCard& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameChoiceCard& default_instance();
  
  void Swap(GLAnsGameChoiceCard* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameChoiceCard* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameChoiceCard& from);
  void MergeFrom(const GLAnsGameChoiceCard& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef GLAnsGameChoiceCard_Type Type;
  static const Type SELECT = GLAnsGameChoiceCard_Type_SELECT;
  static const Type UPSET = GLAnsGameChoiceCard_Type_UPSET;
  static inline bool Type_IsValid(int value) {
    return GLAnsGameChoiceCard_Type_IsValid(value);
  }
  static const Type Type_MIN =
    GLAnsGameChoiceCard_Type_Type_MIN;
  static const Type Type_MAX =
    GLAnsGameChoiceCard_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    GLAnsGameChoiceCard_Type_Type_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // repeated int32 lstCard = 3;
  inline int lstcard_size() const;
  inline void clear_lstcard();
  static const int kLstCardFieldNumber = 3;
  inline ::google::protobuf::int32 lstcard(int index) const;
  inline void set_lstcard(int index, ::google::protobuf::int32 value);
  inline void add_lstcard(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      lstcard() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_lstcard();
  
  // required .GLAnsGameChoiceCard.Type nType = 4;
  inline bool has_ntype() const;
  inline void clear_ntype();
  static const int kNTypeFieldNumber = 4;
  inline ::GLAnsGameChoiceCard_Type ntype() const;
  inline void set_ntype(::GLAnsGameChoiceCard_Type value);
  
  // @@protoc_insertion_point(class_scope:GLAnsGameChoiceCard)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  inline void set_has_ntype();
  inline void clear_has_ntype();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > lstcard_;
  int ntype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameChoiceCard* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameShake : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameShake();
  virtual ~GLAnsGameShake();
  
  GLAnsGameShake(const GLAnsGameShake& from);
  
  inline GLAnsGameShake& operator=(const GLAnsGameShake& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameShake& default_instance();
  
  void Swap(GLAnsGameShake* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameShake* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameShake& from);
  void MergeFrom(const GLAnsGameShake& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // repeated int32 lstCard = 3;
  inline int lstcard_size() const;
  inline void clear_lstcard();
  static const int kLstCardFieldNumber = 3;
  inline ::google::protobuf::int32 lstcard(int index) const;
  inline void set_lstcard(int index, ::google::protobuf::int32 value);
  inline void add_lstcard(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      lstcard() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_lstcard();
  
  // @@protoc_insertion_point(class_scope:GLAnsGameShake)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > lstcard_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameShake* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameShakeAns : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameShakeAns();
  virtual ~GLAnsGameShakeAns();
  
  GLAnsGameShakeAns(const GLAnsGameShakeAns& from);
  
  inline GLAnsGameShakeAns& operator=(const GLAnsGameShakeAns& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameShakeAns& default_instance();
  
  void Swap(GLAnsGameShakeAns* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameShakeAns* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameShakeAns& from);
  void MergeFrom(const GLAnsGameShakeAns& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // repeated int32 lstCard = 3;
  inline int lstcard_size() const;
  inline void clear_lstcard();
  static const int kLstCardFieldNumber = 3;
  inline ::google::protobuf::int32 lstcard(int index) const;
  inline void set_lstcard(int index, ::google::protobuf::int32 value);
  inline void add_lstcard(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      lstcard() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_lstcard();
  
  // required bool bShake = 4;
  inline bool has_bshake() const;
  inline void clear_bshake();
  static const int kBShakeFieldNumber = 4;
  inline bool bshake() const;
  inline void set_bshake(bool value);
  
  // @@protoc_insertion_point(class_scope:GLAnsGameShakeAns)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  inline void set_has_bshake();
  inline void clear_has_bshake();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > lstcard_;
  bool bshake_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameShakeAns* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameShakeCount : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameShakeCount();
  virtual ~GLAnsGameShakeCount();
  
  GLAnsGameShakeCount(const GLAnsGameShakeCount& from);
  
  inline GLAnsGameShakeCount& operator=(const GLAnsGameShakeCount& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameShakeCount& default_instance();
  
  void Swap(GLAnsGameShakeCount* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameShakeCount* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameShakeCount& from);
  void MergeFrom(const GLAnsGameShakeCount& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // required int32 nCnt = 3;
  inline bool has_ncnt() const;
  inline void clear_ncnt();
  static const int kNCntFieldNumber = 3;
  inline ::google::protobuf::int32 ncnt() const;
  inline void set_ncnt(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:GLAnsGameShakeCount)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  inline void set_has_ncnt();
  inline void clear_has_ncnt();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  ::google::protobuf::int32 ncnt_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameShakeCount* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameCapType : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameCapType();
  virtual ~GLAnsGameCapType();
  
  GLAnsGameCapType(const GLAnsGameCapType& from);
  
  inline GLAnsGameCapType& operator=(const GLAnsGameCapType& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameCapType& default_instance();
  
  void Swap(GLAnsGameCapType* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameCapType* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameCapType& from);
  void MergeFrom(const GLAnsGameCapType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef GLAnsGameCapType_CAP_TYPE CAP_TYPE;
  static const CAP_TYPE CAP_THREE = GLAnsGameCapType_CAP_TYPE_CAP_THREE;
  static const CAP_TYPE CAP_DEC = GLAnsGameCapType_CAP_TYPE_CAP_DEC;
  static const CAP_TYPE CAP_FOUR = GLAnsGameCapType_CAP_TYPE_CAP_FOUR;
  static const CAP_TYPE CAP_FIVE = GLAnsGameCapType_CAP_TYPE_CAP_FIVE;
  static const CAP_TYPE CAP_ZERO = GLAnsGameCapType_CAP_TYPE_CAP_ZERO;
  static inline bool CAP_TYPE_IsValid(int value) {
    return GLAnsGameCapType_CAP_TYPE_IsValid(value);
  }
  static const CAP_TYPE CAP_TYPE_MIN =
    GLAnsGameCapType_CAP_TYPE_CAP_TYPE_MIN;
  static const CAP_TYPE CAP_TYPE_MAX =
    GLAnsGameCapType_CAP_TYPE_CAP_TYPE_MAX;
  static const int CAP_TYPE_ARRAYSIZE =
    GLAnsGameCapType_CAP_TYPE_CAP_TYPE_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // required .GLAnsGameCapType.CAP_TYPE nType = 3;
  inline bool has_ntype() const;
  inline void clear_ntype();
  static const int kNTypeFieldNumber = 3;
  inline ::GLAnsGameCapType_CAP_TYPE ntype() const;
  inline void set_ntype(::GLAnsGameCapType_CAP_TYPE value);
  
  // @@protoc_insertion_point(class_scope:GLAnsGameCapType)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  inline void set_has_ntype();
  inline void clear_has_ntype();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  int ntype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameCapType* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameGodori : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameGodori();
  virtual ~GLAnsGameGodori();
  
  GLAnsGameGodori(const GLAnsGameGodori& from);
  
  inline GLAnsGameGodori& operator=(const GLAnsGameGodori& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameGodori& default_instance();
  
  void Swap(GLAnsGameGodori* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameGodori* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameGodori& from);
  void MergeFrom(const GLAnsGameGodori& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef GLAnsGameGodori_JOKBO_STATE JOKBO_STATE;
  static const JOKBO_STATE JOKBO_WARNNING = GLAnsGameGodori_JOKBO_STATE_JOKBO_WARNNING;
  static const JOKBO_STATE JOKBO_COMPLETE = GLAnsGameGodori_JOKBO_STATE_JOKBO_COMPLETE;
  static const JOKBO_STATE JOKBO_FAIL = GLAnsGameGodori_JOKBO_STATE_JOKBO_FAIL;
  static const JOKBO_STATE JOKBO_ZERO = GLAnsGameGodori_JOKBO_STATE_JOKBO_ZERO;
  static inline bool JOKBO_STATE_IsValid(int value) {
    return GLAnsGameGodori_JOKBO_STATE_IsValid(value);
  }
  static const JOKBO_STATE JOKBO_STATE_MIN =
    GLAnsGameGodori_JOKBO_STATE_JOKBO_STATE_MIN;
  static const JOKBO_STATE JOKBO_STATE_MAX =
    GLAnsGameGodori_JOKBO_STATE_JOKBO_STATE_MAX;
  static const int JOKBO_STATE_ARRAYSIZE =
    GLAnsGameGodori_JOKBO_STATE_JOKBO_STATE_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // required .GLAnsGameGodori.JOKBO_STATE nType = 3;
  inline bool has_ntype() const;
  inline void clear_ntype();
  static const int kNTypeFieldNumber = 3;
  inline ::GLAnsGameGodori_JOKBO_STATE ntype() const;
  inline void set_ntype(::GLAnsGameGodori_JOKBO_STATE value);
  
  // @@protoc_insertion_point(class_scope:GLAnsGameGodori)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  inline void set_has_ntype();
  inline void clear_has_ntype();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  int ntype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameGodori* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameKusa : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameKusa();
  virtual ~GLAnsGameKusa();
  
  GLAnsGameKusa(const GLAnsGameKusa& from);
  
  inline GLAnsGameKusa& operator=(const GLAnsGameKusa& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameKusa& default_instance();
  
  void Swap(GLAnsGameKusa* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameKusa* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameKusa& from);
  void MergeFrom(const GLAnsGameKusa& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef GLAnsGameKusa_JOKBO_STATE JOKBO_STATE;
  static const JOKBO_STATE JOKBO_WARNNING = GLAnsGameKusa_JOKBO_STATE_JOKBO_WARNNING;
  static const JOKBO_STATE JOKBO_COMPLETE = GLAnsGameKusa_JOKBO_STATE_JOKBO_COMPLETE;
  static const JOKBO_STATE JOKBO_FAIL = GLAnsGameKusa_JOKBO_STATE_JOKBO_FAIL;
  static const JOKBO_STATE JOKBO_ZERO = GLAnsGameKusa_JOKBO_STATE_JOKBO_ZERO;
  static inline bool JOKBO_STATE_IsValid(int value) {
    return GLAnsGameKusa_JOKBO_STATE_IsValid(value);
  }
  static const JOKBO_STATE JOKBO_STATE_MIN =
    GLAnsGameKusa_JOKBO_STATE_JOKBO_STATE_MIN;
  static const JOKBO_STATE JOKBO_STATE_MAX =
    GLAnsGameKusa_JOKBO_STATE_JOKBO_STATE_MAX;
  static const int JOKBO_STATE_ARRAYSIZE =
    GLAnsGameKusa_JOKBO_STATE_JOKBO_STATE_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // required .GLAnsGameKusa.JOKBO_STATE nType = 3;
  inline bool has_ntype() const;
  inline void clear_ntype();
  static const int kNTypeFieldNumber = 3;
  inline ::GLAnsGameKusa_JOKBO_STATE ntype() const;
  inline void set_ntype(::GLAnsGameKusa_JOKBO_STATE value);
  
  // @@protoc_insertion_point(class_scope:GLAnsGameKusa)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  inline void set_has_ntype();
  inline void clear_has_ntype();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  int ntype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameKusa* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameRed : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameRed();
  virtual ~GLAnsGameRed();
  
  GLAnsGameRed(const GLAnsGameRed& from);
  
  inline GLAnsGameRed& operator=(const GLAnsGameRed& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameRed& default_instance();
  
  void Swap(GLAnsGameRed* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameRed* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameRed& from);
  void MergeFrom(const GLAnsGameRed& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef GLAnsGameRed_JOKBO_STATE JOKBO_STATE;
  static const JOKBO_STATE JOKBO_WARNNING = GLAnsGameRed_JOKBO_STATE_JOKBO_WARNNING;
  static const JOKBO_STATE JOKBO_COMPLETE = GLAnsGameRed_JOKBO_STATE_JOKBO_COMPLETE;
  static const JOKBO_STATE JOKBO_FAIL = GLAnsGameRed_JOKBO_STATE_JOKBO_FAIL;
  static const JOKBO_STATE JOKBO_ZERO = GLAnsGameRed_JOKBO_STATE_JOKBO_ZERO;
  static inline bool JOKBO_STATE_IsValid(int value) {
    return GLAnsGameRed_JOKBO_STATE_IsValid(value);
  }
  static const JOKBO_STATE JOKBO_STATE_MIN =
    GLAnsGameRed_JOKBO_STATE_JOKBO_STATE_MIN;
  static const JOKBO_STATE JOKBO_STATE_MAX =
    GLAnsGameRed_JOKBO_STATE_JOKBO_STATE_MAX;
  static const int JOKBO_STATE_ARRAYSIZE =
    GLAnsGameRed_JOKBO_STATE_JOKBO_STATE_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // required .GLAnsGameRed.JOKBO_STATE nType = 3;
  inline bool has_ntype() const;
  inline void clear_ntype();
  static const int kNTypeFieldNumber = 3;
  inline ::GLAnsGameRed_JOKBO_STATE ntype() const;
  inline void set_ntype(::GLAnsGameRed_JOKBO_STATE value);
  
  // @@protoc_insertion_point(class_scope:GLAnsGameRed)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  inline void set_has_ntype();
  inline void clear_has_ntype();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  int ntype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameRed* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameBlue : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameBlue();
  virtual ~GLAnsGameBlue();
  
  GLAnsGameBlue(const GLAnsGameBlue& from);
  
  inline GLAnsGameBlue& operator=(const GLAnsGameBlue& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameBlue& default_instance();
  
  void Swap(GLAnsGameBlue* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameBlue* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameBlue& from);
  void MergeFrom(const GLAnsGameBlue& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef GLAnsGameBlue_JOKBO_STATE JOKBO_STATE;
  static const JOKBO_STATE JOKBO_WARNNING = GLAnsGameBlue_JOKBO_STATE_JOKBO_WARNNING;
  static const JOKBO_STATE JOKBO_COMPLETE = GLAnsGameBlue_JOKBO_STATE_JOKBO_COMPLETE;
  static const JOKBO_STATE JOKBO_FAIL = GLAnsGameBlue_JOKBO_STATE_JOKBO_FAIL;
  static const JOKBO_STATE JOKBO_ZERO = GLAnsGameBlue_JOKBO_STATE_JOKBO_ZERO;
  static inline bool JOKBO_STATE_IsValid(int value) {
    return GLAnsGameBlue_JOKBO_STATE_IsValid(value);
  }
  static const JOKBO_STATE JOKBO_STATE_MIN =
    GLAnsGameBlue_JOKBO_STATE_JOKBO_STATE_MIN;
  static const JOKBO_STATE JOKBO_STATE_MAX =
    GLAnsGameBlue_JOKBO_STATE_JOKBO_STATE_MAX;
  static const int JOKBO_STATE_ARRAYSIZE =
    GLAnsGameBlue_JOKBO_STATE_JOKBO_STATE_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // required .GLAnsGameBlue.JOKBO_STATE nType = 3;
  inline bool has_ntype() const;
  inline void clear_ntype();
  static const int kNTypeFieldNumber = 3;
  inline ::GLAnsGameBlue_JOKBO_STATE ntype() const;
  inline void set_ntype(::GLAnsGameBlue_JOKBO_STATE value);
  
  // @@protoc_insertion_point(class_scope:GLAnsGameBlue)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  inline void set_has_ntype();
  inline void clear_has_ntype();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  int ntype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameBlue* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameBak : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameBak();
  virtual ~GLAnsGameBak();
  
  GLAnsGameBak(const GLAnsGameBak& from);
  
  inline GLAnsGameBak& operator=(const GLAnsGameBak& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameBak& default_instance();
  
  void Swap(GLAnsGameBak* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameBak* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameBak& from);
  void MergeFrom(const GLAnsGameBak& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef GLAnsGameBak_BAK_TYPE BAK_TYPE;
  static const BAK_TYPE CAPBAK = GLAnsGameBak_BAK_TYPE_CAPBAK;
  static const BAK_TYPE ONEBAK = GLAnsGameBak_BAK_TYPE_ONEBAK;
  static const BAK_TYPE GOBAK = GLAnsGameBak_BAK_TYPE_GOBAK;
  static const BAK_TYPE MUNGBAK = GLAnsGameBak_BAK_TYPE_MUNGBAK;
  static const BAK_TYPE BAK_CANCEL = GLAnsGameBak_BAK_TYPE_BAK_CANCEL;
  static const BAK_TYPE BAK_ZERO = GLAnsGameBak_BAK_TYPE_BAK_ZERO;
  static inline bool BAK_TYPE_IsValid(int value) {
    return GLAnsGameBak_BAK_TYPE_IsValid(value);
  }
  static const BAK_TYPE BAK_TYPE_MIN =
    GLAnsGameBak_BAK_TYPE_BAK_TYPE_MIN;
  static const BAK_TYPE BAK_TYPE_MAX =
    GLAnsGameBak_BAK_TYPE_BAK_TYPE_MAX;
  static const int BAK_TYPE_ARRAYSIZE =
    GLAnsGameBak_BAK_TYPE_BAK_TYPE_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // required .GLAnsGameBak.BAK_TYPE nType = 3;
  inline bool has_ntype() const;
  inline void clear_ntype();
  static const int kNTypeFieldNumber = 3;
  inline ::GLAnsGameBak_BAK_TYPE ntype() const;
  inline void set_ntype(::GLAnsGameBak_BAK_TYPE value);
  
  // @@protoc_insertion_point(class_scope:GLAnsGameBak)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  inline void set_has_ntype();
  inline void clear_has_ntype();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  int ntype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameBak* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameBakFail : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameBakFail();
  virtual ~GLAnsGameBakFail();
  
  GLAnsGameBakFail(const GLAnsGameBakFail& from);
  
  inline GLAnsGameBakFail& operator=(const GLAnsGameBakFail& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameBakFail& default_instance();
  
  void Swap(GLAnsGameBakFail* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameBakFail* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameBakFail& from);
  void MergeFrom(const GLAnsGameBakFail& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef GLAnsGameBakFail_BAK_TYPE BAK_TYPE;
  static const BAK_TYPE CAPBAK = GLAnsGameBakFail_BAK_TYPE_CAPBAK;
  static const BAK_TYPE ONEBAK = GLAnsGameBakFail_BAK_TYPE_ONEBAK;
  static const BAK_TYPE GOBAK = GLAnsGameBakFail_BAK_TYPE_GOBAK;
  static const BAK_TYPE MUNGBAK = GLAnsGameBakFail_BAK_TYPE_MUNGBAK;
  static const BAK_TYPE BAK_CANCEL = GLAnsGameBakFail_BAK_TYPE_BAK_CANCEL;
  static const BAK_TYPE BAK_ZERO = GLAnsGameBakFail_BAK_TYPE_BAK_ZERO;
  static inline bool BAK_TYPE_IsValid(int value) {
    return GLAnsGameBakFail_BAK_TYPE_IsValid(value);
  }
  static const BAK_TYPE BAK_TYPE_MIN =
    GLAnsGameBakFail_BAK_TYPE_BAK_TYPE_MIN;
  static const BAK_TYPE BAK_TYPE_MAX =
    GLAnsGameBakFail_BAK_TYPE_BAK_TYPE_MAX;
  static const int BAK_TYPE_ARRAYSIZE =
    GLAnsGameBakFail_BAK_TYPE_BAK_TYPE_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // required .GLAnsGameBakFail.BAK_TYPE nType = 3;
  inline bool has_ntype() const;
  inline void clear_ntype();
  static const int kNTypeFieldNumber = 3;
  inline ::GLAnsGameBakFail_BAK_TYPE ntype() const;
  inline void set_ntype(::GLAnsGameBakFail_BAK_TYPE value);
  
  // @@protoc_insertion_point(class_scope:GLAnsGameBakFail)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  inline void set_has_ntype();
  inline void clear_has_ntype();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  int ntype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameBakFail* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameNotiMission : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameNotiMission();
  virtual ~GLAnsGameNotiMission();
  
  GLAnsGameNotiMission(const GLAnsGameNotiMission& from);
  
  inline GLAnsGameNotiMission& operator=(const GLAnsGameNotiMission& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameNotiMission& default_instance();
  
  void Swap(GLAnsGameNotiMission* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameNotiMission* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameNotiMission& from);
  void MergeFrom(const GLAnsGameNotiMission& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef GLAnsGameNotiMission_MISSION_TYPE MISSION_TYPE;
  static const MISSION_TYPE CARD = GLAnsGameNotiMission_MISSION_TYPE_CARD;
  static const MISSION_TYPE NONE = GLAnsGameNotiMission_MISSION_TYPE_NONE;
  static const MISSION_TYPE UNCONDITION = GLAnsGameNotiMission_MISSION_TYPE_UNCONDITION;
  static const MISSION_TYPE TWOBBUCK = GLAnsGameNotiMission_MISSION_TYPE_TWOBBUCK;
  static const MISSION_TYPE kMI_TWO_38 = GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_38;
  static const MISSION_TYPE kMI_TWO_13 = GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_13;
  static const MISSION_TYPE kMI_TWO_18 = GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_18;
  static const MISSION_TYPE kMI_TWO_ali_15 = GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_ali_15;
  static const MISSION_TYPE kMI_TWO_ali_16 = GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_ali_16;
  static const MISSION_TYPE kMI_TWO_ali_25 = GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_ali_25;
  static const MISSION_TYPE kMI_TWO_ali_26 = GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_ali_26;
  static const MISSION_TYPE kMI_TWO_doksa_113 = GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_doksa_113;
  static const MISSION_TYPE kMI_TWO_doksa_114 = GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_doksa_114;
  static const MISSION_TYPE kMI_TWO_doksa_213 = GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_doksa_213;
  static const MISSION_TYPE kMI_TWO_doksa_214 = GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_doksa_214;
  static const MISSION_TYPE kMI_TWO_kubbing_133 = GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_kubbing_133;
  static const MISSION_TYPE kMI_TWO_kubbing_134 = GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_kubbing_134;
  static const MISSION_TYPE kMI_TWO_kubbing_233 = GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_kubbing_233;
  static const MISSION_TYPE kMI_TWO_kubbing_234 = GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_kubbing_234;
  static const MISSION_TYPE kMI_TWO_jangbbing_137 = GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_jangbbing_137;
  static const MISSION_TYPE kMI_TWO_jangbbing_138 = GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_jangbbing_138;
  static const MISSION_TYPE kMI_TWO_jangbbing_237 = GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_jangbbing_237;
  static const MISSION_TYPE kMI_TWO_jangbbing_238 = GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_jangbbing_238;
  static const MISSION_TYPE kMI_TWO_jangsa_3713 = GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_jangsa_3713;
  static const MISSION_TYPE kMI_TWO_jangsa_3814 = GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_jangsa_3814;
  static const MISSION_TYPE kMI_TWO_jangsa_3714 = GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_jangsa_3714;
  static const MISSION_TYPE kMI_TWO_jangsa_3813 = GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_jangsa_3813;
  static const MISSION_TYPE kMI_TWO_seroulk_1321 = GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_seroulk_1321;
  static const MISSION_TYPE kMI_TWO_seroulk_1422 = GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_seroulk_1422;
  static const MISSION_TYPE kMI_TWO_seroulk_1322 = GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_seroulk_1322;
  static const MISSION_TYPE kMI_TWO_seroulk_1421 = GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_seroulk_1421;
  static const MISSION_TYPE kMI_TWO_47 = GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_47;
  static const MISSION_TYPE kMI_TWO_37 = GLAnsGameNotiMission_MISSION_TYPE_kMI_TWO_37;
  static const MISSION_TYPE kMI_THREE_godori = GLAnsGameNotiMission_MISSION_TYPE_kMI_THREE_godori;
  static const MISSION_TYPE kMI_THREE_blue = GLAnsGameNotiMission_MISSION_TYPE_kMI_THREE_blue;
  static const MISSION_TYPE kMI_THREE_red = GLAnsGameNotiMission_MISSION_TYPE_kMI_THREE_red;
  static const MISSION_TYPE kMI_THREE_cho = GLAnsGameNotiMission_MISSION_TYPE_kMI_THREE_cho;
  static const MISSION_TYPE kMI_THREE_1_3_8 = GLAnsGameNotiMission_MISSION_TYPE_kMI_THREE_1_3_8;
  static const MISSION_TYPE kMI_THREE_1_11_12 = GLAnsGameNotiMission_MISSION_TYPE_kMI_THREE_1_11_12;
  static const MISSION_TYPE kMI_THREE_3_8_12 = GLAnsGameNotiMission_MISSION_TYPE_kMI_THREE_3_8_12;
  static const MISSION_TYPE kMI_THREE_1_3_11 = GLAnsGameNotiMission_MISSION_TYPE_kMI_THREE_1_3_11;
  static const MISSION_TYPE kMI_THREE_8_11_12 = GLAnsGameNotiMission_MISSION_TYPE_kMI_THREE_8_11_12;
  static const MISSION_TYPE kMI_MONTH_1 = GLAnsGameNotiMission_MISSION_TYPE_kMI_MONTH_1;
  static const MISSION_TYPE kMI_MONTH_2 = GLAnsGameNotiMission_MISSION_TYPE_kMI_MONTH_2;
  static const MISSION_TYPE kMI_MONTH_3 = GLAnsGameNotiMission_MISSION_TYPE_kMI_MONTH_3;
  static const MISSION_TYPE kMI_MONTH_4 = GLAnsGameNotiMission_MISSION_TYPE_kMI_MONTH_4;
  static const MISSION_TYPE kMI_MONTH_5 = GLAnsGameNotiMission_MISSION_TYPE_kMI_MONTH_5;
  static const MISSION_TYPE kMI_MONTH_6 = GLAnsGameNotiMission_MISSION_TYPE_kMI_MONTH_6;
  static const MISSION_TYPE kMI_MONTH_7 = GLAnsGameNotiMission_MISSION_TYPE_kMI_MONTH_7;
  static const MISSION_TYPE kMI_MONTH_8 = GLAnsGameNotiMission_MISSION_TYPE_kMI_MONTH_8;
  static const MISSION_TYPE kMI_MONTH_9 = GLAnsGameNotiMission_MISSION_TYPE_kMI_MONTH_9;
  static const MISSION_TYPE kMI_MONTH_10 = GLAnsGameNotiMission_MISSION_TYPE_kMI_MONTH_10;
  static const MISSION_TYPE kMI_MONTH_11 = GLAnsGameNotiMission_MISSION_TYPE_kMI_MONTH_11;
  static const MISSION_TYPE kMI_MONTH_12 = GLAnsGameNotiMission_MISSION_TYPE_kMI_MONTH_12;
  static const MISSION_TYPE MISSION_ZERO = GLAnsGameNotiMission_MISSION_TYPE_MISSION_ZERO;
  static inline bool MISSION_TYPE_IsValid(int value) {
    return GLAnsGameNotiMission_MISSION_TYPE_IsValid(value);
  }
  static const MISSION_TYPE MISSION_TYPE_MIN =
    GLAnsGameNotiMission_MISSION_TYPE_MISSION_TYPE_MIN;
  static const MISSION_TYPE MISSION_TYPE_MAX =
    GLAnsGameNotiMission_MISSION_TYPE_MISSION_TYPE_MAX;
  static const int MISSION_TYPE_ARRAYSIZE =
    GLAnsGameNotiMission_MISSION_TYPE_MISSION_TYPE_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required int32 nMulNum = 1;
  inline bool has_nmulnum() const;
  inline void clear_nmulnum();
  static const int kNMulNumFieldNumber = 1;
  inline ::google::protobuf::int32 nmulnum() const;
  inline void set_nmulnum(::google::protobuf::int32 value);
  
  // repeated int32 lstCard = 2;
  inline int lstcard_size() const;
  inline void clear_lstcard();
  static const int kLstCardFieldNumber = 2;
  inline ::google::protobuf::int32 lstcard(int index) const;
  inline void set_lstcard(int index, ::google::protobuf::int32 value);
  inline void add_lstcard(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      lstcard() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_lstcard();
  
  // required string title = 3;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 3;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  
  // required .GLAnsGameNotiMission.MISSION_TYPE nType = 4;
  inline bool has_ntype() const;
  inline void clear_ntype();
  static const int kNTypeFieldNumber = 4;
  inline ::GLAnsGameNotiMission_MISSION_TYPE ntype() const;
  inline void set_ntype(::GLAnsGameNotiMission_MISSION_TYPE value);
  
  // @@protoc_insertion_point(class_scope:GLAnsGameNotiMission)
 private:
  inline void set_has_nmulnum();
  inline void clear_has_nmulnum();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_ntype();
  inline void clear_has_ntype();
  
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > lstcard_;
  ::google::protobuf::int32 nmulnum_;
  int ntype_;
  ::std::string* title_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameNotiMission* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameNotiMissionCard : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameNotiMissionCard();
  virtual ~GLAnsGameNotiMissionCard();
  
  GLAnsGameNotiMissionCard(const GLAnsGameNotiMissionCard& from);
  
  inline GLAnsGameNotiMissionCard& operator=(const GLAnsGameNotiMissionCard& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameNotiMissionCard& default_instance();
  
  void Swap(GLAnsGameNotiMissionCard* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameNotiMissionCard* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameNotiMissionCard& from);
  void MergeFrom(const GLAnsGameNotiMissionCard& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // repeated int32 lstCard = 3;
  inline int lstcard_size() const;
  inline void clear_lstcard();
  static const int kLstCardFieldNumber = 3;
  inline ::google::protobuf::int32 lstcard(int index) const;
  inline void set_lstcard(int index, ::google::protobuf::int32 value);
  inline void add_lstcard(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      lstcard() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_lstcard();
  
  // @@protoc_insertion_point(class_scope:GLAnsGameNotiMissionCard)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > lstcard_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameNotiMissionCard* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameMissionState : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameMissionState();
  virtual ~GLAnsGameMissionState();
  
  GLAnsGameMissionState(const GLAnsGameMissionState& from);
  
  inline GLAnsGameMissionState& operator=(const GLAnsGameMissionState& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameMissionState& default_instance();
  
  void Swap(GLAnsGameMissionState* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameMissionState* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameMissionState& from);
  void MergeFrom(const GLAnsGameMissionState& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef GLAnsGameMissionState_MISSION_STATE MISSION_STATE;
  static const MISSION_STATE FAIL = GLAnsGameMissionState_MISSION_STATE_FAIL;
  static const MISSION_STATE SUCCESS = GLAnsGameMissionState_MISSION_STATE_SUCCESS;
  static const MISSION_STATE STATE_ZERO = GLAnsGameMissionState_MISSION_STATE_STATE_ZERO;
  static inline bool MISSION_STATE_IsValid(int value) {
    return GLAnsGameMissionState_MISSION_STATE_IsValid(value);
  }
  static const MISSION_STATE MISSION_STATE_MIN =
    GLAnsGameMissionState_MISSION_STATE_MISSION_STATE_MIN;
  static const MISSION_STATE MISSION_STATE_MAX =
    GLAnsGameMissionState_MISSION_STATE_MISSION_STATE_MAX;
  static const int MISSION_STATE_ARRAYSIZE =
    GLAnsGameMissionState_MISSION_STATE_MISSION_STATE_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // required string money = 3;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 3;
  inline const ::std::string& money() const;
  inline void set_money(const ::std::string& value);
  inline void set_money(const char* value);
  inline void set_money(const char* value, size_t size);
  inline ::std::string* mutable_money();
  inline ::std::string* release_money();
  
  // required .GLAnsGameMissionState.MISSION_STATE nType = 4;
  inline bool has_ntype() const;
  inline void clear_ntype();
  static const int kNTypeFieldNumber = 4;
  inline ::GLAnsGameMissionState_MISSION_STATE ntype() const;
  inline void set_ntype(::GLAnsGameMissionState_MISSION_STATE value);
  
  // @@protoc_insertion_point(class_scope:GLAnsGameMissionState)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_ntype();
  inline void clear_has_ntype();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  ::std::string* money_;
  int ntype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameMissionState* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameGostop : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameGostop();
  virtual ~GLAnsGameGostop();
  
  GLAnsGameGostop(const GLAnsGameGostop& from);
  
  inline GLAnsGameGostop& operator=(const GLAnsGameGostop& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameGostop& default_instance();
  
  void Swap(GLAnsGameGostop* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameGostop* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameGostop& from);
  void MergeFrom(const GLAnsGameGostop& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // required int32 nCnt = 3;
  inline bool has_ncnt() const;
  inline void clear_ncnt();
  static const int kNCntFieldNumber = 3;
  inline ::google::protobuf::int32 ncnt() const;
  inline void set_ncnt(::google::protobuf::int32 value);
  
  // required string money = 4;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 4;
  inline const ::std::string& money() const;
  inline void set_money(const ::std::string& value);
  inline void set_money(const char* value);
  inline void set_money(const char* value, size_t size);
  inline ::std::string* mutable_money();
  inline ::std::string* release_money();
  
  // @@protoc_insertion_point(class_scope:GLAnsGameGostop)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  inline void set_has_ncnt();
  inline void clear_has_ncnt();
  inline void set_has_money();
  inline void clear_has_money();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  ::std::string* money_;
  ::google::protobuf::int32 ncnt_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameGostop* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameGostopAns : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameGostopAns();
  virtual ~GLAnsGameGostopAns();
  
  GLAnsGameGostopAns(const GLAnsGameGostopAns& from);
  
  inline GLAnsGameGostopAns& operator=(const GLAnsGameGostopAns& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameGostopAns& default_instance();
  
  void Swap(GLAnsGameGostopAns* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameGostopAns* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameGostopAns& from);
  void MergeFrom(const GLAnsGameGostopAns& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // required int32 nCnt = 3;
  inline bool has_ncnt() const;
  inline void clear_ncnt();
  static const int kNCntFieldNumber = 3;
  inline ::google::protobuf::int32 ncnt() const;
  inline void set_ncnt(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:GLAnsGameGostopAns)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  inline void set_has_ncnt();
  inline void clear_has_ncnt();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  ::google::protobuf::int32 ncnt_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameGostopAns* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameStopAns : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameStopAns();
  virtual ~GLAnsGameStopAns();
  
  GLAnsGameStopAns(const GLAnsGameStopAns& from);
  
  inline GLAnsGameStopAns& operator=(const GLAnsGameStopAns& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameStopAns& default_instance();
  
  void Swap(GLAnsGameStopAns* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameStopAns* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameStopAns& from);
  void MergeFrom(const GLAnsGameStopAns& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:GLAnsGameStopAns)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameStopAns* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameResult : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameResult();
  virtual ~GLAnsGameResult();
  
  GLAnsGameResult(const GLAnsGameResult& from);
  
  inline GLAnsGameResult& operator=(const GLAnsGameResult& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameResult& default_instance();
  
  void Swap(GLAnsGameResult* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameResult* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameResult& from);
  void MergeFrom(const GLAnsGameResult& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef GLAnsGameResult_GAME_RESULT_TYPE GAME_RESULT_TYPE;
  static const GAME_RESULT_TYPE RESULT_NORMAL = GLAnsGameResult_GAME_RESULT_TYPE_RESULT_NORMAL;
  static const GAME_RESULT_TYPE RESULT_3BBUK = GLAnsGameResult_GAME_RESULT_TYPE_RESULT_3BBUK;
  static const GAME_RESULT_TYPE RESULT_CHONGTONG = GLAnsGameResult_GAME_RESULT_TYPE_RESULT_CHONGTONG;
  static const GAME_RESULT_TYPE RESULT_NAGARI = GLAnsGameResult_GAME_RESULT_TYPE_RESULT_NAGARI;
  static const GAME_RESULT_TYPE RESULT_ZERO = GLAnsGameResult_GAME_RESULT_TYPE_RESULT_ZERO;
  static inline bool GAME_RESULT_TYPE_IsValid(int value) {
    return GLAnsGameResult_GAME_RESULT_TYPE_IsValid(value);
  }
  static const GAME_RESULT_TYPE GAME_RESULT_TYPE_MIN =
    GLAnsGameResult_GAME_RESULT_TYPE_GAME_RESULT_TYPE_MIN;
  static const GAME_RESULT_TYPE GAME_RESULT_TYPE_MAX =
    GLAnsGameResult_GAME_RESULT_TYPE_GAME_RESULT_TYPE_MAX;
  static const int GAME_RESULT_TYPE_ARRAYSIZE =
    GLAnsGameResult_GAME_RESULT_TYPE_GAME_RESULT_TYPE_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // repeated int32 level = 3;
  inline int level_size() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 3;
  inline ::google::protobuf::int32 level(int index) const;
  inline void set_level(int index, ::google::protobuf::int32 value);
  inline void add_level(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      level() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_level();
  
  // required string money = 4;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 4;
  inline const ::std::string& money() const;
  inline void set_money(const ::std::string& value);
  inline void set_money(const char* value);
  inline void set_money(const char* value, size_t size);
  inline ::std::string* mutable_money();
  inline ::std::string* release_money();
  
  // required int32 dealPoint = 5;
  inline bool has_dealpoint() const;
  inline void clear_dealpoint();
  static const int kDealPointFieldNumber = 5;
  inline ::google::protobuf::int32 dealpoint() const;
  inline void set_dealpoint(::google::protobuf::int32 value);
  
  // required int32 capPoint = 6;
  inline bool has_cappoint() const;
  inline void clear_cappoint();
  static const int kCapPointFieldNumber = 6;
  inline ::google::protobuf::int32 cappoint() const;
  inline void set_cappoint(::google::protobuf::int32 value);
  
  // required int32 tenPoint = 7;
  inline bool has_tenpoint() const;
  inline void clear_tenpoint();
  static const int kTenPointFieldNumber = 7;
  inline ::google::protobuf::int32 tenpoint() const;
  inline void set_tenpoint(::google::protobuf::int32 value);
  
  // required int32 fivePoint = 8;
  inline bool has_fivepoint() const;
  inline void clear_fivepoint();
  static const int kFivePointFieldNumber = 8;
  inline ::google::protobuf::int32 fivepoint() const;
  inline void set_fivepoint(::google::protobuf::int32 value);
  
  // required int32 onePoint = 9;
  inline bool has_onepoint() const;
  inline void clear_onepoint();
  static const int kOnePointFieldNumber = 9;
  inline ::google::protobuf::int32 onepoint() const;
  inline void set_onepoint(::google::protobuf::int32 value);
  
  // required int32 godoriPoint = 10;
  inline bool has_godoripoint() const;
  inline void clear_godoripoint();
  static const int kGodoriPointFieldNumber = 10;
  inline ::google::protobuf::int32 godoripoint() const;
  inline void set_godoripoint(::google::protobuf::int32 value);
  
  // required int32 redPoint = 11;
  inline bool has_redpoint() const;
  inline void clear_redpoint();
  static const int kRedPointFieldNumber = 11;
  inline ::google::protobuf::int32 redpoint() const;
  inline void set_redpoint(::google::protobuf::int32 value);
  
  // required int32 bluePoint = 12;
  inline bool has_bluepoint() const;
  inline void clear_bluepoint();
  static const int kBluePointFieldNumber = 12;
  inline ::google::protobuf::int32 bluepoint() const;
  inline void set_bluepoint(::google::protobuf::int32 value);
  
  // required int32 kusaPoint = 13;
  inline bool has_kusapoint() const;
  inline void clear_kusapoint();
  static const int kKusaPointFieldNumber = 13;
  inline ::google::protobuf::int32 kusapoint() const;
  inline void set_kusapoint(::google::protobuf::int32 value);
  
  // required int32 goCnt = 14;
  inline bool has_gocnt() const;
  inline void clear_gocnt();
  static const int kGoCntFieldNumber = 14;
  inline ::google::protobuf::int32 gocnt() const;
  inline void set_gocnt(::google::protobuf::int32 value);
  
  // required int32 basicPoint = 15;
  inline bool has_basicpoint() const;
  inline void clear_basicpoint();
  static const int kBasicPointFieldNumber = 15;
  inline ::google::protobuf::int32 basicpoint() const;
  inline void set_basicpoint(::google::protobuf::int32 value);
  
  // required int32 nagariCnt = 16;
  inline bool has_nagaricnt() const;
  inline void clear_nagaricnt();
  static const int kNagariCntFieldNumber = 16;
  inline ::google::protobuf::int32 nagaricnt() const;
  inline void set_nagaricnt(::google::protobuf::int32 value);
  
  // required int32 nMulGo = 17;
  inline bool has_nmulgo() const;
  inline void clear_nmulgo();
  static const int kNMulGoFieldNumber = 17;
  inline ::google::protobuf::int32 nmulgo() const;
  inline void set_nmulgo(::google::protobuf::int32 value);
  
  // required int32 nMulMission = 18;
  inline bool has_nmulmission() const;
  inline void clear_nmulmission();
  static const int kNMulMissionFieldNumber = 18;
  inline ::google::protobuf::int32 nmulmission() const;
  inline void set_nmulmission(::google::protobuf::int32 value);
  
  // required int32 nMulShake = 19;
  inline bool has_nmulshake() const;
  inline void clear_nmulshake();
  static const int kNMulShakeFieldNumber = 19;
  inline ::google::protobuf::int32 nmulshake() const;
  inline void set_nmulshake(::google::protobuf::int32 value);
  
  // required int32 nMulOneBak = 20;
  inline bool has_nmulonebak() const;
  inline void clear_nmulonebak();
  static const int kNMulOneBakFieldNumber = 20;
  inline ::google::protobuf::int32 nmulonebak() const;
  inline void set_nmulonebak(::google::protobuf::int32 value);
  
  // required int32 nMulCapBak = 21;
  inline bool has_nmulcapbak() const;
  inline void clear_nmulcapbak();
  static const int kNMulCapBakFieldNumber = 21;
  inline ::google::protobuf::int32 nmulcapbak() const;
  inline void set_nmulcapbak(::google::protobuf::int32 value);
  
  // required int32 nMulGoBak = 22;
  inline bool has_nmulgobak() const;
  inline void clear_nmulgobak();
  static const int kNMulGoBakFieldNumber = 22;
  inline ::google::protobuf::int32 nmulgobak() const;
  inline void set_nmulgobak(::google::protobuf::int32 value);
  
  // required int32 nMulMungBak = 23;
  inline bool has_nmulmungbak() const;
  inline void clear_nmulmungbak();
  static const int kNMulMungBakFieldNumber = 23;
  inline ::google::protobuf::int32 nmulmungbak() const;
  inline void set_nmulmungbak(::google::protobuf::int32 value);
  
  // required int32 nMulNagari = 24;
  inline bool has_nmulnagari() const;
  inline void clear_nmulnagari();
  static const int kNMulNagariFieldNumber = 24;
  inline ::google::protobuf::int32 nmulnagari() const;
  inline void set_nmulnagari(::google::protobuf::int32 value);
  
  // required .GLAnsGameResult.GAME_RESULT_TYPE nType = 25;
  inline bool has_ntype() const;
  inline void clear_ntype();
  static const int kNTypeFieldNumber = 25;
  inline ::GLAnsGameResult_GAME_RESULT_TYPE ntype() const;
  inline void set_ntype(::GLAnsGameResult_GAME_RESULT_TYPE value);
  
  // @@protoc_insertion_point(class_scope:GLAnsGameResult)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_dealpoint();
  inline void clear_has_dealpoint();
  inline void set_has_cappoint();
  inline void clear_has_cappoint();
  inline void set_has_tenpoint();
  inline void clear_has_tenpoint();
  inline void set_has_fivepoint();
  inline void clear_has_fivepoint();
  inline void set_has_onepoint();
  inline void clear_has_onepoint();
  inline void set_has_godoripoint();
  inline void clear_has_godoripoint();
  inline void set_has_redpoint();
  inline void clear_has_redpoint();
  inline void set_has_bluepoint();
  inline void clear_has_bluepoint();
  inline void set_has_kusapoint();
  inline void clear_has_kusapoint();
  inline void set_has_gocnt();
  inline void clear_has_gocnt();
  inline void set_has_basicpoint();
  inline void clear_has_basicpoint();
  inline void set_has_nagaricnt();
  inline void clear_has_nagaricnt();
  inline void set_has_nmulgo();
  inline void clear_has_nmulgo();
  inline void set_has_nmulmission();
  inline void clear_has_nmulmission();
  inline void set_has_nmulshake();
  inline void clear_has_nmulshake();
  inline void set_has_nmulonebak();
  inline void clear_has_nmulonebak();
  inline void set_has_nmulcapbak();
  inline void clear_has_nmulcapbak();
  inline void set_has_nmulgobak();
  inline void clear_has_nmulgobak();
  inline void set_has_nmulmungbak();
  inline void clear_has_nmulmungbak();
  inline void set_has_nmulnagari();
  inline void clear_has_nmulnagari();
  inline void set_has_ntype();
  inline void clear_has_ntype();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > level_;
  ::std::string* money_;
  ::google::protobuf::int32 dealpoint_;
  ::google::protobuf::int32 cappoint_;
  ::google::protobuf::int32 tenpoint_;
  ::google::protobuf::int32 fivepoint_;
  ::google::protobuf::int32 onepoint_;
  ::google::protobuf::int32 godoripoint_;
  ::google::protobuf::int32 redpoint_;
  ::google::protobuf::int32 bluepoint_;
  ::google::protobuf::int32 kusapoint_;
  ::google::protobuf::int32 gocnt_;
  ::google::protobuf::int32 basicpoint_;
  ::google::protobuf::int32 nagaricnt_;
  ::google::protobuf::int32 nmulgo_;
  ::google::protobuf::int32 nmulmission_;
  ::google::protobuf::int32 nmulshake_;
  ::google::protobuf::int32 nmulonebak_;
  ::google::protobuf::int32 nmulcapbak_;
  ::google::protobuf::int32 nmulgobak_;
  ::google::protobuf::int32 nmulmungbak_;
  ::google::protobuf::int32 nmulnagari_;
  int ntype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(25 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameResult* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameNotiPoint : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameNotiPoint();
  virtual ~GLAnsGameNotiPoint();
  
  GLAnsGameNotiPoint(const GLAnsGameNotiPoint& from);
  
  inline GLAnsGameNotiPoint& operator=(const GLAnsGameNotiPoint& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameNotiPoint& default_instance();
  
  void Swap(GLAnsGameNotiPoint* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameNotiPoint* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameNotiPoint& from);
  void MergeFrom(const GLAnsGameNotiPoint& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // required int32 point = 3;
  inline bool has_point() const;
  inline void clear_point();
  static const int kPointFieldNumber = 3;
  inline ::google::protobuf::int32 point() const;
  inline void set_point(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:GLAnsGameNotiPoint)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  inline void set_has_point();
  inline void clear_has_point();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  ::google::protobuf::int32 point_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameNotiPoint* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameEnd : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameEnd();
  virtual ~GLAnsGameEnd();
  
  GLAnsGameEnd(const GLAnsGameEnd& from);
  
  inline GLAnsGameEnd& operator=(const GLAnsGameEnd& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameEnd& default_instance();
  
  void Swap(GLAnsGameEnd* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameEnd* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameEnd& from);
  void MergeFrom(const GLAnsGameEnd& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:GLAnsGameEnd)
 private:
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameEnd* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameKick : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameKick();
  virtual ~GLAnsGameKick();
  
  GLAnsGameKick(const GLAnsGameKick& from);
  
  inline GLAnsGameKick& operator=(const GLAnsGameKick& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameKick& default_instance();
  
  void Swap(GLAnsGameKick* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameKick* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameKick& from);
  void MergeFrom(const GLAnsGameKick& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef GLAnsGameKick_KICK_TYPE KICK_TYPE;
  static const KICK_TYPE EXIT_RESERVATION = GLAnsGameKick_KICK_TYPE_EXIT_RESERVATION;
  static const KICK_TYPE LIMITMONEY = GLAnsGameKick_KICK_TYPE_LIMITMONEY;
  static const KICK_TYPE ALLIN = GLAnsGameKick_KICK_TYPE_ALLIN;
  static const KICK_TYPE KICK_ZERO = GLAnsGameKick_KICK_TYPE_KICK_ZERO;
  static inline bool KICK_TYPE_IsValid(int value) {
    return GLAnsGameKick_KICK_TYPE_IsValid(value);
  }
  static const KICK_TYPE KICK_TYPE_MIN =
    GLAnsGameKick_KICK_TYPE_KICK_TYPE_MIN;
  static const KICK_TYPE KICK_TYPE_MAX =
    GLAnsGameKick_KICK_TYPE_KICK_TYPE_MAX;
  static const int KICK_TYPE_ARRAYSIZE =
    GLAnsGameKick_KICK_TYPE_KICK_TYPE_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // required .GLAnsGameKick.KICK_TYPE nType = 3;
  inline bool has_ntype() const;
  inline void clear_ntype();
  static const int kNTypeFieldNumber = 3;
  inline ::GLAnsGameKick_KICK_TYPE ntype() const;
  inline void set_ntype(::GLAnsGameKick_KICK_TYPE value);
  
  // @@protoc_insertion_point(class_scope:GLAnsGameKick)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  inline void set_has_ntype();
  inline void clear_has_ntype();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  int ntype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameKick* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameEmoti : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameEmoti();
  virtual ~GLAnsGameEmoti();
  
  GLAnsGameEmoti(const GLAnsGameEmoti& from);
  
  inline GLAnsGameEmoti& operator=(const GLAnsGameEmoti& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameEmoti& default_instance();
  
  void Swap(GLAnsGameEmoti* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameEmoti* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameEmoti& from);
  void MergeFrom(const GLAnsGameEmoti& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // required int32 nType = 3;
  inline bool has_ntype() const;
  inline void clear_ntype();
  static const int kNTypeFieldNumber = 3;
  inline ::google::protobuf::int32 ntype() const;
  inline void set_ntype(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:GLAnsGameEmoti)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  inline void set_has_ntype();
  inline void clear_has_ntype();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  ::google::protobuf::int32 ntype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameEmoti* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameInit : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameInit();
  virtual ~GLAnsGameInit();
  
  GLAnsGameInit(const GLAnsGameInit& from);
  
  inline GLAnsGameInit& operator=(const GLAnsGameInit& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameInit& default_instance();
  
  void Swap(GLAnsGameInit* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameInit* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameInit& from);
  void MergeFrom(const GLAnsGameInit& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:GLAnsGameInit)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameInit* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameAutoPlay : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameAutoPlay();
  virtual ~GLAnsGameAutoPlay();
  
  GLAnsGameAutoPlay(const GLAnsGameAutoPlay& from);
  
  inline GLAnsGameAutoPlay& operator=(const GLAnsGameAutoPlay& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameAutoPlay& default_instance();
  
  void Swap(GLAnsGameAutoPlay* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameAutoPlay* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameAutoPlay& from);
  void MergeFrom(const GLAnsGameAutoPlay& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // required bool bAuto = 3;
  inline bool has_bauto() const;
  inline void clear_bauto();
  static const int kBAutoFieldNumber = 3;
  inline bool bauto() const;
  inline void set_bauto(bool value);
  
  // @@protoc_insertion_point(class_scope:GLAnsGameAutoPlay)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  inline void set_has_bauto();
  inline void clear_has_bauto();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  bool bauto_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameAutoPlay* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsExitReservation : public ::google::protobuf::MessageLite {
 public:
  GLAnsExitReservation();
  virtual ~GLAnsExitReservation();
  
  GLAnsExitReservation(const GLAnsExitReservation& from);
  
  inline GLAnsExitReservation& operator=(const GLAnsExitReservation& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsExitReservation& default_instance();
  
  void Swap(GLAnsExitReservation* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsExitReservation* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsExitReservation& from);
  void MergeFrom(const GLAnsExitReservation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // required bool bExit = 3;
  inline bool has_bexit() const;
  inline void clear_bexit();
  static const int kBExitFieldNumber = 3;
  inline bool bexit() const;
  inline void set_bexit(bool value);
  
  // @@protoc_insertion_point(class_scope:GLAnsExitReservation)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  inline void set_has_bexit();
  inline void clear_has_bexit();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  bool bexit_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsExitReservation* default_instance_;
};
// -------------------------------------------------------------------

class GLReqGameReady : public ::google::protobuf::MessageLite {
 public:
  GLReqGameReady();
  virtual ~GLReqGameReady();
  
  GLReqGameReady(const GLReqGameReady& from);
  
  inline GLReqGameReady& operator=(const GLReqGameReady& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLReqGameReady& default_instance();
  
  void Swap(GLReqGameReady* other);
  
  // implements Message ----------------------------------------------
  
  GLReqGameReady* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLReqGameReady& from);
  void MergeFrom(const GLReqGameReady& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:GLReqGameReady)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLReqGameReady* default_instance_;
};
// -------------------------------------------------------------------

class GLReqResetReady : public ::google::protobuf::MessageLite {
 public:
  GLReqResetReady();
  virtual ~GLReqResetReady();
  
  GLReqResetReady(const GLReqResetReady& from);
  
  inline GLReqResetReady& operator=(const GLReqResetReady& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLReqResetReady& default_instance();
  
  void Swap(GLReqResetReady* other);
  
  // implements Message ----------------------------------------------
  
  GLReqResetReady* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLReqResetReady& from);
  void MergeFrom(const GLReqResetReady& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:GLReqResetReady)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLReqResetReady* default_instance_;
};
// -------------------------------------------------------------------

class GLReqGameInitGame : public ::google::protobuf::MessageLite {
 public:
  GLReqGameInitGame();
  virtual ~GLReqGameInitGame();
  
  GLReqGameInitGame(const GLReqGameInitGame& from);
  
  inline GLReqGameInitGame& operator=(const GLReqGameInitGame& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLReqGameInitGame& default_instance();
  
  void Swap(GLReqGameInitGame* other);
  
  // implements Message ----------------------------------------------
  
  GLReqGameInitGame* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLReqGameInitGame& from);
  void MergeFrom(const GLReqGameInitGame& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:GLReqGameInitGame)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLReqGameInitGame* default_instance_;
};
// -------------------------------------------------------------------

class GLReqGameReset : public ::google::protobuf::MessageLite {
 public:
  GLReqGameReset();
  virtual ~GLReqGameReset();
  
  GLReqGameReset(const GLReqGameReset& from);
  
  inline GLReqGameReset& operator=(const GLReqGameReset& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLReqGameReset& default_instance();
  
  void Swap(GLReqGameReset* other);
  
  // implements Message ----------------------------------------------
  
  GLReqGameReset* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLReqGameReset& from);
  void MergeFrom(const GLReqGameReset& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:GLReqGameReset)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLReqGameReset* default_instance_;
};
// -------------------------------------------------------------------

class GLReqGameStart : public ::google::protobuf::MessageLite {
 public:
  GLReqGameStart();
  virtual ~GLReqGameStart();
  
  GLReqGameStart(const GLReqGameStart& from);
  
  inline GLReqGameStart& operator=(const GLReqGameStart& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLReqGameStart& default_instance();
  
  void Swap(GLReqGameStart* other);
  
  // implements Message ----------------------------------------------
  
  GLReqGameStart* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLReqGameStart& from);
  void MergeFrom(const GLReqGameStart& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // optional int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:GLReqGameStart)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLReqGameStart* default_instance_;
};
// -------------------------------------------------------------------

class GLReqGameSelectSunCard : public ::google::protobuf::MessageLite {
 public:
  GLReqGameSelectSunCard();
  virtual ~GLReqGameSelectSunCard();
  
  GLReqGameSelectSunCard(const GLReqGameSelectSunCard& from);
  
  inline GLReqGameSelectSunCard& operator=(const GLReqGameSelectSunCard& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLReqGameSelectSunCard& default_instance();
  
  void Swap(GLReqGameSelectSunCard* other);
  
  // implements Message ----------------------------------------------
  
  GLReqGameSelectSunCard* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLReqGameSelectSunCard& from);
  void MergeFrom(const GLReqGameSelectSunCard& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // required int32 nCard = 3;
  inline bool has_ncard() const;
  inline void clear_ncard();
  static const int kNCardFieldNumber = 3;
  inline ::google::protobuf::int32 ncard() const;
  inline void set_ncard(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:GLReqGameSelectSunCard)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  inline void set_has_ncard();
  inline void clear_has_ncard();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  ::google::protobuf::int32 ncard_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLReqGameSelectSunCard* default_instance_;
};
// -------------------------------------------------------------------

class GLReqGameSelectCard : public ::google::protobuf::MessageLite {
 public:
  GLReqGameSelectCard();
  virtual ~GLReqGameSelectCard();
  
  GLReqGameSelectCard(const GLReqGameSelectCard& from);
  
  inline GLReqGameSelectCard& operator=(const GLReqGameSelectCard& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLReqGameSelectCard& default_instance();
  
  void Swap(GLReqGameSelectCard* other);
  
  // implements Message ----------------------------------------------
  
  GLReqGameSelectCard* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLReqGameSelectCard& from);
  void MergeFrom(const GLReqGameSelectCard& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // required int32 nCard = 3;
  inline bool has_ncard() const;
  inline void clear_ncard();
  static const int kNCardFieldNumber = 3;
  inline ::google::protobuf::int32 ncard() const;
  inline void set_ncard(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:GLReqGameSelectCard)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  inline void set_has_ncard();
  inline void clear_has_ncard();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  ::google::protobuf::int32 ncard_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLReqGameSelectCard* default_instance_;
};
// -------------------------------------------------------------------

class GLReqGameAskGoStopAns : public ::google::protobuf::MessageLite {
 public:
  GLReqGameAskGoStopAns();
  virtual ~GLReqGameAskGoStopAns();
  
  GLReqGameAskGoStopAns(const GLReqGameAskGoStopAns& from);
  
  inline GLReqGameAskGoStopAns& operator=(const GLReqGameAskGoStopAns& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLReqGameAskGoStopAns& default_instance();
  
  void Swap(GLReqGameAskGoStopAns* other);
  
  // implements Message ----------------------------------------------
  
  GLReqGameAskGoStopAns* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLReqGameAskGoStopAns& from);
  void MergeFrom(const GLReqGameAskGoStopAns& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // required bool bGo = 3;
  inline bool has_bgo() const;
  inline void clear_bgo();
  static const int kBGoFieldNumber = 3;
  inline bool bgo() const;
  inline void set_bgo(bool value);
  
  // @@protoc_insertion_point(class_scope:GLReqGameAskGoStopAns)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  inline void set_has_bgo();
  inline void clear_has_bgo();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  bool bgo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLReqGameAskGoStopAns* default_instance_;
};
// -------------------------------------------------------------------

class GLReqGameAskShakeAns : public ::google::protobuf::MessageLite {
 public:
  GLReqGameAskShakeAns();
  virtual ~GLReqGameAskShakeAns();
  
  GLReqGameAskShakeAns(const GLReqGameAskShakeAns& from);
  
  inline GLReqGameAskShakeAns& operator=(const GLReqGameAskShakeAns& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLReqGameAskShakeAns& default_instance();
  
  void Swap(GLReqGameAskShakeAns* other);
  
  // implements Message ----------------------------------------------
  
  GLReqGameAskShakeAns* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLReqGameAskShakeAns& from);
  void MergeFrom(const GLReqGameAskShakeAns& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // required bool bShake = 3;
  inline bool has_bshake() const;
  inline void clear_bshake();
  static const int kBShakeFieldNumber = 3;
  inline bool bshake() const;
  inline void set_bshake(bool value);
  
  // @@protoc_insertion_point(class_scope:GLReqGameAskShakeAns)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  inline void set_has_bshake();
  inline void clear_has_bshake();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  bool bshake_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLReqGameAskShakeAns* default_instance_;
};
// -------------------------------------------------------------------

class GLReqGameChoiceCardAns : public ::google::protobuf::MessageLite {
 public:
  GLReqGameChoiceCardAns();
  virtual ~GLReqGameChoiceCardAns();
  
  GLReqGameChoiceCardAns(const GLReqGameChoiceCardAns& from);
  
  inline GLReqGameChoiceCardAns& operator=(const GLReqGameChoiceCardAns& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLReqGameChoiceCardAns& default_instance();
  
  void Swap(GLReqGameChoiceCardAns* other);
  
  // implements Message ----------------------------------------------
  
  GLReqGameChoiceCardAns* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLReqGameChoiceCardAns& from);
  void MergeFrom(const GLReqGameChoiceCardAns& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef GLReqGameChoiceCardAns_Type Type;
  static const Type SELECT = GLReqGameChoiceCardAns_Type_SELECT;
  static const Type UPSET = GLReqGameChoiceCardAns_Type_UPSET;
  static inline bool Type_IsValid(int value) {
    return GLReqGameChoiceCardAns_Type_IsValid(value);
  }
  static const Type Type_MIN =
    GLReqGameChoiceCardAns_Type_Type_MIN;
  static const Type Type_MAX =
    GLReqGameChoiceCardAns_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    GLReqGameChoiceCardAns_Type_Type_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // required int32 nCard = 3;
  inline bool has_ncard() const;
  inline void clear_ncard();
  static const int kNCardFieldNumber = 3;
  inline ::google::protobuf::int32 ncard() const;
  inline void set_ncard(::google::protobuf::int32 value);
  
  // required .GLReqGameChoiceCardAns.Type nType = 4;
  inline bool has_ntype() const;
  inline void clear_ntype();
  static const int kNTypeFieldNumber = 4;
  inline ::GLReqGameChoiceCardAns_Type ntype() const;
  inline void set_ntype(::GLReqGameChoiceCardAns_Type value);
  
  // @@protoc_insertion_point(class_scope:GLReqGameChoiceCardAns)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  inline void set_has_ncard();
  inline void clear_has_ncard();
  inline void set_has_ntype();
  inline void clear_has_ntype();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  ::google::protobuf::int32 ncard_;
  int ntype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLReqGameChoiceCardAns* default_instance_;
};
// -------------------------------------------------------------------

class GLReqGameMoveTen : public ::google::protobuf::MessageLite {
 public:
  GLReqGameMoveTen();
  virtual ~GLReqGameMoveTen();
  
  GLReqGameMoveTen(const GLReqGameMoveTen& from);
  
  inline GLReqGameMoveTen& operator=(const GLReqGameMoveTen& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLReqGameMoveTen& default_instance();
  
  void Swap(GLReqGameMoveTen* other);
  
  // implements Message ----------------------------------------------
  
  GLReqGameMoveTen* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLReqGameMoveTen& from);
  void MergeFrom(const GLReqGameMoveTen& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // required bool bMove = 3;
  inline bool has_bmove() const;
  inline void clear_bmove();
  static const int kBMoveFieldNumber = 3;
  inline bool bmove() const;
  inline void set_bmove(bool value);
  
  // @@protoc_insertion_point(class_scope:GLReqGameMoveTen)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  inline void set_has_bmove();
  inline void clear_has_bmove();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  bool bmove_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLReqGameMoveTen* default_instance_;
};
// -------------------------------------------------------------------

class GLReqGameChongTong : public ::google::protobuf::MessageLite {
 public:
  GLReqGameChongTong();
  virtual ~GLReqGameChongTong();
  
  GLReqGameChongTong(const GLReqGameChongTong& from);
  
  inline GLReqGameChongTong& operator=(const GLReqGameChongTong& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLReqGameChongTong& default_instance();
  
  void Swap(GLReqGameChongTong* other);
  
  // implements Message ----------------------------------------------
  
  GLReqGameChongTong* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLReqGameChongTong& from);
  void MergeFrom(const GLReqGameChongTong& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // required bool bYes = 3;
  inline bool has_byes() const;
  inline void clear_byes();
  static const int kBYesFieldNumber = 3;
  inline bool byes() const;
  inline void set_byes(bool value);
  
  // @@protoc_insertion_point(class_scope:GLReqGameChongTong)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  inline void set_has_byes();
  inline void clear_has_byes();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  bool byes_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLReqGameChongTong* default_instance_;
};
// -------------------------------------------------------------------

class GLReqGameEnd : public ::google::protobuf::MessageLite {
 public:
  GLReqGameEnd();
  virtual ~GLReqGameEnd();
  
  GLReqGameEnd(const GLReqGameEnd& from);
  
  inline GLReqGameEnd& operator=(const GLReqGameEnd& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLReqGameEnd& default_instance();
  
  void Swap(GLReqGameEnd* other);
  
  // implements Message ----------------------------------------------
  
  GLReqGameEnd* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLReqGameEnd& from);
  void MergeFrom(const GLReqGameEnd& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:GLReqGameEnd)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLReqGameEnd* default_instance_;
};
// -------------------------------------------------------------------

class GLReqResultOk : public ::google::protobuf::MessageLite {
 public:
  GLReqResultOk();
  virtual ~GLReqResultOk();
  
  GLReqResultOk(const GLReqResultOk& from);
  
  inline GLReqResultOk& operator=(const GLReqResultOk& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLReqResultOk& default_instance();
  
  void Swap(GLReqResultOk* other);
  
  // implements Message ----------------------------------------------
  
  GLReqResultOk* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLReqResultOk& from);
  void MergeFrom(const GLReqResultOk& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:GLReqResultOk)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLReqResultOk* default_instance_;
};
// -------------------------------------------------------------------

class GLReqGameAutoPlay : public ::google::protobuf::MessageLite {
 public:
  GLReqGameAutoPlay();
  virtual ~GLReqGameAutoPlay();
  
  GLReqGameAutoPlay(const GLReqGameAutoPlay& from);
  
  inline GLReqGameAutoPlay& operator=(const GLReqGameAutoPlay& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLReqGameAutoPlay& default_instance();
  
  void Swap(GLReqGameAutoPlay* other);
  
  // implements Message ----------------------------------------------
  
  GLReqGameAutoPlay* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLReqGameAutoPlay& from);
  void MergeFrom(const GLReqGameAutoPlay& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // required bool bAuto = 3;
  inline bool has_bauto() const;
  inline void clear_bauto();
  static const int kBAutoFieldNumber = 3;
  inline bool bauto() const;
  inline void set_bauto(bool value);
  
  // @@protoc_insertion_point(class_scope:GLReqGameAutoPlay)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  inline void set_has_bauto();
  inline void clear_has_bauto();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  bool bauto_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLReqGameAutoPlay* default_instance_;
};
// -------------------------------------------------------------------

class GLReqGameEmoti : public ::google::protobuf::MessageLite {
 public:
  GLReqGameEmoti();
  virtual ~GLReqGameEmoti();
  
  GLReqGameEmoti(const GLReqGameEmoti& from);
  
  inline GLReqGameEmoti& operator=(const GLReqGameEmoti& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLReqGameEmoti& default_instance();
  
  void Swap(GLReqGameEmoti* other);
  
  // implements Message ----------------------------------------------
  
  GLReqGameEmoti* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLReqGameEmoti& from);
  void MergeFrom(const GLReqGameEmoti& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // required int32 nType = 3;
  inline bool has_ntype() const;
  inline void clear_ntype();
  static const int kNTypeFieldNumber = 3;
  inline ::google::protobuf::int32 ntype() const;
  inline void set_ntype(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:GLReqGameEmoti)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  inline void set_has_ntype();
  inline void clear_has_ntype();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  ::google::protobuf::int32 ntype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLReqGameEmoti* default_instance_;
};
// -------------------------------------------------------------------

class GLReqExitReservation : public ::google::protobuf::MessageLite {
 public:
  GLReqExitReservation();
  virtual ~GLReqExitReservation();
  
  GLReqExitReservation(const GLReqExitReservation& from);
  
  inline GLReqExitReservation& operator=(const GLReqExitReservation& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLReqExitReservation& default_instance();
  
  void Swap(GLReqExitReservation* other);
  
  // implements Message ----------------------------------------------
  
  GLReqExitReservation* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLReqExitReservation& from);
  void MergeFrom(const GLReqExitReservation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 gameIndex = 2;
  inline bool has_gameindex() const;
  inline void clear_gameindex();
  static const int kGameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 gameindex() const;
  inline void set_gameindex(::google::protobuf::int32 value);
  
  // required bool bExit = 3;
  inline bool has_bexit() const;
  inline void clear_bexit();
  static const int kBExitFieldNumber = 3;
  inline bool bexit() const;
  inline void set_bexit(bool value);
  
  // @@protoc_insertion_point(class_scope:GLReqExitReservation)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gameindex();
  inline void clear_has_gameindex();
  inline void set_has_bexit();
  inline void clear_has_bexit();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gameindex_;
  bool bexit_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLReqExitReservation* default_instance_;
};
// -------------------------------------------------------------------

class GLReqRelayInfo : public ::google::protobuf::MessageLite {
 public:
  GLReqRelayInfo();
  virtual ~GLReqRelayInfo();
  
  GLReqRelayInfo(const GLReqRelayInfo& from);
  
  inline GLReqRelayInfo& operator=(const GLReqRelayInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLReqRelayInfo& default_instance();
  
  void Swap(GLReqRelayInfo* other);
  
  // implements Message ----------------------------------------------
  
  GLReqRelayInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLReqRelayInfo& from);
  void MergeFrom(const GLReqRelayInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:GLReqRelayInfo)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  
  ::google::protobuf::int32 gameid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLReqRelayInfo* default_instance_;
};
// -------------------------------------------------------------------

class G_REQ_GAME_TEST_PACKET : public ::google::protobuf::MessageLite {
 public:
  G_REQ_GAME_TEST_PACKET();
  virtual ~G_REQ_GAME_TEST_PACKET();
  
  G_REQ_GAME_TEST_PACKET(const G_REQ_GAME_TEST_PACKET& from);
  
  inline G_REQ_GAME_TEST_PACKET& operator=(const G_REQ_GAME_TEST_PACKET& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const G_REQ_GAME_TEST_PACKET& default_instance();
  
  void Swap(G_REQ_GAME_TEST_PACKET* other);
  
  // implements Message ----------------------------------------------
  
  G_REQ_GAME_TEST_PACKET* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const G_REQ_GAME_TEST_PACKET& from);
  void MergeFrom(const G_REQ_GAME_TEST_PACKET& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 gameID = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // required int32 test_int = 2;
  inline bool has_test_int() const;
  inline void clear_test_int();
  static const int kTestIntFieldNumber = 2;
  inline ::google::protobuf::int32 test_int() const;
  inline void set_test_int(::google::protobuf::int32 value);
  
  // required string test_string = 3;
  inline bool has_test_string() const;
  inline void clear_test_string();
  static const int kTestStringFieldNumber = 3;
  inline const ::std::string& test_string() const;
  inline void set_test_string(const ::std::string& value);
  inline void set_test_string(const char* value);
  inline void set_test_string(const char* value, size_t size);
  inline ::std::string* mutable_test_string();
  inline ::std::string* release_test_string();
  
  // @@protoc_insertion_point(class_scope:G_REQ_GAME_TEST_PACKET)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_test_int();
  inline void clear_has_test_int();
  inline void set_has_test_string();
  inline void clear_has_test_string();
  
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 test_int_;
  ::std::string* test_string_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static G_REQ_GAME_TEST_PACKET* default_instance_;
};
// -------------------------------------------------------------------

class GLAnsGameProtocol : public ::google::protobuf::MessageLite {
 public:
  GLAnsGameProtocol();
  virtual ~GLAnsGameProtocol();
  
  GLAnsGameProtocol(const GLAnsGameProtocol& from);
  
  inline GLAnsGameProtocol& operator=(const GLAnsGameProtocol& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLAnsGameProtocol& default_instance();
  
  void Swap(GLAnsGameProtocol* other);
  
  // implements Message ----------------------------------------------
  
  GLAnsGameProtocol* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLAnsGameProtocol& from);
  void MergeFrom(const GLAnsGameProtocol& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef GLAnsGameProtocol_Type Type;
  static const Type NONE = GLAnsGameProtocol_Type_NONE;
  static const Type GAME_STARTREADY = GLAnsGameProtocol_Type_GAME_STARTREADY;
  static const Type GAME_RESETREADY = GLAnsGameProtocol_Type_GAME_RESETREADY;
  static const Type GAME_INIT = GLAnsGameProtocol_Type_GAME_INIT;
  static const Type GAME_START = GLAnsGameProtocol_Type_GAME_START;
  static const Type GAME_RESET = GLAnsGameProtocol_Type_GAME_RESET;
  static const Type GAME_NOTISUN = GLAnsGameProtocol_Type_GAME_NOTISUN;
  static const Type GAME_SELECTSUN = GLAnsGameProtocol_Type_GAME_SELECTSUN;
  static const Type GAME_NOTISELECTSUN = GLAnsGameProtocol_Type_GAME_NOTISELECTSUN;
  static const Type GAME_SHARING = GLAnsGameProtocol_Type_GAME_SHARING;
  static const Type GAME_NAGARI = GLAnsGameProtocol_Type_GAME_NAGARI;
  static const Type GAME_CHONGTONG = GLAnsGameProtocol_Type_GAME_CHONGTONG;
  static const Type GAME_SELECTCARD = GLAnsGameProtocol_Type_GAME_SELECTCARD;
  static const Type GAME_BONUS = GLAnsGameProtocol_Type_GAME_BONUS;
  static const Type GAME_TAKEPEE = GLAnsGameProtocol_Type_GAME_TAKEPEE;
  static const Type GAME_BBUCK = GLAnsGameProtocol_Type_GAME_BBUCK;
  static const Type GAME_SERISEBBUK = GLAnsGameProtocol_Type_GAME_SERISEBBUK;
  static const Type GAME_BBUCKEAT = GLAnsGameProtocol_Type_GAME_BBUCKEAT;
  static const Type GAME_BOMB = GLAnsGameProtocol_Type_GAME_BOMB;
  static const Type GAME_PAN = GLAnsGameProtocol_Type_GAME_PAN;
  static const Type GAME_DADAK = GLAnsGameProtocol_Type_GAME_DADAK;
  static const Type GAME_JJOK = GLAnsGameProtocol_Type_GAME_JJOK;
  static const Type GAME_UPSET = GLAnsGameProtocol_Type_GAME_UPSET;
  static const Type GAME_ALLEATUP = GLAnsGameProtocol_Type_GAME_ALLEATUP;
  static const Type GAME_NOTITURN = GLAnsGameProtocol_Type_GAME_NOTITURN;
  static const Type GAME_MOVETEN = GLAnsGameProtocol_Type_GAME_MOVETEN;
  static const Type GAME_MOVETENANS = GLAnsGameProtocol_Type_GAME_MOVETENANS;
  static const Type GAME_CHOICECARD = GLAnsGameProtocol_Type_GAME_CHOICECARD;
  static const Type GAME_SHAKE = GLAnsGameProtocol_Type_GAME_SHAKE;
  static const Type GAME_SHAKEANS = GLAnsGameProtocol_Type_GAME_SHAKEANS;
  static const Type GAME_SHAKECOUNT = GLAnsGameProtocol_Type_GAME_SHAKECOUNT;
  static const Type GAME_CAPTYPE = GLAnsGameProtocol_Type_GAME_CAPTYPE;
  static const Type GAME_GODORI = GLAnsGameProtocol_Type_GAME_GODORI;
  static const Type GAME_KUSA = GLAnsGameProtocol_Type_GAME_KUSA;
  static const Type GAME_RED = GLAnsGameProtocol_Type_GAME_RED;
  static const Type GAME_BLUE = GLAnsGameProtocol_Type_GAME_BLUE;
  static const Type GAME_BAK = GLAnsGameProtocol_Type_GAME_BAK;
  static const Type GAME_BAKFAIL = GLAnsGameProtocol_Type_GAME_BAKFAIL;
  static const Type GAME_NOTYMISSION = GLAnsGameProtocol_Type_GAME_NOTYMISSION;
  static const Type GAME_NOTIMISSIONCARD = GLAnsGameProtocol_Type_GAME_NOTIMISSIONCARD;
  static const Type GAME_MISSIONSTATE = GLAnsGameProtocol_Type_GAME_MISSIONSTATE;
  static const Type GAME_GOSTOP = GLAnsGameProtocol_Type_GAME_GOSTOP;
  static const Type GAME_GOSTOPANS = GLAnsGameProtocol_Type_GAME_GOSTOPANS;
  static const Type GAME_STOPANS = GLAnsGameProtocol_Type_GAME_STOPANS;
  static const Type GAME_RESULT = GLAnsGameProtocol_Type_GAME_RESULT;
  static const Type GAME_NOTIPOINT = GLAnsGameProtocol_Type_GAME_NOTIPOINT;
  static const Type GAME_END = GLAnsGameProtocol_Type_GAME_END;
  static const Type GAME_KICK = GLAnsGameProtocol_Type_GAME_KICK;
  static const Type GAME_EMOTI = GLAnsGameProtocol_Type_GAME_EMOTI;
  static const Type GAME_AUTOPLAY = GLAnsGameProtocol_Type_GAME_AUTOPLAY;
  static const Type GAME_RELAYINFO = GLAnsGameProtocol_Type_GAME_RELAYINFO;
  static const Type GAME_EXITRESERVATION = GLAnsGameProtocol_Type_GAME_EXITRESERVATION;
  static inline bool Type_IsValid(int value) {
    return GLAnsGameProtocol_Type_IsValid(value);
  }
  static const Type Type_MIN =
    GLAnsGameProtocol_Type_Type_MIN;
  static const Type Type_MAX =
    GLAnsGameProtocol_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    GLAnsGameProtocol_Type_Type_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required .GLAnsGameProtocol.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::GLAnsGameProtocol_Type type() const;
  inline void set_type(::GLAnsGameProtocol_Type value);
  
  // optional .GLAnsGameStartReady gameStartReady = 2;
  inline bool has_gamestartready() const;
  inline void clear_gamestartready();
  static const int kGameStartReadyFieldNumber = 2;
  inline const ::GLAnsGameStartReady& gamestartready() const;
  inline ::GLAnsGameStartReady* mutable_gamestartready();
  inline ::GLAnsGameStartReady* release_gamestartready();
  
  // optional .GLAnsGameResetReady gameResetReady = 3;
  inline bool has_gameresetready() const;
  inline void clear_gameresetready();
  static const int kGameResetReadyFieldNumber = 3;
  inline const ::GLAnsGameResetReady& gameresetready() const;
  inline ::GLAnsGameResetReady* mutable_gameresetready();
  inline ::GLAnsGameResetReady* release_gameresetready();
  
  // optional .GLAnsGameInit gameinit = 4;
  inline bool has_gameinit() const;
  inline void clear_gameinit();
  static const int kGameinitFieldNumber = 4;
  inline const ::GLAnsGameInit& gameinit() const;
  inline ::GLAnsGameInit* mutable_gameinit();
  inline ::GLAnsGameInit* release_gameinit();
  
  // optional .GLAnsGameStart gameStart = 5;
  inline bool has_gamestart() const;
  inline void clear_gamestart();
  static const int kGameStartFieldNumber = 5;
  inline const ::GLAnsGameStart& gamestart() const;
  inline ::GLAnsGameStart* mutable_gamestart();
  inline ::GLAnsGameStart* release_gamestart();
  
  // optional .GLAnsGameReset gameReset = 6;
  inline bool has_gamereset() const;
  inline void clear_gamereset();
  static const int kGameResetFieldNumber = 6;
  inline const ::GLAnsGameReset& gamereset() const;
  inline ::GLAnsGameReset* mutable_gamereset();
  inline ::GLAnsGameReset* release_gamereset();
  
  // optional .GLAnsGameNotiSun gameNotiSun = 7;
  inline bool has_gamenotisun() const;
  inline void clear_gamenotisun();
  static const int kGameNotiSunFieldNumber = 7;
  inline const ::GLAnsGameNotiSun& gamenotisun() const;
  inline ::GLAnsGameNotiSun* mutable_gamenotisun();
  inline ::GLAnsGameNotiSun* release_gamenotisun();
  
  // optional .GLAnsGameSelectSun gameSelectSun = 8;
  inline bool has_gameselectsun() const;
  inline void clear_gameselectsun();
  static const int kGameSelectSunFieldNumber = 8;
  inline const ::GLAnsGameSelectSun& gameselectsun() const;
  inline ::GLAnsGameSelectSun* mutable_gameselectsun();
  inline ::GLAnsGameSelectSun* release_gameselectsun();
  
  // optional .GLAnsGameNotiSelectSun gameNotiSelectSun = 9;
  inline bool has_gamenotiselectsun() const;
  inline void clear_gamenotiselectsun();
  static const int kGameNotiSelectSunFieldNumber = 9;
  inline const ::GLAnsGameNotiSelectSun& gamenotiselectsun() const;
  inline ::GLAnsGameNotiSelectSun* mutable_gamenotiselectsun();
  inline ::GLAnsGameNotiSelectSun* release_gamenotiselectsun();
  
  // optional .GLAnsGameSharing gameSharing = 10;
  inline bool has_gamesharing() const;
  inline void clear_gamesharing();
  static const int kGameSharingFieldNumber = 10;
  inline const ::GLAnsGameSharing& gamesharing() const;
  inline ::GLAnsGameSharing* mutable_gamesharing();
  inline ::GLAnsGameSharing* release_gamesharing();
  
  // optional .GLAnsGameNagari gameNagari = 11;
  inline bool has_gamenagari() const;
  inline void clear_gamenagari();
  static const int kGameNagariFieldNumber = 11;
  inline const ::GLAnsGameNagari& gamenagari() const;
  inline ::GLAnsGameNagari* mutable_gamenagari();
  inline ::GLAnsGameNagari* release_gamenagari();
  
  // optional .GLAnsGameChongTong gameChongTong = 12;
  inline bool has_gamechongtong() const;
  inline void clear_gamechongtong();
  static const int kGameChongTongFieldNumber = 12;
  inline const ::GLAnsGameChongTong& gamechongtong() const;
  inline ::GLAnsGameChongTong* mutable_gamechongtong();
  inline ::GLAnsGameChongTong* release_gamechongtong();
  
  // optional .GLAnsGameSelectCard gameSelectCard = 13;
  inline bool has_gameselectcard() const;
  inline void clear_gameselectcard();
  static const int kGameSelectCardFieldNumber = 13;
  inline const ::GLAnsGameSelectCard& gameselectcard() const;
  inline ::GLAnsGameSelectCard* mutable_gameselectcard();
  inline ::GLAnsGameSelectCard* release_gameselectcard();
  
  // optional .GLAnsGameBonus gameBonus = 14;
  inline bool has_gamebonus() const;
  inline void clear_gamebonus();
  static const int kGameBonusFieldNumber = 14;
  inline const ::GLAnsGameBonus& gamebonus() const;
  inline ::GLAnsGameBonus* mutable_gamebonus();
  inline ::GLAnsGameBonus* release_gamebonus();
  
  // optional .GLAnsGameTakePee gameTakePee = 15;
  inline bool has_gametakepee() const;
  inline void clear_gametakepee();
  static const int kGameTakePeeFieldNumber = 15;
  inline const ::GLAnsGameTakePee& gametakepee() const;
  inline ::GLAnsGameTakePee* mutable_gametakepee();
  inline ::GLAnsGameTakePee* release_gametakepee();
  
  // optional .GLAnsGameBbuck gameBbuck = 16;
  inline bool has_gamebbuck() const;
  inline void clear_gamebbuck();
  static const int kGameBbuckFieldNumber = 16;
  inline const ::GLAnsGameBbuck& gamebbuck() const;
  inline ::GLAnsGameBbuck* mutable_gamebbuck();
  inline ::GLAnsGameBbuck* release_gamebbuck();
  
  // optional .GLAnsGameSeriseBbuck gameSeriseBbuck = 17;
  inline bool has_gameserisebbuck() const;
  inline void clear_gameserisebbuck();
  static const int kGameSeriseBbuckFieldNumber = 17;
  inline const ::GLAnsGameSeriseBbuck& gameserisebbuck() const;
  inline ::GLAnsGameSeriseBbuck* mutable_gameserisebbuck();
  inline ::GLAnsGameSeriseBbuck* release_gameserisebbuck();
  
  // optional .GLAnsGameBbuckEat gameBbuckEat = 18;
  inline bool has_gamebbuckeat() const;
  inline void clear_gamebbuckeat();
  static const int kGameBbuckEatFieldNumber = 18;
  inline const ::GLAnsGameBbuckEat& gamebbuckeat() const;
  inline ::GLAnsGameBbuckEat* mutable_gamebbuckeat();
  inline ::GLAnsGameBbuckEat* release_gamebbuckeat();
  
  // optional .GLAnsGameBomb gameBomb = 19;
  inline bool has_gamebomb() const;
  inline void clear_gamebomb();
  static const int kGameBombFieldNumber = 19;
  inline const ::GLAnsGameBomb& gamebomb() const;
  inline ::GLAnsGameBomb* mutable_gamebomb();
  inline ::GLAnsGameBomb* release_gamebomb();
  
  // optional .GLAnsGamePan gamePan = 20;
  inline bool has_gamepan() const;
  inline void clear_gamepan();
  static const int kGamePanFieldNumber = 20;
  inline const ::GLAnsGamePan& gamepan() const;
  inline ::GLAnsGamePan* mutable_gamepan();
  inline ::GLAnsGamePan* release_gamepan();
  
  // optional .GLAnsGameDadak gameDadak = 21;
  inline bool has_gamedadak() const;
  inline void clear_gamedadak();
  static const int kGameDadakFieldNumber = 21;
  inline const ::GLAnsGameDadak& gamedadak() const;
  inline ::GLAnsGameDadak* mutable_gamedadak();
  inline ::GLAnsGameDadak* release_gamedadak();
  
  // optional .GLAnsGameJjok gameJjok = 22;
  inline bool has_gamejjok() const;
  inline void clear_gamejjok();
  static const int kGameJjokFieldNumber = 22;
  inline const ::GLAnsGameJjok& gamejjok() const;
  inline ::GLAnsGameJjok* mutable_gamejjok();
  inline ::GLAnsGameJjok* release_gamejjok();
  
  // optional .GLAnsGameUpset gameUpset = 23;
  inline bool has_gameupset() const;
  inline void clear_gameupset();
  static const int kGameUpsetFieldNumber = 23;
  inline const ::GLAnsGameUpset& gameupset() const;
  inline ::GLAnsGameUpset* mutable_gameupset();
  inline ::GLAnsGameUpset* release_gameupset();
  
  // optional .GLAnsGameAllEatUp gameAllEatUp = 24;
  inline bool has_gamealleatup() const;
  inline void clear_gamealleatup();
  static const int kGameAllEatUpFieldNumber = 24;
  inline const ::GLAnsGameAllEatUp& gamealleatup() const;
  inline ::GLAnsGameAllEatUp* mutable_gamealleatup();
  inline ::GLAnsGameAllEatUp* release_gamealleatup();
  
  // optional .GLAnsGameNotiTurn gameNotiTurn = 25;
  inline bool has_gamenotiturn() const;
  inline void clear_gamenotiturn();
  static const int kGameNotiTurnFieldNumber = 25;
  inline const ::GLAnsGameNotiTurn& gamenotiturn() const;
  inline ::GLAnsGameNotiTurn* mutable_gamenotiturn();
  inline ::GLAnsGameNotiTurn* release_gamenotiturn();
  
  // optional .GLAnsGameMoveTen gameMoveTen = 26;
  inline bool has_gamemoveten() const;
  inline void clear_gamemoveten();
  static const int kGameMoveTenFieldNumber = 26;
  inline const ::GLAnsGameMoveTen& gamemoveten() const;
  inline ::GLAnsGameMoveTen* mutable_gamemoveten();
  inline ::GLAnsGameMoveTen* release_gamemoveten();
  
  // optional .GLAnsGameMoveTenAns gameMoveTenAns = 27;
  inline bool has_gamemovetenans() const;
  inline void clear_gamemovetenans();
  static const int kGameMoveTenAnsFieldNumber = 27;
  inline const ::GLAnsGameMoveTenAns& gamemovetenans() const;
  inline ::GLAnsGameMoveTenAns* mutable_gamemovetenans();
  inline ::GLAnsGameMoveTenAns* release_gamemovetenans();
  
  // optional .GLAnsGameChoiceCard gameChoiceCard = 28;
  inline bool has_gamechoicecard() const;
  inline void clear_gamechoicecard();
  static const int kGameChoiceCardFieldNumber = 28;
  inline const ::GLAnsGameChoiceCard& gamechoicecard() const;
  inline ::GLAnsGameChoiceCard* mutable_gamechoicecard();
  inline ::GLAnsGameChoiceCard* release_gamechoicecard();
  
  // optional .GLAnsGameShake gameShake = 29;
  inline bool has_gameshake() const;
  inline void clear_gameshake();
  static const int kGameShakeFieldNumber = 29;
  inline const ::GLAnsGameShake& gameshake() const;
  inline ::GLAnsGameShake* mutable_gameshake();
  inline ::GLAnsGameShake* release_gameshake();
  
  // optional .GLAnsGameShakeAns gameShakeAns = 30;
  inline bool has_gameshakeans() const;
  inline void clear_gameshakeans();
  static const int kGameShakeAnsFieldNumber = 30;
  inline const ::GLAnsGameShakeAns& gameshakeans() const;
  inline ::GLAnsGameShakeAns* mutable_gameshakeans();
  inline ::GLAnsGameShakeAns* release_gameshakeans();
  
  // optional .GLAnsGameShakeCount gameShakeCount = 31;
  inline bool has_gameshakecount() const;
  inline void clear_gameshakecount();
  static const int kGameShakeCountFieldNumber = 31;
  inline const ::GLAnsGameShakeCount& gameshakecount() const;
  inline ::GLAnsGameShakeCount* mutable_gameshakecount();
  inline ::GLAnsGameShakeCount* release_gameshakecount();
  
  // optional .GLAnsGameCapType gameCapType = 32;
  inline bool has_gamecaptype() const;
  inline void clear_gamecaptype();
  static const int kGameCapTypeFieldNumber = 32;
  inline const ::GLAnsGameCapType& gamecaptype() const;
  inline ::GLAnsGameCapType* mutable_gamecaptype();
  inline ::GLAnsGameCapType* release_gamecaptype();
  
  // optional .GLAnsGameGodori gameGodori = 33;
  inline bool has_gamegodori() const;
  inline void clear_gamegodori();
  static const int kGameGodoriFieldNumber = 33;
  inline const ::GLAnsGameGodori& gamegodori() const;
  inline ::GLAnsGameGodori* mutable_gamegodori();
  inline ::GLAnsGameGodori* release_gamegodori();
  
  // optional .GLAnsGameKusa gameKusa = 34;
  inline bool has_gamekusa() const;
  inline void clear_gamekusa();
  static const int kGameKusaFieldNumber = 34;
  inline const ::GLAnsGameKusa& gamekusa() const;
  inline ::GLAnsGameKusa* mutable_gamekusa();
  inline ::GLAnsGameKusa* release_gamekusa();
  
  // optional .GLAnsGameRed gameRed = 35;
  inline bool has_gamered() const;
  inline void clear_gamered();
  static const int kGameRedFieldNumber = 35;
  inline const ::GLAnsGameRed& gamered() const;
  inline ::GLAnsGameRed* mutable_gamered();
  inline ::GLAnsGameRed* release_gamered();
  
  // optional .GLAnsGameBlue gameBlue = 36;
  inline bool has_gameblue() const;
  inline void clear_gameblue();
  static const int kGameBlueFieldNumber = 36;
  inline const ::GLAnsGameBlue& gameblue() const;
  inline ::GLAnsGameBlue* mutable_gameblue();
  inline ::GLAnsGameBlue* release_gameblue();
  
  // optional .GLAnsGameBak gameBak = 37;
  inline bool has_gamebak() const;
  inline void clear_gamebak();
  static const int kGameBakFieldNumber = 37;
  inline const ::GLAnsGameBak& gamebak() const;
  inline ::GLAnsGameBak* mutable_gamebak();
  inline ::GLAnsGameBak* release_gamebak();
  
  // optional .GLAnsGameBakFail gameBakFail = 38;
  inline bool has_gamebakfail() const;
  inline void clear_gamebakfail();
  static const int kGameBakFailFieldNumber = 38;
  inline const ::GLAnsGameBakFail& gamebakfail() const;
  inline ::GLAnsGameBakFail* mutable_gamebakfail();
  inline ::GLAnsGameBakFail* release_gamebakfail();
  
  // optional .GLAnsGameNotiMission gameNotiMission = 39;
  inline bool has_gamenotimission() const;
  inline void clear_gamenotimission();
  static const int kGameNotiMissionFieldNumber = 39;
  inline const ::GLAnsGameNotiMission& gamenotimission() const;
  inline ::GLAnsGameNotiMission* mutable_gamenotimission();
  inline ::GLAnsGameNotiMission* release_gamenotimission();
  
  // optional .GLAnsGameNotiMissionCard gameNotiMissionCard = 40;
  inline bool has_gamenotimissioncard() const;
  inline void clear_gamenotimissioncard();
  static const int kGameNotiMissionCardFieldNumber = 40;
  inline const ::GLAnsGameNotiMissionCard& gamenotimissioncard() const;
  inline ::GLAnsGameNotiMissionCard* mutable_gamenotimissioncard();
  inline ::GLAnsGameNotiMissionCard* release_gamenotimissioncard();
  
  // optional .GLAnsGameMissionState gameMissionState = 41;
  inline bool has_gamemissionstate() const;
  inline void clear_gamemissionstate();
  static const int kGameMissionStateFieldNumber = 41;
  inline const ::GLAnsGameMissionState& gamemissionstate() const;
  inline ::GLAnsGameMissionState* mutable_gamemissionstate();
  inline ::GLAnsGameMissionState* release_gamemissionstate();
  
  // optional .GLAnsGameGostop gameGostop = 42;
  inline bool has_gamegostop() const;
  inline void clear_gamegostop();
  static const int kGameGostopFieldNumber = 42;
  inline const ::GLAnsGameGostop& gamegostop() const;
  inline ::GLAnsGameGostop* mutable_gamegostop();
  inline ::GLAnsGameGostop* release_gamegostop();
  
  // optional .GLAnsGameGostopAns gameGostopAns = 43;
  inline bool has_gamegostopans() const;
  inline void clear_gamegostopans();
  static const int kGameGostopAnsFieldNumber = 43;
  inline const ::GLAnsGameGostopAns& gamegostopans() const;
  inline ::GLAnsGameGostopAns* mutable_gamegostopans();
  inline ::GLAnsGameGostopAns* release_gamegostopans();
  
  // optional .GLAnsGameStopAns gameStopAns = 44;
  inline bool has_gamestopans() const;
  inline void clear_gamestopans();
  static const int kGameStopAnsFieldNumber = 44;
  inline const ::GLAnsGameStopAns& gamestopans() const;
  inline ::GLAnsGameStopAns* mutable_gamestopans();
  inline ::GLAnsGameStopAns* release_gamestopans();
  
  // optional .GLAnsGameResult gameResult = 45;
  inline bool has_gameresult() const;
  inline void clear_gameresult();
  static const int kGameResultFieldNumber = 45;
  inline const ::GLAnsGameResult& gameresult() const;
  inline ::GLAnsGameResult* mutable_gameresult();
  inline ::GLAnsGameResult* release_gameresult();
  
  // optional .GLAnsGameNotiPoint gameNotiPoint = 46;
  inline bool has_gamenotipoint() const;
  inline void clear_gamenotipoint();
  static const int kGameNotiPointFieldNumber = 46;
  inline const ::GLAnsGameNotiPoint& gamenotipoint() const;
  inline ::GLAnsGameNotiPoint* mutable_gamenotipoint();
  inline ::GLAnsGameNotiPoint* release_gamenotipoint();
  
  // optional .GLAnsGameEnd gameEnd = 47;
  inline bool has_gameend() const;
  inline void clear_gameend();
  static const int kGameEndFieldNumber = 47;
  inline const ::GLAnsGameEnd& gameend() const;
  inline ::GLAnsGameEnd* mutable_gameend();
  inline ::GLAnsGameEnd* release_gameend();
  
  // optional .GLAnsGameKick gameKick = 48;
  inline bool has_gamekick() const;
  inline void clear_gamekick();
  static const int kGameKickFieldNumber = 48;
  inline const ::GLAnsGameKick& gamekick() const;
  inline ::GLAnsGameKick* mutable_gamekick();
  inline ::GLAnsGameKick* release_gamekick();
  
  // optional .GLAnsGameEmoti ansGameEmoti = 49;
  inline bool has_ansgameemoti() const;
  inline void clear_ansgameemoti();
  static const int kAnsGameEmotiFieldNumber = 49;
  inline const ::GLAnsGameEmoti& ansgameemoti() const;
  inline ::GLAnsGameEmoti* mutable_ansgameemoti();
  inline ::GLAnsGameEmoti* release_ansgameemoti();
  
  // optional .GLAnsGameAutoPlay ansGameAutoPlay = 50;
  inline bool has_ansgameautoplay() const;
  inline void clear_ansgameautoplay();
  static const int kAnsGameAutoPlayFieldNumber = 50;
  inline const ::GLAnsGameAutoPlay& ansgameautoplay() const;
  inline ::GLAnsGameAutoPlay* mutable_ansgameautoplay();
  inline ::GLAnsGameAutoPlay* release_ansgameautoplay();
  
  // optional .GLAnsGameRelayInfo ansGameRelayInfo = 51;
  inline bool has_ansgamerelayinfo() const;
  inline void clear_ansgamerelayinfo();
  static const int kAnsGameRelayInfoFieldNumber = 51;
  inline const ::GLAnsGameRelayInfo& ansgamerelayinfo() const;
  inline ::GLAnsGameRelayInfo* mutable_ansgamerelayinfo();
  inline ::GLAnsGameRelayInfo* release_ansgamerelayinfo();
  
  // optional .GLAnsExitReservation ansExitReservation = 52;
  inline bool has_ansexitreservation() const;
  inline void clear_ansexitreservation();
  static const int kAnsExitReservationFieldNumber = 52;
  inline const ::GLAnsExitReservation& ansexitreservation() const;
  inline ::GLAnsExitReservation* mutable_ansexitreservation();
  inline ::GLAnsExitReservation* release_ansexitreservation();
  
  // @@protoc_insertion_point(class_scope:GLAnsGameProtocol)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_gamestartready();
  inline void clear_has_gamestartready();
  inline void set_has_gameresetready();
  inline void clear_has_gameresetready();
  inline void set_has_gameinit();
  inline void clear_has_gameinit();
  inline void set_has_gamestart();
  inline void clear_has_gamestart();
  inline void set_has_gamereset();
  inline void clear_has_gamereset();
  inline void set_has_gamenotisun();
  inline void clear_has_gamenotisun();
  inline void set_has_gameselectsun();
  inline void clear_has_gameselectsun();
  inline void set_has_gamenotiselectsun();
  inline void clear_has_gamenotiselectsun();
  inline void set_has_gamesharing();
  inline void clear_has_gamesharing();
  inline void set_has_gamenagari();
  inline void clear_has_gamenagari();
  inline void set_has_gamechongtong();
  inline void clear_has_gamechongtong();
  inline void set_has_gameselectcard();
  inline void clear_has_gameselectcard();
  inline void set_has_gamebonus();
  inline void clear_has_gamebonus();
  inline void set_has_gametakepee();
  inline void clear_has_gametakepee();
  inline void set_has_gamebbuck();
  inline void clear_has_gamebbuck();
  inline void set_has_gameserisebbuck();
  inline void clear_has_gameserisebbuck();
  inline void set_has_gamebbuckeat();
  inline void clear_has_gamebbuckeat();
  inline void set_has_gamebomb();
  inline void clear_has_gamebomb();
  inline void set_has_gamepan();
  inline void clear_has_gamepan();
  inline void set_has_gamedadak();
  inline void clear_has_gamedadak();
  inline void set_has_gamejjok();
  inline void clear_has_gamejjok();
  inline void set_has_gameupset();
  inline void clear_has_gameupset();
  inline void set_has_gamealleatup();
  inline void clear_has_gamealleatup();
  inline void set_has_gamenotiturn();
  inline void clear_has_gamenotiturn();
  inline void set_has_gamemoveten();
  inline void clear_has_gamemoveten();
  inline void set_has_gamemovetenans();
  inline void clear_has_gamemovetenans();
  inline void set_has_gamechoicecard();
  inline void clear_has_gamechoicecard();
  inline void set_has_gameshake();
  inline void clear_has_gameshake();
  inline void set_has_gameshakeans();
  inline void clear_has_gameshakeans();
  inline void set_has_gameshakecount();
  inline void clear_has_gameshakecount();
  inline void set_has_gamecaptype();
  inline void clear_has_gamecaptype();
  inline void set_has_gamegodori();
  inline void clear_has_gamegodori();
  inline void set_has_gamekusa();
  inline void clear_has_gamekusa();
  inline void set_has_gamered();
  inline void clear_has_gamered();
  inline void set_has_gameblue();
  inline void clear_has_gameblue();
  inline void set_has_gamebak();
  inline void clear_has_gamebak();
  inline void set_has_gamebakfail();
  inline void clear_has_gamebakfail();
  inline void set_has_gamenotimission();
  inline void clear_has_gamenotimission();
  inline void set_has_gamenotimissioncard();
  inline void clear_has_gamenotimissioncard();
  inline void set_has_gamemissionstate();
  inline void clear_has_gamemissionstate();
  inline void set_has_gamegostop();
  inline void clear_has_gamegostop();
  inline void set_has_gamegostopans();
  inline void clear_has_gamegostopans();
  inline void set_has_gamestopans();
  inline void clear_has_gamestopans();
  inline void set_has_gameresult();
  inline void clear_has_gameresult();
  inline void set_has_gamenotipoint();
  inline void clear_has_gamenotipoint();
  inline void set_has_gameend();
  inline void clear_has_gameend();
  inline void set_has_gamekick();
  inline void clear_has_gamekick();
  inline void set_has_ansgameemoti();
  inline void clear_has_ansgameemoti();
  inline void set_has_ansgameautoplay();
  inline void clear_has_ansgameautoplay();
  inline void set_has_ansgamerelayinfo();
  inline void clear_has_ansgamerelayinfo();
  inline void set_has_ansexitreservation();
  inline void clear_has_ansexitreservation();
  
  ::GLAnsGameStartReady* gamestartready_;
  ::GLAnsGameResetReady* gameresetready_;
  ::GLAnsGameInit* gameinit_;
  ::GLAnsGameStart* gamestart_;
  ::GLAnsGameReset* gamereset_;
  ::GLAnsGameNotiSun* gamenotisun_;
  ::GLAnsGameSelectSun* gameselectsun_;
  ::GLAnsGameNotiSelectSun* gamenotiselectsun_;
  ::GLAnsGameSharing* gamesharing_;
  ::GLAnsGameNagari* gamenagari_;
  ::GLAnsGameChongTong* gamechongtong_;
  ::GLAnsGameSelectCard* gameselectcard_;
  ::GLAnsGameBonus* gamebonus_;
  ::GLAnsGameTakePee* gametakepee_;
  ::GLAnsGameBbuck* gamebbuck_;
  ::GLAnsGameSeriseBbuck* gameserisebbuck_;
  ::GLAnsGameBbuckEat* gamebbuckeat_;
  ::GLAnsGameBomb* gamebomb_;
  ::GLAnsGamePan* gamepan_;
  ::GLAnsGameDadak* gamedadak_;
  ::GLAnsGameJjok* gamejjok_;
  ::GLAnsGameUpset* gameupset_;
  ::GLAnsGameAllEatUp* gamealleatup_;
  ::GLAnsGameNotiTurn* gamenotiturn_;
  ::GLAnsGameMoveTen* gamemoveten_;
  ::GLAnsGameMoveTenAns* gamemovetenans_;
  ::GLAnsGameChoiceCard* gamechoicecard_;
  ::GLAnsGameShake* gameshake_;
  ::GLAnsGameShakeAns* gameshakeans_;
  ::GLAnsGameShakeCount* gameshakecount_;
  ::GLAnsGameCapType* gamecaptype_;
  ::GLAnsGameGodori* gamegodori_;
  ::GLAnsGameKusa* gamekusa_;
  ::GLAnsGameRed* gamered_;
  ::GLAnsGameBlue* gameblue_;
  ::GLAnsGameBak* gamebak_;
  ::GLAnsGameBakFail* gamebakfail_;
  ::GLAnsGameNotiMission* gamenotimission_;
  ::GLAnsGameNotiMissionCard* gamenotimissioncard_;
  ::GLAnsGameMissionState* gamemissionstate_;
  ::GLAnsGameGostop* gamegostop_;
  ::GLAnsGameGostopAns* gamegostopans_;
  ::GLAnsGameStopAns* gamestopans_;
  ::GLAnsGameResult* gameresult_;
  ::GLAnsGameNotiPoint* gamenotipoint_;
  ::GLAnsGameEnd* gameend_;
  ::GLAnsGameKick* gamekick_;
  ::GLAnsGameEmoti* ansgameemoti_;
  ::GLAnsGameAutoPlay* ansgameautoplay_;
  ::GLAnsGameRelayInfo* ansgamerelayinfo_;
  ::GLAnsExitReservation* ansexitreservation_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(52 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLAnsGameProtocol* default_instance_;
};
// -------------------------------------------------------------------

class GLReqGameProtocol : public ::google::protobuf::MessageLite {
 public:
  GLReqGameProtocol();
  virtual ~GLReqGameProtocol();
  
  GLReqGameProtocol(const GLReqGameProtocol& from);
  
  inline GLReqGameProtocol& operator=(const GLReqGameProtocol& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GLReqGameProtocol& default_instance();
  
  void Swap(GLReqGameProtocol* other);
  
  // implements Message ----------------------------------------------
  
  GLReqGameProtocol* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GLReqGameProtocol& from);
  void MergeFrom(const GLReqGameProtocol& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef GLReqGameProtocol_Type Type;
  static const Type NONE = GLReqGameProtocol_Type_NONE;
  static const Type REQ_GAME_READY = GLReqGameProtocol_Type_REQ_GAME_READY;
  static const Type REQ_GAME_RESETREADY = GLReqGameProtocol_Type_REQ_GAME_RESETREADY;
  static const Type REQ_GAME_INITGAME = GLReqGameProtocol_Type_REQ_GAME_INITGAME;
  static const Type REQ_GAME_RESET = GLReqGameProtocol_Type_REQ_GAME_RESET;
  static const Type REQ_GAME_START = GLReqGameProtocol_Type_REQ_GAME_START;
  static const Type REQ_GAME_SELECTSUNCARD = GLReqGameProtocol_Type_REQ_GAME_SELECTSUNCARD;
  static const Type REQ_GAME_SELECTCARD = GLReqGameProtocol_Type_REQ_GAME_SELECTCARD;
  static const Type REQ_GAME_ASKGOSTOPANS = GLReqGameProtocol_Type_REQ_GAME_ASKGOSTOPANS;
  static const Type REQ_GAME_ASKSHAKEANS = GLReqGameProtocol_Type_REQ_GAME_ASKSHAKEANS;
  static const Type REQ_GAME_CHOICECARDANS = GLReqGameProtocol_Type_REQ_GAME_CHOICECARDANS;
  static const Type REQ_GAME_MOVETEN = GLReqGameProtocol_Type_REQ_GAME_MOVETEN;
  static const Type REQ_GAME_CHONGTONG = GLReqGameProtocol_Type_REQ_GAME_CHONGTONG;
  static const Type REQ_GAME_END = GLReqGameProtocol_Type_REQ_GAME_END;
  static const Type REQ_GAME_RESULTOK = GLReqGameProtocol_Type_REQ_GAME_RESULTOK;
  static const Type REQ_GAME_AUTOPLAY = GLReqGameProtocol_Type_REQ_GAME_AUTOPLAY;
  static const Type REQ_GAME_EMOTI = GLReqGameProtocol_Type_REQ_GAME_EMOTI;
  static const Type REQ_GAME_EXITRESERVATION = GLReqGameProtocol_Type_REQ_GAME_EXITRESERVATION;
  static const Type REQ_GAME_RELAYINFO = GLReqGameProtocol_Type_REQ_GAME_RELAYINFO;
  static const Type REQ_GAME_INITGAMETAN = GLReqGameProtocol_Type_REQ_GAME_INITGAMETAN;
  static const Type REQ_GAME_TEST_PACKET = GLReqGameProtocol_Type_REQ_GAME_TEST_PACKET;
  static inline bool Type_IsValid(int value) {
    return GLReqGameProtocol_Type_IsValid(value);
  }
  static const Type Type_MIN =
    GLReqGameProtocol_Type_Type_MIN;
  static const Type Type_MAX =
    GLReqGameProtocol_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    GLReqGameProtocol_Type_Type_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required .GLReqGameProtocol.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::GLReqGameProtocol_Type type() const;
  inline void set_type(::GLReqGameProtocol_Type value);
  
  // optional .GLReqGameReady reqGameReady = 2;
  inline bool has_reqgameready() const;
  inline void clear_reqgameready();
  static const int kReqGameReadyFieldNumber = 2;
  inline const ::GLReqGameReady& reqgameready() const;
  inline ::GLReqGameReady* mutable_reqgameready();
  inline ::GLReqGameReady* release_reqgameready();
  
  // optional .GLReqResetReady reqResetReady = 3;
  inline bool has_reqresetready() const;
  inline void clear_reqresetready();
  static const int kReqResetReadyFieldNumber = 3;
  inline const ::GLReqResetReady& reqresetready() const;
  inline ::GLReqResetReady* mutable_reqresetready();
  inline ::GLReqResetReady* release_reqresetready();
  
  // optional .GLReqGameInitGame reqInitGame = 4;
  inline bool has_reqinitgame() const;
  inline void clear_reqinitgame();
  static const int kReqInitGameFieldNumber = 4;
  inline const ::GLReqGameInitGame& reqinitgame() const;
  inline ::GLReqGameInitGame* mutable_reqinitgame();
  inline ::GLReqGameInitGame* release_reqinitgame();
  
  // optional .GLReqGameReset reqReset = 5;
  inline bool has_reqreset() const;
  inline void clear_reqreset();
  static const int kReqResetFieldNumber = 5;
  inline const ::GLReqGameReset& reqreset() const;
  inline ::GLReqGameReset* mutable_reqreset();
  inline ::GLReqGameReset* release_reqreset();
  
  // optional .GLReqGameStart reqStart = 6;
  inline bool has_reqstart() const;
  inline void clear_reqstart();
  static const int kReqStartFieldNumber = 6;
  inline const ::GLReqGameStart& reqstart() const;
  inline ::GLReqGameStart* mutable_reqstart();
  inline ::GLReqGameStart* release_reqstart();
  
  // optional .GLReqGameSelectSunCard reqSelectSunCard = 7;
  inline bool has_reqselectsuncard() const;
  inline void clear_reqselectsuncard();
  static const int kReqSelectSunCardFieldNumber = 7;
  inline const ::GLReqGameSelectSunCard& reqselectsuncard() const;
  inline ::GLReqGameSelectSunCard* mutable_reqselectsuncard();
  inline ::GLReqGameSelectSunCard* release_reqselectsuncard();
  
  // optional .GLReqGameSelectCard reqSelectCard = 8;
  inline bool has_reqselectcard() const;
  inline void clear_reqselectcard();
  static const int kReqSelectCardFieldNumber = 8;
  inline const ::GLReqGameSelectCard& reqselectcard() const;
  inline ::GLReqGameSelectCard* mutable_reqselectcard();
  inline ::GLReqGameSelectCard* release_reqselectcard();
  
  // optional .GLReqGameAskGoStopAns reqAskGoStopAns = 9;
  inline bool has_reqaskgostopans() const;
  inline void clear_reqaskgostopans();
  static const int kReqAskGoStopAnsFieldNumber = 9;
  inline const ::GLReqGameAskGoStopAns& reqaskgostopans() const;
  inline ::GLReqGameAskGoStopAns* mutable_reqaskgostopans();
  inline ::GLReqGameAskGoStopAns* release_reqaskgostopans();
  
  // optional .GLReqGameAskShakeAns reqAskShakeAns = 10;
  inline bool has_reqaskshakeans() const;
  inline void clear_reqaskshakeans();
  static const int kReqAskShakeAnsFieldNumber = 10;
  inline const ::GLReqGameAskShakeAns& reqaskshakeans() const;
  inline ::GLReqGameAskShakeAns* mutable_reqaskshakeans();
  inline ::GLReqGameAskShakeAns* release_reqaskshakeans();
  
  // optional .GLReqGameChoiceCardAns reqChoiceCardAns = 11;
  inline bool has_reqchoicecardans() const;
  inline void clear_reqchoicecardans();
  static const int kReqChoiceCardAnsFieldNumber = 11;
  inline const ::GLReqGameChoiceCardAns& reqchoicecardans() const;
  inline ::GLReqGameChoiceCardAns* mutable_reqchoicecardans();
  inline ::GLReqGameChoiceCardAns* release_reqchoicecardans();
  
  // optional .GLReqGameMoveTen reqMoveTen = 12;
  inline bool has_reqmoveten() const;
  inline void clear_reqmoveten();
  static const int kReqMoveTenFieldNumber = 12;
  inline const ::GLReqGameMoveTen& reqmoveten() const;
  inline ::GLReqGameMoveTen* mutable_reqmoveten();
  inline ::GLReqGameMoveTen* release_reqmoveten();
  
  // optional .GLReqGameChongTong reqChongTong = 13;
  inline bool has_reqchongtong() const;
  inline void clear_reqchongtong();
  static const int kReqChongTongFieldNumber = 13;
  inline const ::GLReqGameChongTong& reqchongtong() const;
  inline ::GLReqGameChongTong* mutable_reqchongtong();
  inline ::GLReqGameChongTong* release_reqchongtong();
  
  // optional .GLReqGameEnd reqGameEnd = 14;
  inline bool has_reqgameend() const;
  inline void clear_reqgameend();
  static const int kReqGameEndFieldNumber = 14;
  inline const ::GLReqGameEnd& reqgameend() const;
  inline ::GLReqGameEnd* mutable_reqgameend();
  inline ::GLReqGameEnd* release_reqgameend();
  
  // optional .GLReqResultOk reqResultOk = 15;
  inline bool has_reqresultok() const;
  inline void clear_reqresultok();
  static const int kReqResultOkFieldNumber = 15;
  inline const ::GLReqResultOk& reqresultok() const;
  inline ::GLReqResultOk* mutable_reqresultok();
  inline ::GLReqResultOk* release_reqresultok();
  
  // optional .GLReqGameAutoPlay reqGameAutoPlay = 16;
  inline bool has_reqgameautoplay() const;
  inline void clear_reqgameautoplay();
  static const int kReqGameAutoPlayFieldNumber = 16;
  inline const ::GLReqGameAutoPlay& reqgameautoplay() const;
  inline ::GLReqGameAutoPlay* mutable_reqgameautoplay();
  inline ::GLReqGameAutoPlay* release_reqgameautoplay();
  
  // optional .GLReqGameEmoti reqGameEmoti = 17;
  inline bool has_reqgameemoti() const;
  inline void clear_reqgameemoti();
  static const int kReqGameEmotiFieldNumber = 17;
  inline const ::GLReqGameEmoti& reqgameemoti() const;
  inline ::GLReqGameEmoti* mutable_reqgameemoti();
  inline ::GLReqGameEmoti* release_reqgameemoti();
  
  // optional .GLReqExitReservation reqExitReservation = 18;
  inline bool has_reqexitreservation() const;
  inline void clear_reqexitreservation();
  static const int kReqExitReservationFieldNumber = 18;
  inline const ::GLReqExitReservation& reqexitreservation() const;
  inline ::GLReqExitReservation* mutable_reqexitreservation();
  inline ::GLReqExitReservation* release_reqexitreservation();
  
  // optional .GLReqRelayInfo reqRelayInfo = 19;
  inline bool has_reqrelayinfo() const;
  inline void clear_reqrelayinfo();
  static const int kReqRelayInfoFieldNumber = 19;
  inline const ::GLReqRelayInfo& reqrelayinfo() const;
  inline ::GLReqRelayInfo* mutable_reqrelayinfo();
  inline ::GLReqRelayInfo* release_reqrelayinfo();
  
  // optional .GLReqGameInitGameTan reqTanInit = 20;
  inline bool has_reqtaninit() const;
  inline void clear_reqtaninit();
  static const int kReqTanInitFieldNumber = 20;
  inline const ::GLReqGameInitGameTan& reqtaninit() const;
  inline ::GLReqGameInitGameTan* mutable_reqtaninit();
  inline ::GLReqGameInitGameTan* release_reqtaninit();
  
  // optional .G_REQ_GAME_TEST_PACKET g_REQ_GAME_TEST_PACKET = 21;
  inline bool has_g_req_game_test_packet() const;
  inline void clear_g_req_game_test_packet();
  static const int kGREQGAMETESTPACKETFieldNumber = 21;
  inline const ::G_REQ_GAME_TEST_PACKET& g_req_game_test_packet() const;
  inline ::G_REQ_GAME_TEST_PACKET* mutable_g_req_game_test_packet();
  inline ::G_REQ_GAME_TEST_PACKET* release_g_req_game_test_packet();
  
  // @@protoc_insertion_point(class_scope:GLReqGameProtocol)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_reqgameready();
  inline void clear_has_reqgameready();
  inline void set_has_reqresetready();
  inline void clear_has_reqresetready();
  inline void set_has_reqinitgame();
  inline void clear_has_reqinitgame();
  inline void set_has_reqreset();
  inline void clear_has_reqreset();
  inline void set_has_reqstart();
  inline void clear_has_reqstart();
  inline void set_has_reqselectsuncard();
  inline void clear_has_reqselectsuncard();
  inline void set_has_reqselectcard();
  inline void clear_has_reqselectcard();
  inline void set_has_reqaskgostopans();
  inline void clear_has_reqaskgostopans();
  inline void set_has_reqaskshakeans();
  inline void clear_has_reqaskshakeans();
  inline void set_has_reqchoicecardans();
  inline void clear_has_reqchoicecardans();
  inline void set_has_reqmoveten();
  inline void clear_has_reqmoveten();
  inline void set_has_reqchongtong();
  inline void clear_has_reqchongtong();
  inline void set_has_reqgameend();
  inline void clear_has_reqgameend();
  inline void set_has_reqresultok();
  inline void clear_has_reqresultok();
  inline void set_has_reqgameautoplay();
  inline void clear_has_reqgameautoplay();
  inline void set_has_reqgameemoti();
  inline void clear_has_reqgameemoti();
  inline void set_has_reqexitreservation();
  inline void clear_has_reqexitreservation();
  inline void set_has_reqrelayinfo();
  inline void clear_has_reqrelayinfo();
  inline void set_has_reqtaninit();
  inline void clear_has_reqtaninit();
  inline void set_has_g_req_game_test_packet();
  inline void clear_has_g_req_game_test_packet();
  
  ::GLReqGameReady* reqgameready_;
  ::GLReqResetReady* reqresetready_;
  ::GLReqGameInitGame* reqinitgame_;
  ::GLReqGameReset* reqreset_;
  ::GLReqGameStart* reqstart_;
  ::GLReqGameSelectSunCard* reqselectsuncard_;
  ::GLReqGameSelectCard* reqselectcard_;
  ::GLReqGameAskGoStopAns* reqaskgostopans_;
  ::GLReqGameAskShakeAns* reqaskshakeans_;
  ::GLReqGameChoiceCardAns* reqchoicecardans_;
  ::GLReqGameMoveTen* reqmoveten_;
  ::GLReqGameChongTong* reqchongtong_;
  ::GLReqGameEnd* reqgameend_;
  ::GLReqResultOk* reqresultok_;
  ::GLReqGameAutoPlay* reqgameautoplay_;
  ::GLReqGameEmoti* reqgameemoti_;
  ::GLReqExitReservation* reqexitreservation_;
  ::GLReqRelayInfo* reqrelayinfo_;
  ::GLReqGameInitGameTan* reqtaninit_;
  ::G_REQ_GAME_TEST_PACKET* g_req_game_test_packet_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(21 + 31) / 32];
  
  friend void  protobuf_AddDesc_gameLogic_2eproto();
  friend void protobuf_AssignDesc_gameLogic_2eproto();
  friend void protobuf_ShutdownFile_gameLogic_2eproto();
  
  void InitAsDefaultInstance();
  static GLReqGameProtocol* default_instance_;
};
// ===================================================================


// ===================================================================

// GameUserInfo

// required .GameInfo gameInfo = 1;
inline bool GameUserInfo::has_gameinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameUserInfo::set_has_gameinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameUserInfo::clear_has_gameinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameUserInfo::clear_gameinfo() {
  if (gameinfo_ != NULL) gameinfo_->::GameInfo::Clear();
  clear_has_gameinfo();
}
inline const ::GameInfo& GameUserInfo::gameinfo() const {
  return gameinfo_ != NULL ? *gameinfo_ : *default_instance_->gameinfo_;
}
inline ::GameInfo* GameUserInfo::mutable_gameinfo() {
  set_has_gameinfo();
  if (gameinfo_ == NULL) gameinfo_ = new ::GameInfo;
  return gameinfo_;
}
inline ::GameInfo* GameUserInfo::release_gameinfo() {
  clear_has_gameinfo();
  ::GameInfo* temp = gameinfo_;
  gameinfo_ = NULL;
  return temp;
}

// required .MemberInfo memberInfo = 2;
inline bool GameUserInfo::has_memberinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameUserInfo::set_has_memberinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameUserInfo::clear_has_memberinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameUserInfo::clear_memberinfo() {
  if (memberinfo_ != NULL) memberinfo_->::MemberInfo::Clear();
  clear_has_memberinfo();
}
inline const ::MemberInfo& GameUserInfo::memberinfo() const {
  return memberinfo_ != NULL ? *memberinfo_ : *default_instance_->memberinfo_;
}
inline ::MemberInfo* GameUserInfo::mutable_memberinfo() {
  set_has_memberinfo();
  if (memberinfo_ == NULL) memberinfo_ = new ::MemberInfo;
  return memberinfo_;
}
inline ::MemberInfo* GameUserInfo::release_memberinfo() {
  clear_has_memberinfo();
  ::MemberInfo* temp = memberinfo_;
  memberinfo_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// GameRoomInfo

// required int32 roomID = 1;
inline bool GameRoomInfo::has_roomid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameRoomInfo::set_has_roomid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameRoomInfo::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameRoomInfo::clear_roomid() {
  roomid_ = 0;
  clear_has_roomid();
}
inline ::google::protobuf::int32 GameRoomInfo::roomid() const {
  return roomid_;
}
inline void GameRoomInfo::set_roomid(::google::protobuf::int32 value) {
  set_has_roomid();
  roomid_ = value;
}

// required int32 pointMoney = 2;
inline bool GameRoomInfo::has_pointmoney() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameRoomInfo::set_has_pointmoney() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameRoomInfo::clear_has_pointmoney() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameRoomInfo::clear_pointmoney() {
  pointmoney_ = 0;
  clear_has_pointmoney();
}
inline ::google::protobuf::int32 GameRoomInfo::pointmoney() const {
  return pointmoney_;
}
inline void GameRoomInfo::set_pointmoney(::google::protobuf::int32 value) {
  set_has_pointmoney();
  pointmoney_ = value;
}

// repeated .GameUserInfo gameUserInfo = 3;
inline int GameRoomInfo::gameuserinfo_size() const {
  return gameuserinfo_.size();
}
inline void GameRoomInfo::clear_gameuserinfo() {
  gameuserinfo_.Clear();
}
inline const ::GameUserInfo& GameRoomInfo::gameuserinfo(int index) const {
  return gameuserinfo_.Get(index);
}
inline ::GameUserInfo* GameRoomInfo::mutable_gameuserinfo(int index) {
  return gameuserinfo_.Mutable(index);
}
inline ::GameUserInfo* GameRoomInfo::add_gameuserinfo() {
  return gameuserinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::GameUserInfo >&
GameRoomInfo::gameuserinfo() const {
  return gameuserinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::GameUserInfo >*
GameRoomInfo::mutable_gameuserinfo() {
  return &gameuserinfo_;
}

// -------------------------------------------------------------------

// GameInfo

// required int32 gameID = 1;
inline bool GameInfo::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameInfo::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameInfo::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameInfo::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GameInfo::gameid() const {
  return gameid_;
}
inline void GameInfo::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GameInfo::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameInfo::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameInfo::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameInfo::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GameInfo::gameindex() const {
  return gameindex_;
}
inline void GameInfo::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// required int32 level = 3;
inline bool GameInfo::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameInfo::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameInfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameInfo::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 GameInfo::level() const {
  return level_;
}
inline void GameInfo::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// required int32 exp = 4;
inline bool GameInfo::has_exp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameInfo::set_has_exp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameInfo::clear_has_exp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameInfo::clear_exp() {
  exp_ = 0;
  clear_has_exp();
}
inline ::google::protobuf::int32 GameInfo::exp() const {
  return exp_;
}
inline void GameInfo::set_exp(::google::protobuf::int32 value) {
  set_has_exp();
  exp_ = value;
}

// required string money = 5;
inline bool GameInfo::has_money() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameInfo::set_has_money() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameInfo::clear_has_money() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameInfo::clear_money() {
  if (money_ != &::google::protobuf::internal::kEmptyString) {
    money_->clear();
  }
  clear_has_money();
}
inline const ::std::string& GameInfo::money() const {
  return *money_;
}
inline void GameInfo::set_money(const ::std::string& value) {
  set_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    money_ = new ::std::string;
  }
  money_->assign(value);
}
inline void GameInfo::set_money(const char* value) {
  set_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    money_ = new ::std::string;
  }
  money_->assign(value);
}
inline void GameInfo::set_money(const char* value, size_t size) {
  set_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    money_ = new ::std::string;
  }
  money_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameInfo::mutable_money() {
  set_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    money_ = new ::std::string;
  }
  return money_;
}
inline ::std::string* GameInfo::release_money() {
  clear_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = money_;
    money_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 winCnt = 6;
inline bool GameInfo::has_wincnt() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GameInfo::set_has_wincnt() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GameInfo::clear_has_wincnt() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GameInfo::clear_wincnt() {
  wincnt_ = 0;
  clear_has_wincnt();
}
inline ::google::protobuf::int32 GameInfo::wincnt() const {
  return wincnt_;
}
inline void GameInfo::set_wincnt(::google::protobuf::int32 value) {
  set_has_wincnt();
  wincnt_ = value;
}

// required int32 loseCnt = 7;
inline bool GameInfo::has_losecnt() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GameInfo::set_has_losecnt() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GameInfo::clear_has_losecnt() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GameInfo::clear_losecnt() {
  losecnt_ = 0;
  clear_has_losecnt();
}
inline ::google::protobuf::int32 GameInfo::losecnt() const {
  return losecnt_;
}
inline void GameInfo::set_losecnt(::google::protobuf::int32 value) {
  set_has_losecnt();
  losecnt_ = value;
}

// required int32 allInCnt = 8;
inline bool GameInfo::has_allincnt() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GameInfo::set_has_allincnt() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GameInfo::clear_has_allincnt() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GameInfo::clear_allincnt() {
  allincnt_ = 0;
  clear_has_allincnt();
}
inline ::google::protobuf::int32 GameInfo::allincnt() const {
  return allincnt_;
}
inline void GameInfo::set_allincnt(::google::protobuf::int32 value) {
  set_has_allincnt();
  allincnt_ = value;
}

// required string highMoney = 9;
inline bool GameInfo::has_highmoney() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GameInfo::set_has_highmoney() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GameInfo::clear_has_highmoney() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GameInfo::clear_highmoney() {
  if (highmoney_ != &::google::protobuf::internal::kEmptyString) {
    highmoney_->clear();
  }
  clear_has_highmoney();
}
inline const ::std::string& GameInfo::highmoney() const {
  return *highmoney_;
}
inline void GameInfo::set_highmoney(const ::std::string& value) {
  set_has_highmoney();
  if (highmoney_ == &::google::protobuf::internal::kEmptyString) {
    highmoney_ = new ::std::string;
  }
  highmoney_->assign(value);
}
inline void GameInfo::set_highmoney(const char* value) {
  set_has_highmoney();
  if (highmoney_ == &::google::protobuf::internal::kEmptyString) {
    highmoney_ = new ::std::string;
  }
  highmoney_->assign(value);
}
inline void GameInfo::set_highmoney(const char* value, size_t size) {
  set_has_highmoney();
  if (highmoney_ == &::google::protobuf::internal::kEmptyString) {
    highmoney_ = new ::std::string;
  }
  highmoney_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameInfo::mutable_highmoney() {
  set_has_highmoney();
  if (highmoney_ == &::google::protobuf::internal::kEmptyString) {
    highmoney_ = new ::std::string;
  }
  return highmoney_;
}
inline ::std::string* GameInfo::release_highmoney() {
  clear_has_highmoney();
  if (highmoney_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = highmoney_;
    highmoney_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 highPoint = 10;
inline bool GameInfo::has_highpoint() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GameInfo::set_has_highpoint() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GameInfo::clear_has_highpoint() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GameInfo::clear_highpoint() {
  highpoint_ = 0;
  clear_has_highpoint();
}
inline ::google::protobuf::int32 GameInfo::highpoint() const {
  return highpoint_;
}
inline void GameInfo::set_highpoint(::google::protobuf::int32 value) {
  set_has_highpoint();
  highpoint_ = value;
}

// required int32 todayWin = 11;
inline bool GameInfo::has_todaywin() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GameInfo::set_has_todaywin() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GameInfo::clear_has_todaywin() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GameInfo::clear_todaywin() {
  todaywin_ = 0;
  clear_has_todaywin();
}
inline ::google::protobuf::int32 GameInfo::todaywin() const {
  return todaywin_;
}
inline void GameInfo::set_todaywin(::google::protobuf::int32 value) {
  set_has_todaywin();
  todaywin_ = value;
}

// required int32 todayLose = 12;
inline bool GameInfo::has_todaylose() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GameInfo::set_has_todaylose() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GameInfo::clear_has_todaylose() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GameInfo::clear_todaylose() {
  todaylose_ = 0;
  clear_has_todaylose();
}
inline ::google::protobuf::int32 GameInfo::todaylose() const {
  return todaylose_;
}
inline void GameInfo::set_todaylose(::google::protobuf::int32 value) {
  set_has_todaylose();
  todaylose_ = value;
}

// required int32 todayHighPoint = 13;
inline bool GameInfo::has_todayhighpoint() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GameInfo::set_has_todayhighpoint() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GameInfo::clear_has_todayhighpoint() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GameInfo::clear_todayhighpoint() {
  todayhighpoint_ = 0;
  clear_has_todayhighpoint();
}
inline ::google::protobuf::int32 GameInfo::todayhighpoint() const {
  return todayhighpoint_;
}
inline void GameInfo::set_todayhighpoint(::google::protobuf::int32 value) {
  set_has_todayhighpoint();
  todayhighpoint_ = value;
}

// required string todayHighMoney = 14;
inline bool GameInfo::has_todayhighmoney() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void GameInfo::set_has_todayhighmoney() {
  _has_bits_[0] |= 0x00002000u;
}
inline void GameInfo::clear_has_todayhighmoney() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void GameInfo::clear_todayhighmoney() {
  if (todayhighmoney_ != &::google::protobuf::internal::kEmptyString) {
    todayhighmoney_->clear();
  }
  clear_has_todayhighmoney();
}
inline const ::std::string& GameInfo::todayhighmoney() const {
  return *todayhighmoney_;
}
inline void GameInfo::set_todayhighmoney(const ::std::string& value) {
  set_has_todayhighmoney();
  if (todayhighmoney_ == &::google::protobuf::internal::kEmptyString) {
    todayhighmoney_ = new ::std::string;
  }
  todayhighmoney_->assign(value);
}
inline void GameInfo::set_todayhighmoney(const char* value) {
  set_has_todayhighmoney();
  if (todayhighmoney_ == &::google::protobuf::internal::kEmptyString) {
    todayhighmoney_ = new ::std::string;
  }
  todayhighmoney_->assign(value);
}
inline void GameInfo::set_todayhighmoney(const char* value, size_t size) {
  set_has_todayhighmoney();
  if (todayhighmoney_ == &::google::protobuf::internal::kEmptyString) {
    todayhighmoney_ = new ::std::string;
  }
  todayhighmoney_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameInfo::mutable_todayhighmoney() {
  set_has_todayhighmoney();
  if (todayhighmoney_ == &::google::protobuf::internal::kEmptyString) {
    todayhighmoney_ = new ::std::string;
  }
  return todayhighmoney_;
}
inline ::std::string* GameInfo::release_todayhighmoney() {
  clear_has_todayhighmoney();
  if (todayhighmoney_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = todayhighmoney_;
    todayhighmoney_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 todayAllinCnt = 15;
inline bool GameInfo::has_todayallincnt() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void GameInfo::set_has_todayallincnt() {
  _has_bits_[0] |= 0x00004000u;
}
inline void GameInfo::clear_has_todayallincnt() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void GameInfo::clear_todayallincnt() {
  todayallincnt_ = 0;
  clear_has_todayallincnt();
}
inline ::google::protobuf::int32 GameInfo::todayallincnt() const {
  return todayallincnt_;
}
inline void GameInfo::set_todayallincnt(::google::protobuf::int32 value) {
  set_has_todayallincnt();
  todayallincnt_ = value;
}

// required int32 todayRefill = 16;
inline bool GameInfo::has_todayrefill() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void GameInfo::set_has_todayrefill() {
  _has_bits_[0] |= 0x00008000u;
}
inline void GameInfo::clear_has_todayrefill() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void GameInfo::clear_todayrefill() {
  todayrefill_ = 0;
  clear_has_todayrefill();
}
inline ::google::protobuf::int32 GameInfo::todayrefill() const {
  return todayrefill_;
}
inline void GameInfo::set_todayrefill(::google::protobuf::int32 value) {
  set_has_todayrefill();
  todayrefill_ = value;
}

// required string safeMoney = 17;
inline bool GameInfo::has_safemoney() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void GameInfo::set_has_safemoney() {
  _has_bits_[0] |= 0x00010000u;
}
inline void GameInfo::clear_has_safemoney() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void GameInfo::clear_safemoney() {
  if (safemoney_ != &::google::protobuf::internal::kEmptyString) {
    safemoney_->clear();
  }
  clear_has_safemoney();
}
inline const ::std::string& GameInfo::safemoney() const {
  return *safemoney_;
}
inline void GameInfo::set_safemoney(const ::std::string& value) {
  set_has_safemoney();
  if (safemoney_ == &::google::protobuf::internal::kEmptyString) {
    safemoney_ = new ::std::string;
  }
  safemoney_->assign(value);
}
inline void GameInfo::set_safemoney(const char* value) {
  set_has_safemoney();
  if (safemoney_ == &::google::protobuf::internal::kEmptyString) {
    safemoney_ = new ::std::string;
  }
  safemoney_->assign(value);
}
inline void GameInfo::set_safemoney(const char* value, size_t size) {
  set_has_safemoney();
  if (safemoney_ == &::google::protobuf::internal::kEmptyString) {
    safemoney_ = new ::std::string;
  }
  safemoney_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameInfo::mutable_safemoney() {
  set_has_safemoney();
  if (safemoney_ == &::google::protobuf::internal::kEmptyString) {
    safemoney_ = new ::std::string;
  }
  return safemoney_;
}
inline ::std::string* GameInfo::release_safemoney() {
  clear_has_safemoney();
  if (safemoney_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = safemoney_;
    safemoney_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// MoneyInfo

// required int32 gameID = 1;
inline bool MoneyInfo::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneyInfo::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoneyInfo::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoneyInfo::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 MoneyInfo::gameid() const {
  return gameid_;
}
inline void MoneyInfo::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required string money = 2;
inline bool MoneyInfo::has_money() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneyInfo::set_has_money() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoneyInfo::clear_has_money() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoneyInfo::clear_money() {
  if (money_ != &::google::protobuf::internal::kEmptyString) {
    money_->clear();
  }
  clear_has_money();
}
inline const ::std::string& MoneyInfo::money() const {
  return *money_;
}
inline void MoneyInfo::set_money(const ::std::string& value) {
  set_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    money_ = new ::std::string;
  }
  money_->assign(value);
}
inline void MoneyInfo::set_money(const char* value) {
  set_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    money_ = new ::std::string;
  }
  money_->assign(value);
}
inline void MoneyInfo::set_money(const char* value, size_t size) {
  set_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    money_ = new ::std::string;
  }
  money_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MoneyInfo::mutable_money() {
  set_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    money_ = new ::std::string;
  }
  return money_;
}
inline ::std::string* MoneyInfo::release_money() {
  clear_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = money_;
    money_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GameUpdateInfo

// repeated .GameInfo gameInfo = 1;
inline int GameUpdateInfo::gameinfo_size() const {
  return gameinfo_.size();
}
inline void GameUpdateInfo::clear_gameinfo() {
  gameinfo_.Clear();
}
inline const ::GameInfo& GameUpdateInfo::gameinfo(int index) const {
  return gameinfo_.Get(index);
}
inline ::GameInfo* GameUpdateInfo::mutable_gameinfo(int index) {
  return gameinfo_.Mutable(index);
}
inline ::GameInfo* GameUpdateInfo::add_gameinfo() {
  return gameinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::GameInfo >&
GameUpdateInfo::gameinfo() const {
  return gameinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::GameInfo >*
GameUpdateInfo::mutable_gameinfo() {
  return &gameinfo_;
}

// repeated .MoneyInfo moneyInfo = 2;
inline int GameUpdateInfo::moneyinfo_size() const {
  return moneyinfo_.size();
}
inline void GameUpdateInfo::clear_moneyinfo() {
  moneyinfo_.Clear();
}
inline const ::MoneyInfo& GameUpdateInfo::moneyinfo(int index) const {
  return moneyinfo_.Get(index);
}
inline ::MoneyInfo* GameUpdateInfo::mutable_moneyinfo(int index) {
  return moneyinfo_.Mutable(index);
}
inline ::MoneyInfo* GameUpdateInfo::add_moneyinfo() {
  return moneyinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MoneyInfo >&
GameUpdateInfo::moneyinfo() const {
  return moneyinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::MoneyInfo >*
GameUpdateInfo::mutable_moneyinfo() {
  return &moneyinfo_;
}

// -------------------------------------------------------------------

// SafeEventMoneyUpdate

// required string totalMoney = 1;
inline bool SafeEventMoneyUpdate::has_totalmoney() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SafeEventMoneyUpdate::set_has_totalmoney() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SafeEventMoneyUpdate::clear_has_totalmoney() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SafeEventMoneyUpdate::clear_totalmoney() {
  if (totalmoney_ != &::google::protobuf::internal::kEmptyString) {
    totalmoney_->clear();
  }
  clear_has_totalmoney();
}
inline const ::std::string& SafeEventMoneyUpdate::totalmoney() const {
  return *totalmoney_;
}
inline void SafeEventMoneyUpdate::set_totalmoney(const ::std::string& value) {
  set_has_totalmoney();
  if (totalmoney_ == &::google::protobuf::internal::kEmptyString) {
    totalmoney_ = new ::std::string;
  }
  totalmoney_->assign(value);
}
inline void SafeEventMoneyUpdate::set_totalmoney(const char* value) {
  set_has_totalmoney();
  if (totalmoney_ == &::google::protobuf::internal::kEmptyString) {
    totalmoney_ = new ::std::string;
  }
  totalmoney_->assign(value);
}
inline void SafeEventMoneyUpdate::set_totalmoney(const char* value, size_t size) {
  set_has_totalmoney();
  if (totalmoney_ == &::google::protobuf::internal::kEmptyString) {
    totalmoney_ = new ::std::string;
  }
  totalmoney_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SafeEventMoneyUpdate::mutable_totalmoney() {
  set_has_totalmoney();
  if (totalmoney_ == &::google::protobuf::internal::kEmptyString) {
    totalmoney_ = new ::std::string;
  }
  return totalmoney_;
}
inline ::std::string* SafeEventMoneyUpdate::release_totalmoney() {
  clear_has_totalmoney();
  if (totalmoney_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = totalmoney_;
    totalmoney_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string deltaMoney = 2;
inline bool SafeEventMoneyUpdate::has_deltamoney() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SafeEventMoneyUpdate::set_has_deltamoney() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SafeEventMoneyUpdate::clear_has_deltamoney() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SafeEventMoneyUpdate::clear_deltamoney() {
  if (deltamoney_ != &::google::protobuf::internal::kEmptyString) {
    deltamoney_->clear();
  }
  clear_has_deltamoney();
}
inline const ::std::string& SafeEventMoneyUpdate::deltamoney() const {
  return *deltamoney_;
}
inline void SafeEventMoneyUpdate::set_deltamoney(const ::std::string& value) {
  set_has_deltamoney();
  if (deltamoney_ == &::google::protobuf::internal::kEmptyString) {
    deltamoney_ = new ::std::string;
  }
  deltamoney_->assign(value);
}
inline void SafeEventMoneyUpdate::set_deltamoney(const char* value) {
  set_has_deltamoney();
  if (deltamoney_ == &::google::protobuf::internal::kEmptyString) {
    deltamoney_ = new ::std::string;
  }
  deltamoney_->assign(value);
}
inline void SafeEventMoneyUpdate::set_deltamoney(const char* value, size_t size) {
  set_has_deltamoney();
  if (deltamoney_ == &::google::protobuf::internal::kEmptyString) {
    deltamoney_ = new ::std::string;
  }
  deltamoney_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SafeEventMoneyUpdate::mutable_deltamoney() {
  set_has_deltamoney();
  if (deltamoney_ == &::google::protobuf::internal::kEmptyString) {
    deltamoney_ = new ::std::string;
  }
  return deltamoney_;
}
inline ::std::string* SafeEventMoneyUpdate::release_deltamoney() {
  clear_has_deltamoney();
  if (deltamoney_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deltamoney_;
    deltamoney_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string dealMoney = 3;
inline bool SafeEventMoneyUpdate::has_dealmoney() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SafeEventMoneyUpdate::set_has_dealmoney() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SafeEventMoneyUpdate::clear_has_dealmoney() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SafeEventMoneyUpdate::clear_dealmoney() {
  if (dealmoney_ != &::google::protobuf::internal::kEmptyString) {
    dealmoney_->clear();
  }
  clear_has_dealmoney();
}
inline const ::std::string& SafeEventMoneyUpdate::dealmoney() const {
  return *dealmoney_;
}
inline void SafeEventMoneyUpdate::set_dealmoney(const ::std::string& value) {
  set_has_dealmoney();
  if (dealmoney_ == &::google::protobuf::internal::kEmptyString) {
    dealmoney_ = new ::std::string;
  }
  dealmoney_->assign(value);
}
inline void SafeEventMoneyUpdate::set_dealmoney(const char* value) {
  set_has_dealmoney();
  if (dealmoney_ == &::google::protobuf::internal::kEmptyString) {
    dealmoney_ = new ::std::string;
  }
  dealmoney_->assign(value);
}
inline void SafeEventMoneyUpdate::set_dealmoney(const char* value, size_t size) {
  set_has_dealmoney();
  if (dealmoney_ == &::google::protobuf::internal::kEmptyString) {
    dealmoney_ = new ::std::string;
  }
  dealmoney_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SafeEventMoneyUpdate::mutable_dealmoney() {
  set_has_dealmoney();
  if (dealmoney_ == &::google::protobuf::internal::kEmptyString) {
    dealmoney_ = new ::std::string;
  }
  return dealmoney_;
}
inline ::std::string* SafeEventMoneyUpdate::release_dealmoney() {
  clear_has_dealmoney();
  if (dealmoney_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dealmoney_;
    dealmoney_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RefillMoneyUpdate

// required string totalMoney = 1;
inline bool RefillMoneyUpdate::has_totalmoney() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RefillMoneyUpdate::set_has_totalmoney() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RefillMoneyUpdate::clear_has_totalmoney() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RefillMoneyUpdate::clear_totalmoney() {
  if (totalmoney_ != &::google::protobuf::internal::kEmptyString) {
    totalmoney_->clear();
  }
  clear_has_totalmoney();
}
inline const ::std::string& RefillMoneyUpdate::totalmoney() const {
  return *totalmoney_;
}
inline void RefillMoneyUpdate::set_totalmoney(const ::std::string& value) {
  set_has_totalmoney();
  if (totalmoney_ == &::google::protobuf::internal::kEmptyString) {
    totalmoney_ = new ::std::string;
  }
  totalmoney_->assign(value);
}
inline void RefillMoneyUpdate::set_totalmoney(const char* value) {
  set_has_totalmoney();
  if (totalmoney_ == &::google::protobuf::internal::kEmptyString) {
    totalmoney_ = new ::std::string;
  }
  totalmoney_->assign(value);
}
inline void RefillMoneyUpdate::set_totalmoney(const char* value, size_t size) {
  set_has_totalmoney();
  if (totalmoney_ == &::google::protobuf::internal::kEmptyString) {
    totalmoney_ = new ::std::string;
  }
  totalmoney_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RefillMoneyUpdate::mutable_totalmoney() {
  set_has_totalmoney();
  if (totalmoney_ == &::google::protobuf::internal::kEmptyString) {
    totalmoney_ = new ::std::string;
  }
  return totalmoney_;
}
inline ::std::string* RefillMoneyUpdate::release_totalmoney() {
  clear_has_totalmoney();
  if (totalmoney_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = totalmoney_;
    totalmoney_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string refillMoney = 2;
inline bool RefillMoneyUpdate::has_refillmoney() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RefillMoneyUpdate::set_has_refillmoney() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RefillMoneyUpdate::clear_has_refillmoney() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RefillMoneyUpdate::clear_refillmoney() {
  if (refillmoney_ != &::google::protobuf::internal::kEmptyString) {
    refillmoney_->clear();
  }
  clear_has_refillmoney();
}
inline const ::std::string& RefillMoneyUpdate::refillmoney() const {
  return *refillmoney_;
}
inline void RefillMoneyUpdate::set_refillmoney(const ::std::string& value) {
  set_has_refillmoney();
  if (refillmoney_ == &::google::protobuf::internal::kEmptyString) {
    refillmoney_ = new ::std::string;
  }
  refillmoney_->assign(value);
}
inline void RefillMoneyUpdate::set_refillmoney(const char* value) {
  set_has_refillmoney();
  if (refillmoney_ == &::google::protobuf::internal::kEmptyString) {
    refillmoney_ = new ::std::string;
  }
  refillmoney_->assign(value);
}
inline void RefillMoneyUpdate::set_refillmoney(const char* value, size_t size) {
  set_has_refillmoney();
  if (refillmoney_ == &::google::protobuf::internal::kEmptyString) {
    refillmoney_ = new ::std::string;
  }
  refillmoney_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RefillMoneyUpdate::mutable_refillmoney() {
  set_has_refillmoney();
  if (refillmoney_ == &::google::protobuf::internal::kEmptyString) {
    refillmoney_ = new ::std::string;
  }
  return refillmoney_;
}
inline ::std::string* RefillMoneyUpdate::release_refillmoney() {
  clear_has_refillmoney();
  if (refillmoney_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = refillmoney_;
    refillmoney_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string bonusMoney = 3;
inline bool RefillMoneyUpdate::has_bonusmoney() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RefillMoneyUpdate::set_has_bonusmoney() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RefillMoneyUpdate::clear_has_bonusmoney() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RefillMoneyUpdate::clear_bonusmoney() {
  if (bonusmoney_ != &::google::protobuf::internal::kEmptyString) {
    bonusmoney_->clear();
  }
  clear_has_bonusmoney();
}
inline const ::std::string& RefillMoneyUpdate::bonusmoney() const {
  return *bonusmoney_;
}
inline void RefillMoneyUpdate::set_bonusmoney(const ::std::string& value) {
  set_has_bonusmoney();
  if (bonusmoney_ == &::google::protobuf::internal::kEmptyString) {
    bonusmoney_ = new ::std::string;
  }
  bonusmoney_->assign(value);
}
inline void RefillMoneyUpdate::set_bonusmoney(const char* value) {
  set_has_bonusmoney();
  if (bonusmoney_ == &::google::protobuf::internal::kEmptyString) {
    bonusmoney_ = new ::std::string;
  }
  bonusmoney_->assign(value);
}
inline void RefillMoneyUpdate::set_bonusmoney(const char* value, size_t size) {
  set_has_bonusmoney();
  if (bonusmoney_ == &::google::protobuf::internal::kEmptyString) {
    bonusmoney_ = new ::std::string;
  }
  bonusmoney_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RefillMoneyUpdate::mutable_bonusmoney() {
  set_has_bonusmoney();
  if (bonusmoney_ == &::google::protobuf::internal::kEmptyString) {
    bonusmoney_ = new ::std::string;
  }
  return bonusmoney_;
}
inline ::std::string* RefillMoneyUpdate::release_bonusmoney() {
  clear_has_bonusmoney();
  if (bonusmoney_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bonusmoney_;
    bonusmoney_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 refillCount = 4;
inline bool RefillMoneyUpdate::has_refillcount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RefillMoneyUpdate::set_has_refillcount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RefillMoneyUpdate::clear_has_refillcount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RefillMoneyUpdate::clear_refillcount() {
  refillcount_ = 0;
  clear_has_refillcount();
}
inline ::google::protobuf::int32 RefillMoneyUpdate::refillcount() const {
  return refillcount_;
}
inline void RefillMoneyUpdate::set_refillcount(::google::protobuf::int32 value) {
  set_has_refillcount();
  refillcount_ = value;
}

// required int32 errorCode = 5;
inline bool RefillMoneyUpdate::has_errorcode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RefillMoneyUpdate::set_has_errorcode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RefillMoneyUpdate::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RefillMoneyUpdate::clear_errorcode() {
  errorcode_ = 0;
  clear_has_errorcode();
}
inline ::google::protobuf::int32 RefillMoneyUpdate::errorcode() const {
  return errorcode_;
}
inline void RefillMoneyUpdate::set_errorcode(::google::protobuf::int32 value) {
  set_has_errorcode();
  errorcode_ = value;
}

// -------------------------------------------------------------------

// MissionDBInfo

// required int32 gameID = 1;
inline bool MissionDBInfo::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MissionDBInfo::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MissionDBInfo::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MissionDBInfo::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 MissionDBInfo::gameid() const {
  return gameid_;
}
inline void MissionDBInfo::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required string totalMoney = 2;
inline bool MissionDBInfo::has_totalmoney() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MissionDBInfo::set_has_totalmoney() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MissionDBInfo::clear_has_totalmoney() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MissionDBInfo::clear_totalmoney() {
  if (totalmoney_ != &::google::protobuf::internal::kEmptyString) {
    totalmoney_->clear();
  }
  clear_has_totalmoney();
}
inline const ::std::string& MissionDBInfo::totalmoney() const {
  return *totalmoney_;
}
inline void MissionDBInfo::set_totalmoney(const ::std::string& value) {
  set_has_totalmoney();
  if (totalmoney_ == &::google::protobuf::internal::kEmptyString) {
    totalmoney_ = new ::std::string;
  }
  totalmoney_->assign(value);
}
inline void MissionDBInfo::set_totalmoney(const char* value) {
  set_has_totalmoney();
  if (totalmoney_ == &::google::protobuf::internal::kEmptyString) {
    totalmoney_ = new ::std::string;
  }
  totalmoney_->assign(value);
}
inline void MissionDBInfo::set_totalmoney(const char* value, size_t size) {
  set_has_totalmoney();
  if (totalmoney_ == &::google::protobuf::internal::kEmptyString) {
    totalmoney_ = new ::std::string;
  }
  totalmoney_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MissionDBInfo::mutable_totalmoney() {
  set_has_totalmoney();
  if (totalmoney_ == &::google::protobuf::internal::kEmptyString) {
    totalmoney_ = new ::std::string;
  }
  return totalmoney_;
}
inline ::std::string* MissionDBInfo::release_totalmoney() {
  clear_has_totalmoney();
  if (totalmoney_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = totalmoney_;
    totalmoney_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .MissionDBInfo.EVENT_TYPE nType = 3;
inline bool MissionDBInfo::has_ntype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MissionDBInfo::set_has_ntype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MissionDBInfo::clear_has_ntype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MissionDBInfo::clear_ntype() {
  ntype_ = 1;
  clear_has_ntype();
}
inline ::MissionDBInfo_EVENT_TYPE MissionDBInfo::ntype() const {
  return static_cast< ::MissionDBInfo_EVENT_TYPE >(ntype_);
}
inline void MissionDBInfo::set_ntype(::MissionDBInfo_EVENT_TYPE value) {
  GOOGLE_DCHECK(::MissionDBInfo_EVENT_TYPE_IsValid(value));
  set_has_ntype();
  ntype_ = value;
}

// -------------------------------------------------------------------

// MemberInfo

// required int32 gameID = 1;
inline bool MemberInfo::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MemberInfo::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MemberInfo::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MemberInfo::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 MemberInfo::gameid() const {
  return gameid_;
}
inline void MemberInfo::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required string avatarUrl = 2;
inline bool MemberInfo::has_avatarurl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MemberInfo::set_has_avatarurl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MemberInfo::clear_has_avatarurl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MemberInfo::clear_avatarurl() {
  if (avatarurl_ != &::google::protobuf::internal::kEmptyString) {
    avatarurl_->clear();
  }
  clear_has_avatarurl();
}
inline const ::std::string& MemberInfo::avatarurl() const {
  return *avatarurl_;
}
inline void MemberInfo::set_avatarurl(const ::std::string& value) {
  set_has_avatarurl();
  if (avatarurl_ == &::google::protobuf::internal::kEmptyString) {
    avatarurl_ = new ::std::string;
  }
  avatarurl_->assign(value);
}
inline void MemberInfo::set_avatarurl(const char* value) {
  set_has_avatarurl();
  if (avatarurl_ == &::google::protobuf::internal::kEmptyString) {
    avatarurl_ = new ::std::string;
  }
  avatarurl_->assign(value);
}
inline void MemberInfo::set_avatarurl(const char* value, size_t size) {
  set_has_avatarurl();
  if (avatarurl_ == &::google::protobuf::internal::kEmptyString) {
    avatarurl_ = new ::std::string;
  }
  avatarurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MemberInfo::mutable_avatarurl() {
  set_has_avatarurl();
  if (avatarurl_ == &::google::protobuf::internal::kEmptyString) {
    avatarurl_ = new ::std::string;
  }
  return avatarurl_;
}
inline ::std::string* MemberInfo::release_avatarurl() {
  clear_has_avatarurl();
  if (avatarurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = avatarurl_;
    avatarurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string nickName = 3;
inline bool MemberInfo::has_nickname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MemberInfo::set_has_nickname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MemberInfo::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MemberInfo::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& MemberInfo::nickname() const {
  return *nickname_;
}
inline void MemberInfo::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void MemberInfo::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void MemberInfo::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MemberInfo::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* MemberInfo::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bool sexOption = 4;
inline bool MemberInfo::has_sexoption() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MemberInfo::set_has_sexoption() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MemberInfo::clear_has_sexoption() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MemberInfo::clear_sexoption() {
  sexoption_ = false;
  clear_has_sexoption();
}
inline bool MemberInfo::sexoption() const {
  return sexoption_;
}
inline void MemberInfo::set_sexoption(bool value) {
  set_has_sexoption();
  sexoption_ = value;
}

// -------------------------------------------------------------------

// GLAnsGameRelayInfo

// optional int32 gameID = 1;
inline bool GLAnsGameRelayInfo::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameRelayInfo::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameRelayInfo::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameRelayInfo::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLAnsGameRelayInfo::gameid() const {
  return gameid_;
}
inline void GLAnsGameRelayInfo::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLAnsGameRelayInfo::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameRelayInfo::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameRelayInfo::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameRelayInfo::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLAnsGameRelayInfo::gameindex() const {
  return gameindex_;
}
inline void GLAnsGameRelayInfo::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// required .GameUserInfo gameInfo = 3;
inline bool GLAnsGameRelayInfo::has_gameinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GLAnsGameRelayInfo::set_has_gameinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GLAnsGameRelayInfo::clear_has_gameinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GLAnsGameRelayInfo::clear_gameinfo() {
  if (gameinfo_ != NULL) gameinfo_->::GameUserInfo::Clear();
  clear_has_gameinfo();
}
inline const ::GameUserInfo& GLAnsGameRelayInfo::gameinfo() const {
  return gameinfo_ != NULL ? *gameinfo_ : *default_instance_->gameinfo_;
}
inline ::GameUserInfo* GLAnsGameRelayInfo::mutable_gameinfo() {
  set_has_gameinfo();
  if (gameinfo_ == NULL) gameinfo_ = new ::GameUserInfo;
  return gameinfo_;
}
inline ::GameUserInfo* GLAnsGameRelayInfo::release_gameinfo() {
  clear_has_gameinfo();
  ::GameUserInfo* temp = gameinfo_;
  gameinfo_ = NULL;
  return temp;
}

// required .GameUserInfo youGameInfo = 4;
inline bool GLAnsGameRelayInfo::has_yougameinfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GLAnsGameRelayInfo::set_has_yougameinfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GLAnsGameRelayInfo::clear_has_yougameinfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GLAnsGameRelayInfo::clear_yougameinfo() {
  if (yougameinfo_ != NULL) yougameinfo_->::GameUserInfo::Clear();
  clear_has_yougameinfo();
}
inline const ::GameUserInfo& GLAnsGameRelayInfo::yougameinfo() const {
  return yougameinfo_ != NULL ? *yougameinfo_ : *default_instance_->yougameinfo_;
}
inline ::GameUserInfo* GLAnsGameRelayInfo::mutable_yougameinfo() {
  set_has_yougameinfo();
  if (yougameinfo_ == NULL) yougameinfo_ = new ::GameUserInfo;
  return yougameinfo_;
}
inline ::GameUserInfo* GLAnsGameRelayInfo::release_yougameinfo() {
  clear_has_yougameinfo();
  ::GameUserInfo* temp = yougameinfo_;
  yougameinfo_ = NULL;
  return temp;
}

// repeated int32 myHoldCard = 5;
inline int GLAnsGameRelayInfo::myholdcard_size() const {
  return myholdcard_.size();
}
inline void GLAnsGameRelayInfo::clear_myholdcard() {
  myholdcard_.Clear();
}
inline ::google::protobuf::int32 GLAnsGameRelayInfo::myholdcard(int index) const {
  return myholdcard_.Get(index);
}
inline void GLAnsGameRelayInfo::set_myholdcard(int index, ::google::protobuf::int32 value) {
  myholdcard_.Set(index, value);
}
inline void GLAnsGameRelayInfo::add_myholdcard(::google::protobuf::int32 value) {
  myholdcard_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GLAnsGameRelayInfo::myholdcard() const {
  return myholdcard_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GLAnsGameRelayInfo::mutable_myholdcard() {
  return &myholdcard_;
}

// repeated int32 myHaveCard = 6;
inline int GLAnsGameRelayInfo::myhavecard_size() const {
  return myhavecard_.size();
}
inline void GLAnsGameRelayInfo::clear_myhavecard() {
  myhavecard_.Clear();
}
inline ::google::protobuf::int32 GLAnsGameRelayInfo::myhavecard(int index) const {
  return myhavecard_.Get(index);
}
inline void GLAnsGameRelayInfo::set_myhavecard(int index, ::google::protobuf::int32 value) {
  myhavecard_.Set(index, value);
}
inline void GLAnsGameRelayInfo::add_myhavecard(::google::protobuf::int32 value) {
  myhavecard_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GLAnsGameRelayInfo::myhavecard() const {
  return myhavecard_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GLAnsGameRelayInfo::mutable_myhavecard() {
  return &myhavecard_;
}

// repeated int32 OpenCard = 7;
inline int GLAnsGameRelayInfo::opencard_size() const {
  return opencard_.size();
}
inline void GLAnsGameRelayInfo::clear_opencard() {
  opencard_.Clear();
}
inline ::google::protobuf::int32 GLAnsGameRelayInfo::opencard(int index) const {
  return opencard_.Get(index);
}
inline void GLAnsGameRelayInfo::set_opencard(int index, ::google::protobuf::int32 value) {
  opencard_.Set(index, value);
}
inline void GLAnsGameRelayInfo::add_opencard(::google::protobuf::int32 value) {
  opencard_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GLAnsGameRelayInfo::opencard() const {
  return opencard_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GLAnsGameRelayInfo::mutable_opencard() {
  return &opencard_;
}

// required int32 youHoldCount = 8;
inline bool GLAnsGameRelayInfo::has_youholdcount() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GLAnsGameRelayInfo::set_has_youholdcount() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GLAnsGameRelayInfo::clear_has_youholdcount() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GLAnsGameRelayInfo::clear_youholdcount() {
  youholdcount_ = 0;
  clear_has_youholdcount();
}
inline ::google::protobuf::int32 GLAnsGameRelayInfo::youholdcount() const {
  return youholdcount_;
}
inline void GLAnsGameRelayInfo::set_youholdcount(::google::protobuf::int32 value) {
  set_has_youholdcount();
  youholdcount_ = value;
}

// repeated int32 youHaveCard = 9;
inline int GLAnsGameRelayInfo::youhavecard_size() const {
  return youhavecard_.size();
}
inline void GLAnsGameRelayInfo::clear_youhavecard() {
  youhavecard_.Clear();
}
inline ::google::protobuf::int32 GLAnsGameRelayInfo::youhavecard(int index) const {
  return youhavecard_.Get(index);
}
inline void GLAnsGameRelayInfo::set_youhavecard(int index, ::google::protobuf::int32 value) {
  youhavecard_.Set(index, value);
}
inline void GLAnsGameRelayInfo::add_youhavecard(::google::protobuf::int32 value) {
  youhavecard_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GLAnsGameRelayInfo::youhavecard() const {
  return youhavecard_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GLAnsGameRelayInfo::mutable_youhavecard() {
  return &youhavecard_;
}

// required .GLAnsGameRelayInfo.JOKBO_STATE myGodoriType = 10;
inline bool GLAnsGameRelayInfo::has_mygodoritype() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GLAnsGameRelayInfo::set_has_mygodoritype() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GLAnsGameRelayInfo::clear_has_mygodoritype() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GLAnsGameRelayInfo::clear_mygodoritype() {
  mygodoritype_ = 1;
  clear_has_mygodoritype();
}
inline ::GLAnsGameRelayInfo_JOKBO_STATE GLAnsGameRelayInfo::mygodoritype() const {
  return static_cast< ::GLAnsGameRelayInfo_JOKBO_STATE >(mygodoritype_);
}
inline void GLAnsGameRelayInfo::set_mygodoritype(::GLAnsGameRelayInfo_JOKBO_STATE value) {
  GOOGLE_DCHECK(::GLAnsGameRelayInfo_JOKBO_STATE_IsValid(value));
  set_has_mygodoritype();
  mygodoritype_ = value;
}

// required .GLAnsGameRelayInfo.JOKBO_STATE myRedType = 11;
inline bool GLAnsGameRelayInfo::has_myredtype() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GLAnsGameRelayInfo::set_has_myredtype() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GLAnsGameRelayInfo::clear_has_myredtype() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GLAnsGameRelayInfo::clear_myredtype() {
  myredtype_ = 1;
  clear_has_myredtype();
}
inline ::GLAnsGameRelayInfo_JOKBO_STATE GLAnsGameRelayInfo::myredtype() const {
  return static_cast< ::GLAnsGameRelayInfo_JOKBO_STATE >(myredtype_);
}
inline void GLAnsGameRelayInfo::set_myredtype(::GLAnsGameRelayInfo_JOKBO_STATE value) {
  GOOGLE_DCHECK(::GLAnsGameRelayInfo_JOKBO_STATE_IsValid(value));
  set_has_myredtype();
  myredtype_ = value;
}

// required .GLAnsGameRelayInfo.JOKBO_STATE myBlueType = 12;
inline bool GLAnsGameRelayInfo::has_mybluetype() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GLAnsGameRelayInfo::set_has_mybluetype() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GLAnsGameRelayInfo::clear_has_mybluetype() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GLAnsGameRelayInfo::clear_mybluetype() {
  mybluetype_ = 1;
  clear_has_mybluetype();
}
inline ::GLAnsGameRelayInfo_JOKBO_STATE GLAnsGameRelayInfo::mybluetype() const {
  return static_cast< ::GLAnsGameRelayInfo_JOKBO_STATE >(mybluetype_);
}
inline void GLAnsGameRelayInfo::set_mybluetype(::GLAnsGameRelayInfo_JOKBO_STATE value) {
  GOOGLE_DCHECK(::GLAnsGameRelayInfo_JOKBO_STATE_IsValid(value));
  set_has_mybluetype();
  mybluetype_ = value;
}

// required .GLAnsGameRelayInfo.JOKBO_STATE myKusaType = 13;
inline bool GLAnsGameRelayInfo::has_mykusatype() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GLAnsGameRelayInfo::set_has_mykusatype() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GLAnsGameRelayInfo::clear_has_mykusatype() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GLAnsGameRelayInfo::clear_mykusatype() {
  mykusatype_ = 1;
  clear_has_mykusatype();
}
inline ::GLAnsGameRelayInfo_JOKBO_STATE GLAnsGameRelayInfo::mykusatype() const {
  return static_cast< ::GLAnsGameRelayInfo_JOKBO_STATE >(mykusatype_);
}
inline void GLAnsGameRelayInfo::set_mykusatype(::GLAnsGameRelayInfo_JOKBO_STATE value) {
  GOOGLE_DCHECK(::GLAnsGameRelayInfo_JOKBO_STATE_IsValid(value));
  set_has_mykusatype();
  mykusatype_ = value;
}

// required .GLAnsGameRelayInfo.JOKBO_STATE youGodoriType = 14;
inline bool GLAnsGameRelayInfo::has_yougodoritype() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void GLAnsGameRelayInfo::set_has_yougodoritype() {
  _has_bits_[0] |= 0x00002000u;
}
inline void GLAnsGameRelayInfo::clear_has_yougodoritype() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void GLAnsGameRelayInfo::clear_yougodoritype() {
  yougodoritype_ = 1;
  clear_has_yougodoritype();
}
inline ::GLAnsGameRelayInfo_JOKBO_STATE GLAnsGameRelayInfo::yougodoritype() const {
  return static_cast< ::GLAnsGameRelayInfo_JOKBO_STATE >(yougodoritype_);
}
inline void GLAnsGameRelayInfo::set_yougodoritype(::GLAnsGameRelayInfo_JOKBO_STATE value) {
  GOOGLE_DCHECK(::GLAnsGameRelayInfo_JOKBO_STATE_IsValid(value));
  set_has_yougodoritype();
  yougodoritype_ = value;
}

// required .GLAnsGameRelayInfo.JOKBO_STATE youRedType = 15;
inline bool GLAnsGameRelayInfo::has_youredtype() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void GLAnsGameRelayInfo::set_has_youredtype() {
  _has_bits_[0] |= 0x00004000u;
}
inline void GLAnsGameRelayInfo::clear_has_youredtype() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void GLAnsGameRelayInfo::clear_youredtype() {
  youredtype_ = 1;
  clear_has_youredtype();
}
inline ::GLAnsGameRelayInfo_JOKBO_STATE GLAnsGameRelayInfo::youredtype() const {
  return static_cast< ::GLAnsGameRelayInfo_JOKBO_STATE >(youredtype_);
}
inline void GLAnsGameRelayInfo::set_youredtype(::GLAnsGameRelayInfo_JOKBO_STATE value) {
  GOOGLE_DCHECK(::GLAnsGameRelayInfo_JOKBO_STATE_IsValid(value));
  set_has_youredtype();
  youredtype_ = value;
}

// required .GLAnsGameRelayInfo.JOKBO_STATE youBlueType = 16;
inline bool GLAnsGameRelayInfo::has_youbluetype() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void GLAnsGameRelayInfo::set_has_youbluetype() {
  _has_bits_[0] |= 0x00008000u;
}
inline void GLAnsGameRelayInfo::clear_has_youbluetype() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void GLAnsGameRelayInfo::clear_youbluetype() {
  youbluetype_ = 1;
  clear_has_youbluetype();
}
inline ::GLAnsGameRelayInfo_JOKBO_STATE GLAnsGameRelayInfo::youbluetype() const {
  return static_cast< ::GLAnsGameRelayInfo_JOKBO_STATE >(youbluetype_);
}
inline void GLAnsGameRelayInfo::set_youbluetype(::GLAnsGameRelayInfo_JOKBO_STATE value) {
  GOOGLE_DCHECK(::GLAnsGameRelayInfo_JOKBO_STATE_IsValid(value));
  set_has_youbluetype();
  youbluetype_ = value;
}

// required .GLAnsGameRelayInfo.JOKBO_STATE youKusaType = 17;
inline bool GLAnsGameRelayInfo::has_youkusatype() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void GLAnsGameRelayInfo::set_has_youkusatype() {
  _has_bits_[0] |= 0x00010000u;
}
inline void GLAnsGameRelayInfo::clear_has_youkusatype() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void GLAnsGameRelayInfo::clear_youkusatype() {
  youkusatype_ = 1;
  clear_has_youkusatype();
}
inline ::GLAnsGameRelayInfo_JOKBO_STATE GLAnsGameRelayInfo::youkusatype() const {
  return static_cast< ::GLAnsGameRelayInfo_JOKBO_STATE >(youkusatype_);
}
inline void GLAnsGameRelayInfo::set_youkusatype(::GLAnsGameRelayInfo_JOKBO_STATE value) {
  GOOGLE_DCHECK(::GLAnsGameRelayInfo_JOKBO_STATE_IsValid(value));
  set_has_youkusatype();
  youkusatype_ = value;
}

// required int32 myPoint = 18;
inline bool GLAnsGameRelayInfo::has_mypoint() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void GLAnsGameRelayInfo::set_has_mypoint() {
  _has_bits_[0] |= 0x00020000u;
}
inline void GLAnsGameRelayInfo::clear_has_mypoint() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void GLAnsGameRelayInfo::clear_mypoint() {
  mypoint_ = 0;
  clear_has_mypoint();
}
inline ::google::protobuf::int32 GLAnsGameRelayInfo::mypoint() const {
  return mypoint_;
}
inline void GLAnsGameRelayInfo::set_mypoint(::google::protobuf::int32 value) {
  set_has_mypoint();
  mypoint_ = value;
}

// required int32 myGoPoint = 19;
inline bool GLAnsGameRelayInfo::has_mygopoint() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void GLAnsGameRelayInfo::set_has_mygopoint() {
  _has_bits_[0] |= 0x00040000u;
}
inline void GLAnsGameRelayInfo::clear_has_mygopoint() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void GLAnsGameRelayInfo::clear_mygopoint() {
  mygopoint_ = 0;
  clear_has_mygopoint();
}
inline ::google::protobuf::int32 GLAnsGameRelayInfo::mygopoint() const {
  return mygopoint_;
}
inline void GLAnsGameRelayInfo::set_mygopoint(::google::protobuf::int32 value) {
  set_has_mygopoint();
  mygopoint_ = value;
}

// required int32 myShakeCount = 20;
inline bool GLAnsGameRelayInfo::has_myshakecount() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void GLAnsGameRelayInfo::set_has_myshakecount() {
  _has_bits_[0] |= 0x00080000u;
}
inline void GLAnsGameRelayInfo::clear_has_myshakecount() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void GLAnsGameRelayInfo::clear_myshakecount() {
  myshakecount_ = 0;
  clear_has_myshakecount();
}
inline ::google::protobuf::int32 GLAnsGameRelayInfo::myshakecount() const {
  return myshakecount_;
}
inline void GLAnsGameRelayInfo::set_myshakecount(::google::protobuf::int32 value) {
  set_has_myshakecount();
  myshakecount_ = value;
}

// required int32 myBuckCount = 21;
inline bool GLAnsGameRelayInfo::has_mybuckcount() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void GLAnsGameRelayInfo::set_has_mybuckcount() {
  _has_bits_[0] |= 0x00100000u;
}
inline void GLAnsGameRelayInfo::clear_has_mybuckcount() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void GLAnsGameRelayInfo::clear_mybuckcount() {
  mybuckcount_ = 0;
  clear_has_mybuckcount();
}
inline ::google::protobuf::int32 GLAnsGameRelayInfo::mybuckcount() const {
  return mybuckcount_;
}
inline void GLAnsGameRelayInfo::set_mybuckcount(::google::protobuf::int32 value) {
  set_has_mybuckcount();
  mybuckcount_ = value;
}

// required int32 youPoint = 22;
inline bool GLAnsGameRelayInfo::has_youpoint() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void GLAnsGameRelayInfo::set_has_youpoint() {
  _has_bits_[0] |= 0x00200000u;
}
inline void GLAnsGameRelayInfo::clear_has_youpoint() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void GLAnsGameRelayInfo::clear_youpoint() {
  youpoint_ = 0;
  clear_has_youpoint();
}
inline ::google::protobuf::int32 GLAnsGameRelayInfo::youpoint() const {
  return youpoint_;
}
inline void GLAnsGameRelayInfo::set_youpoint(::google::protobuf::int32 value) {
  set_has_youpoint();
  youpoint_ = value;
}

// required int32 youGoPoint = 23;
inline bool GLAnsGameRelayInfo::has_yougopoint() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void GLAnsGameRelayInfo::set_has_yougopoint() {
  _has_bits_[0] |= 0x00400000u;
}
inline void GLAnsGameRelayInfo::clear_has_yougopoint() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void GLAnsGameRelayInfo::clear_yougopoint() {
  yougopoint_ = 0;
  clear_has_yougopoint();
}
inline ::google::protobuf::int32 GLAnsGameRelayInfo::yougopoint() const {
  return yougopoint_;
}
inline void GLAnsGameRelayInfo::set_yougopoint(::google::protobuf::int32 value) {
  set_has_yougopoint();
  yougopoint_ = value;
}

// required int32 youShakeCount = 24;
inline bool GLAnsGameRelayInfo::has_youshakecount() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void GLAnsGameRelayInfo::set_has_youshakecount() {
  _has_bits_[0] |= 0x00800000u;
}
inline void GLAnsGameRelayInfo::clear_has_youshakecount() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void GLAnsGameRelayInfo::clear_youshakecount() {
  youshakecount_ = 0;
  clear_has_youshakecount();
}
inline ::google::protobuf::int32 GLAnsGameRelayInfo::youshakecount() const {
  return youshakecount_;
}
inline void GLAnsGameRelayInfo::set_youshakecount(::google::protobuf::int32 value) {
  set_has_youshakecount();
  youshakecount_ = value;
}

// required int32 youBuckCount = 25;
inline bool GLAnsGameRelayInfo::has_youbuckcount() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void GLAnsGameRelayInfo::set_has_youbuckcount() {
  _has_bits_[0] |= 0x01000000u;
}
inline void GLAnsGameRelayInfo::clear_has_youbuckcount() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void GLAnsGameRelayInfo::clear_youbuckcount() {
  youbuckcount_ = 0;
  clear_has_youbuckcount();
}
inline ::google::protobuf::int32 GLAnsGameRelayInfo::youbuckcount() const {
  return youbuckcount_;
}
inline void GLAnsGameRelayInfo::set_youbuckcount(::google::protobuf::int32 value) {
  set_has_youbuckcount();
  youbuckcount_ = value;
}

// required int32 gameSun = 26;
inline bool GLAnsGameRelayInfo::has_gamesun() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void GLAnsGameRelayInfo::set_has_gamesun() {
  _has_bits_[0] |= 0x02000000u;
}
inline void GLAnsGameRelayInfo::clear_has_gamesun() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void GLAnsGameRelayInfo::clear_gamesun() {
  gamesun_ = 0;
  clear_has_gamesun();
}
inline ::google::protobuf::int32 GLAnsGameRelayInfo::gamesun() const {
  return gamesun_;
}
inline void GLAnsGameRelayInfo::set_gamesun(::google::protobuf::int32 value) {
  set_has_gamesun();
  gamesun_ = value;
}

// required int32 currenTurn = 27;
inline bool GLAnsGameRelayInfo::has_currenturn() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void GLAnsGameRelayInfo::set_has_currenturn() {
  _has_bits_[0] |= 0x04000000u;
}
inline void GLAnsGameRelayInfo::clear_has_currenturn() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void GLAnsGameRelayInfo::clear_currenturn() {
  currenturn_ = 0;
  clear_has_currenturn();
}
inline ::google::protobuf::int32 GLAnsGameRelayInfo::currenturn() const {
  return currenturn_;
}
inline void GLAnsGameRelayInfo::set_currenturn(::google::protobuf::int32 value) {
  set_has_currenturn();
  currenturn_ = value;
}

// required int32 turnCount = 28;
inline bool GLAnsGameRelayInfo::has_turncount() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void GLAnsGameRelayInfo::set_has_turncount() {
  _has_bits_[0] |= 0x08000000u;
}
inline void GLAnsGameRelayInfo::clear_has_turncount() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void GLAnsGameRelayInfo::clear_turncount() {
  turncount_ = 0;
  clear_has_turncount();
}
inline ::google::protobuf::int32 GLAnsGameRelayInfo::turncount() const {
  return turncount_;
}
inline void GLAnsGameRelayInfo::set_turncount(::google::protobuf::int32 value) {
  set_has_turncount();
  turncount_ = value;
}

// required int32 missionMulNum = 29;
inline bool GLAnsGameRelayInfo::has_missionmulnum() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void GLAnsGameRelayInfo::set_has_missionmulnum() {
  _has_bits_[0] |= 0x10000000u;
}
inline void GLAnsGameRelayInfo::clear_has_missionmulnum() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void GLAnsGameRelayInfo::clear_missionmulnum() {
  missionmulnum_ = 0;
  clear_has_missionmulnum();
}
inline ::google::protobuf::int32 GLAnsGameRelayInfo::missionmulnum() const {
  return missionmulnum_;
}
inline void GLAnsGameRelayInfo::set_missionmulnum(::google::protobuf::int32 value) {
  set_has_missionmulnum();
  missionmulnum_ = value;
}

// repeated int32 missionCard = 30;
inline int GLAnsGameRelayInfo::missioncard_size() const {
  return missioncard_.size();
}
inline void GLAnsGameRelayInfo::clear_missioncard() {
  missioncard_.Clear();
}
inline ::google::protobuf::int32 GLAnsGameRelayInfo::missioncard(int index) const {
  return missioncard_.Get(index);
}
inline void GLAnsGameRelayInfo::set_missioncard(int index, ::google::protobuf::int32 value) {
  missioncard_.Set(index, value);
}
inline void GLAnsGameRelayInfo::add_missioncard(::google::protobuf::int32 value) {
  missioncard_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GLAnsGameRelayInfo::missioncard() const {
  return missioncard_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GLAnsGameRelayInfo::mutable_missioncard() {
  return &missioncard_;
}

// required string missionTitle = 31;
inline bool GLAnsGameRelayInfo::has_missiontitle() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void GLAnsGameRelayInfo::set_has_missiontitle() {
  _has_bits_[0] |= 0x40000000u;
}
inline void GLAnsGameRelayInfo::clear_has_missiontitle() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void GLAnsGameRelayInfo::clear_missiontitle() {
  if (missiontitle_ != &::google::protobuf::internal::kEmptyString) {
    missiontitle_->clear();
  }
  clear_has_missiontitle();
}
inline const ::std::string& GLAnsGameRelayInfo::missiontitle() const {
  return *missiontitle_;
}
inline void GLAnsGameRelayInfo::set_missiontitle(const ::std::string& value) {
  set_has_missiontitle();
  if (missiontitle_ == &::google::protobuf::internal::kEmptyString) {
    missiontitle_ = new ::std::string;
  }
  missiontitle_->assign(value);
}
inline void GLAnsGameRelayInfo::set_missiontitle(const char* value) {
  set_has_missiontitle();
  if (missiontitle_ == &::google::protobuf::internal::kEmptyString) {
    missiontitle_ = new ::std::string;
  }
  missiontitle_->assign(value);
}
inline void GLAnsGameRelayInfo::set_missiontitle(const char* value, size_t size) {
  set_has_missiontitle();
  if (missiontitle_ == &::google::protobuf::internal::kEmptyString) {
    missiontitle_ = new ::std::string;
  }
  missiontitle_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GLAnsGameRelayInfo::mutable_missiontitle() {
  set_has_missiontitle();
  if (missiontitle_ == &::google::protobuf::internal::kEmptyString) {
    missiontitle_ = new ::std::string;
  }
  return missiontitle_;
}
inline ::std::string* GLAnsGameRelayInfo::release_missiontitle() {
  clear_has_missiontitle();
  if (missiontitle_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = missiontitle_;
    missiontitle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .GLAnsGameRelayInfo.MISSION_TYPE missionType = 32;
inline bool GLAnsGameRelayInfo::has_missiontype() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void GLAnsGameRelayInfo::set_has_missiontype() {
  _has_bits_[0] |= 0x80000000u;
}
inline void GLAnsGameRelayInfo::clear_has_missiontype() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void GLAnsGameRelayInfo::clear_missiontype() {
  missiontype_ = 1;
  clear_has_missiontype();
}
inline ::GLAnsGameRelayInfo_MISSION_TYPE GLAnsGameRelayInfo::missiontype() const {
  return static_cast< ::GLAnsGameRelayInfo_MISSION_TYPE >(missiontype_);
}
inline void GLAnsGameRelayInfo::set_missiontype(::GLAnsGameRelayInfo_MISSION_TYPE value) {
  GOOGLE_DCHECK(::GLAnsGameRelayInfo_MISSION_TYPE_IsValid(value));
  set_has_missiontype();
  missiontype_ = value;
}

// optional int32 missionUserID = 33;
inline bool GLAnsGameRelayInfo::has_missionuserid() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void GLAnsGameRelayInfo::set_has_missionuserid() {
  _has_bits_[1] |= 0x00000001u;
}
inline void GLAnsGameRelayInfo::clear_has_missionuserid() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void GLAnsGameRelayInfo::clear_missionuserid() {
  missionuserid_ = 0;
  clear_has_missionuserid();
}
inline ::google::protobuf::int32 GLAnsGameRelayInfo::missionuserid() const {
  return missionuserid_;
}
inline void GLAnsGameRelayInfo::set_missionuserid(::google::protobuf::int32 value) {
  set_has_missionuserid();
  missionuserid_ = value;
}

// required .GLAnsGameRelayInfo.MISSION_STATE missionStateType = 34;
inline bool GLAnsGameRelayInfo::has_missionstatetype() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void GLAnsGameRelayInfo::set_has_missionstatetype() {
  _has_bits_[1] |= 0x00000002u;
}
inline void GLAnsGameRelayInfo::clear_has_missionstatetype() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void GLAnsGameRelayInfo::clear_missionstatetype() {
  missionstatetype_ = 1;
  clear_has_missionstatetype();
}
inline ::GLAnsGameRelayInfo_MISSION_STATE GLAnsGameRelayInfo::missionstatetype() const {
  return static_cast< ::GLAnsGameRelayInfo_MISSION_STATE >(missionstatetype_);
}
inline void GLAnsGameRelayInfo::set_missionstatetype(::GLAnsGameRelayInfo_MISSION_STATE value) {
  GOOGLE_DCHECK(::GLAnsGameRelayInfo_MISSION_STATE_IsValid(value));
  set_has_missionstatetype();
  missionstatetype_ = value;
}

// repeated int32 missionGetCard = 35;
inline int GLAnsGameRelayInfo::missiongetcard_size() const {
  return missiongetcard_.size();
}
inline void GLAnsGameRelayInfo::clear_missiongetcard() {
  missiongetcard_.Clear();
}
inline ::google::protobuf::int32 GLAnsGameRelayInfo::missiongetcard(int index) const {
  return missiongetcard_.Get(index);
}
inline void GLAnsGameRelayInfo::set_missiongetcard(int index, ::google::protobuf::int32 value) {
  missiongetcard_.Set(index, value);
}
inline void GLAnsGameRelayInfo::add_missiongetcard(::google::protobuf::int32 value) {
  missiongetcard_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GLAnsGameRelayInfo::missiongetcard() const {
  return missiongetcard_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GLAnsGameRelayInfo::mutable_missiongetcard() {
  return &missiongetcard_;
}

// repeated int32 youMissionGetCard = 36;
inline int GLAnsGameRelayInfo::youmissiongetcard_size() const {
  return youmissiongetcard_.size();
}
inline void GLAnsGameRelayInfo::clear_youmissiongetcard() {
  youmissiongetcard_.Clear();
}
inline ::google::protobuf::int32 GLAnsGameRelayInfo::youmissiongetcard(int index) const {
  return youmissiongetcard_.Get(index);
}
inline void GLAnsGameRelayInfo::set_youmissiongetcard(int index, ::google::protobuf::int32 value) {
  youmissiongetcard_.Set(index, value);
}
inline void GLAnsGameRelayInfo::add_youmissiongetcard(::google::protobuf::int32 value) {
  youmissiongetcard_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GLAnsGameRelayInfo::youmissiongetcard() const {
  return youmissiongetcard_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GLAnsGameRelayInfo::mutable_youmissiongetcard() {
  return &youmissiongetcard_;
}

// required bool nineMoved = 37;
inline bool GLAnsGameRelayInfo::has_ninemoved() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void GLAnsGameRelayInfo::set_has_ninemoved() {
  _has_bits_[1] |= 0x00000010u;
}
inline void GLAnsGameRelayInfo::clear_has_ninemoved() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void GLAnsGameRelayInfo::clear_ninemoved() {
  ninemoved_ = false;
  clear_has_ninemoved();
}
inline bool GLAnsGameRelayInfo::ninemoved() const {
  return ninemoved_;
}
inline void GLAnsGameRelayInfo::set_ninemoved(bool value) {
  set_has_ninemoved();
  ninemoved_ = value;
}

// -------------------------------------------------------------------

// GLReqGameInitGameTan

// optional int32 gameID = 1;
inline bool GLReqGameInitGameTan::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLReqGameInitGameTan::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLReqGameInitGameTan::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLReqGameInitGameTan::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLReqGameInitGameTan::gameid() const {
  return gameid_;
}
inline void GLReqGameInitGameTan::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 tanType = 2;
inline bool GLReqGameInitGameTan::has_tantype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLReqGameInitGameTan::set_has_tantype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLReqGameInitGameTan::clear_has_tantype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLReqGameInitGameTan::clear_tantype() {
  tantype_ = 0;
  clear_has_tantype();
}
inline ::google::protobuf::int32 GLReqGameInitGameTan::tantype() const {
  return tantype_;
}
inline void GLReqGameInitGameTan::set_tantype(::google::protobuf::int32 value) {
  set_has_tantype();
  tantype_ = value;
}

// required int32 missionType = 3;
inline bool GLReqGameInitGameTan::has_missiontype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GLReqGameInitGameTan::set_has_missiontype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GLReqGameInitGameTan::clear_has_missiontype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GLReqGameInitGameTan::clear_missiontype() {
  missiontype_ = 0;
  clear_has_missiontype();
}
inline ::google::protobuf::int32 GLReqGameInitGameTan::missiontype() const {
  return missiontype_;
}
inline void GLReqGameInitGameTan::set_missiontype(::google::protobuf::int32 value) {
  set_has_missiontype();
  missiontype_ = value;
}

// required int32 missionMul = 4;
inline bool GLReqGameInitGameTan::has_missionmul() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GLReqGameInitGameTan::set_has_missionmul() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GLReqGameInitGameTan::clear_has_missionmul() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GLReqGameInitGameTan::clear_missionmul() {
  missionmul_ = 0;
  clear_has_missionmul();
}
inline ::google::protobuf::int32 GLReqGameInitGameTan::missionmul() const {
  return missionmul_;
}
inline void GLReqGameInitGameTan::set_missionmul(::google::protobuf::int32 value) {
  set_has_missionmul();
  missionmul_ = value;
}

// -------------------------------------------------------------------

// GLAnsGameStartReady

// required int32 gameID = 1;
inline bool GLAnsGameStartReady::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameStartReady::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameStartReady::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameStartReady::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLAnsGameStartReady::gameid() const {
  return gameid_;
}
inline void GLAnsGameStartReady::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLAnsGameStartReady::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameStartReady::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameStartReady::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameStartReady::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLAnsGameStartReady::gameindex() const {
  return gameindex_;
}
inline void GLAnsGameStartReady::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// -------------------------------------------------------------------

// GLAnsGameResetReady

// optional int32 gameID = 1;
inline bool GLAnsGameResetReady::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameResetReady::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameResetReady::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameResetReady::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLAnsGameResetReady::gameid() const {
  return gameid_;
}
inline void GLAnsGameResetReady::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLAnsGameResetReady::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameResetReady::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameResetReady::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameResetReady::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLAnsGameResetReady::gameindex() const {
  return gameindex_;
}
inline void GLAnsGameResetReady::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// -------------------------------------------------------------------

// GLAnsGameStart

// optional int32 gameID = 1;
inline bool GLAnsGameStart::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameStart::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameStart::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameStart::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLAnsGameStart::gameid() const {
  return gameid_;
}
inline void GLAnsGameStart::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// optional int32 gameIndex = 2;
inline bool GLAnsGameStart::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameStart::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameStart::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameStart::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLAnsGameStart::gameindex() const {
  return gameindex_;
}
inline void GLAnsGameStart::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// -------------------------------------------------------------------

// GLAnsGameReset

// optional int32 gameID = 1;
inline bool GLAnsGameReset::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameReset::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameReset::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameReset::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLAnsGameReset::gameid() const {
  return gameid_;
}
inline void GLAnsGameReset::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// optional int32 gameIndex = 2;
inline bool GLAnsGameReset::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameReset::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameReset::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameReset::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLAnsGameReset::gameindex() const {
  return gameindex_;
}
inline void GLAnsGameReset::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// -------------------------------------------------------------------

// GLAnsGameNotiSun

// optional int32 gameID = 1;
inline bool GLAnsGameNotiSun::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameNotiSun::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameNotiSun::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameNotiSun::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLAnsGameNotiSun::gameid() const {
  return gameid_;
}
inline void GLAnsGameNotiSun::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLAnsGameNotiSun::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameNotiSun::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameNotiSun::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameNotiSun::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLAnsGameNotiSun::gameindex() const {
  return gameindex_;
}
inline void GLAnsGameNotiSun::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// -------------------------------------------------------------------

// GLReqGameSelectSun

// required int32 gameID = 1;
inline bool GLReqGameSelectSun::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLReqGameSelectSun::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLReqGameSelectSun::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLReqGameSelectSun::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLReqGameSelectSun::gameid() const {
  return gameid_;
}
inline void GLReqGameSelectSun::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLReqGameSelectSun::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLReqGameSelectSun::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLReqGameSelectSun::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLReqGameSelectSun::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLReqGameSelectSun::gameindex() const {
  return gameindex_;
}
inline void GLReqGameSelectSun::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// required int32 selectIndex = 3;
inline bool GLReqGameSelectSun::has_selectindex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GLReqGameSelectSun::set_has_selectindex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GLReqGameSelectSun::clear_has_selectindex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GLReqGameSelectSun::clear_selectindex() {
  selectindex_ = 0;
  clear_has_selectindex();
}
inline ::google::protobuf::int32 GLReqGameSelectSun::selectindex() const {
  return selectindex_;
}
inline void GLReqGameSelectSun::set_selectindex(::google::protobuf::int32 value) {
  set_has_selectindex();
  selectindex_ = value;
}

// -------------------------------------------------------------------

// GLAnsGameSelectSun

// required int32 gameID = 1;
inline bool GLAnsGameSelectSun::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameSelectSun::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameSelectSun::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameSelectSun::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLAnsGameSelectSun::gameid() const {
  return gameid_;
}
inline void GLAnsGameSelectSun::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLAnsGameSelectSun::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameSelectSun::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameSelectSun::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameSelectSun::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLAnsGameSelectSun::gameindex() const {
  return gameindex_;
}
inline void GLAnsGameSelectSun::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// required int32 selectIndex = 3;
inline bool GLAnsGameSelectSun::has_selectindex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GLAnsGameSelectSun::set_has_selectindex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GLAnsGameSelectSun::clear_has_selectindex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GLAnsGameSelectSun::clear_selectindex() {
  selectindex_ = 0;
  clear_has_selectindex();
}
inline ::google::protobuf::int32 GLAnsGameSelectSun::selectindex() const {
  return selectindex_;
}
inline void GLAnsGameSelectSun::set_selectindex(::google::protobuf::int32 value) {
  set_has_selectindex();
  selectindex_ = value;
}

// -------------------------------------------------------------------

// GLAnsGameNotiSelectSun

// required int32 gameID = 1;
inline bool GLAnsGameNotiSelectSun::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameNotiSelectSun::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameNotiSelectSun::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameNotiSelectSun::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLAnsGameNotiSelectSun::gameid() const {
  return gameid_;
}
inline void GLAnsGameNotiSelectSun::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLAnsGameNotiSelectSun::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameNotiSelectSun::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameNotiSelectSun::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameNotiSelectSun::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLAnsGameNotiSelectSun::gameindex() const {
  return gameindex_;
}
inline void GLAnsGameNotiSelectSun::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// repeated int32 nCard = 3;
inline int GLAnsGameNotiSelectSun::ncard_size() const {
  return ncard_.size();
}
inline void GLAnsGameNotiSelectSun::clear_ncard() {
  ncard_.Clear();
}
inline ::google::protobuf::int32 GLAnsGameNotiSelectSun::ncard(int index) const {
  return ncard_.Get(index);
}
inline void GLAnsGameNotiSelectSun::set_ncard(int index, ::google::protobuf::int32 value) {
  ncard_.Set(index, value);
}
inline void GLAnsGameNotiSelectSun::add_ncard(::google::protobuf::int32 value) {
  ncard_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GLAnsGameNotiSelectSun::ncard() const {
  return ncard_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GLAnsGameNotiSelectSun::mutable_ncard() {
  return &ncard_;
}

// -------------------------------------------------------------------

// GLAnsGameSharing

// optional int32 gameID = 1;
inline bool GLAnsGameSharing::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameSharing::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameSharing::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameSharing::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLAnsGameSharing::gameid() const {
  return gameid_;
}
inline void GLAnsGameSharing::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLAnsGameSharing::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameSharing::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameSharing::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameSharing::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLAnsGameSharing::gameindex() const {
  return gameindex_;
}
inline void GLAnsGameSharing::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// repeated int32 lstOpenCard = 3;
inline int GLAnsGameSharing::lstopencard_size() const {
  return lstopencard_.size();
}
inline void GLAnsGameSharing::clear_lstopencard() {
  lstopencard_.Clear();
}
inline ::google::protobuf::int32 GLAnsGameSharing::lstopencard(int index) const {
  return lstopencard_.Get(index);
}
inline void GLAnsGameSharing::set_lstopencard(int index, ::google::protobuf::int32 value) {
  lstopencard_.Set(index, value);
}
inline void GLAnsGameSharing::add_lstopencard(::google::protobuf::int32 value) {
  lstopencard_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GLAnsGameSharing::lstopencard() const {
  return lstopencard_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GLAnsGameSharing::mutable_lstopencard() {
  return &lstopencard_;
}

// repeated int32 lstHoldCard = 4;
inline int GLAnsGameSharing::lstholdcard_size() const {
  return lstholdcard_.size();
}
inline void GLAnsGameSharing::clear_lstholdcard() {
  lstholdcard_.Clear();
}
inline ::google::protobuf::int32 GLAnsGameSharing::lstholdcard(int index) const {
  return lstholdcard_.Get(index);
}
inline void GLAnsGameSharing::set_lstholdcard(int index, ::google::protobuf::int32 value) {
  lstholdcard_.Set(index, value);
}
inline void GLAnsGameSharing::add_lstholdcard(::google::protobuf::int32 value) {
  lstholdcard_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GLAnsGameSharing::lstholdcard() const {
  return lstholdcard_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GLAnsGameSharing::mutable_lstholdcard() {
  return &lstholdcard_;
}

// -------------------------------------------------------------------

// GLAnsGameNagari

// required .GLAnsGameNagari.NAGARI_TYPE nType = 1;
inline bool GLAnsGameNagari::has_ntype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameNagari::set_has_ntype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameNagari::clear_has_ntype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameNagari::clear_ntype() {
  ntype_ = 1;
  clear_has_ntype();
}
inline ::GLAnsGameNagari_NAGARI_TYPE GLAnsGameNagari::ntype() const {
  return static_cast< ::GLAnsGameNagari_NAGARI_TYPE >(ntype_);
}
inline void GLAnsGameNagari::set_ntype(::GLAnsGameNagari_NAGARI_TYPE value) {
  GOOGLE_DCHECK(::GLAnsGameNagari_NAGARI_TYPE_IsValid(value));
  set_has_ntype();
  ntype_ = value;
}

// repeated int32 lstCard = 3;
inline int GLAnsGameNagari::lstcard_size() const {
  return lstcard_.size();
}
inline void GLAnsGameNagari::clear_lstcard() {
  lstcard_.Clear();
}
inline ::google::protobuf::int32 GLAnsGameNagari::lstcard(int index) const {
  return lstcard_.Get(index);
}
inline void GLAnsGameNagari::set_lstcard(int index, ::google::protobuf::int32 value) {
  lstcard_.Set(index, value);
}
inline void GLAnsGameNagari::add_lstcard(::google::protobuf::int32 value) {
  lstcard_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GLAnsGameNagari::lstcard() const {
  return lstcard_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GLAnsGameNagari::mutable_lstcard() {
  return &lstcard_;
}

// -------------------------------------------------------------------

// GLAnsGameChongTong

// optional int32 gameID = 1;
inline bool GLAnsGameChongTong::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameChongTong::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameChongTong::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameChongTong::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLAnsGameChongTong::gameid() const {
  return gameid_;
}
inline void GLAnsGameChongTong::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLAnsGameChongTong::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameChongTong::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameChongTong::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameChongTong::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLAnsGameChongTong::gameindex() const {
  return gameindex_;
}
inline void GLAnsGameChongTong::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// repeated int32 lstCard = 3;
inline int GLAnsGameChongTong::lstcard_size() const {
  return lstcard_.size();
}
inline void GLAnsGameChongTong::clear_lstcard() {
  lstcard_.Clear();
}
inline ::google::protobuf::int32 GLAnsGameChongTong::lstcard(int index) const {
  return lstcard_.Get(index);
}
inline void GLAnsGameChongTong::set_lstcard(int index, ::google::protobuf::int32 value) {
  lstcard_.Set(index, value);
}
inline void GLAnsGameChongTong::add_lstcard(::google::protobuf::int32 value) {
  lstcard_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GLAnsGameChongTong::lstcard() const {
  return lstcard_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GLAnsGameChongTong::mutable_lstcard() {
  return &lstcard_;
}

// -------------------------------------------------------------------

// GLAnsGameSelectCard

// optional int32 gameID = 1;
inline bool GLAnsGameSelectCard::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameSelectCard::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameSelectCard::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameSelectCard::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLAnsGameSelectCard::gameid() const {
  return gameid_;
}
inline void GLAnsGameSelectCard::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLAnsGameSelectCard::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameSelectCard::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameSelectCard::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameSelectCard::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLAnsGameSelectCard::gameindex() const {
  return gameindex_;
}
inline void GLAnsGameSelectCard::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// repeated int32 lstCard = 3;
inline int GLAnsGameSelectCard::lstcard_size() const {
  return lstcard_.size();
}
inline void GLAnsGameSelectCard::clear_lstcard() {
  lstcard_.Clear();
}
inline ::google::protobuf::int32 GLAnsGameSelectCard::lstcard(int index) const {
  return lstcard_.Get(index);
}
inline void GLAnsGameSelectCard::set_lstcard(int index, ::google::protobuf::int32 value) {
  lstcard_.Set(index, value);
}
inline void GLAnsGameSelectCard::add_lstcard(::google::protobuf::int32 value) {
  lstcard_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GLAnsGameSelectCard::lstcard() const {
  return lstcard_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GLAnsGameSelectCard::mutable_lstcard() {
  return &lstcard_;
}

// -------------------------------------------------------------------

// GLAnsGameBonus

// optional int32 gameID = 1;
inline bool GLAnsGameBonus::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameBonus::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameBonus::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameBonus::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLAnsGameBonus::gameid() const {
  return gameid_;
}
inline void GLAnsGameBonus::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLAnsGameBonus::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameBonus::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameBonus::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameBonus::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLAnsGameBonus::gameindex() const {
  return gameindex_;
}
inline void GLAnsGameBonus::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// required int32 nCard = 3;
inline bool GLAnsGameBonus::has_ncard() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GLAnsGameBonus::set_has_ncard() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GLAnsGameBonus::clear_has_ncard() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GLAnsGameBonus::clear_ncard() {
  ncard_ = 0;
  clear_has_ncard();
}
inline ::google::protobuf::int32 GLAnsGameBonus::ncard() const {
  return ncard_;
}
inline void GLAnsGameBonus::set_ncard(::google::protobuf::int32 value) {
  set_has_ncard();
  ncard_ = value;
}

// required int32 nCard2 = 4;
inline bool GLAnsGameBonus::has_ncard2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GLAnsGameBonus::set_has_ncard2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GLAnsGameBonus::clear_has_ncard2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GLAnsGameBonus::clear_ncard2() {
  ncard2_ = 0;
  clear_has_ncard2();
}
inline ::google::protobuf::int32 GLAnsGameBonus::ncard2() const {
  return ncard2_;
}
inline void GLAnsGameBonus::set_ncard2(::google::protobuf::int32 value) {
  set_has_ncard2();
  ncard2_ = value;
}

// -------------------------------------------------------------------

// GLAnsGameTakePee

// optional int32 gameID = 1;
inline bool GLAnsGameTakePee::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameTakePee::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameTakePee::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameTakePee::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLAnsGameTakePee::gameid() const {
  return gameid_;
}
inline void GLAnsGameTakePee::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLAnsGameTakePee::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameTakePee::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameTakePee::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameTakePee::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLAnsGameTakePee::gameindex() const {
  return gameindex_;
}
inline void GLAnsGameTakePee::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// required int32 nCard = 3;
inline bool GLAnsGameTakePee::has_ncard() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GLAnsGameTakePee::set_has_ncard() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GLAnsGameTakePee::clear_has_ncard() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GLAnsGameTakePee::clear_ncard() {
  ncard_ = 0;
  clear_has_ncard();
}
inline ::google::protobuf::int32 GLAnsGameTakePee::ncard() const {
  return ncard_;
}
inline void GLAnsGameTakePee::set_ncard(::google::protobuf::int32 value) {
  set_has_ncard();
  ncard_ = value;
}

// -------------------------------------------------------------------

// GLAnsGameBbuck

// optional int32 gameID = 1;
inline bool GLAnsGameBbuck::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameBbuck::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameBbuck::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameBbuck::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLAnsGameBbuck::gameid() const {
  return gameid_;
}
inline void GLAnsGameBbuck::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLAnsGameBbuck::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameBbuck::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameBbuck::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameBbuck::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLAnsGameBbuck::gameindex() const {
  return gameindex_;
}
inline void GLAnsGameBbuck::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// repeated int32 lstCard = 3;
inline int GLAnsGameBbuck::lstcard_size() const {
  return lstcard_.size();
}
inline void GLAnsGameBbuck::clear_lstcard() {
  lstcard_.Clear();
}
inline ::google::protobuf::int32 GLAnsGameBbuck::lstcard(int index) const {
  return lstcard_.Get(index);
}
inline void GLAnsGameBbuck::set_lstcard(int index, ::google::protobuf::int32 value) {
  lstcard_.Set(index, value);
}
inline void GLAnsGameBbuck::add_lstcard(::google::protobuf::int32 value) {
  lstcard_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GLAnsGameBbuck::lstcard() const {
  return lstcard_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GLAnsGameBbuck::mutable_lstcard() {
  return &lstcard_;
}

// required int32 nCnt = 4;
inline bool GLAnsGameBbuck::has_ncnt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GLAnsGameBbuck::set_has_ncnt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GLAnsGameBbuck::clear_has_ncnt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GLAnsGameBbuck::clear_ncnt() {
  ncnt_ = 0;
  clear_has_ncnt();
}
inline ::google::protobuf::int32 GLAnsGameBbuck::ncnt() const {
  return ncnt_;
}
inline void GLAnsGameBbuck::set_ncnt(::google::protobuf::int32 value) {
  set_has_ncnt();
  ncnt_ = value;
}

// -------------------------------------------------------------------

// GLAnsGameSeriseBbuck

// optional int32 gameID = 1;
inline bool GLAnsGameSeriseBbuck::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameSeriseBbuck::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameSeriseBbuck::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameSeriseBbuck::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLAnsGameSeriseBbuck::gameid() const {
  return gameid_;
}
inline void GLAnsGameSeriseBbuck::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLAnsGameSeriseBbuck::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameSeriseBbuck::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameSeriseBbuck::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameSeriseBbuck::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLAnsGameSeriseBbuck::gameindex() const {
  return gameindex_;
}
inline void GLAnsGameSeriseBbuck::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// repeated int32 lstCard = 3;
inline int GLAnsGameSeriseBbuck::lstcard_size() const {
  return lstcard_.size();
}
inline void GLAnsGameSeriseBbuck::clear_lstcard() {
  lstcard_.Clear();
}
inline ::google::protobuf::int32 GLAnsGameSeriseBbuck::lstcard(int index) const {
  return lstcard_.Get(index);
}
inline void GLAnsGameSeriseBbuck::set_lstcard(int index, ::google::protobuf::int32 value) {
  lstcard_.Set(index, value);
}
inline void GLAnsGameSeriseBbuck::add_lstcard(::google::protobuf::int32 value) {
  lstcard_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GLAnsGameSeriseBbuck::lstcard() const {
  return lstcard_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GLAnsGameSeriseBbuck::mutable_lstcard() {
  return &lstcard_;
}

// required int32 nCnt = 4;
inline bool GLAnsGameSeriseBbuck::has_ncnt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GLAnsGameSeriseBbuck::set_has_ncnt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GLAnsGameSeriseBbuck::clear_has_ncnt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GLAnsGameSeriseBbuck::clear_ncnt() {
  ncnt_ = 0;
  clear_has_ncnt();
}
inline ::google::protobuf::int32 GLAnsGameSeriseBbuck::ncnt() const {
  return ncnt_;
}
inline void GLAnsGameSeriseBbuck::set_ncnt(::google::protobuf::int32 value) {
  set_has_ncnt();
  ncnt_ = value;
}

// required string money = 5;
inline bool GLAnsGameSeriseBbuck::has_money() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GLAnsGameSeriseBbuck::set_has_money() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GLAnsGameSeriseBbuck::clear_has_money() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GLAnsGameSeriseBbuck::clear_money() {
  if (money_ != &::google::protobuf::internal::kEmptyString) {
    money_->clear();
  }
  clear_has_money();
}
inline const ::std::string& GLAnsGameSeriseBbuck::money() const {
  return *money_;
}
inline void GLAnsGameSeriseBbuck::set_money(const ::std::string& value) {
  set_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    money_ = new ::std::string;
  }
  money_->assign(value);
}
inline void GLAnsGameSeriseBbuck::set_money(const char* value) {
  set_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    money_ = new ::std::string;
  }
  money_->assign(value);
}
inline void GLAnsGameSeriseBbuck::set_money(const char* value, size_t size) {
  set_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    money_ = new ::std::string;
  }
  money_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GLAnsGameSeriseBbuck::mutable_money() {
  set_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    money_ = new ::std::string;
  }
  return money_;
}
inline ::std::string* GLAnsGameSeriseBbuck::release_money() {
  clear_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = money_;
    money_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GLAnsGameBbuckEat

// optional int32 gameID = 1;
inline bool GLAnsGameBbuckEat::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameBbuckEat::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameBbuckEat::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameBbuckEat::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLAnsGameBbuckEat::gameid() const {
  return gameid_;
}
inline void GLAnsGameBbuckEat::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLAnsGameBbuckEat::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameBbuckEat::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameBbuckEat::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameBbuckEat::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLAnsGameBbuckEat::gameindex() const {
  return gameindex_;
}
inline void GLAnsGameBbuckEat::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// required .GLAnsGameBbuckEat.CARD_TYPE nCardType = 3;
inline bool GLAnsGameBbuckEat::has_ncardtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GLAnsGameBbuckEat::set_has_ncardtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GLAnsGameBbuckEat::clear_has_ncardtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GLAnsGameBbuckEat::clear_ncardtype() {
  ncardtype_ = 1;
  clear_has_ncardtype();
}
inline ::GLAnsGameBbuckEat_CARD_TYPE GLAnsGameBbuckEat::ncardtype() const {
  return static_cast< ::GLAnsGameBbuckEat_CARD_TYPE >(ncardtype_);
}
inline void GLAnsGameBbuckEat::set_ncardtype(::GLAnsGameBbuckEat_CARD_TYPE value) {
  GOOGLE_DCHECK(::GLAnsGameBbuckEat_CARD_TYPE_IsValid(value));
  set_has_ncardtype();
  ncardtype_ = value;
}

// required .GLAnsGameBbuckEat.BBUCK_TYPE nBBuckType = 4;
inline bool GLAnsGameBbuckEat::has_nbbucktype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GLAnsGameBbuckEat::set_has_nbbucktype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GLAnsGameBbuckEat::clear_has_nbbucktype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GLAnsGameBbuckEat::clear_nbbucktype() {
  nbbucktype_ = 1;
  clear_has_nbbucktype();
}
inline ::GLAnsGameBbuckEat_BBUCK_TYPE GLAnsGameBbuckEat::nbbucktype() const {
  return static_cast< ::GLAnsGameBbuckEat_BBUCK_TYPE >(nbbucktype_);
}
inline void GLAnsGameBbuckEat::set_nbbucktype(::GLAnsGameBbuckEat_BBUCK_TYPE value) {
  GOOGLE_DCHECK(::GLAnsGameBbuckEat_BBUCK_TYPE_IsValid(value));
  set_has_nbbucktype();
  nbbucktype_ = value;
}

// -------------------------------------------------------------------

// GLAnsGameBomb

// optional int32 gameID = 1;
inline bool GLAnsGameBomb::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameBomb::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameBomb::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameBomb::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLAnsGameBomb::gameid() const {
  return gameid_;
}
inline void GLAnsGameBomb::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLAnsGameBomb::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameBomb::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameBomb::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameBomb::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLAnsGameBomb::gameindex() const {
  return gameindex_;
}
inline void GLAnsGameBomb::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// required .GLAnsGameBomb.CARD_TYPE nCardType = 3;
inline bool GLAnsGameBomb::has_ncardtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GLAnsGameBomb::set_has_ncardtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GLAnsGameBomb::clear_has_ncardtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GLAnsGameBomb::clear_ncardtype() {
  ncardtype_ = 1;
  clear_has_ncardtype();
}
inline ::GLAnsGameBomb_CARD_TYPE GLAnsGameBomb::ncardtype() const {
  return static_cast< ::GLAnsGameBomb_CARD_TYPE >(ncardtype_);
}
inline void GLAnsGameBomb::set_ncardtype(::GLAnsGameBomb_CARD_TYPE value) {
  GOOGLE_DCHECK(::GLAnsGameBomb_CARD_TYPE_IsValid(value));
  set_has_ncardtype();
  ncardtype_ = value;
}

// required int32 nCnt = 4;
inline bool GLAnsGameBomb::has_ncnt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GLAnsGameBomb::set_has_ncnt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GLAnsGameBomb::clear_has_ncnt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GLAnsGameBomb::clear_ncnt() {
  ncnt_ = 0;
  clear_has_ncnt();
}
inline ::google::protobuf::int32 GLAnsGameBomb::ncnt() const {
  return ncnt_;
}
inline void GLAnsGameBomb::set_ncnt(::google::protobuf::int32 value) {
  set_has_ncnt();
  ncnt_ = value;
}

// -------------------------------------------------------------------

// GLAnsGamePan

// optional int32 gameID = 1;
inline bool GLAnsGamePan::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGamePan::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGamePan::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGamePan::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLAnsGamePan::gameid() const {
  return gameid_;
}
inline void GLAnsGamePan::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLAnsGamePan::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGamePan::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGamePan::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGamePan::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLAnsGamePan::gameindex() const {
  return gameindex_;
}
inline void GLAnsGamePan::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// -------------------------------------------------------------------

// GLAnsGameDadak

// optional int32 gameID = 1;
inline bool GLAnsGameDadak::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameDadak::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameDadak::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameDadak::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLAnsGameDadak::gameid() const {
  return gameid_;
}
inline void GLAnsGameDadak::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLAnsGameDadak::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameDadak::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameDadak::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameDadak::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLAnsGameDadak::gameindex() const {
  return gameindex_;
}
inline void GLAnsGameDadak::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// required .GLAnsGameDadak.CARD_TYPE nCardType = 3;
inline bool GLAnsGameDadak::has_ncardtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GLAnsGameDadak::set_has_ncardtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GLAnsGameDadak::clear_has_ncardtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GLAnsGameDadak::clear_ncardtype() {
  ncardtype_ = 1;
  clear_has_ncardtype();
}
inline ::GLAnsGameDadak_CARD_TYPE GLAnsGameDadak::ncardtype() const {
  return static_cast< ::GLAnsGameDadak_CARD_TYPE >(ncardtype_);
}
inline void GLAnsGameDadak::set_ncardtype(::GLAnsGameDadak_CARD_TYPE value) {
  GOOGLE_DCHECK(::GLAnsGameDadak_CARD_TYPE_IsValid(value));
  set_has_ncardtype();
  ncardtype_ = value;
}

// -------------------------------------------------------------------

// GLAnsGameJjok

// optional int32 gameID = 1;
inline bool GLAnsGameJjok::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameJjok::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameJjok::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameJjok::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLAnsGameJjok::gameid() const {
  return gameid_;
}
inline void GLAnsGameJjok::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLAnsGameJjok::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameJjok::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameJjok::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameJjok::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLAnsGameJjok::gameindex() const {
  return gameindex_;
}
inline void GLAnsGameJjok::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// required .GLAnsGameJjok.CARD_TYPE nCardType = 3;
inline bool GLAnsGameJjok::has_ncardtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GLAnsGameJjok::set_has_ncardtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GLAnsGameJjok::clear_has_ncardtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GLAnsGameJjok::clear_ncardtype() {
  ncardtype_ = 1;
  clear_has_ncardtype();
}
inline ::GLAnsGameJjok_CARD_TYPE GLAnsGameJjok::ncardtype() const {
  return static_cast< ::GLAnsGameJjok_CARD_TYPE >(ncardtype_);
}
inline void GLAnsGameJjok::set_ncardtype(::GLAnsGameJjok_CARD_TYPE value) {
  GOOGLE_DCHECK(::GLAnsGameJjok_CARD_TYPE_IsValid(value));
  set_has_ncardtype();
  ncardtype_ = value;
}

// -------------------------------------------------------------------

// GLAnsGameUpset

// optional int32 gameID = 1;
inline bool GLAnsGameUpset::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameUpset::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameUpset::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameUpset::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLAnsGameUpset::gameid() const {
  return gameid_;
}
inline void GLAnsGameUpset::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLAnsGameUpset::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameUpset::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameUpset::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameUpset::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLAnsGameUpset::gameindex() const {
  return gameindex_;
}
inline void GLAnsGameUpset::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// required int32 nCard = 3;
inline bool GLAnsGameUpset::has_ncard() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GLAnsGameUpset::set_has_ncard() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GLAnsGameUpset::clear_has_ncard() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GLAnsGameUpset::clear_ncard() {
  ncard_ = 0;
  clear_has_ncard();
}
inline ::google::protobuf::int32 GLAnsGameUpset::ncard() const {
  return ncard_;
}
inline void GLAnsGameUpset::set_ncard(::google::protobuf::int32 value) {
  set_has_ncard();
  ncard_ = value;
}

// -------------------------------------------------------------------

// GLAnsGameAllEatUp

// optional int32 gameID = 1;
inline bool GLAnsGameAllEatUp::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameAllEatUp::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameAllEatUp::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameAllEatUp::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLAnsGameAllEatUp::gameid() const {
  return gameid_;
}
inline void GLAnsGameAllEatUp::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLAnsGameAllEatUp::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameAllEatUp::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameAllEatUp::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameAllEatUp::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLAnsGameAllEatUp::gameindex() const {
  return gameindex_;
}
inline void GLAnsGameAllEatUp::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// repeated int32 lstCard = 3;
inline int GLAnsGameAllEatUp::lstcard_size() const {
  return lstcard_.size();
}
inline void GLAnsGameAllEatUp::clear_lstcard() {
  lstcard_.Clear();
}
inline ::google::protobuf::int32 GLAnsGameAllEatUp::lstcard(int index) const {
  return lstcard_.Get(index);
}
inline void GLAnsGameAllEatUp::set_lstcard(int index, ::google::protobuf::int32 value) {
  lstcard_.Set(index, value);
}
inline void GLAnsGameAllEatUp::add_lstcard(::google::protobuf::int32 value) {
  lstcard_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GLAnsGameAllEatUp::lstcard() const {
  return lstcard_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GLAnsGameAllEatUp::mutable_lstcard() {
  return &lstcard_;
}

// -------------------------------------------------------------------

// GLAnsGameNotiTurn

// optional int32 gameID = 1;
inline bool GLAnsGameNotiTurn::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameNotiTurn::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameNotiTurn::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameNotiTurn::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLAnsGameNotiTurn::gameid() const {
  return gameid_;
}
inline void GLAnsGameNotiTurn::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLAnsGameNotiTurn::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameNotiTurn::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameNotiTurn::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameNotiTurn::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLAnsGameNotiTurn::gameindex() const {
  return gameindex_;
}
inline void GLAnsGameNotiTurn::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// -------------------------------------------------------------------

// GLAnsGameMoveTen

// optional int32 gameID = 1;
inline bool GLAnsGameMoveTen::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameMoveTen::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameMoveTen::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameMoveTen::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLAnsGameMoveTen::gameid() const {
  return gameid_;
}
inline void GLAnsGameMoveTen::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLAnsGameMoveTen::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameMoveTen::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameMoveTen::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameMoveTen::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLAnsGameMoveTen::gameindex() const {
  return gameindex_;
}
inline void GLAnsGameMoveTen::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// -------------------------------------------------------------------

// GLAnsGameMoveTenAns

// optional int32 gameID = 1;
inline bool GLAnsGameMoveTenAns::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameMoveTenAns::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameMoveTenAns::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameMoveTenAns::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLAnsGameMoveTenAns::gameid() const {
  return gameid_;
}
inline void GLAnsGameMoveTenAns::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLAnsGameMoveTenAns::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameMoveTenAns::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameMoveTenAns::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameMoveTenAns::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLAnsGameMoveTenAns::gameindex() const {
  return gameindex_;
}
inline void GLAnsGameMoveTenAns::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// required bool bMove = 3;
inline bool GLAnsGameMoveTenAns::has_bmove() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GLAnsGameMoveTenAns::set_has_bmove() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GLAnsGameMoveTenAns::clear_has_bmove() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GLAnsGameMoveTenAns::clear_bmove() {
  bmove_ = false;
  clear_has_bmove();
}
inline bool GLAnsGameMoveTenAns::bmove() const {
  return bmove_;
}
inline void GLAnsGameMoveTenAns::set_bmove(bool value) {
  set_has_bmove();
  bmove_ = value;
}

// -------------------------------------------------------------------

// GLAnsGameChoiceCard

// optional int32 gameID = 1;
inline bool GLAnsGameChoiceCard::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameChoiceCard::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameChoiceCard::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameChoiceCard::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLAnsGameChoiceCard::gameid() const {
  return gameid_;
}
inline void GLAnsGameChoiceCard::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLAnsGameChoiceCard::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameChoiceCard::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameChoiceCard::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameChoiceCard::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLAnsGameChoiceCard::gameindex() const {
  return gameindex_;
}
inline void GLAnsGameChoiceCard::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// repeated int32 lstCard = 3;
inline int GLAnsGameChoiceCard::lstcard_size() const {
  return lstcard_.size();
}
inline void GLAnsGameChoiceCard::clear_lstcard() {
  lstcard_.Clear();
}
inline ::google::protobuf::int32 GLAnsGameChoiceCard::lstcard(int index) const {
  return lstcard_.Get(index);
}
inline void GLAnsGameChoiceCard::set_lstcard(int index, ::google::protobuf::int32 value) {
  lstcard_.Set(index, value);
}
inline void GLAnsGameChoiceCard::add_lstcard(::google::protobuf::int32 value) {
  lstcard_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GLAnsGameChoiceCard::lstcard() const {
  return lstcard_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GLAnsGameChoiceCard::mutable_lstcard() {
  return &lstcard_;
}

// required .GLAnsGameChoiceCard.Type nType = 4;
inline bool GLAnsGameChoiceCard::has_ntype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GLAnsGameChoiceCard::set_has_ntype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GLAnsGameChoiceCard::clear_has_ntype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GLAnsGameChoiceCard::clear_ntype() {
  ntype_ = 1;
  clear_has_ntype();
}
inline ::GLAnsGameChoiceCard_Type GLAnsGameChoiceCard::ntype() const {
  return static_cast< ::GLAnsGameChoiceCard_Type >(ntype_);
}
inline void GLAnsGameChoiceCard::set_ntype(::GLAnsGameChoiceCard_Type value) {
  GOOGLE_DCHECK(::GLAnsGameChoiceCard_Type_IsValid(value));
  set_has_ntype();
  ntype_ = value;
}

// -------------------------------------------------------------------

// GLAnsGameShake

// optional int32 gameID = 1;
inline bool GLAnsGameShake::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameShake::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameShake::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameShake::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLAnsGameShake::gameid() const {
  return gameid_;
}
inline void GLAnsGameShake::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLAnsGameShake::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameShake::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameShake::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameShake::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLAnsGameShake::gameindex() const {
  return gameindex_;
}
inline void GLAnsGameShake::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// repeated int32 lstCard = 3;
inline int GLAnsGameShake::lstcard_size() const {
  return lstcard_.size();
}
inline void GLAnsGameShake::clear_lstcard() {
  lstcard_.Clear();
}
inline ::google::protobuf::int32 GLAnsGameShake::lstcard(int index) const {
  return lstcard_.Get(index);
}
inline void GLAnsGameShake::set_lstcard(int index, ::google::protobuf::int32 value) {
  lstcard_.Set(index, value);
}
inline void GLAnsGameShake::add_lstcard(::google::protobuf::int32 value) {
  lstcard_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GLAnsGameShake::lstcard() const {
  return lstcard_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GLAnsGameShake::mutable_lstcard() {
  return &lstcard_;
}

// -------------------------------------------------------------------

// GLAnsGameShakeAns

// optional int32 gameID = 1;
inline bool GLAnsGameShakeAns::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameShakeAns::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameShakeAns::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameShakeAns::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLAnsGameShakeAns::gameid() const {
  return gameid_;
}
inline void GLAnsGameShakeAns::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLAnsGameShakeAns::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameShakeAns::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameShakeAns::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameShakeAns::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLAnsGameShakeAns::gameindex() const {
  return gameindex_;
}
inline void GLAnsGameShakeAns::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// repeated int32 lstCard = 3;
inline int GLAnsGameShakeAns::lstcard_size() const {
  return lstcard_.size();
}
inline void GLAnsGameShakeAns::clear_lstcard() {
  lstcard_.Clear();
}
inline ::google::protobuf::int32 GLAnsGameShakeAns::lstcard(int index) const {
  return lstcard_.Get(index);
}
inline void GLAnsGameShakeAns::set_lstcard(int index, ::google::protobuf::int32 value) {
  lstcard_.Set(index, value);
}
inline void GLAnsGameShakeAns::add_lstcard(::google::protobuf::int32 value) {
  lstcard_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GLAnsGameShakeAns::lstcard() const {
  return lstcard_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GLAnsGameShakeAns::mutable_lstcard() {
  return &lstcard_;
}

// required bool bShake = 4;
inline bool GLAnsGameShakeAns::has_bshake() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GLAnsGameShakeAns::set_has_bshake() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GLAnsGameShakeAns::clear_has_bshake() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GLAnsGameShakeAns::clear_bshake() {
  bshake_ = false;
  clear_has_bshake();
}
inline bool GLAnsGameShakeAns::bshake() const {
  return bshake_;
}
inline void GLAnsGameShakeAns::set_bshake(bool value) {
  set_has_bshake();
  bshake_ = value;
}

// -------------------------------------------------------------------

// GLAnsGameShakeCount

// optional int32 gameID = 1;
inline bool GLAnsGameShakeCount::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameShakeCount::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameShakeCount::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameShakeCount::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLAnsGameShakeCount::gameid() const {
  return gameid_;
}
inline void GLAnsGameShakeCount::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLAnsGameShakeCount::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameShakeCount::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameShakeCount::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameShakeCount::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLAnsGameShakeCount::gameindex() const {
  return gameindex_;
}
inline void GLAnsGameShakeCount::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// required int32 nCnt = 3;
inline bool GLAnsGameShakeCount::has_ncnt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GLAnsGameShakeCount::set_has_ncnt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GLAnsGameShakeCount::clear_has_ncnt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GLAnsGameShakeCount::clear_ncnt() {
  ncnt_ = 0;
  clear_has_ncnt();
}
inline ::google::protobuf::int32 GLAnsGameShakeCount::ncnt() const {
  return ncnt_;
}
inline void GLAnsGameShakeCount::set_ncnt(::google::protobuf::int32 value) {
  set_has_ncnt();
  ncnt_ = value;
}

// -------------------------------------------------------------------

// GLAnsGameCapType

// optional int32 gameID = 1;
inline bool GLAnsGameCapType::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameCapType::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameCapType::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameCapType::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLAnsGameCapType::gameid() const {
  return gameid_;
}
inline void GLAnsGameCapType::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLAnsGameCapType::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameCapType::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameCapType::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameCapType::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLAnsGameCapType::gameindex() const {
  return gameindex_;
}
inline void GLAnsGameCapType::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// required .GLAnsGameCapType.CAP_TYPE nType = 3;
inline bool GLAnsGameCapType::has_ntype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GLAnsGameCapType::set_has_ntype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GLAnsGameCapType::clear_has_ntype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GLAnsGameCapType::clear_ntype() {
  ntype_ = 1;
  clear_has_ntype();
}
inline ::GLAnsGameCapType_CAP_TYPE GLAnsGameCapType::ntype() const {
  return static_cast< ::GLAnsGameCapType_CAP_TYPE >(ntype_);
}
inline void GLAnsGameCapType::set_ntype(::GLAnsGameCapType_CAP_TYPE value) {
  GOOGLE_DCHECK(::GLAnsGameCapType_CAP_TYPE_IsValid(value));
  set_has_ntype();
  ntype_ = value;
}

// -------------------------------------------------------------------

// GLAnsGameGodori

// optional int32 gameID = 1;
inline bool GLAnsGameGodori::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameGodori::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameGodori::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameGodori::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLAnsGameGodori::gameid() const {
  return gameid_;
}
inline void GLAnsGameGodori::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLAnsGameGodori::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameGodori::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameGodori::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameGodori::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLAnsGameGodori::gameindex() const {
  return gameindex_;
}
inline void GLAnsGameGodori::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// required .GLAnsGameGodori.JOKBO_STATE nType = 3;
inline bool GLAnsGameGodori::has_ntype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GLAnsGameGodori::set_has_ntype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GLAnsGameGodori::clear_has_ntype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GLAnsGameGodori::clear_ntype() {
  ntype_ = 1;
  clear_has_ntype();
}
inline ::GLAnsGameGodori_JOKBO_STATE GLAnsGameGodori::ntype() const {
  return static_cast< ::GLAnsGameGodori_JOKBO_STATE >(ntype_);
}
inline void GLAnsGameGodori::set_ntype(::GLAnsGameGodori_JOKBO_STATE value) {
  GOOGLE_DCHECK(::GLAnsGameGodori_JOKBO_STATE_IsValid(value));
  set_has_ntype();
  ntype_ = value;
}

// -------------------------------------------------------------------

// GLAnsGameKusa

// optional int32 gameID = 1;
inline bool GLAnsGameKusa::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameKusa::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameKusa::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameKusa::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLAnsGameKusa::gameid() const {
  return gameid_;
}
inline void GLAnsGameKusa::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLAnsGameKusa::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameKusa::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameKusa::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameKusa::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLAnsGameKusa::gameindex() const {
  return gameindex_;
}
inline void GLAnsGameKusa::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// required .GLAnsGameKusa.JOKBO_STATE nType = 3;
inline bool GLAnsGameKusa::has_ntype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GLAnsGameKusa::set_has_ntype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GLAnsGameKusa::clear_has_ntype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GLAnsGameKusa::clear_ntype() {
  ntype_ = 1;
  clear_has_ntype();
}
inline ::GLAnsGameKusa_JOKBO_STATE GLAnsGameKusa::ntype() const {
  return static_cast< ::GLAnsGameKusa_JOKBO_STATE >(ntype_);
}
inline void GLAnsGameKusa::set_ntype(::GLAnsGameKusa_JOKBO_STATE value) {
  GOOGLE_DCHECK(::GLAnsGameKusa_JOKBO_STATE_IsValid(value));
  set_has_ntype();
  ntype_ = value;
}

// -------------------------------------------------------------------

// GLAnsGameRed

// optional int32 gameID = 1;
inline bool GLAnsGameRed::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameRed::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameRed::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameRed::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLAnsGameRed::gameid() const {
  return gameid_;
}
inline void GLAnsGameRed::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLAnsGameRed::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameRed::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameRed::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameRed::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLAnsGameRed::gameindex() const {
  return gameindex_;
}
inline void GLAnsGameRed::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// required .GLAnsGameRed.JOKBO_STATE nType = 3;
inline bool GLAnsGameRed::has_ntype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GLAnsGameRed::set_has_ntype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GLAnsGameRed::clear_has_ntype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GLAnsGameRed::clear_ntype() {
  ntype_ = 1;
  clear_has_ntype();
}
inline ::GLAnsGameRed_JOKBO_STATE GLAnsGameRed::ntype() const {
  return static_cast< ::GLAnsGameRed_JOKBO_STATE >(ntype_);
}
inline void GLAnsGameRed::set_ntype(::GLAnsGameRed_JOKBO_STATE value) {
  GOOGLE_DCHECK(::GLAnsGameRed_JOKBO_STATE_IsValid(value));
  set_has_ntype();
  ntype_ = value;
}

// -------------------------------------------------------------------

// GLAnsGameBlue

// optional int32 gameID = 1;
inline bool GLAnsGameBlue::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameBlue::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameBlue::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameBlue::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLAnsGameBlue::gameid() const {
  return gameid_;
}
inline void GLAnsGameBlue::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLAnsGameBlue::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameBlue::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameBlue::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameBlue::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLAnsGameBlue::gameindex() const {
  return gameindex_;
}
inline void GLAnsGameBlue::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// required .GLAnsGameBlue.JOKBO_STATE nType = 3;
inline bool GLAnsGameBlue::has_ntype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GLAnsGameBlue::set_has_ntype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GLAnsGameBlue::clear_has_ntype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GLAnsGameBlue::clear_ntype() {
  ntype_ = 1;
  clear_has_ntype();
}
inline ::GLAnsGameBlue_JOKBO_STATE GLAnsGameBlue::ntype() const {
  return static_cast< ::GLAnsGameBlue_JOKBO_STATE >(ntype_);
}
inline void GLAnsGameBlue::set_ntype(::GLAnsGameBlue_JOKBO_STATE value) {
  GOOGLE_DCHECK(::GLAnsGameBlue_JOKBO_STATE_IsValid(value));
  set_has_ntype();
  ntype_ = value;
}

// -------------------------------------------------------------------

// GLAnsGameBak

// optional int32 gameID = 1;
inline bool GLAnsGameBak::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameBak::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameBak::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameBak::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLAnsGameBak::gameid() const {
  return gameid_;
}
inline void GLAnsGameBak::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLAnsGameBak::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameBak::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameBak::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameBak::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLAnsGameBak::gameindex() const {
  return gameindex_;
}
inline void GLAnsGameBak::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// required .GLAnsGameBak.BAK_TYPE nType = 3;
inline bool GLAnsGameBak::has_ntype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GLAnsGameBak::set_has_ntype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GLAnsGameBak::clear_has_ntype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GLAnsGameBak::clear_ntype() {
  ntype_ = 1;
  clear_has_ntype();
}
inline ::GLAnsGameBak_BAK_TYPE GLAnsGameBak::ntype() const {
  return static_cast< ::GLAnsGameBak_BAK_TYPE >(ntype_);
}
inline void GLAnsGameBak::set_ntype(::GLAnsGameBak_BAK_TYPE value) {
  GOOGLE_DCHECK(::GLAnsGameBak_BAK_TYPE_IsValid(value));
  set_has_ntype();
  ntype_ = value;
}

// -------------------------------------------------------------------

// GLAnsGameBakFail

// optional int32 gameID = 1;
inline bool GLAnsGameBakFail::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameBakFail::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameBakFail::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameBakFail::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLAnsGameBakFail::gameid() const {
  return gameid_;
}
inline void GLAnsGameBakFail::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLAnsGameBakFail::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameBakFail::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameBakFail::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameBakFail::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLAnsGameBakFail::gameindex() const {
  return gameindex_;
}
inline void GLAnsGameBakFail::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// required .GLAnsGameBakFail.BAK_TYPE nType = 3;
inline bool GLAnsGameBakFail::has_ntype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GLAnsGameBakFail::set_has_ntype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GLAnsGameBakFail::clear_has_ntype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GLAnsGameBakFail::clear_ntype() {
  ntype_ = 1;
  clear_has_ntype();
}
inline ::GLAnsGameBakFail_BAK_TYPE GLAnsGameBakFail::ntype() const {
  return static_cast< ::GLAnsGameBakFail_BAK_TYPE >(ntype_);
}
inline void GLAnsGameBakFail::set_ntype(::GLAnsGameBakFail_BAK_TYPE value) {
  GOOGLE_DCHECK(::GLAnsGameBakFail_BAK_TYPE_IsValid(value));
  set_has_ntype();
  ntype_ = value;
}

// -------------------------------------------------------------------

// GLAnsGameNotiMission

// required int32 nMulNum = 1;
inline bool GLAnsGameNotiMission::has_nmulnum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameNotiMission::set_has_nmulnum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameNotiMission::clear_has_nmulnum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameNotiMission::clear_nmulnum() {
  nmulnum_ = 0;
  clear_has_nmulnum();
}
inline ::google::protobuf::int32 GLAnsGameNotiMission::nmulnum() const {
  return nmulnum_;
}
inline void GLAnsGameNotiMission::set_nmulnum(::google::protobuf::int32 value) {
  set_has_nmulnum();
  nmulnum_ = value;
}

// repeated int32 lstCard = 2;
inline int GLAnsGameNotiMission::lstcard_size() const {
  return lstcard_.size();
}
inline void GLAnsGameNotiMission::clear_lstcard() {
  lstcard_.Clear();
}
inline ::google::protobuf::int32 GLAnsGameNotiMission::lstcard(int index) const {
  return lstcard_.Get(index);
}
inline void GLAnsGameNotiMission::set_lstcard(int index, ::google::protobuf::int32 value) {
  lstcard_.Set(index, value);
}
inline void GLAnsGameNotiMission::add_lstcard(::google::protobuf::int32 value) {
  lstcard_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GLAnsGameNotiMission::lstcard() const {
  return lstcard_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GLAnsGameNotiMission::mutable_lstcard() {
  return &lstcard_;
}

// required string title = 3;
inline bool GLAnsGameNotiMission::has_title() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GLAnsGameNotiMission::set_has_title() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GLAnsGameNotiMission::clear_has_title() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GLAnsGameNotiMission::clear_title() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& GLAnsGameNotiMission::title() const {
  return *title_;
}
inline void GLAnsGameNotiMission::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void GLAnsGameNotiMission::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void GLAnsGameNotiMission::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GLAnsGameNotiMission::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* GLAnsGameNotiMission::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .GLAnsGameNotiMission.MISSION_TYPE nType = 4;
inline bool GLAnsGameNotiMission::has_ntype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GLAnsGameNotiMission::set_has_ntype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GLAnsGameNotiMission::clear_has_ntype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GLAnsGameNotiMission::clear_ntype() {
  ntype_ = 1;
  clear_has_ntype();
}
inline ::GLAnsGameNotiMission_MISSION_TYPE GLAnsGameNotiMission::ntype() const {
  return static_cast< ::GLAnsGameNotiMission_MISSION_TYPE >(ntype_);
}
inline void GLAnsGameNotiMission::set_ntype(::GLAnsGameNotiMission_MISSION_TYPE value) {
  GOOGLE_DCHECK(::GLAnsGameNotiMission_MISSION_TYPE_IsValid(value));
  set_has_ntype();
  ntype_ = value;
}

// -------------------------------------------------------------------

// GLAnsGameNotiMissionCard

// optional int32 gameID = 1;
inline bool GLAnsGameNotiMissionCard::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameNotiMissionCard::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameNotiMissionCard::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameNotiMissionCard::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLAnsGameNotiMissionCard::gameid() const {
  return gameid_;
}
inline void GLAnsGameNotiMissionCard::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLAnsGameNotiMissionCard::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameNotiMissionCard::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameNotiMissionCard::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameNotiMissionCard::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLAnsGameNotiMissionCard::gameindex() const {
  return gameindex_;
}
inline void GLAnsGameNotiMissionCard::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// repeated int32 lstCard = 3;
inline int GLAnsGameNotiMissionCard::lstcard_size() const {
  return lstcard_.size();
}
inline void GLAnsGameNotiMissionCard::clear_lstcard() {
  lstcard_.Clear();
}
inline ::google::protobuf::int32 GLAnsGameNotiMissionCard::lstcard(int index) const {
  return lstcard_.Get(index);
}
inline void GLAnsGameNotiMissionCard::set_lstcard(int index, ::google::protobuf::int32 value) {
  lstcard_.Set(index, value);
}
inline void GLAnsGameNotiMissionCard::add_lstcard(::google::protobuf::int32 value) {
  lstcard_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GLAnsGameNotiMissionCard::lstcard() const {
  return lstcard_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GLAnsGameNotiMissionCard::mutable_lstcard() {
  return &lstcard_;
}

// -------------------------------------------------------------------

// GLAnsGameMissionState

// optional int32 gameID = 1;
inline bool GLAnsGameMissionState::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameMissionState::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameMissionState::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameMissionState::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLAnsGameMissionState::gameid() const {
  return gameid_;
}
inline void GLAnsGameMissionState::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLAnsGameMissionState::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameMissionState::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameMissionState::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameMissionState::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLAnsGameMissionState::gameindex() const {
  return gameindex_;
}
inline void GLAnsGameMissionState::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// required string money = 3;
inline bool GLAnsGameMissionState::has_money() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GLAnsGameMissionState::set_has_money() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GLAnsGameMissionState::clear_has_money() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GLAnsGameMissionState::clear_money() {
  if (money_ != &::google::protobuf::internal::kEmptyString) {
    money_->clear();
  }
  clear_has_money();
}
inline const ::std::string& GLAnsGameMissionState::money() const {
  return *money_;
}
inline void GLAnsGameMissionState::set_money(const ::std::string& value) {
  set_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    money_ = new ::std::string;
  }
  money_->assign(value);
}
inline void GLAnsGameMissionState::set_money(const char* value) {
  set_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    money_ = new ::std::string;
  }
  money_->assign(value);
}
inline void GLAnsGameMissionState::set_money(const char* value, size_t size) {
  set_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    money_ = new ::std::string;
  }
  money_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GLAnsGameMissionState::mutable_money() {
  set_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    money_ = new ::std::string;
  }
  return money_;
}
inline ::std::string* GLAnsGameMissionState::release_money() {
  clear_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = money_;
    money_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .GLAnsGameMissionState.MISSION_STATE nType = 4;
inline bool GLAnsGameMissionState::has_ntype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GLAnsGameMissionState::set_has_ntype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GLAnsGameMissionState::clear_has_ntype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GLAnsGameMissionState::clear_ntype() {
  ntype_ = 1;
  clear_has_ntype();
}
inline ::GLAnsGameMissionState_MISSION_STATE GLAnsGameMissionState::ntype() const {
  return static_cast< ::GLAnsGameMissionState_MISSION_STATE >(ntype_);
}
inline void GLAnsGameMissionState::set_ntype(::GLAnsGameMissionState_MISSION_STATE value) {
  GOOGLE_DCHECK(::GLAnsGameMissionState_MISSION_STATE_IsValid(value));
  set_has_ntype();
  ntype_ = value;
}

// -------------------------------------------------------------------

// GLAnsGameGostop

// optional int32 gameID = 1;
inline bool GLAnsGameGostop::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameGostop::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameGostop::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameGostop::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLAnsGameGostop::gameid() const {
  return gameid_;
}
inline void GLAnsGameGostop::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLAnsGameGostop::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameGostop::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameGostop::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameGostop::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLAnsGameGostop::gameindex() const {
  return gameindex_;
}
inline void GLAnsGameGostop::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// required int32 nCnt = 3;
inline bool GLAnsGameGostop::has_ncnt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GLAnsGameGostop::set_has_ncnt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GLAnsGameGostop::clear_has_ncnt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GLAnsGameGostop::clear_ncnt() {
  ncnt_ = 0;
  clear_has_ncnt();
}
inline ::google::protobuf::int32 GLAnsGameGostop::ncnt() const {
  return ncnt_;
}
inline void GLAnsGameGostop::set_ncnt(::google::protobuf::int32 value) {
  set_has_ncnt();
  ncnt_ = value;
}

// required string money = 4;
inline bool GLAnsGameGostop::has_money() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GLAnsGameGostop::set_has_money() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GLAnsGameGostop::clear_has_money() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GLAnsGameGostop::clear_money() {
  if (money_ != &::google::protobuf::internal::kEmptyString) {
    money_->clear();
  }
  clear_has_money();
}
inline const ::std::string& GLAnsGameGostop::money() const {
  return *money_;
}
inline void GLAnsGameGostop::set_money(const ::std::string& value) {
  set_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    money_ = new ::std::string;
  }
  money_->assign(value);
}
inline void GLAnsGameGostop::set_money(const char* value) {
  set_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    money_ = new ::std::string;
  }
  money_->assign(value);
}
inline void GLAnsGameGostop::set_money(const char* value, size_t size) {
  set_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    money_ = new ::std::string;
  }
  money_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GLAnsGameGostop::mutable_money() {
  set_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    money_ = new ::std::string;
  }
  return money_;
}
inline ::std::string* GLAnsGameGostop::release_money() {
  clear_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = money_;
    money_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GLAnsGameGostopAns

// optional int32 gameID = 1;
inline bool GLAnsGameGostopAns::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameGostopAns::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameGostopAns::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameGostopAns::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLAnsGameGostopAns::gameid() const {
  return gameid_;
}
inline void GLAnsGameGostopAns::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLAnsGameGostopAns::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameGostopAns::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameGostopAns::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameGostopAns::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLAnsGameGostopAns::gameindex() const {
  return gameindex_;
}
inline void GLAnsGameGostopAns::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// required int32 nCnt = 3;
inline bool GLAnsGameGostopAns::has_ncnt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GLAnsGameGostopAns::set_has_ncnt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GLAnsGameGostopAns::clear_has_ncnt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GLAnsGameGostopAns::clear_ncnt() {
  ncnt_ = 0;
  clear_has_ncnt();
}
inline ::google::protobuf::int32 GLAnsGameGostopAns::ncnt() const {
  return ncnt_;
}
inline void GLAnsGameGostopAns::set_ncnt(::google::protobuf::int32 value) {
  set_has_ncnt();
  ncnt_ = value;
}

// -------------------------------------------------------------------

// GLAnsGameStopAns

// optional int32 gameID = 1;
inline bool GLAnsGameStopAns::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameStopAns::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameStopAns::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameStopAns::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLAnsGameStopAns::gameid() const {
  return gameid_;
}
inline void GLAnsGameStopAns::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLAnsGameStopAns::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameStopAns::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameStopAns::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameStopAns::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLAnsGameStopAns::gameindex() const {
  return gameindex_;
}
inline void GLAnsGameStopAns::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// -------------------------------------------------------------------

// GLAnsGameResult

// optional int32 gameID = 1;
inline bool GLAnsGameResult::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameResult::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameResult::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameResult::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLAnsGameResult::gameid() const {
  return gameid_;
}
inline void GLAnsGameResult::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLAnsGameResult::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameResult::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameResult::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameResult::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLAnsGameResult::gameindex() const {
  return gameindex_;
}
inline void GLAnsGameResult::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// repeated int32 level = 3;
inline int GLAnsGameResult::level_size() const {
  return level_.size();
}
inline void GLAnsGameResult::clear_level() {
  level_.Clear();
}
inline ::google::protobuf::int32 GLAnsGameResult::level(int index) const {
  return level_.Get(index);
}
inline void GLAnsGameResult::set_level(int index, ::google::protobuf::int32 value) {
  level_.Set(index, value);
}
inline void GLAnsGameResult::add_level(::google::protobuf::int32 value) {
  level_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GLAnsGameResult::level() const {
  return level_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GLAnsGameResult::mutable_level() {
  return &level_;
}

// required string money = 4;
inline bool GLAnsGameResult::has_money() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GLAnsGameResult::set_has_money() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GLAnsGameResult::clear_has_money() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GLAnsGameResult::clear_money() {
  if (money_ != &::google::protobuf::internal::kEmptyString) {
    money_->clear();
  }
  clear_has_money();
}
inline const ::std::string& GLAnsGameResult::money() const {
  return *money_;
}
inline void GLAnsGameResult::set_money(const ::std::string& value) {
  set_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    money_ = new ::std::string;
  }
  money_->assign(value);
}
inline void GLAnsGameResult::set_money(const char* value) {
  set_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    money_ = new ::std::string;
  }
  money_->assign(value);
}
inline void GLAnsGameResult::set_money(const char* value, size_t size) {
  set_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    money_ = new ::std::string;
  }
  money_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GLAnsGameResult::mutable_money() {
  set_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    money_ = new ::std::string;
  }
  return money_;
}
inline ::std::string* GLAnsGameResult::release_money() {
  clear_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = money_;
    money_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 dealPoint = 5;
inline bool GLAnsGameResult::has_dealpoint() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GLAnsGameResult::set_has_dealpoint() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GLAnsGameResult::clear_has_dealpoint() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GLAnsGameResult::clear_dealpoint() {
  dealpoint_ = 0;
  clear_has_dealpoint();
}
inline ::google::protobuf::int32 GLAnsGameResult::dealpoint() const {
  return dealpoint_;
}
inline void GLAnsGameResult::set_dealpoint(::google::protobuf::int32 value) {
  set_has_dealpoint();
  dealpoint_ = value;
}

// required int32 capPoint = 6;
inline bool GLAnsGameResult::has_cappoint() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GLAnsGameResult::set_has_cappoint() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GLAnsGameResult::clear_has_cappoint() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GLAnsGameResult::clear_cappoint() {
  cappoint_ = 0;
  clear_has_cappoint();
}
inline ::google::protobuf::int32 GLAnsGameResult::cappoint() const {
  return cappoint_;
}
inline void GLAnsGameResult::set_cappoint(::google::protobuf::int32 value) {
  set_has_cappoint();
  cappoint_ = value;
}

// required int32 tenPoint = 7;
inline bool GLAnsGameResult::has_tenpoint() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GLAnsGameResult::set_has_tenpoint() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GLAnsGameResult::clear_has_tenpoint() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GLAnsGameResult::clear_tenpoint() {
  tenpoint_ = 0;
  clear_has_tenpoint();
}
inline ::google::protobuf::int32 GLAnsGameResult::tenpoint() const {
  return tenpoint_;
}
inline void GLAnsGameResult::set_tenpoint(::google::protobuf::int32 value) {
  set_has_tenpoint();
  tenpoint_ = value;
}

// required int32 fivePoint = 8;
inline bool GLAnsGameResult::has_fivepoint() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GLAnsGameResult::set_has_fivepoint() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GLAnsGameResult::clear_has_fivepoint() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GLAnsGameResult::clear_fivepoint() {
  fivepoint_ = 0;
  clear_has_fivepoint();
}
inline ::google::protobuf::int32 GLAnsGameResult::fivepoint() const {
  return fivepoint_;
}
inline void GLAnsGameResult::set_fivepoint(::google::protobuf::int32 value) {
  set_has_fivepoint();
  fivepoint_ = value;
}

// required int32 onePoint = 9;
inline bool GLAnsGameResult::has_onepoint() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GLAnsGameResult::set_has_onepoint() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GLAnsGameResult::clear_has_onepoint() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GLAnsGameResult::clear_onepoint() {
  onepoint_ = 0;
  clear_has_onepoint();
}
inline ::google::protobuf::int32 GLAnsGameResult::onepoint() const {
  return onepoint_;
}
inline void GLAnsGameResult::set_onepoint(::google::protobuf::int32 value) {
  set_has_onepoint();
  onepoint_ = value;
}

// required int32 godoriPoint = 10;
inline bool GLAnsGameResult::has_godoripoint() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GLAnsGameResult::set_has_godoripoint() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GLAnsGameResult::clear_has_godoripoint() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GLAnsGameResult::clear_godoripoint() {
  godoripoint_ = 0;
  clear_has_godoripoint();
}
inline ::google::protobuf::int32 GLAnsGameResult::godoripoint() const {
  return godoripoint_;
}
inline void GLAnsGameResult::set_godoripoint(::google::protobuf::int32 value) {
  set_has_godoripoint();
  godoripoint_ = value;
}

// required int32 redPoint = 11;
inline bool GLAnsGameResult::has_redpoint() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GLAnsGameResult::set_has_redpoint() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GLAnsGameResult::clear_has_redpoint() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GLAnsGameResult::clear_redpoint() {
  redpoint_ = 0;
  clear_has_redpoint();
}
inline ::google::protobuf::int32 GLAnsGameResult::redpoint() const {
  return redpoint_;
}
inline void GLAnsGameResult::set_redpoint(::google::protobuf::int32 value) {
  set_has_redpoint();
  redpoint_ = value;
}

// required int32 bluePoint = 12;
inline bool GLAnsGameResult::has_bluepoint() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GLAnsGameResult::set_has_bluepoint() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GLAnsGameResult::clear_has_bluepoint() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GLAnsGameResult::clear_bluepoint() {
  bluepoint_ = 0;
  clear_has_bluepoint();
}
inline ::google::protobuf::int32 GLAnsGameResult::bluepoint() const {
  return bluepoint_;
}
inline void GLAnsGameResult::set_bluepoint(::google::protobuf::int32 value) {
  set_has_bluepoint();
  bluepoint_ = value;
}

// required int32 kusaPoint = 13;
inline bool GLAnsGameResult::has_kusapoint() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GLAnsGameResult::set_has_kusapoint() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GLAnsGameResult::clear_has_kusapoint() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GLAnsGameResult::clear_kusapoint() {
  kusapoint_ = 0;
  clear_has_kusapoint();
}
inline ::google::protobuf::int32 GLAnsGameResult::kusapoint() const {
  return kusapoint_;
}
inline void GLAnsGameResult::set_kusapoint(::google::protobuf::int32 value) {
  set_has_kusapoint();
  kusapoint_ = value;
}

// required int32 goCnt = 14;
inline bool GLAnsGameResult::has_gocnt() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void GLAnsGameResult::set_has_gocnt() {
  _has_bits_[0] |= 0x00002000u;
}
inline void GLAnsGameResult::clear_has_gocnt() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void GLAnsGameResult::clear_gocnt() {
  gocnt_ = 0;
  clear_has_gocnt();
}
inline ::google::protobuf::int32 GLAnsGameResult::gocnt() const {
  return gocnt_;
}
inline void GLAnsGameResult::set_gocnt(::google::protobuf::int32 value) {
  set_has_gocnt();
  gocnt_ = value;
}

// required int32 basicPoint = 15;
inline bool GLAnsGameResult::has_basicpoint() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void GLAnsGameResult::set_has_basicpoint() {
  _has_bits_[0] |= 0x00004000u;
}
inline void GLAnsGameResult::clear_has_basicpoint() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void GLAnsGameResult::clear_basicpoint() {
  basicpoint_ = 0;
  clear_has_basicpoint();
}
inline ::google::protobuf::int32 GLAnsGameResult::basicpoint() const {
  return basicpoint_;
}
inline void GLAnsGameResult::set_basicpoint(::google::protobuf::int32 value) {
  set_has_basicpoint();
  basicpoint_ = value;
}

// required int32 nagariCnt = 16;
inline bool GLAnsGameResult::has_nagaricnt() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void GLAnsGameResult::set_has_nagaricnt() {
  _has_bits_[0] |= 0x00008000u;
}
inline void GLAnsGameResult::clear_has_nagaricnt() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void GLAnsGameResult::clear_nagaricnt() {
  nagaricnt_ = 0;
  clear_has_nagaricnt();
}
inline ::google::protobuf::int32 GLAnsGameResult::nagaricnt() const {
  return nagaricnt_;
}
inline void GLAnsGameResult::set_nagaricnt(::google::protobuf::int32 value) {
  set_has_nagaricnt();
  nagaricnt_ = value;
}

// required int32 nMulGo = 17;
inline bool GLAnsGameResult::has_nmulgo() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void GLAnsGameResult::set_has_nmulgo() {
  _has_bits_[0] |= 0x00010000u;
}
inline void GLAnsGameResult::clear_has_nmulgo() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void GLAnsGameResult::clear_nmulgo() {
  nmulgo_ = 0;
  clear_has_nmulgo();
}
inline ::google::protobuf::int32 GLAnsGameResult::nmulgo() const {
  return nmulgo_;
}
inline void GLAnsGameResult::set_nmulgo(::google::protobuf::int32 value) {
  set_has_nmulgo();
  nmulgo_ = value;
}

// required int32 nMulMission = 18;
inline bool GLAnsGameResult::has_nmulmission() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void GLAnsGameResult::set_has_nmulmission() {
  _has_bits_[0] |= 0x00020000u;
}
inline void GLAnsGameResult::clear_has_nmulmission() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void GLAnsGameResult::clear_nmulmission() {
  nmulmission_ = 0;
  clear_has_nmulmission();
}
inline ::google::protobuf::int32 GLAnsGameResult::nmulmission() const {
  return nmulmission_;
}
inline void GLAnsGameResult::set_nmulmission(::google::protobuf::int32 value) {
  set_has_nmulmission();
  nmulmission_ = value;
}

// required int32 nMulShake = 19;
inline bool GLAnsGameResult::has_nmulshake() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void GLAnsGameResult::set_has_nmulshake() {
  _has_bits_[0] |= 0x00040000u;
}
inline void GLAnsGameResult::clear_has_nmulshake() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void GLAnsGameResult::clear_nmulshake() {
  nmulshake_ = 0;
  clear_has_nmulshake();
}
inline ::google::protobuf::int32 GLAnsGameResult::nmulshake() const {
  return nmulshake_;
}
inline void GLAnsGameResult::set_nmulshake(::google::protobuf::int32 value) {
  set_has_nmulshake();
  nmulshake_ = value;
}

// required int32 nMulOneBak = 20;
inline bool GLAnsGameResult::has_nmulonebak() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void GLAnsGameResult::set_has_nmulonebak() {
  _has_bits_[0] |= 0x00080000u;
}
inline void GLAnsGameResult::clear_has_nmulonebak() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void GLAnsGameResult::clear_nmulonebak() {
  nmulonebak_ = 0;
  clear_has_nmulonebak();
}
inline ::google::protobuf::int32 GLAnsGameResult::nmulonebak() const {
  return nmulonebak_;
}
inline void GLAnsGameResult::set_nmulonebak(::google::protobuf::int32 value) {
  set_has_nmulonebak();
  nmulonebak_ = value;
}

// required int32 nMulCapBak = 21;
inline bool GLAnsGameResult::has_nmulcapbak() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void GLAnsGameResult::set_has_nmulcapbak() {
  _has_bits_[0] |= 0x00100000u;
}
inline void GLAnsGameResult::clear_has_nmulcapbak() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void GLAnsGameResult::clear_nmulcapbak() {
  nmulcapbak_ = 0;
  clear_has_nmulcapbak();
}
inline ::google::protobuf::int32 GLAnsGameResult::nmulcapbak() const {
  return nmulcapbak_;
}
inline void GLAnsGameResult::set_nmulcapbak(::google::protobuf::int32 value) {
  set_has_nmulcapbak();
  nmulcapbak_ = value;
}

// required int32 nMulGoBak = 22;
inline bool GLAnsGameResult::has_nmulgobak() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void GLAnsGameResult::set_has_nmulgobak() {
  _has_bits_[0] |= 0x00200000u;
}
inline void GLAnsGameResult::clear_has_nmulgobak() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void GLAnsGameResult::clear_nmulgobak() {
  nmulgobak_ = 0;
  clear_has_nmulgobak();
}
inline ::google::protobuf::int32 GLAnsGameResult::nmulgobak() const {
  return nmulgobak_;
}
inline void GLAnsGameResult::set_nmulgobak(::google::protobuf::int32 value) {
  set_has_nmulgobak();
  nmulgobak_ = value;
}

// required int32 nMulMungBak = 23;
inline bool GLAnsGameResult::has_nmulmungbak() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void GLAnsGameResult::set_has_nmulmungbak() {
  _has_bits_[0] |= 0x00400000u;
}
inline void GLAnsGameResult::clear_has_nmulmungbak() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void GLAnsGameResult::clear_nmulmungbak() {
  nmulmungbak_ = 0;
  clear_has_nmulmungbak();
}
inline ::google::protobuf::int32 GLAnsGameResult::nmulmungbak() const {
  return nmulmungbak_;
}
inline void GLAnsGameResult::set_nmulmungbak(::google::protobuf::int32 value) {
  set_has_nmulmungbak();
  nmulmungbak_ = value;
}

// required int32 nMulNagari = 24;
inline bool GLAnsGameResult::has_nmulnagari() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void GLAnsGameResult::set_has_nmulnagari() {
  _has_bits_[0] |= 0x00800000u;
}
inline void GLAnsGameResult::clear_has_nmulnagari() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void GLAnsGameResult::clear_nmulnagari() {
  nmulnagari_ = 0;
  clear_has_nmulnagari();
}
inline ::google::protobuf::int32 GLAnsGameResult::nmulnagari() const {
  return nmulnagari_;
}
inline void GLAnsGameResult::set_nmulnagari(::google::protobuf::int32 value) {
  set_has_nmulnagari();
  nmulnagari_ = value;
}

// required .GLAnsGameResult.GAME_RESULT_TYPE nType = 25;
inline bool GLAnsGameResult::has_ntype() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void GLAnsGameResult::set_has_ntype() {
  _has_bits_[0] |= 0x01000000u;
}
inline void GLAnsGameResult::clear_has_ntype() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void GLAnsGameResult::clear_ntype() {
  ntype_ = 1;
  clear_has_ntype();
}
inline ::GLAnsGameResult_GAME_RESULT_TYPE GLAnsGameResult::ntype() const {
  return static_cast< ::GLAnsGameResult_GAME_RESULT_TYPE >(ntype_);
}
inline void GLAnsGameResult::set_ntype(::GLAnsGameResult_GAME_RESULT_TYPE value) {
  GOOGLE_DCHECK(::GLAnsGameResult_GAME_RESULT_TYPE_IsValid(value));
  set_has_ntype();
  ntype_ = value;
}

// -------------------------------------------------------------------

// GLAnsGameNotiPoint

// optional int32 gameID = 1;
inline bool GLAnsGameNotiPoint::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameNotiPoint::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameNotiPoint::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameNotiPoint::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLAnsGameNotiPoint::gameid() const {
  return gameid_;
}
inline void GLAnsGameNotiPoint::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLAnsGameNotiPoint::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameNotiPoint::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameNotiPoint::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameNotiPoint::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLAnsGameNotiPoint::gameindex() const {
  return gameindex_;
}
inline void GLAnsGameNotiPoint::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// required int32 point = 3;
inline bool GLAnsGameNotiPoint::has_point() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GLAnsGameNotiPoint::set_has_point() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GLAnsGameNotiPoint::clear_has_point() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GLAnsGameNotiPoint::clear_point() {
  point_ = 0;
  clear_has_point();
}
inline ::google::protobuf::int32 GLAnsGameNotiPoint::point() const {
  return point_;
}
inline void GLAnsGameNotiPoint::set_point(::google::protobuf::int32 value) {
  set_has_point();
  point_ = value;
}

// -------------------------------------------------------------------

// GLAnsGameEnd

// -------------------------------------------------------------------

// GLAnsGameKick

// optional int32 gameID = 1;
inline bool GLAnsGameKick::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameKick::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameKick::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameKick::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLAnsGameKick::gameid() const {
  return gameid_;
}
inline void GLAnsGameKick::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLAnsGameKick::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameKick::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameKick::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameKick::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLAnsGameKick::gameindex() const {
  return gameindex_;
}
inline void GLAnsGameKick::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// required .GLAnsGameKick.KICK_TYPE nType = 3;
inline bool GLAnsGameKick::has_ntype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GLAnsGameKick::set_has_ntype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GLAnsGameKick::clear_has_ntype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GLAnsGameKick::clear_ntype() {
  ntype_ = 1;
  clear_has_ntype();
}
inline ::GLAnsGameKick_KICK_TYPE GLAnsGameKick::ntype() const {
  return static_cast< ::GLAnsGameKick_KICK_TYPE >(ntype_);
}
inline void GLAnsGameKick::set_ntype(::GLAnsGameKick_KICK_TYPE value) {
  GOOGLE_DCHECK(::GLAnsGameKick_KICK_TYPE_IsValid(value));
  set_has_ntype();
  ntype_ = value;
}

// -------------------------------------------------------------------

// GLAnsGameEmoti

// optional int32 gameID = 1;
inline bool GLAnsGameEmoti::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameEmoti::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameEmoti::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameEmoti::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLAnsGameEmoti::gameid() const {
  return gameid_;
}
inline void GLAnsGameEmoti::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLAnsGameEmoti::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameEmoti::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameEmoti::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameEmoti::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLAnsGameEmoti::gameindex() const {
  return gameindex_;
}
inline void GLAnsGameEmoti::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// required int32 nType = 3;
inline bool GLAnsGameEmoti::has_ntype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GLAnsGameEmoti::set_has_ntype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GLAnsGameEmoti::clear_has_ntype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GLAnsGameEmoti::clear_ntype() {
  ntype_ = 0;
  clear_has_ntype();
}
inline ::google::protobuf::int32 GLAnsGameEmoti::ntype() const {
  return ntype_;
}
inline void GLAnsGameEmoti::set_ntype(::google::protobuf::int32 value) {
  set_has_ntype();
  ntype_ = value;
}

// -------------------------------------------------------------------

// GLAnsGameInit

// optional int32 gameID = 1;
inline bool GLAnsGameInit::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameInit::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameInit::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameInit::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLAnsGameInit::gameid() const {
  return gameid_;
}
inline void GLAnsGameInit::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLAnsGameInit::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameInit::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameInit::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameInit::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLAnsGameInit::gameindex() const {
  return gameindex_;
}
inline void GLAnsGameInit::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// -------------------------------------------------------------------

// GLAnsGameAutoPlay

// optional int32 gameID = 1;
inline bool GLAnsGameAutoPlay::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameAutoPlay::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameAutoPlay::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameAutoPlay::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLAnsGameAutoPlay::gameid() const {
  return gameid_;
}
inline void GLAnsGameAutoPlay::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLAnsGameAutoPlay::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameAutoPlay::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameAutoPlay::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameAutoPlay::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLAnsGameAutoPlay::gameindex() const {
  return gameindex_;
}
inline void GLAnsGameAutoPlay::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// required bool bAuto = 3;
inline bool GLAnsGameAutoPlay::has_bauto() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GLAnsGameAutoPlay::set_has_bauto() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GLAnsGameAutoPlay::clear_has_bauto() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GLAnsGameAutoPlay::clear_bauto() {
  bauto_ = false;
  clear_has_bauto();
}
inline bool GLAnsGameAutoPlay::bauto() const {
  return bauto_;
}
inline void GLAnsGameAutoPlay::set_bauto(bool value) {
  set_has_bauto();
  bauto_ = value;
}

// -------------------------------------------------------------------

// GLAnsExitReservation

// optional int32 gameID = 1;
inline bool GLAnsExitReservation::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsExitReservation::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsExitReservation::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsExitReservation::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLAnsExitReservation::gameid() const {
  return gameid_;
}
inline void GLAnsExitReservation::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLAnsExitReservation::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsExitReservation::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsExitReservation::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsExitReservation::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLAnsExitReservation::gameindex() const {
  return gameindex_;
}
inline void GLAnsExitReservation::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// required bool bExit = 3;
inline bool GLAnsExitReservation::has_bexit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GLAnsExitReservation::set_has_bexit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GLAnsExitReservation::clear_has_bexit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GLAnsExitReservation::clear_bexit() {
  bexit_ = false;
  clear_has_bexit();
}
inline bool GLAnsExitReservation::bexit() const {
  return bexit_;
}
inline void GLAnsExitReservation::set_bexit(bool value) {
  set_has_bexit();
  bexit_ = value;
}

// -------------------------------------------------------------------

// GLReqGameReady

// required int32 gameID = 1;
inline bool GLReqGameReady::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLReqGameReady::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLReqGameReady::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLReqGameReady::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLReqGameReady::gameid() const {
  return gameid_;
}
inline void GLReqGameReady::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLReqGameReady::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLReqGameReady::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLReqGameReady::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLReqGameReady::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLReqGameReady::gameindex() const {
  return gameindex_;
}
inline void GLReqGameReady::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// -------------------------------------------------------------------

// GLReqResetReady

// optional int32 gameID = 1;
inline bool GLReqResetReady::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLReqResetReady::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLReqResetReady::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLReqResetReady::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLReqResetReady::gameid() const {
  return gameid_;
}
inline void GLReqResetReady::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLReqResetReady::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLReqResetReady::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLReqResetReady::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLReqResetReady::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLReqResetReady::gameindex() const {
  return gameindex_;
}
inline void GLReqResetReady::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// -------------------------------------------------------------------

// GLReqGameInitGame

// optional int32 gameID = 1;
inline bool GLReqGameInitGame::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLReqGameInitGame::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLReqGameInitGame::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLReqGameInitGame::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLReqGameInitGame::gameid() const {
  return gameid_;
}
inline void GLReqGameInitGame::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLReqGameInitGame::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLReqGameInitGame::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLReqGameInitGame::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLReqGameInitGame::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLReqGameInitGame::gameindex() const {
  return gameindex_;
}
inline void GLReqGameInitGame::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// -------------------------------------------------------------------

// GLReqGameReset

// optional int32 gameID = 1;
inline bool GLReqGameReset::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLReqGameReset::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLReqGameReset::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLReqGameReset::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLReqGameReset::gameid() const {
  return gameid_;
}
inline void GLReqGameReset::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLReqGameReset::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLReqGameReset::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLReqGameReset::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLReqGameReset::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLReqGameReset::gameindex() const {
  return gameindex_;
}
inline void GLReqGameReset::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// -------------------------------------------------------------------

// GLReqGameStart

// optional int32 gameID = 1;
inline bool GLReqGameStart::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLReqGameStart::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLReqGameStart::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLReqGameStart::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLReqGameStart::gameid() const {
  return gameid_;
}
inline void GLReqGameStart::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// optional int32 gameIndex = 2;
inline bool GLReqGameStart::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLReqGameStart::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLReqGameStart::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLReqGameStart::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLReqGameStart::gameindex() const {
  return gameindex_;
}
inline void GLReqGameStart::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// -------------------------------------------------------------------

// GLReqGameSelectSunCard

// optional int32 gameID = 1;
inline bool GLReqGameSelectSunCard::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLReqGameSelectSunCard::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLReqGameSelectSunCard::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLReqGameSelectSunCard::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLReqGameSelectSunCard::gameid() const {
  return gameid_;
}
inline void GLReqGameSelectSunCard::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLReqGameSelectSunCard::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLReqGameSelectSunCard::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLReqGameSelectSunCard::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLReqGameSelectSunCard::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLReqGameSelectSunCard::gameindex() const {
  return gameindex_;
}
inline void GLReqGameSelectSunCard::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// required int32 nCard = 3;
inline bool GLReqGameSelectSunCard::has_ncard() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GLReqGameSelectSunCard::set_has_ncard() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GLReqGameSelectSunCard::clear_has_ncard() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GLReqGameSelectSunCard::clear_ncard() {
  ncard_ = 0;
  clear_has_ncard();
}
inline ::google::protobuf::int32 GLReqGameSelectSunCard::ncard() const {
  return ncard_;
}
inline void GLReqGameSelectSunCard::set_ncard(::google::protobuf::int32 value) {
  set_has_ncard();
  ncard_ = value;
}

// -------------------------------------------------------------------

// GLReqGameSelectCard

// optional int32 gameID = 1;
inline bool GLReqGameSelectCard::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLReqGameSelectCard::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLReqGameSelectCard::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLReqGameSelectCard::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLReqGameSelectCard::gameid() const {
  return gameid_;
}
inline void GLReqGameSelectCard::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLReqGameSelectCard::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLReqGameSelectCard::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLReqGameSelectCard::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLReqGameSelectCard::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLReqGameSelectCard::gameindex() const {
  return gameindex_;
}
inline void GLReqGameSelectCard::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// required int32 nCard = 3;
inline bool GLReqGameSelectCard::has_ncard() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GLReqGameSelectCard::set_has_ncard() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GLReqGameSelectCard::clear_has_ncard() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GLReqGameSelectCard::clear_ncard() {
  ncard_ = 0;
  clear_has_ncard();
}
inline ::google::protobuf::int32 GLReqGameSelectCard::ncard() const {
  return ncard_;
}
inline void GLReqGameSelectCard::set_ncard(::google::protobuf::int32 value) {
  set_has_ncard();
  ncard_ = value;
}

// -------------------------------------------------------------------

// GLReqGameAskGoStopAns

// optional int32 gameID = 1;
inline bool GLReqGameAskGoStopAns::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLReqGameAskGoStopAns::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLReqGameAskGoStopAns::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLReqGameAskGoStopAns::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLReqGameAskGoStopAns::gameid() const {
  return gameid_;
}
inline void GLReqGameAskGoStopAns::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLReqGameAskGoStopAns::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLReqGameAskGoStopAns::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLReqGameAskGoStopAns::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLReqGameAskGoStopAns::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLReqGameAskGoStopAns::gameindex() const {
  return gameindex_;
}
inline void GLReqGameAskGoStopAns::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// required bool bGo = 3;
inline bool GLReqGameAskGoStopAns::has_bgo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GLReqGameAskGoStopAns::set_has_bgo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GLReqGameAskGoStopAns::clear_has_bgo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GLReqGameAskGoStopAns::clear_bgo() {
  bgo_ = false;
  clear_has_bgo();
}
inline bool GLReqGameAskGoStopAns::bgo() const {
  return bgo_;
}
inline void GLReqGameAskGoStopAns::set_bgo(bool value) {
  set_has_bgo();
  bgo_ = value;
}

// -------------------------------------------------------------------

// GLReqGameAskShakeAns

// optional int32 gameID = 1;
inline bool GLReqGameAskShakeAns::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLReqGameAskShakeAns::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLReqGameAskShakeAns::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLReqGameAskShakeAns::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLReqGameAskShakeAns::gameid() const {
  return gameid_;
}
inline void GLReqGameAskShakeAns::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLReqGameAskShakeAns::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLReqGameAskShakeAns::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLReqGameAskShakeAns::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLReqGameAskShakeAns::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLReqGameAskShakeAns::gameindex() const {
  return gameindex_;
}
inline void GLReqGameAskShakeAns::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// required bool bShake = 3;
inline bool GLReqGameAskShakeAns::has_bshake() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GLReqGameAskShakeAns::set_has_bshake() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GLReqGameAskShakeAns::clear_has_bshake() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GLReqGameAskShakeAns::clear_bshake() {
  bshake_ = false;
  clear_has_bshake();
}
inline bool GLReqGameAskShakeAns::bshake() const {
  return bshake_;
}
inline void GLReqGameAskShakeAns::set_bshake(bool value) {
  set_has_bshake();
  bshake_ = value;
}

// -------------------------------------------------------------------

// GLReqGameChoiceCardAns

// optional int32 gameID = 1;
inline bool GLReqGameChoiceCardAns::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLReqGameChoiceCardAns::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLReqGameChoiceCardAns::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLReqGameChoiceCardAns::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLReqGameChoiceCardAns::gameid() const {
  return gameid_;
}
inline void GLReqGameChoiceCardAns::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLReqGameChoiceCardAns::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLReqGameChoiceCardAns::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLReqGameChoiceCardAns::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLReqGameChoiceCardAns::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLReqGameChoiceCardAns::gameindex() const {
  return gameindex_;
}
inline void GLReqGameChoiceCardAns::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// required int32 nCard = 3;
inline bool GLReqGameChoiceCardAns::has_ncard() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GLReqGameChoiceCardAns::set_has_ncard() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GLReqGameChoiceCardAns::clear_has_ncard() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GLReqGameChoiceCardAns::clear_ncard() {
  ncard_ = 0;
  clear_has_ncard();
}
inline ::google::protobuf::int32 GLReqGameChoiceCardAns::ncard() const {
  return ncard_;
}
inline void GLReqGameChoiceCardAns::set_ncard(::google::protobuf::int32 value) {
  set_has_ncard();
  ncard_ = value;
}

// required .GLReqGameChoiceCardAns.Type nType = 4;
inline bool GLReqGameChoiceCardAns::has_ntype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GLReqGameChoiceCardAns::set_has_ntype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GLReqGameChoiceCardAns::clear_has_ntype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GLReqGameChoiceCardAns::clear_ntype() {
  ntype_ = 1;
  clear_has_ntype();
}
inline ::GLReqGameChoiceCardAns_Type GLReqGameChoiceCardAns::ntype() const {
  return static_cast< ::GLReqGameChoiceCardAns_Type >(ntype_);
}
inline void GLReqGameChoiceCardAns::set_ntype(::GLReqGameChoiceCardAns_Type value) {
  GOOGLE_DCHECK(::GLReqGameChoiceCardAns_Type_IsValid(value));
  set_has_ntype();
  ntype_ = value;
}

// -------------------------------------------------------------------

// GLReqGameMoveTen

// optional int32 gameID = 1;
inline bool GLReqGameMoveTen::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLReqGameMoveTen::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLReqGameMoveTen::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLReqGameMoveTen::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLReqGameMoveTen::gameid() const {
  return gameid_;
}
inline void GLReqGameMoveTen::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLReqGameMoveTen::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLReqGameMoveTen::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLReqGameMoveTen::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLReqGameMoveTen::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLReqGameMoveTen::gameindex() const {
  return gameindex_;
}
inline void GLReqGameMoveTen::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// required bool bMove = 3;
inline bool GLReqGameMoveTen::has_bmove() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GLReqGameMoveTen::set_has_bmove() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GLReqGameMoveTen::clear_has_bmove() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GLReqGameMoveTen::clear_bmove() {
  bmove_ = false;
  clear_has_bmove();
}
inline bool GLReqGameMoveTen::bmove() const {
  return bmove_;
}
inline void GLReqGameMoveTen::set_bmove(bool value) {
  set_has_bmove();
  bmove_ = value;
}

// -------------------------------------------------------------------

// GLReqGameChongTong

// optional int32 gameID = 1;
inline bool GLReqGameChongTong::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLReqGameChongTong::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLReqGameChongTong::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLReqGameChongTong::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLReqGameChongTong::gameid() const {
  return gameid_;
}
inline void GLReqGameChongTong::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLReqGameChongTong::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLReqGameChongTong::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLReqGameChongTong::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLReqGameChongTong::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLReqGameChongTong::gameindex() const {
  return gameindex_;
}
inline void GLReqGameChongTong::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// required bool bYes = 3;
inline bool GLReqGameChongTong::has_byes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GLReqGameChongTong::set_has_byes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GLReqGameChongTong::clear_has_byes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GLReqGameChongTong::clear_byes() {
  byes_ = false;
  clear_has_byes();
}
inline bool GLReqGameChongTong::byes() const {
  return byes_;
}
inline void GLReqGameChongTong::set_byes(bool value) {
  set_has_byes();
  byes_ = value;
}

// -------------------------------------------------------------------

// GLReqGameEnd

// optional int32 gameID = 1;
inline bool GLReqGameEnd::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLReqGameEnd::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLReqGameEnd::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLReqGameEnd::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLReqGameEnd::gameid() const {
  return gameid_;
}
inline void GLReqGameEnd::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLReqGameEnd::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLReqGameEnd::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLReqGameEnd::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLReqGameEnd::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLReqGameEnd::gameindex() const {
  return gameindex_;
}
inline void GLReqGameEnd::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// -------------------------------------------------------------------

// GLReqResultOk

// optional int32 gameID = 1;
inline bool GLReqResultOk::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLReqResultOk::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLReqResultOk::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLReqResultOk::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLReqResultOk::gameid() const {
  return gameid_;
}
inline void GLReqResultOk::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLReqResultOk::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLReqResultOk::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLReqResultOk::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLReqResultOk::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLReqResultOk::gameindex() const {
  return gameindex_;
}
inline void GLReqResultOk::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// -------------------------------------------------------------------

// GLReqGameAutoPlay

// optional int32 gameID = 1;
inline bool GLReqGameAutoPlay::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLReqGameAutoPlay::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLReqGameAutoPlay::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLReqGameAutoPlay::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLReqGameAutoPlay::gameid() const {
  return gameid_;
}
inline void GLReqGameAutoPlay::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLReqGameAutoPlay::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLReqGameAutoPlay::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLReqGameAutoPlay::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLReqGameAutoPlay::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLReqGameAutoPlay::gameindex() const {
  return gameindex_;
}
inline void GLReqGameAutoPlay::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// required bool bAuto = 3;
inline bool GLReqGameAutoPlay::has_bauto() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GLReqGameAutoPlay::set_has_bauto() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GLReqGameAutoPlay::clear_has_bauto() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GLReqGameAutoPlay::clear_bauto() {
  bauto_ = false;
  clear_has_bauto();
}
inline bool GLReqGameAutoPlay::bauto() const {
  return bauto_;
}
inline void GLReqGameAutoPlay::set_bauto(bool value) {
  set_has_bauto();
  bauto_ = value;
}

// -------------------------------------------------------------------

// GLReqGameEmoti

// optional int32 gameID = 1;
inline bool GLReqGameEmoti::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLReqGameEmoti::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLReqGameEmoti::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLReqGameEmoti::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLReqGameEmoti::gameid() const {
  return gameid_;
}
inline void GLReqGameEmoti::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLReqGameEmoti::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLReqGameEmoti::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLReqGameEmoti::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLReqGameEmoti::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLReqGameEmoti::gameindex() const {
  return gameindex_;
}
inline void GLReqGameEmoti::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// required int32 nType = 3;
inline bool GLReqGameEmoti::has_ntype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GLReqGameEmoti::set_has_ntype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GLReqGameEmoti::clear_has_ntype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GLReqGameEmoti::clear_ntype() {
  ntype_ = 0;
  clear_has_ntype();
}
inline ::google::protobuf::int32 GLReqGameEmoti::ntype() const {
  return ntype_;
}
inline void GLReqGameEmoti::set_ntype(::google::protobuf::int32 value) {
  set_has_ntype();
  ntype_ = value;
}

// -------------------------------------------------------------------

// GLReqExitReservation

// optional int32 gameID = 1;
inline bool GLReqExitReservation::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLReqExitReservation::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLReqExitReservation::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLReqExitReservation::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLReqExitReservation::gameid() const {
  return gameid_;
}
inline void GLReqExitReservation::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 gameIndex = 2;
inline bool GLReqExitReservation::has_gameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLReqExitReservation::set_has_gameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLReqExitReservation::clear_has_gameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLReqExitReservation::clear_gameindex() {
  gameindex_ = 0;
  clear_has_gameindex();
}
inline ::google::protobuf::int32 GLReqExitReservation::gameindex() const {
  return gameindex_;
}
inline void GLReqExitReservation::set_gameindex(::google::protobuf::int32 value) {
  set_has_gameindex();
  gameindex_ = value;
}

// required bool bExit = 3;
inline bool GLReqExitReservation::has_bexit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GLReqExitReservation::set_has_bexit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GLReqExitReservation::clear_has_bexit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GLReqExitReservation::clear_bexit() {
  bexit_ = false;
  clear_has_bexit();
}
inline bool GLReqExitReservation::bexit() const {
  return bexit_;
}
inline void GLReqExitReservation::set_bexit(bool value) {
  set_has_bexit();
  bexit_ = value;
}

// -------------------------------------------------------------------

// GLReqRelayInfo

// required int32 gameID = 1;
inline bool GLReqRelayInfo::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLReqRelayInfo::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLReqRelayInfo::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLReqRelayInfo::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GLReqRelayInfo::gameid() const {
  return gameid_;
}
inline void GLReqRelayInfo::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// -------------------------------------------------------------------

// G_REQ_GAME_TEST_PACKET

// optional int32 gameID = 1;
inline bool G_REQ_GAME_TEST_PACKET::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void G_REQ_GAME_TEST_PACKET::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void G_REQ_GAME_TEST_PACKET::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void G_REQ_GAME_TEST_PACKET::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 G_REQ_GAME_TEST_PACKET::gameid() const {
  return gameid_;
}
inline void G_REQ_GAME_TEST_PACKET::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 test_int = 2;
inline bool G_REQ_GAME_TEST_PACKET::has_test_int() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void G_REQ_GAME_TEST_PACKET::set_has_test_int() {
  _has_bits_[0] |= 0x00000002u;
}
inline void G_REQ_GAME_TEST_PACKET::clear_has_test_int() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void G_REQ_GAME_TEST_PACKET::clear_test_int() {
  test_int_ = 0;
  clear_has_test_int();
}
inline ::google::protobuf::int32 G_REQ_GAME_TEST_PACKET::test_int() const {
  return test_int_;
}
inline void G_REQ_GAME_TEST_PACKET::set_test_int(::google::protobuf::int32 value) {
  set_has_test_int();
  test_int_ = value;
}

// required string test_string = 3;
inline bool G_REQ_GAME_TEST_PACKET::has_test_string() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void G_REQ_GAME_TEST_PACKET::set_has_test_string() {
  _has_bits_[0] |= 0x00000004u;
}
inline void G_REQ_GAME_TEST_PACKET::clear_has_test_string() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void G_REQ_GAME_TEST_PACKET::clear_test_string() {
  if (test_string_ != &::google::protobuf::internal::kEmptyString) {
    test_string_->clear();
  }
  clear_has_test_string();
}
inline const ::std::string& G_REQ_GAME_TEST_PACKET::test_string() const {
  return *test_string_;
}
inline void G_REQ_GAME_TEST_PACKET::set_test_string(const ::std::string& value) {
  set_has_test_string();
  if (test_string_ == &::google::protobuf::internal::kEmptyString) {
    test_string_ = new ::std::string;
  }
  test_string_->assign(value);
}
inline void G_REQ_GAME_TEST_PACKET::set_test_string(const char* value) {
  set_has_test_string();
  if (test_string_ == &::google::protobuf::internal::kEmptyString) {
    test_string_ = new ::std::string;
  }
  test_string_->assign(value);
}
inline void G_REQ_GAME_TEST_PACKET::set_test_string(const char* value, size_t size) {
  set_has_test_string();
  if (test_string_ == &::google::protobuf::internal::kEmptyString) {
    test_string_ = new ::std::string;
  }
  test_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* G_REQ_GAME_TEST_PACKET::mutable_test_string() {
  set_has_test_string();
  if (test_string_ == &::google::protobuf::internal::kEmptyString) {
    test_string_ = new ::std::string;
  }
  return test_string_;
}
inline ::std::string* G_REQ_GAME_TEST_PACKET::release_test_string() {
  clear_has_test_string();
  if (test_string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = test_string_;
    test_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GLAnsGameProtocol

// required .GLAnsGameProtocol.Type type = 1;
inline bool GLAnsGameProtocol::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLAnsGameProtocol::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLAnsGameProtocol::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLAnsGameProtocol::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::GLAnsGameProtocol_Type GLAnsGameProtocol::type() const {
  return static_cast< ::GLAnsGameProtocol_Type >(type_);
}
inline void GLAnsGameProtocol::set_type(::GLAnsGameProtocol_Type value) {
  GOOGLE_DCHECK(::GLAnsGameProtocol_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .GLAnsGameStartReady gameStartReady = 2;
inline bool GLAnsGameProtocol::has_gamestartready() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLAnsGameProtocol::set_has_gamestartready() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLAnsGameProtocol::clear_has_gamestartready() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLAnsGameProtocol::clear_gamestartready() {
  if (gamestartready_ != NULL) gamestartready_->::GLAnsGameStartReady::Clear();
  clear_has_gamestartready();
}
inline const ::GLAnsGameStartReady& GLAnsGameProtocol::gamestartready() const {
  return gamestartready_ != NULL ? *gamestartready_ : *default_instance_->gamestartready_;
}
inline ::GLAnsGameStartReady* GLAnsGameProtocol::mutable_gamestartready() {
  set_has_gamestartready();
  if (gamestartready_ == NULL) gamestartready_ = new ::GLAnsGameStartReady;
  return gamestartready_;
}
inline ::GLAnsGameStartReady* GLAnsGameProtocol::release_gamestartready() {
  clear_has_gamestartready();
  ::GLAnsGameStartReady* temp = gamestartready_;
  gamestartready_ = NULL;
  return temp;
}

// optional .GLAnsGameResetReady gameResetReady = 3;
inline bool GLAnsGameProtocol::has_gameresetready() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GLAnsGameProtocol::set_has_gameresetready() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GLAnsGameProtocol::clear_has_gameresetready() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GLAnsGameProtocol::clear_gameresetready() {
  if (gameresetready_ != NULL) gameresetready_->::GLAnsGameResetReady::Clear();
  clear_has_gameresetready();
}
inline const ::GLAnsGameResetReady& GLAnsGameProtocol::gameresetready() const {
  return gameresetready_ != NULL ? *gameresetready_ : *default_instance_->gameresetready_;
}
inline ::GLAnsGameResetReady* GLAnsGameProtocol::mutable_gameresetready() {
  set_has_gameresetready();
  if (gameresetready_ == NULL) gameresetready_ = new ::GLAnsGameResetReady;
  return gameresetready_;
}
inline ::GLAnsGameResetReady* GLAnsGameProtocol::release_gameresetready() {
  clear_has_gameresetready();
  ::GLAnsGameResetReady* temp = gameresetready_;
  gameresetready_ = NULL;
  return temp;
}

// optional .GLAnsGameInit gameinit = 4;
inline bool GLAnsGameProtocol::has_gameinit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GLAnsGameProtocol::set_has_gameinit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GLAnsGameProtocol::clear_has_gameinit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GLAnsGameProtocol::clear_gameinit() {
  if (gameinit_ != NULL) gameinit_->::GLAnsGameInit::Clear();
  clear_has_gameinit();
}
inline const ::GLAnsGameInit& GLAnsGameProtocol::gameinit() const {
  return gameinit_ != NULL ? *gameinit_ : *default_instance_->gameinit_;
}
inline ::GLAnsGameInit* GLAnsGameProtocol::mutable_gameinit() {
  set_has_gameinit();
  if (gameinit_ == NULL) gameinit_ = new ::GLAnsGameInit;
  return gameinit_;
}
inline ::GLAnsGameInit* GLAnsGameProtocol::release_gameinit() {
  clear_has_gameinit();
  ::GLAnsGameInit* temp = gameinit_;
  gameinit_ = NULL;
  return temp;
}

// optional .GLAnsGameStart gameStart = 5;
inline bool GLAnsGameProtocol::has_gamestart() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GLAnsGameProtocol::set_has_gamestart() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GLAnsGameProtocol::clear_has_gamestart() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GLAnsGameProtocol::clear_gamestart() {
  if (gamestart_ != NULL) gamestart_->::GLAnsGameStart::Clear();
  clear_has_gamestart();
}
inline const ::GLAnsGameStart& GLAnsGameProtocol::gamestart() const {
  return gamestart_ != NULL ? *gamestart_ : *default_instance_->gamestart_;
}
inline ::GLAnsGameStart* GLAnsGameProtocol::mutable_gamestart() {
  set_has_gamestart();
  if (gamestart_ == NULL) gamestart_ = new ::GLAnsGameStart;
  return gamestart_;
}
inline ::GLAnsGameStart* GLAnsGameProtocol::release_gamestart() {
  clear_has_gamestart();
  ::GLAnsGameStart* temp = gamestart_;
  gamestart_ = NULL;
  return temp;
}

// optional .GLAnsGameReset gameReset = 6;
inline bool GLAnsGameProtocol::has_gamereset() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GLAnsGameProtocol::set_has_gamereset() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GLAnsGameProtocol::clear_has_gamereset() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GLAnsGameProtocol::clear_gamereset() {
  if (gamereset_ != NULL) gamereset_->::GLAnsGameReset::Clear();
  clear_has_gamereset();
}
inline const ::GLAnsGameReset& GLAnsGameProtocol::gamereset() const {
  return gamereset_ != NULL ? *gamereset_ : *default_instance_->gamereset_;
}
inline ::GLAnsGameReset* GLAnsGameProtocol::mutable_gamereset() {
  set_has_gamereset();
  if (gamereset_ == NULL) gamereset_ = new ::GLAnsGameReset;
  return gamereset_;
}
inline ::GLAnsGameReset* GLAnsGameProtocol::release_gamereset() {
  clear_has_gamereset();
  ::GLAnsGameReset* temp = gamereset_;
  gamereset_ = NULL;
  return temp;
}

// optional .GLAnsGameNotiSun gameNotiSun = 7;
inline bool GLAnsGameProtocol::has_gamenotisun() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GLAnsGameProtocol::set_has_gamenotisun() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GLAnsGameProtocol::clear_has_gamenotisun() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GLAnsGameProtocol::clear_gamenotisun() {
  if (gamenotisun_ != NULL) gamenotisun_->::GLAnsGameNotiSun::Clear();
  clear_has_gamenotisun();
}
inline const ::GLAnsGameNotiSun& GLAnsGameProtocol::gamenotisun() const {
  return gamenotisun_ != NULL ? *gamenotisun_ : *default_instance_->gamenotisun_;
}
inline ::GLAnsGameNotiSun* GLAnsGameProtocol::mutable_gamenotisun() {
  set_has_gamenotisun();
  if (gamenotisun_ == NULL) gamenotisun_ = new ::GLAnsGameNotiSun;
  return gamenotisun_;
}
inline ::GLAnsGameNotiSun* GLAnsGameProtocol::release_gamenotisun() {
  clear_has_gamenotisun();
  ::GLAnsGameNotiSun* temp = gamenotisun_;
  gamenotisun_ = NULL;
  return temp;
}

// optional .GLAnsGameSelectSun gameSelectSun = 8;
inline bool GLAnsGameProtocol::has_gameselectsun() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GLAnsGameProtocol::set_has_gameselectsun() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GLAnsGameProtocol::clear_has_gameselectsun() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GLAnsGameProtocol::clear_gameselectsun() {
  if (gameselectsun_ != NULL) gameselectsun_->::GLAnsGameSelectSun::Clear();
  clear_has_gameselectsun();
}
inline const ::GLAnsGameSelectSun& GLAnsGameProtocol::gameselectsun() const {
  return gameselectsun_ != NULL ? *gameselectsun_ : *default_instance_->gameselectsun_;
}
inline ::GLAnsGameSelectSun* GLAnsGameProtocol::mutable_gameselectsun() {
  set_has_gameselectsun();
  if (gameselectsun_ == NULL) gameselectsun_ = new ::GLAnsGameSelectSun;
  return gameselectsun_;
}
inline ::GLAnsGameSelectSun* GLAnsGameProtocol::release_gameselectsun() {
  clear_has_gameselectsun();
  ::GLAnsGameSelectSun* temp = gameselectsun_;
  gameselectsun_ = NULL;
  return temp;
}

// optional .GLAnsGameNotiSelectSun gameNotiSelectSun = 9;
inline bool GLAnsGameProtocol::has_gamenotiselectsun() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GLAnsGameProtocol::set_has_gamenotiselectsun() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GLAnsGameProtocol::clear_has_gamenotiselectsun() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GLAnsGameProtocol::clear_gamenotiselectsun() {
  if (gamenotiselectsun_ != NULL) gamenotiselectsun_->::GLAnsGameNotiSelectSun::Clear();
  clear_has_gamenotiselectsun();
}
inline const ::GLAnsGameNotiSelectSun& GLAnsGameProtocol::gamenotiselectsun() const {
  return gamenotiselectsun_ != NULL ? *gamenotiselectsun_ : *default_instance_->gamenotiselectsun_;
}
inline ::GLAnsGameNotiSelectSun* GLAnsGameProtocol::mutable_gamenotiselectsun() {
  set_has_gamenotiselectsun();
  if (gamenotiselectsun_ == NULL) gamenotiselectsun_ = new ::GLAnsGameNotiSelectSun;
  return gamenotiselectsun_;
}
inline ::GLAnsGameNotiSelectSun* GLAnsGameProtocol::release_gamenotiselectsun() {
  clear_has_gamenotiselectsun();
  ::GLAnsGameNotiSelectSun* temp = gamenotiselectsun_;
  gamenotiselectsun_ = NULL;
  return temp;
}

// optional .GLAnsGameSharing gameSharing = 10;
inline bool GLAnsGameProtocol::has_gamesharing() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GLAnsGameProtocol::set_has_gamesharing() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GLAnsGameProtocol::clear_has_gamesharing() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GLAnsGameProtocol::clear_gamesharing() {
  if (gamesharing_ != NULL) gamesharing_->::GLAnsGameSharing::Clear();
  clear_has_gamesharing();
}
inline const ::GLAnsGameSharing& GLAnsGameProtocol::gamesharing() const {
  return gamesharing_ != NULL ? *gamesharing_ : *default_instance_->gamesharing_;
}
inline ::GLAnsGameSharing* GLAnsGameProtocol::mutable_gamesharing() {
  set_has_gamesharing();
  if (gamesharing_ == NULL) gamesharing_ = new ::GLAnsGameSharing;
  return gamesharing_;
}
inline ::GLAnsGameSharing* GLAnsGameProtocol::release_gamesharing() {
  clear_has_gamesharing();
  ::GLAnsGameSharing* temp = gamesharing_;
  gamesharing_ = NULL;
  return temp;
}

// optional .GLAnsGameNagari gameNagari = 11;
inline bool GLAnsGameProtocol::has_gamenagari() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GLAnsGameProtocol::set_has_gamenagari() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GLAnsGameProtocol::clear_has_gamenagari() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GLAnsGameProtocol::clear_gamenagari() {
  if (gamenagari_ != NULL) gamenagari_->::GLAnsGameNagari::Clear();
  clear_has_gamenagari();
}
inline const ::GLAnsGameNagari& GLAnsGameProtocol::gamenagari() const {
  return gamenagari_ != NULL ? *gamenagari_ : *default_instance_->gamenagari_;
}
inline ::GLAnsGameNagari* GLAnsGameProtocol::mutable_gamenagari() {
  set_has_gamenagari();
  if (gamenagari_ == NULL) gamenagari_ = new ::GLAnsGameNagari;
  return gamenagari_;
}
inline ::GLAnsGameNagari* GLAnsGameProtocol::release_gamenagari() {
  clear_has_gamenagari();
  ::GLAnsGameNagari* temp = gamenagari_;
  gamenagari_ = NULL;
  return temp;
}

// optional .GLAnsGameChongTong gameChongTong = 12;
inline bool GLAnsGameProtocol::has_gamechongtong() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GLAnsGameProtocol::set_has_gamechongtong() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GLAnsGameProtocol::clear_has_gamechongtong() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GLAnsGameProtocol::clear_gamechongtong() {
  if (gamechongtong_ != NULL) gamechongtong_->::GLAnsGameChongTong::Clear();
  clear_has_gamechongtong();
}
inline const ::GLAnsGameChongTong& GLAnsGameProtocol::gamechongtong() const {
  return gamechongtong_ != NULL ? *gamechongtong_ : *default_instance_->gamechongtong_;
}
inline ::GLAnsGameChongTong* GLAnsGameProtocol::mutable_gamechongtong() {
  set_has_gamechongtong();
  if (gamechongtong_ == NULL) gamechongtong_ = new ::GLAnsGameChongTong;
  return gamechongtong_;
}
inline ::GLAnsGameChongTong* GLAnsGameProtocol::release_gamechongtong() {
  clear_has_gamechongtong();
  ::GLAnsGameChongTong* temp = gamechongtong_;
  gamechongtong_ = NULL;
  return temp;
}

// optional .GLAnsGameSelectCard gameSelectCard = 13;
inline bool GLAnsGameProtocol::has_gameselectcard() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GLAnsGameProtocol::set_has_gameselectcard() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GLAnsGameProtocol::clear_has_gameselectcard() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GLAnsGameProtocol::clear_gameselectcard() {
  if (gameselectcard_ != NULL) gameselectcard_->::GLAnsGameSelectCard::Clear();
  clear_has_gameselectcard();
}
inline const ::GLAnsGameSelectCard& GLAnsGameProtocol::gameselectcard() const {
  return gameselectcard_ != NULL ? *gameselectcard_ : *default_instance_->gameselectcard_;
}
inline ::GLAnsGameSelectCard* GLAnsGameProtocol::mutable_gameselectcard() {
  set_has_gameselectcard();
  if (gameselectcard_ == NULL) gameselectcard_ = new ::GLAnsGameSelectCard;
  return gameselectcard_;
}
inline ::GLAnsGameSelectCard* GLAnsGameProtocol::release_gameselectcard() {
  clear_has_gameselectcard();
  ::GLAnsGameSelectCard* temp = gameselectcard_;
  gameselectcard_ = NULL;
  return temp;
}

// optional .GLAnsGameBonus gameBonus = 14;
inline bool GLAnsGameProtocol::has_gamebonus() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void GLAnsGameProtocol::set_has_gamebonus() {
  _has_bits_[0] |= 0x00002000u;
}
inline void GLAnsGameProtocol::clear_has_gamebonus() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void GLAnsGameProtocol::clear_gamebonus() {
  if (gamebonus_ != NULL) gamebonus_->::GLAnsGameBonus::Clear();
  clear_has_gamebonus();
}
inline const ::GLAnsGameBonus& GLAnsGameProtocol::gamebonus() const {
  return gamebonus_ != NULL ? *gamebonus_ : *default_instance_->gamebonus_;
}
inline ::GLAnsGameBonus* GLAnsGameProtocol::mutable_gamebonus() {
  set_has_gamebonus();
  if (gamebonus_ == NULL) gamebonus_ = new ::GLAnsGameBonus;
  return gamebonus_;
}
inline ::GLAnsGameBonus* GLAnsGameProtocol::release_gamebonus() {
  clear_has_gamebonus();
  ::GLAnsGameBonus* temp = gamebonus_;
  gamebonus_ = NULL;
  return temp;
}

// optional .GLAnsGameTakePee gameTakePee = 15;
inline bool GLAnsGameProtocol::has_gametakepee() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void GLAnsGameProtocol::set_has_gametakepee() {
  _has_bits_[0] |= 0x00004000u;
}
inline void GLAnsGameProtocol::clear_has_gametakepee() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void GLAnsGameProtocol::clear_gametakepee() {
  if (gametakepee_ != NULL) gametakepee_->::GLAnsGameTakePee::Clear();
  clear_has_gametakepee();
}
inline const ::GLAnsGameTakePee& GLAnsGameProtocol::gametakepee() const {
  return gametakepee_ != NULL ? *gametakepee_ : *default_instance_->gametakepee_;
}
inline ::GLAnsGameTakePee* GLAnsGameProtocol::mutable_gametakepee() {
  set_has_gametakepee();
  if (gametakepee_ == NULL) gametakepee_ = new ::GLAnsGameTakePee;
  return gametakepee_;
}
inline ::GLAnsGameTakePee* GLAnsGameProtocol::release_gametakepee() {
  clear_has_gametakepee();
  ::GLAnsGameTakePee* temp = gametakepee_;
  gametakepee_ = NULL;
  return temp;
}

// optional .GLAnsGameBbuck gameBbuck = 16;
inline bool GLAnsGameProtocol::has_gamebbuck() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void GLAnsGameProtocol::set_has_gamebbuck() {
  _has_bits_[0] |= 0x00008000u;
}
inline void GLAnsGameProtocol::clear_has_gamebbuck() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void GLAnsGameProtocol::clear_gamebbuck() {
  if (gamebbuck_ != NULL) gamebbuck_->::GLAnsGameBbuck::Clear();
  clear_has_gamebbuck();
}
inline const ::GLAnsGameBbuck& GLAnsGameProtocol::gamebbuck() const {
  return gamebbuck_ != NULL ? *gamebbuck_ : *default_instance_->gamebbuck_;
}
inline ::GLAnsGameBbuck* GLAnsGameProtocol::mutable_gamebbuck() {
  set_has_gamebbuck();
  if (gamebbuck_ == NULL) gamebbuck_ = new ::GLAnsGameBbuck;
  return gamebbuck_;
}
inline ::GLAnsGameBbuck* GLAnsGameProtocol::release_gamebbuck() {
  clear_has_gamebbuck();
  ::GLAnsGameBbuck* temp = gamebbuck_;
  gamebbuck_ = NULL;
  return temp;
}

// optional .GLAnsGameSeriseBbuck gameSeriseBbuck = 17;
inline bool GLAnsGameProtocol::has_gameserisebbuck() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void GLAnsGameProtocol::set_has_gameserisebbuck() {
  _has_bits_[0] |= 0x00010000u;
}
inline void GLAnsGameProtocol::clear_has_gameserisebbuck() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void GLAnsGameProtocol::clear_gameserisebbuck() {
  if (gameserisebbuck_ != NULL) gameserisebbuck_->::GLAnsGameSeriseBbuck::Clear();
  clear_has_gameserisebbuck();
}
inline const ::GLAnsGameSeriseBbuck& GLAnsGameProtocol::gameserisebbuck() const {
  return gameserisebbuck_ != NULL ? *gameserisebbuck_ : *default_instance_->gameserisebbuck_;
}
inline ::GLAnsGameSeriseBbuck* GLAnsGameProtocol::mutable_gameserisebbuck() {
  set_has_gameserisebbuck();
  if (gameserisebbuck_ == NULL) gameserisebbuck_ = new ::GLAnsGameSeriseBbuck;
  return gameserisebbuck_;
}
inline ::GLAnsGameSeriseBbuck* GLAnsGameProtocol::release_gameserisebbuck() {
  clear_has_gameserisebbuck();
  ::GLAnsGameSeriseBbuck* temp = gameserisebbuck_;
  gameserisebbuck_ = NULL;
  return temp;
}

// optional .GLAnsGameBbuckEat gameBbuckEat = 18;
inline bool GLAnsGameProtocol::has_gamebbuckeat() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void GLAnsGameProtocol::set_has_gamebbuckeat() {
  _has_bits_[0] |= 0x00020000u;
}
inline void GLAnsGameProtocol::clear_has_gamebbuckeat() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void GLAnsGameProtocol::clear_gamebbuckeat() {
  if (gamebbuckeat_ != NULL) gamebbuckeat_->::GLAnsGameBbuckEat::Clear();
  clear_has_gamebbuckeat();
}
inline const ::GLAnsGameBbuckEat& GLAnsGameProtocol::gamebbuckeat() const {
  return gamebbuckeat_ != NULL ? *gamebbuckeat_ : *default_instance_->gamebbuckeat_;
}
inline ::GLAnsGameBbuckEat* GLAnsGameProtocol::mutable_gamebbuckeat() {
  set_has_gamebbuckeat();
  if (gamebbuckeat_ == NULL) gamebbuckeat_ = new ::GLAnsGameBbuckEat;
  return gamebbuckeat_;
}
inline ::GLAnsGameBbuckEat* GLAnsGameProtocol::release_gamebbuckeat() {
  clear_has_gamebbuckeat();
  ::GLAnsGameBbuckEat* temp = gamebbuckeat_;
  gamebbuckeat_ = NULL;
  return temp;
}

// optional .GLAnsGameBomb gameBomb = 19;
inline bool GLAnsGameProtocol::has_gamebomb() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void GLAnsGameProtocol::set_has_gamebomb() {
  _has_bits_[0] |= 0x00040000u;
}
inline void GLAnsGameProtocol::clear_has_gamebomb() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void GLAnsGameProtocol::clear_gamebomb() {
  if (gamebomb_ != NULL) gamebomb_->::GLAnsGameBomb::Clear();
  clear_has_gamebomb();
}
inline const ::GLAnsGameBomb& GLAnsGameProtocol::gamebomb() const {
  return gamebomb_ != NULL ? *gamebomb_ : *default_instance_->gamebomb_;
}
inline ::GLAnsGameBomb* GLAnsGameProtocol::mutable_gamebomb() {
  set_has_gamebomb();
  if (gamebomb_ == NULL) gamebomb_ = new ::GLAnsGameBomb;
  return gamebomb_;
}
inline ::GLAnsGameBomb* GLAnsGameProtocol::release_gamebomb() {
  clear_has_gamebomb();
  ::GLAnsGameBomb* temp = gamebomb_;
  gamebomb_ = NULL;
  return temp;
}

// optional .GLAnsGamePan gamePan = 20;
inline bool GLAnsGameProtocol::has_gamepan() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void GLAnsGameProtocol::set_has_gamepan() {
  _has_bits_[0] |= 0x00080000u;
}
inline void GLAnsGameProtocol::clear_has_gamepan() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void GLAnsGameProtocol::clear_gamepan() {
  if (gamepan_ != NULL) gamepan_->::GLAnsGamePan::Clear();
  clear_has_gamepan();
}
inline const ::GLAnsGamePan& GLAnsGameProtocol::gamepan() const {
  return gamepan_ != NULL ? *gamepan_ : *default_instance_->gamepan_;
}
inline ::GLAnsGamePan* GLAnsGameProtocol::mutable_gamepan() {
  set_has_gamepan();
  if (gamepan_ == NULL) gamepan_ = new ::GLAnsGamePan;
  return gamepan_;
}
inline ::GLAnsGamePan* GLAnsGameProtocol::release_gamepan() {
  clear_has_gamepan();
  ::GLAnsGamePan* temp = gamepan_;
  gamepan_ = NULL;
  return temp;
}

// optional .GLAnsGameDadak gameDadak = 21;
inline bool GLAnsGameProtocol::has_gamedadak() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void GLAnsGameProtocol::set_has_gamedadak() {
  _has_bits_[0] |= 0x00100000u;
}
inline void GLAnsGameProtocol::clear_has_gamedadak() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void GLAnsGameProtocol::clear_gamedadak() {
  if (gamedadak_ != NULL) gamedadak_->::GLAnsGameDadak::Clear();
  clear_has_gamedadak();
}
inline const ::GLAnsGameDadak& GLAnsGameProtocol::gamedadak() const {
  return gamedadak_ != NULL ? *gamedadak_ : *default_instance_->gamedadak_;
}
inline ::GLAnsGameDadak* GLAnsGameProtocol::mutable_gamedadak() {
  set_has_gamedadak();
  if (gamedadak_ == NULL) gamedadak_ = new ::GLAnsGameDadak;
  return gamedadak_;
}
inline ::GLAnsGameDadak* GLAnsGameProtocol::release_gamedadak() {
  clear_has_gamedadak();
  ::GLAnsGameDadak* temp = gamedadak_;
  gamedadak_ = NULL;
  return temp;
}

// optional .GLAnsGameJjok gameJjok = 22;
inline bool GLAnsGameProtocol::has_gamejjok() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void GLAnsGameProtocol::set_has_gamejjok() {
  _has_bits_[0] |= 0x00200000u;
}
inline void GLAnsGameProtocol::clear_has_gamejjok() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void GLAnsGameProtocol::clear_gamejjok() {
  if (gamejjok_ != NULL) gamejjok_->::GLAnsGameJjok::Clear();
  clear_has_gamejjok();
}
inline const ::GLAnsGameJjok& GLAnsGameProtocol::gamejjok() const {
  return gamejjok_ != NULL ? *gamejjok_ : *default_instance_->gamejjok_;
}
inline ::GLAnsGameJjok* GLAnsGameProtocol::mutable_gamejjok() {
  set_has_gamejjok();
  if (gamejjok_ == NULL) gamejjok_ = new ::GLAnsGameJjok;
  return gamejjok_;
}
inline ::GLAnsGameJjok* GLAnsGameProtocol::release_gamejjok() {
  clear_has_gamejjok();
  ::GLAnsGameJjok* temp = gamejjok_;
  gamejjok_ = NULL;
  return temp;
}

// optional .GLAnsGameUpset gameUpset = 23;
inline bool GLAnsGameProtocol::has_gameupset() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void GLAnsGameProtocol::set_has_gameupset() {
  _has_bits_[0] |= 0x00400000u;
}
inline void GLAnsGameProtocol::clear_has_gameupset() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void GLAnsGameProtocol::clear_gameupset() {
  if (gameupset_ != NULL) gameupset_->::GLAnsGameUpset::Clear();
  clear_has_gameupset();
}
inline const ::GLAnsGameUpset& GLAnsGameProtocol::gameupset() const {
  return gameupset_ != NULL ? *gameupset_ : *default_instance_->gameupset_;
}
inline ::GLAnsGameUpset* GLAnsGameProtocol::mutable_gameupset() {
  set_has_gameupset();
  if (gameupset_ == NULL) gameupset_ = new ::GLAnsGameUpset;
  return gameupset_;
}
inline ::GLAnsGameUpset* GLAnsGameProtocol::release_gameupset() {
  clear_has_gameupset();
  ::GLAnsGameUpset* temp = gameupset_;
  gameupset_ = NULL;
  return temp;
}

// optional .GLAnsGameAllEatUp gameAllEatUp = 24;
inline bool GLAnsGameProtocol::has_gamealleatup() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void GLAnsGameProtocol::set_has_gamealleatup() {
  _has_bits_[0] |= 0x00800000u;
}
inline void GLAnsGameProtocol::clear_has_gamealleatup() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void GLAnsGameProtocol::clear_gamealleatup() {
  if (gamealleatup_ != NULL) gamealleatup_->::GLAnsGameAllEatUp::Clear();
  clear_has_gamealleatup();
}
inline const ::GLAnsGameAllEatUp& GLAnsGameProtocol::gamealleatup() const {
  return gamealleatup_ != NULL ? *gamealleatup_ : *default_instance_->gamealleatup_;
}
inline ::GLAnsGameAllEatUp* GLAnsGameProtocol::mutable_gamealleatup() {
  set_has_gamealleatup();
  if (gamealleatup_ == NULL) gamealleatup_ = new ::GLAnsGameAllEatUp;
  return gamealleatup_;
}
inline ::GLAnsGameAllEatUp* GLAnsGameProtocol::release_gamealleatup() {
  clear_has_gamealleatup();
  ::GLAnsGameAllEatUp* temp = gamealleatup_;
  gamealleatup_ = NULL;
  return temp;
}

// optional .GLAnsGameNotiTurn gameNotiTurn = 25;
inline bool GLAnsGameProtocol::has_gamenotiturn() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void GLAnsGameProtocol::set_has_gamenotiturn() {
  _has_bits_[0] |= 0x01000000u;
}
inline void GLAnsGameProtocol::clear_has_gamenotiturn() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void GLAnsGameProtocol::clear_gamenotiturn() {
  if (gamenotiturn_ != NULL) gamenotiturn_->::GLAnsGameNotiTurn::Clear();
  clear_has_gamenotiturn();
}
inline const ::GLAnsGameNotiTurn& GLAnsGameProtocol::gamenotiturn() const {
  return gamenotiturn_ != NULL ? *gamenotiturn_ : *default_instance_->gamenotiturn_;
}
inline ::GLAnsGameNotiTurn* GLAnsGameProtocol::mutable_gamenotiturn() {
  set_has_gamenotiturn();
  if (gamenotiturn_ == NULL) gamenotiturn_ = new ::GLAnsGameNotiTurn;
  return gamenotiturn_;
}
inline ::GLAnsGameNotiTurn* GLAnsGameProtocol::release_gamenotiturn() {
  clear_has_gamenotiturn();
  ::GLAnsGameNotiTurn* temp = gamenotiturn_;
  gamenotiturn_ = NULL;
  return temp;
}

// optional .GLAnsGameMoveTen gameMoveTen = 26;
inline bool GLAnsGameProtocol::has_gamemoveten() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void GLAnsGameProtocol::set_has_gamemoveten() {
  _has_bits_[0] |= 0x02000000u;
}
inline void GLAnsGameProtocol::clear_has_gamemoveten() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void GLAnsGameProtocol::clear_gamemoveten() {
  if (gamemoveten_ != NULL) gamemoveten_->::GLAnsGameMoveTen::Clear();
  clear_has_gamemoveten();
}
inline const ::GLAnsGameMoveTen& GLAnsGameProtocol::gamemoveten() const {
  return gamemoveten_ != NULL ? *gamemoveten_ : *default_instance_->gamemoveten_;
}
inline ::GLAnsGameMoveTen* GLAnsGameProtocol::mutable_gamemoveten() {
  set_has_gamemoveten();
  if (gamemoveten_ == NULL) gamemoveten_ = new ::GLAnsGameMoveTen;
  return gamemoveten_;
}
inline ::GLAnsGameMoveTen* GLAnsGameProtocol::release_gamemoveten() {
  clear_has_gamemoveten();
  ::GLAnsGameMoveTen* temp = gamemoveten_;
  gamemoveten_ = NULL;
  return temp;
}

// optional .GLAnsGameMoveTenAns gameMoveTenAns = 27;
inline bool GLAnsGameProtocol::has_gamemovetenans() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void GLAnsGameProtocol::set_has_gamemovetenans() {
  _has_bits_[0] |= 0x04000000u;
}
inline void GLAnsGameProtocol::clear_has_gamemovetenans() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void GLAnsGameProtocol::clear_gamemovetenans() {
  if (gamemovetenans_ != NULL) gamemovetenans_->::GLAnsGameMoveTenAns::Clear();
  clear_has_gamemovetenans();
}
inline const ::GLAnsGameMoveTenAns& GLAnsGameProtocol::gamemovetenans() const {
  return gamemovetenans_ != NULL ? *gamemovetenans_ : *default_instance_->gamemovetenans_;
}
inline ::GLAnsGameMoveTenAns* GLAnsGameProtocol::mutable_gamemovetenans() {
  set_has_gamemovetenans();
  if (gamemovetenans_ == NULL) gamemovetenans_ = new ::GLAnsGameMoveTenAns;
  return gamemovetenans_;
}
inline ::GLAnsGameMoveTenAns* GLAnsGameProtocol::release_gamemovetenans() {
  clear_has_gamemovetenans();
  ::GLAnsGameMoveTenAns* temp = gamemovetenans_;
  gamemovetenans_ = NULL;
  return temp;
}

// optional .GLAnsGameChoiceCard gameChoiceCard = 28;
inline bool GLAnsGameProtocol::has_gamechoicecard() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void GLAnsGameProtocol::set_has_gamechoicecard() {
  _has_bits_[0] |= 0x08000000u;
}
inline void GLAnsGameProtocol::clear_has_gamechoicecard() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void GLAnsGameProtocol::clear_gamechoicecard() {
  if (gamechoicecard_ != NULL) gamechoicecard_->::GLAnsGameChoiceCard::Clear();
  clear_has_gamechoicecard();
}
inline const ::GLAnsGameChoiceCard& GLAnsGameProtocol::gamechoicecard() const {
  return gamechoicecard_ != NULL ? *gamechoicecard_ : *default_instance_->gamechoicecard_;
}
inline ::GLAnsGameChoiceCard* GLAnsGameProtocol::mutable_gamechoicecard() {
  set_has_gamechoicecard();
  if (gamechoicecard_ == NULL) gamechoicecard_ = new ::GLAnsGameChoiceCard;
  return gamechoicecard_;
}
inline ::GLAnsGameChoiceCard* GLAnsGameProtocol::release_gamechoicecard() {
  clear_has_gamechoicecard();
  ::GLAnsGameChoiceCard* temp = gamechoicecard_;
  gamechoicecard_ = NULL;
  return temp;
}

// optional .GLAnsGameShake gameShake = 29;
inline bool GLAnsGameProtocol::has_gameshake() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void GLAnsGameProtocol::set_has_gameshake() {
  _has_bits_[0] |= 0x10000000u;
}
inline void GLAnsGameProtocol::clear_has_gameshake() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void GLAnsGameProtocol::clear_gameshake() {
  if (gameshake_ != NULL) gameshake_->::GLAnsGameShake::Clear();
  clear_has_gameshake();
}
inline const ::GLAnsGameShake& GLAnsGameProtocol::gameshake() const {
  return gameshake_ != NULL ? *gameshake_ : *default_instance_->gameshake_;
}
inline ::GLAnsGameShake* GLAnsGameProtocol::mutable_gameshake() {
  set_has_gameshake();
  if (gameshake_ == NULL) gameshake_ = new ::GLAnsGameShake;
  return gameshake_;
}
inline ::GLAnsGameShake* GLAnsGameProtocol::release_gameshake() {
  clear_has_gameshake();
  ::GLAnsGameShake* temp = gameshake_;
  gameshake_ = NULL;
  return temp;
}

// optional .GLAnsGameShakeAns gameShakeAns = 30;
inline bool GLAnsGameProtocol::has_gameshakeans() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void GLAnsGameProtocol::set_has_gameshakeans() {
  _has_bits_[0] |= 0x20000000u;
}
inline void GLAnsGameProtocol::clear_has_gameshakeans() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void GLAnsGameProtocol::clear_gameshakeans() {
  if (gameshakeans_ != NULL) gameshakeans_->::GLAnsGameShakeAns::Clear();
  clear_has_gameshakeans();
}
inline const ::GLAnsGameShakeAns& GLAnsGameProtocol::gameshakeans() const {
  return gameshakeans_ != NULL ? *gameshakeans_ : *default_instance_->gameshakeans_;
}
inline ::GLAnsGameShakeAns* GLAnsGameProtocol::mutable_gameshakeans() {
  set_has_gameshakeans();
  if (gameshakeans_ == NULL) gameshakeans_ = new ::GLAnsGameShakeAns;
  return gameshakeans_;
}
inline ::GLAnsGameShakeAns* GLAnsGameProtocol::release_gameshakeans() {
  clear_has_gameshakeans();
  ::GLAnsGameShakeAns* temp = gameshakeans_;
  gameshakeans_ = NULL;
  return temp;
}

// optional .GLAnsGameShakeCount gameShakeCount = 31;
inline bool GLAnsGameProtocol::has_gameshakecount() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void GLAnsGameProtocol::set_has_gameshakecount() {
  _has_bits_[0] |= 0x40000000u;
}
inline void GLAnsGameProtocol::clear_has_gameshakecount() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void GLAnsGameProtocol::clear_gameshakecount() {
  if (gameshakecount_ != NULL) gameshakecount_->::GLAnsGameShakeCount::Clear();
  clear_has_gameshakecount();
}
inline const ::GLAnsGameShakeCount& GLAnsGameProtocol::gameshakecount() const {
  return gameshakecount_ != NULL ? *gameshakecount_ : *default_instance_->gameshakecount_;
}
inline ::GLAnsGameShakeCount* GLAnsGameProtocol::mutable_gameshakecount() {
  set_has_gameshakecount();
  if (gameshakecount_ == NULL) gameshakecount_ = new ::GLAnsGameShakeCount;
  return gameshakecount_;
}
inline ::GLAnsGameShakeCount* GLAnsGameProtocol::release_gameshakecount() {
  clear_has_gameshakecount();
  ::GLAnsGameShakeCount* temp = gameshakecount_;
  gameshakecount_ = NULL;
  return temp;
}

// optional .GLAnsGameCapType gameCapType = 32;
inline bool GLAnsGameProtocol::has_gamecaptype() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void GLAnsGameProtocol::set_has_gamecaptype() {
  _has_bits_[0] |= 0x80000000u;
}
inline void GLAnsGameProtocol::clear_has_gamecaptype() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void GLAnsGameProtocol::clear_gamecaptype() {
  if (gamecaptype_ != NULL) gamecaptype_->::GLAnsGameCapType::Clear();
  clear_has_gamecaptype();
}
inline const ::GLAnsGameCapType& GLAnsGameProtocol::gamecaptype() const {
  return gamecaptype_ != NULL ? *gamecaptype_ : *default_instance_->gamecaptype_;
}
inline ::GLAnsGameCapType* GLAnsGameProtocol::mutable_gamecaptype() {
  set_has_gamecaptype();
  if (gamecaptype_ == NULL) gamecaptype_ = new ::GLAnsGameCapType;
  return gamecaptype_;
}
inline ::GLAnsGameCapType* GLAnsGameProtocol::release_gamecaptype() {
  clear_has_gamecaptype();
  ::GLAnsGameCapType* temp = gamecaptype_;
  gamecaptype_ = NULL;
  return temp;
}

// optional .GLAnsGameGodori gameGodori = 33;
inline bool GLAnsGameProtocol::has_gamegodori() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void GLAnsGameProtocol::set_has_gamegodori() {
  _has_bits_[1] |= 0x00000001u;
}
inline void GLAnsGameProtocol::clear_has_gamegodori() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void GLAnsGameProtocol::clear_gamegodori() {
  if (gamegodori_ != NULL) gamegodori_->::GLAnsGameGodori::Clear();
  clear_has_gamegodori();
}
inline const ::GLAnsGameGodori& GLAnsGameProtocol::gamegodori() const {
  return gamegodori_ != NULL ? *gamegodori_ : *default_instance_->gamegodori_;
}
inline ::GLAnsGameGodori* GLAnsGameProtocol::mutable_gamegodori() {
  set_has_gamegodori();
  if (gamegodori_ == NULL) gamegodori_ = new ::GLAnsGameGodori;
  return gamegodori_;
}
inline ::GLAnsGameGodori* GLAnsGameProtocol::release_gamegodori() {
  clear_has_gamegodori();
  ::GLAnsGameGodori* temp = gamegodori_;
  gamegodori_ = NULL;
  return temp;
}

// optional .GLAnsGameKusa gameKusa = 34;
inline bool GLAnsGameProtocol::has_gamekusa() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void GLAnsGameProtocol::set_has_gamekusa() {
  _has_bits_[1] |= 0x00000002u;
}
inline void GLAnsGameProtocol::clear_has_gamekusa() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void GLAnsGameProtocol::clear_gamekusa() {
  if (gamekusa_ != NULL) gamekusa_->::GLAnsGameKusa::Clear();
  clear_has_gamekusa();
}
inline const ::GLAnsGameKusa& GLAnsGameProtocol::gamekusa() const {
  return gamekusa_ != NULL ? *gamekusa_ : *default_instance_->gamekusa_;
}
inline ::GLAnsGameKusa* GLAnsGameProtocol::mutable_gamekusa() {
  set_has_gamekusa();
  if (gamekusa_ == NULL) gamekusa_ = new ::GLAnsGameKusa;
  return gamekusa_;
}
inline ::GLAnsGameKusa* GLAnsGameProtocol::release_gamekusa() {
  clear_has_gamekusa();
  ::GLAnsGameKusa* temp = gamekusa_;
  gamekusa_ = NULL;
  return temp;
}

// optional .GLAnsGameRed gameRed = 35;
inline bool GLAnsGameProtocol::has_gamered() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void GLAnsGameProtocol::set_has_gamered() {
  _has_bits_[1] |= 0x00000004u;
}
inline void GLAnsGameProtocol::clear_has_gamered() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void GLAnsGameProtocol::clear_gamered() {
  if (gamered_ != NULL) gamered_->::GLAnsGameRed::Clear();
  clear_has_gamered();
}
inline const ::GLAnsGameRed& GLAnsGameProtocol::gamered() const {
  return gamered_ != NULL ? *gamered_ : *default_instance_->gamered_;
}
inline ::GLAnsGameRed* GLAnsGameProtocol::mutable_gamered() {
  set_has_gamered();
  if (gamered_ == NULL) gamered_ = new ::GLAnsGameRed;
  return gamered_;
}
inline ::GLAnsGameRed* GLAnsGameProtocol::release_gamered() {
  clear_has_gamered();
  ::GLAnsGameRed* temp = gamered_;
  gamered_ = NULL;
  return temp;
}

// optional .GLAnsGameBlue gameBlue = 36;
inline bool GLAnsGameProtocol::has_gameblue() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void GLAnsGameProtocol::set_has_gameblue() {
  _has_bits_[1] |= 0x00000008u;
}
inline void GLAnsGameProtocol::clear_has_gameblue() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void GLAnsGameProtocol::clear_gameblue() {
  if (gameblue_ != NULL) gameblue_->::GLAnsGameBlue::Clear();
  clear_has_gameblue();
}
inline const ::GLAnsGameBlue& GLAnsGameProtocol::gameblue() const {
  return gameblue_ != NULL ? *gameblue_ : *default_instance_->gameblue_;
}
inline ::GLAnsGameBlue* GLAnsGameProtocol::mutable_gameblue() {
  set_has_gameblue();
  if (gameblue_ == NULL) gameblue_ = new ::GLAnsGameBlue;
  return gameblue_;
}
inline ::GLAnsGameBlue* GLAnsGameProtocol::release_gameblue() {
  clear_has_gameblue();
  ::GLAnsGameBlue* temp = gameblue_;
  gameblue_ = NULL;
  return temp;
}

// optional .GLAnsGameBak gameBak = 37;
inline bool GLAnsGameProtocol::has_gamebak() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void GLAnsGameProtocol::set_has_gamebak() {
  _has_bits_[1] |= 0x00000010u;
}
inline void GLAnsGameProtocol::clear_has_gamebak() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void GLAnsGameProtocol::clear_gamebak() {
  if (gamebak_ != NULL) gamebak_->::GLAnsGameBak::Clear();
  clear_has_gamebak();
}
inline const ::GLAnsGameBak& GLAnsGameProtocol::gamebak() const {
  return gamebak_ != NULL ? *gamebak_ : *default_instance_->gamebak_;
}
inline ::GLAnsGameBak* GLAnsGameProtocol::mutable_gamebak() {
  set_has_gamebak();
  if (gamebak_ == NULL) gamebak_ = new ::GLAnsGameBak;
  return gamebak_;
}
inline ::GLAnsGameBak* GLAnsGameProtocol::release_gamebak() {
  clear_has_gamebak();
  ::GLAnsGameBak* temp = gamebak_;
  gamebak_ = NULL;
  return temp;
}

// optional .GLAnsGameBakFail gameBakFail = 38;
inline bool GLAnsGameProtocol::has_gamebakfail() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void GLAnsGameProtocol::set_has_gamebakfail() {
  _has_bits_[1] |= 0x00000020u;
}
inline void GLAnsGameProtocol::clear_has_gamebakfail() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void GLAnsGameProtocol::clear_gamebakfail() {
  if (gamebakfail_ != NULL) gamebakfail_->::GLAnsGameBakFail::Clear();
  clear_has_gamebakfail();
}
inline const ::GLAnsGameBakFail& GLAnsGameProtocol::gamebakfail() const {
  return gamebakfail_ != NULL ? *gamebakfail_ : *default_instance_->gamebakfail_;
}
inline ::GLAnsGameBakFail* GLAnsGameProtocol::mutable_gamebakfail() {
  set_has_gamebakfail();
  if (gamebakfail_ == NULL) gamebakfail_ = new ::GLAnsGameBakFail;
  return gamebakfail_;
}
inline ::GLAnsGameBakFail* GLAnsGameProtocol::release_gamebakfail() {
  clear_has_gamebakfail();
  ::GLAnsGameBakFail* temp = gamebakfail_;
  gamebakfail_ = NULL;
  return temp;
}

// optional .GLAnsGameNotiMission gameNotiMission = 39;
inline bool GLAnsGameProtocol::has_gamenotimission() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void GLAnsGameProtocol::set_has_gamenotimission() {
  _has_bits_[1] |= 0x00000040u;
}
inline void GLAnsGameProtocol::clear_has_gamenotimission() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void GLAnsGameProtocol::clear_gamenotimission() {
  if (gamenotimission_ != NULL) gamenotimission_->::GLAnsGameNotiMission::Clear();
  clear_has_gamenotimission();
}
inline const ::GLAnsGameNotiMission& GLAnsGameProtocol::gamenotimission() const {
  return gamenotimission_ != NULL ? *gamenotimission_ : *default_instance_->gamenotimission_;
}
inline ::GLAnsGameNotiMission* GLAnsGameProtocol::mutable_gamenotimission() {
  set_has_gamenotimission();
  if (gamenotimission_ == NULL) gamenotimission_ = new ::GLAnsGameNotiMission;
  return gamenotimission_;
}
inline ::GLAnsGameNotiMission* GLAnsGameProtocol::release_gamenotimission() {
  clear_has_gamenotimission();
  ::GLAnsGameNotiMission* temp = gamenotimission_;
  gamenotimission_ = NULL;
  return temp;
}

// optional .GLAnsGameNotiMissionCard gameNotiMissionCard = 40;
inline bool GLAnsGameProtocol::has_gamenotimissioncard() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void GLAnsGameProtocol::set_has_gamenotimissioncard() {
  _has_bits_[1] |= 0x00000080u;
}
inline void GLAnsGameProtocol::clear_has_gamenotimissioncard() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void GLAnsGameProtocol::clear_gamenotimissioncard() {
  if (gamenotimissioncard_ != NULL) gamenotimissioncard_->::GLAnsGameNotiMissionCard::Clear();
  clear_has_gamenotimissioncard();
}
inline const ::GLAnsGameNotiMissionCard& GLAnsGameProtocol::gamenotimissioncard() const {
  return gamenotimissioncard_ != NULL ? *gamenotimissioncard_ : *default_instance_->gamenotimissioncard_;
}
inline ::GLAnsGameNotiMissionCard* GLAnsGameProtocol::mutable_gamenotimissioncard() {
  set_has_gamenotimissioncard();
  if (gamenotimissioncard_ == NULL) gamenotimissioncard_ = new ::GLAnsGameNotiMissionCard;
  return gamenotimissioncard_;
}
inline ::GLAnsGameNotiMissionCard* GLAnsGameProtocol::release_gamenotimissioncard() {
  clear_has_gamenotimissioncard();
  ::GLAnsGameNotiMissionCard* temp = gamenotimissioncard_;
  gamenotimissioncard_ = NULL;
  return temp;
}

// optional .GLAnsGameMissionState gameMissionState = 41;
inline bool GLAnsGameProtocol::has_gamemissionstate() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void GLAnsGameProtocol::set_has_gamemissionstate() {
  _has_bits_[1] |= 0x00000100u;
}
inline void GLAnsGameProtocol::clear_has_gamemissionstate() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void GLAnsGameProtocol::clear_gamemissionstate() {
  if (gamemissionstate_ != NULL) gamemissionstate_->::GLAnsGameMissionState::Clear();
  clear_has_gamemissionstate();
}
inline const ::GLAnsGameMissionState& GLAnsGameProtocol::gamemissionstate() const {
  return gamemissionstate_ != NULL ? *gamemissionstate_ : *default_instance_->gamemissionstate_;
}
inline ::GLAnsGameMissionState* GLAnsGameProtocol::mutable_gamemissionstate() {
  set_has_gamemissionstate();
  if (gamemissionstate_ == NULL) gamemissionstate_ = new ::GLAnsGameMissionState;
  return gamemissionstate_;
}
inline ::GLAnsGameMissionState* GLAnsGameProtocol::release_gamemissionstate() {
  clear_has_gamemissionstate();
  ::GLAnsGameMissionState* temp = gamemissionstate_;
  gamemissionstate_ = NULL;
  return temp;
}

// optional .GLAnsGameGostop gameGostop = 42;
inline bool GLAnsGameProtocol::has_gamegostop() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void GLAnsGameProtocol::set_has_gamegostop() {
  _has_bits_[1] |= 0x00000200u;
}
inline void GLAnsGameProtocol::clear_has_gamegostop() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void GLAnsGameProtocol::clear_gamegostop() {
  if (gamegostop_ != NULL) gamegostop_->::GLAnsGameGostop::Clear();
  clear_has_gamegostop();
}
inline const ::GLAnsGameGostop& GLAnsGameProtocol::gamegostop() const {
  return gamegostop_ != NULL ? *gamegostop_ : *default_instance_->gamegostop_;
}
inline ::GLAnsGameGostop* GLAnsGameProtocol::mutable_gamegostop() {
  set_has_gamegostop();
  if (gamegostop_ == NULL) gamegostop_ = new ::GLAnsGameGostop;
  return gamegostop_;
}
inline ::GLAnsGameGostop* GLAnsGameProtocol::release_gamegostop() {
  clear_has_gamegostop();
  ::GLAnsGameGostop* temp = gamegostop_;
  gamegostop_ = NULL;
  return temp;
}

// optional .GLAnsGameGostopAns gameGostopAns = 43;
inline bool GLAnsGameProtocol::has_gamegostopans() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void GLAnsGameProtocol::set_has_gamegostopans() {
  _has_bits_[1] |= 0x00000400u;
}
inline void GLAnsGameProtocol::clear_has_gamegostopans() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void GLAnsGameProtocol::clear_gamegostopans() {
  if (gamegostopans_ != NULL) gamegostopans_->::GLAnsGameGostopAns::Clear();
  clear_has_gamegostopans();
}
inline const ::GLAnsGameGostopAns& GLAnsGameProtocol::gamegostopans() const {
  return gamegostopans_ != NULL ? *gamegostopans_ : *default_instance_->gamegostopans_;
}
inline ::GLAnsGameGostopAns* GLAnsGameProtocol::mutable_gamegostopans() {
  set_has_gamegostopans();
  if (gamegostopans_ == NULL) gamegostopans_ = new ::GLAnsGameGostopAns;
  return gamegostopans_;
}
inline ::GLAnsGameGostopAns* GLAnsGameProtocol::release_gamegostopans() {
  clear_has_gamegostopans();
  ::GLAnsGameGostopAns* temp = gamegostopans_;
  gamegostopans_ = NULL;
  return temp;
}

// optional .GLAnsGameStopAns gameStopAns = 44;
inline bool GLAnsGameProtocol::has_gamestopans() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void GLAnsGameProtocol::set_has_gamestopans() {
  _has_bits_[1] |= 0x00000800u;
}
inline void GLAnsGameProtocol::clear_has_gamestopans() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void GLAnsGameProtocol::clear_gamestopans() {
  if (gamestopans_ != NULL) gamestopans_->::GLAnsGameStopAns::Clear();
  clear_has_gamestopans();
}
inline const ::GLAnsGameStopAns& GLAnsGameProtocol::gamestopans() const {
  return gamestopans_ != NULL ? *gamestopans_ : *default_instance_->gamestopans_;
}
inline ::GLAnsGameStopAns* GLAnsGameProtocol::mutable_gamestopans() {
  set_has_gamestopans();
  if (gamestopans_ == NULL) gamestopans_ = new ::GLAnsGameStopAns;
  return gamestopans_;
}
inline ::GLAnsGameStopAns* GLAnsGameProtocol::release_gamestopans() {
  clear_has_gamestopans();
  ::GLAnsGameStopAns* temp = gamestopans_;
  gamestopans_ = NULL;
  return temp;
}

// optional .GLAnsGameResult gameResult = 45;
inline bool GLAnsGameProtocol::has_gameresult() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void GLAnsGameProtocol::set_has_gameresult() {
  _has_bits_[1] |= 0x00001000u;
}
inline void GLAnsGameProtocol::clear_has_gameresult() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void GLAnsGameProtocol::clear_gameresult() {
  if (gameresult_ != NULL) gameresult_->::GLAnsGameResult::Clear();
  clear_has_gameresult();
}
inline const ::GLAnsGameResult& GLAnsGameProtocol::gameresult() const {
  return gameresult_ != NULL ? *gameresult_ : *default_instance_->gameresult_;
}
inline ::GLAnsGameResult* GLAnsGameProtocol::mutable_gameresult() {
  set_has_gameresult();
  if (gameresult_ == NULL) gameresult_ = new ::GLAnsGameResult;
  return gameresult_;
}
inline ::GLAnsGameResult* GLAnsGameProtocol::release_gameresult() {
  clear_has_gameresult();
  ::GLAnsGameResult* temp = gameresult_;
  gameresult_ = NULL;
  return temp;
}

// optional .GLAnsGameNotiPoint gameNotiPoint = 46;
inline bool GLAnsGameProtocol::has_gamenotipoint() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void GLAnsGameProtocol::set_has_gamenotipoint() {
  _has_bits_[1] |= 0x00002000u;
}
inline void GLAnsGameProtocol::clear_has_gamenotipoint() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void GLAnsGameProtocol::clear_gamenotipoint() {
  if (gamenotipoint_ != NULL) gamenotipoint_->::GLAnsGameNotiPoint::Clear();
  clear_has_gamenotipoint();
}
inline const ::GLAnsGameNotiPoint& GLAnsGameProtocol::gamenotipoint() const {
  return gamenotipoint_ != NULL ? *gamenotipoint_ : *default_instance_->gamenotipoint_;
}
inline ::GLAnsGameNotiPoint* GLAnsGameProtocol::mutable_gamenotipoint() {
  set_has_gamenotipoint();
  if (gamenotipoint_ == NULL) gamenotipoint_ = new ::GLAnsGameNotiPoint;
  return gamenotipoint_;
}
inline ::GLAnsGameNotiPoint* GLAnsGameProtocol::release_gamenotipoint() {
  clear_has_gamenotipoint();
  ::GLAnsGameNotiPoint* temp = gamenotipoint_;
  gamenotipoint_ = NULL;
  return temp;
}

// optional .GLAnsGameEnd gameEnd = 47;
inline bool GLAnsGameProtocol::has_gameend() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void GLAnsGameProtocol::set_has_gameend() {
  _has_bits_[1] |= 0x00004000u;
}
inline void GLAnsGameProtocol::clear_has_gameend() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void GLAnsGameProtocol::clear_gameend() {
  if (gameend_ != NULL) gameend_->::GLAnsGameEnd::Clear();
  clear_has_gameend();
}
inline const ::GLAnsGameEnd& GLAnsGameProtocol::gameend() const {
  return gameend_ != NULL ? *gameend_ : *default_instance_->gameend_;
}
inline ::GLAnsGameEnd* GLAnsGameProtocol::mutable_gameend() {
  set_has_gameend();
  if (gameend_ == NULL) gameend_ = new ::GLAnsGameEnd;
  return gameend_;
}
inline ::GLAnsGameEnd* GLAnsGameProtocol::release_gameend() {
  clear_has_gameend();
  ::GLAnsGameEnd* temp = gameend_;
  gameend_ = NULL;
  return temp;
}

// optional .GLAnsGameKick gameKick = 48;
inline bool GLAnsGameProtocol::has_gamekick() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void GLAnsGameProtocol::set_has_gamekick() {
  _has_bits_[1] |= 0x00008000u;
}
inline void GLAnsGameProtocol::clear_has_gamekick() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void GLAnsGameProtocol::clear_gamekick() {
  if (gamekick_ != NULL) gamekick_->::GLAnsGameKick::Clear();
  clear_has_gamekick();
}
inline const ::GLAnsGameKick& GLAnsGameProtocol::gamekick() const {
  return gamekick_ != NULL ? *gamekick_ : *default_instance_->gamekick_;
}
inline ::GLAnsGameKick* GLAnsGameProtocol::mutable_gamekick() {
  set_has_gamekick();
  if (gamekick_ == NULL) gamekick_ = new ::GLAnsGameKick;
  return gamekick_;
}
inline ::GLAnsGameKick* GLAnsGameProtocol::release_gamekick() {
  clear_has_gamekick();
  ::GLAnsGameKick* temp = gamekick_;
  gamekick_ = NULL;
  return temp;
}

// optional .GLAnsGameEmoti ansGameEmoti = 49;
inline bool GLAnsGameProtocol::has_ansgameemoti() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void GLAnsGameProtocol::set_has_ansgameemoti() {
  _has_bits_[1] |= 0x00010000u;
}
inline void GLAnsGameProtocol::clear_has_ansgameemoti() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void GLAnsGameProtocol::clear_ansgameemoti() {
  if (ansgameemoti_ != NULL) ansgameemoti_->::GLAnsGameEmoti::Clear();
  clear_has_ansgameemoti();
}
inline const ::GLAnsGameEmoti& GLAnsGameProtocol::ansgameemoti() const {
  return ansgameemoti_ != NULL ? *ansgameemoti_ : *default_instance_->ansgameemoti_;
}
inline ::GLAnsGameEmoti* GLAnsGameProtocol::mutable_ansgameemoti() {
  set_has_ansgameemoti();
  if (ansgameemoti_ == NULL) ansgameemoti_ = new ::GLAnsGameEmoti;
  return ansgameemoti_;
}
inline ::GLAnsGameEmoti* GLAnsGameProtocol::release_ansgameemoti() {
  clear_has_ansgameemoti();
  ::GLAnsGameEmoti* temp = ansgameemoti_;
  ansgameemoti_ = NULL;
  return temp;
}

// optional .GLAnsGameAutoPlay ansGameAutoPlay = 50;
inline bool GLAnsGameProtocol::has_ansgameautoplay() const {
  return (_has_bits_[1] & 0x00020000u) != 0;
}
inline void GLAnsGameProtocol::set_has_ansgameautoplay() {
  _has_bits_[1] |= 0x00020000u;
}
inline void GLAnsGameProtocol::clear_has_ansgameautoplay() {
  _has_bits_[1] &= ~0x00020000u;
}
inline void GLAnsGameProtocol::clear_ansgameautoplay() {
  if (ansgameautoplay_ != NULL) ansgameautoplay_->::GLAnsGameAutoPlay::Clear();
  clear_has_ansgameautoplay();
}
inline const ::GLAnsGameAutoPlay& GLAnsGameProtocol::ansgameautoplay() const {
  return ansgameautoplay_ != NULL ? *ansgameautoplay_ : *default_instance_->ansgameautoplay_;
}
inline ::GLAnsGameAutoPlay* GLAnsGameProtocol::mutable_ansgameautoplay() {
  set_has_ansgameautoplay();
  if (ansgameautoplay_ == NULL) ansgameautoplay_ = new ::GLAnsGameAutoPlay;
  return ansgameautoplay_;
}
inline ::GLAnsGameAutoPlay* GLAnsGameProtocol::release_ansgameautoplay() {
  clear_has_ansgameautoplay();
  ::GLAnsGameAutoPlay* temp = ansgameautoplay_;
  ansgameautoplay_ = NULL;
  return temp;
}

// optional .GLAnsGameRelayInfo ansGameRelayInfo = 51;
inline bool GLAnsGameProtocol::has_ansgamerelayinfo() const {
  return (_has_bits_[1] & 0x00040000u) != 0;
}
inline void GLAnsGameProtocol::set_has_ansgamerelayinfo() {
  _has_bits_[1] |= 0x00040000u;
}
inline void GLAnsGameProtocol::clear_has_ansgamerelayinfo() {
  _has_bits_[1] &= ~0x00040000u;
}
inline void GLAnsGameProtocol::clear_ansgamerelayinfo() {
  if (ansgamerelayinfo_ != NULL) ansgamerelayinfo_->::GLAnsGameRelayInfo::Clear();
  clear_has_ansgamerelayinfo();
}
inline const ::GLAnsGameRelayInfo& GLAnsGameProtocol::ansgamerelayinfo() const {
  return ansgamerelayinfo_ != NULL ? *ansgamerelayinfo_ : *default_instance_->ansgamerelayinfo_;
}
inline ::GLAnsGameRelayInfo* GLAnsGameProtocol::mutable_ansgamerelayinfo() {
  set_has_ansgamerelayinfo();
  if (ansgamerelayinfo_ == NULL) ansgamerelayinfo_ = new ::GLAnsGameRelayInfo;
  return ansgamerelayinfo_;
}
inline ::GLAnsGameRelayInfo* GLAnsGameProtocol::release_ansgamerelayinfo() {
  clear_has_ansgamerelayinfo();
  ::GLAnsGameRelayInfo* temp = ansgamerelayinfo_;
  ansgamerelayinfo_ = NULL;
  return temp;
}

// optional .GLAnsExitReservation ansExitReservation = 52;
inline bool GLAnsGameProtocol::has_ansexitreservation() const {
  return (_has_bits_[1] & 0x00080000u) != 0;
}
inline void GLAnsGameProtocol::set_has_ansexitreservation() {
  _has_bits_[1] |= 0x00080000u;
}
inline void GLAnsGameProtocol::clear_has_ansexitreservation() {
  _has_bits_[1] &= ~0x00080000u;
}
inline void GLAnsGameProtocol::clear_ansexitreservation() {
  if (ansexitreservation_ != NULL) ansexitreservation_->::GLAnsExitReservation::Clear();
  clear_has_ansexitreservation();
}
inline const ::GLAnsExitReservation& GLAnsGameProtocol::ansexitreservation() const {
  return ansexitreservation_ != NULL ? *ansexitreservation_ : *default_instance_->ansexitreservation_;
}
inline ::GLAnsExitReservation* GLAnsGameProtocol::mutable_ansexitreservation() {
  set_has_ansexitreservation();
  if (ansexitreservation_ == NULL) ansexitreservation_ = new ::GLAnsExitReservation;
  return ansexitreservation_;
}
inline ::GLAnsExitReservation* GLAnsGameProtocol::release_ansexitreservation() {
  clear_has_ansexitreservation();
  ::GLAnsExitReservation* temp = ansexitreservation_;
  ansexitreservation_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// GLReqGameProtocol

// required .GLReqGameProtocol.Type type = 1;
inline bool GLReqGameProtocol::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLReqGameProtocol::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLReqGameProtocol::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLReqGameProtocol::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::GLReqGameProtocol_Type GLReqGameProtocol::type() const {
  return static_cast< ::GLReqGameProtocol_Type >(type_);
}
inline void GLReqGameProtocol::set_type(::GLReqGameProtocol_Type value) {
  GOOGLE_DCHECK(::GLReqGameProtocol_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .GLReqGameReady reqGameReady = 2;
inline bool GLReqGameProtocol::has_reqgameready() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLReqGameProtocol::set_has_reqgameready() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLReqGameProtocol::clear_has_reqgameready() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLReqGameProtocol::clear_reqgameready() {
  if (reqgameready_ != NULL) reqgameready_->::GLReqGameReady::Clear();
  clear_has_reqgameready();
}
inline const ::GLReqGameReady& GLReqGameProtocol::reqgameready() const {
  return reqgameready_ != NULL ? *reqgameready_ : *default_instance_->reqgameready_;
}
inline ::GLReqGameReady* GLReqGameProtocol::mutable_reqgameready() {
  set_has_reqgameready();
  if (reqgameready_ == NULL) reqgameready_ = new ::GLReqGameReady;
  return reqgameready_;
}
inline ::GLReqGameReady* GLReqGameProtocol::release_reqgameready() {
  clear_has_reqgameready();
  ::GLReqGameReady* temp = reqgameready_;
  reqgameready_ = NULL;
  return temp;
}

// optional .GLReqResetReady reqResetReady = 3;
inline bool GLReqGameProtocol::has_reqresetready() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GLReqGameProtocol::set_has_reqresetready() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GLReqGameProtocol::clear_has_reqresetready() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GLReqGameProtocol::clear_reqresetready() {
  if (reqresetready_ != NULL) reqresetready_->::GLReqResetReady::Clear();
  clear_has_reqresetready();
}
inline const ::GLReqResetReady& GLReqGameProtocol::reqresetready() const {
  return reqresetready_ != NULL ? *reqresetready_ : *default_instance_->reqresetready_;
}
inline ::GLReqResetReady* GLReqGameProtocol::mutable_reqresetready() {
  set_has_reqresetready();
  if (reqresetready_ == NULL) reqresetready_ = new ::GLReqResetReady;
  return reqresetready_;
}
inline ::GLReqResetReady* GLReqGameProtocol::release_reqresetready() {
  clear_has_reqresetready();
  ::GLReqResetReady* temp = reqresetready_;
  reqresetready_ = NULL;
  return temp;
}

// optional .GLReqGameInitGame reqInitGame = 4;
inline bool GLReqGameProtocol::has_reqinitgame() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GLReqGameProtocol::set_has_reqinitgame() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GLReqGameProtocol::clear_has_reqinitgame() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GLReqGameProtocol::clear_reqinitgame() {
  if (reqinitgame_ != NULL) reqinitgame_->::GLReqGameInitGame::Clear();
  clear_has_reqinitgame();
}
inline const ::GLReqGameInitGame& GLReqGameProtocol::reqinitgame() const {
  return reqinitgame_ != NULL ? *reqinitgame_ : *default_instance_->reqinitgame_;
}
inline ::GLReqGameInitGame* GLReqGameProtocol::mutable_reqinitgame() {
  set_has_reqinitgame();
  if (reqinitgame_ == NULL) reqinitgame_ = new ::GLReqGameInitGame;
  return reqinitgame_;
}
inline ::GLReqGameInitGame* GLReqGameProtocol::release_reqinitgame() {
  clear_has_reqinitgame();
  ::GLReqGameInitGame* temp = reqinitgame_;
  reqinitgame_ = NULL;
  return temp;
}

// optional .GLReqGameReset reqReset = 5;
inline bool GLReqGameProtocol::has_reqreset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GLReqGameProtocol::set_has_reqreset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GLReqGameProtocol::clear_has_reqreset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GLReqGameProtocol::clear_reqreset() {
  if (reqreset_ != NULL) reqreset_->::GLReqGameReset::Clear();
  clear_has_reqreset();
}
inline const ::GLReqGameReset& GLReqGameProtocol::reqreset() const {
  return reqreset_ != NULL ? *reqreset_ : *default_instance_->reqreset_;
}
inline ::GLReqGameReset* GLReqGameProtocol::mutable_reqreset() {
  set_has_reqreset();
  if (reqreset_ == NULL) reqreset_ = new ::GLReqGameReset;
  return reqreset_;
}
inline ::GLReqGameReset* GLReqGameProtocol::release_reqreset() {
  clear_has_reqreset();
  ::GLReqGameReset* temp = reqreset_;
  reqreset_ = NULL;
  return temp;
}

// optional .GLReqGameStart reqStart = 6;
inline bool GLReqGameProtocol::has_reqstart() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GLReqGameProtocol::set_has_reqstart() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GLReqGameProtocol::clear_has_reqstart() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GLReqGameProtocol::clear_reqstart() {
  if (reqstart_ != NULL) reqstart_->::GLReqGameStart::Clear();
  clear_has_reqstart();
}
inline const ::GLReqGameStart& GLReqGameProtocol::reqstart() const {
  return reqstart_ != NULL ? *reqstart_ : *default_instance_->reqstart_;
}
inline ::GLReqGameStart* GLReqGameProtocol::mutable_reqstart() {
  set_has_reqstart();
  if (reqstart_ == NULL) reqstart_ = new ::GLReqGameStart;
  return reqstart_;
}
inline ::GLReqGameStart* GLReqGameProtocol::release_reqstart() {
  clear_has_reqstart();
  ::GLReqGameStart* temp = reqstart_;
  reqstart_ = NULL;
  return temp;
}

// optional .GLReqGameSelectSunCard reqSelectSunCard = 7;
inline bool GLReqGameProtocol::has_reqselectsuncard() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GLReqGameProtocol::set_has_reqselectsuncard() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GLReqGameProtocol::clear_has_reqselectsuncard() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GLReqGameProtocol::clear_reqselectsuncard() {
  if (reqselectsuncard_ != NULL) reqselectsuncard_->::GLReqGameSelectSunCard::Clear();
  clear_has_reqselectsuncard();
}
inline const ::GLReqGameSelectSunCard& GLReqGameProtocol::reqselectsuncard() const {
  return reqselectsuncard_ != NULL ? *reqselectsuncard_ : *default_instance_->reqselectsuncard_;
}
inline ::GLReqGameSelectSunCard* GLReqGameProtocol::mutable_reqselectsuncard() {
  set_has_reqselectsuncard();
  if (reqselectsuncard_ == NULL) reqselectsuncard_ = new ::GLReqGameSelectSunCard;
  return reqselectsuncard_;
}
inline ::GLReqGameSelectSunCard* GLReqGameProtocol::release_reqselectsuncard() {
  clear_has_reqselectsuncard();
  ::GLReqGameSelectSunCard* temp = reqselectsuncard_;
  reqselectsuncard_ = NULL;
  return temp;
}

// optional .GLReqGameSelectCard reqSelectCard = 8;
inline bool GLReqGameProtocol::has_reqselectcard() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GLReqGameProtocol::set_has_reqselectcard() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GLReqGameProtocol::clear_has_reqselectcard() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GLReqGameProtocol::clear_reqselectcard() {
  if (reqselectcard_ != NULL) reqselectcard_->::GLReqGameSelectCard::Clear();
  clear_has_reqselectcard();
}
inline const ::GLReqGameSelectCard& GLReqGameProtocol::reqselectcard() const {
  return reqselectcard_ != NULL ? *reqselectcard_ : *default_instance_->reqselectcard_;
}
inline ::GLReqGameSelectCard* GLReqGameProtocol::mutable_reqselectcard() {
  set_has_reqselectcard();
  if (reqselectcard_ == NULL) reqselectcard_ = new ::GLReqGameSelectCard;
  return reqselectcard_;
}
inline ::GLReqGameSelectCard* GLReqGameProtocol::release_reqselectcard() {
  clear_has_reqselectcard();
  ::GLReqGameSelectCard* temp = reqselectcard_;
  reqselectcard_ = NULL;
  return temp;
}

// optional .GLReqGameAskGoStopAns reqAskGoStopAns = 9;
inline bool GLReqGameProtocol::has_reqaskgostopans() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GLReqGameProtocol::set_has_reqaskgostopans() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GLReqGameProtocol::clear_has_reqaskgostopans() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GLReqGameProtocol::clear_reqaskgostopans() {
  if (reqaskgostopans_ != NULL) reqaskgostopans_->::GLReqGameAskGoStopAns::Clear();
  clear_has_reqaskgostopans();
}
inline const ::GLReqGameAskGoStopAns& GLReqGameProtocol::reqaskgostopans() const {
  return reqaskgostopans_ != NULL ? *reqaskgostopans_ : *default_instance_->reqaskgostopans_;
}
inline ::GLReqGameAskGoStopAns* GLReqGameProtocol::mutable_reqaskgostopans() {
  set_has_reqaskgostopans();
  if (reqaskgostopans_ == NULL) reqaskgostopans_ = new ::GLReqGameAskGoStopAns;
  return reqaskgostopans_;
}
inline ::GLReqGameAskGoStopAns* GLReqGameProtocol::release_reqaskgostopans() {
  clear_has_reqaskgostopans();
  ::GLReqGameAskGoStopAns* temp = reqaskgostopans_;
  reqaskgostopans_ = NULL;
  return temp;
}

// optional .GLReqGameAskShakeAns reqAskShakeAns = 10;
inline bool GLReqGameProtocol::has_reqaskshakeans() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GLReqGameProtocol::set_has_reqaskshakeans() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GLReqGameProtocol::clear_has_reqaskshakeans() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GLReqGameProtocol::clear_reqaskshakeans() {
  if (reqaskshakeans_ != NULL) reqaskshakeans_->::GLReqGameAskShakeAns::Clear();
  clear_has_reqaskshakeans();
}
inline const ::GLReqGameAskShakeAns& GLReqGameProtocol::reqaskshakeans() const {
  return reqaskshakeans_ != NULL ? *reqaskshakeans_ : *default_instance_->reqaskshakeans_;
}
inline ::GLReqGameAskShakeAns* GLReqGameProtocol::mutable_reqaskshakeans() {
  set_has_reqaskshakeans();
  if (reqaskshakeans_ == NULL) reqaskshakeans_ = new ::GLReqGameAskShakeAns;
  return reqaskshakeans_;
}
inline ::GLReqGameAskShakeAns* GLReqGameProtocol::release_reqaskshakeans() {
  clear_has_reqaskshakeans();
  ::GLReqGameAskShakeAns* temp = reqaskshakeans_;
  reqaskshakeans_ = NULL;
  return temp;
}

// optional .GLReqGameChoiceCardAns reqChoiceCardAns = 11;
inline bool GLReqGameProtocol::has_reqchoicecardans() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GLReqGameProtocol::set_has_reqchoicecardans() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GLReqGameProtocol::clear_has_reqchoicecardans() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GLReqGameProtocol::clear_reqchoicecardans() {
  if (reqchoicecardans_ != NULL) reqchoicecardans_->::GLReqGameChoiceCardAns::Clear();
  clear_has_reqchoicecardans();
}
inline const ::GLReqGameChoiceCardAns& GLReqGameProtocol::reqchoicecardans() const {
  return reqchoicecardans_ != NULL ? *reqchoicecardans_ : *default_instance_->reqchoicecardans_;
}
inline ::GLReqGameChoiceCardAns* GLReqGameProtocol::mutable_reqchoicecardans() {
  set_has_reqchoicecardans();
  if (reqchoicecardans_ == NULL) reqchoicecardans_ = new ::GLReqGameChoiceCardAns;
  return reqchoicecardans_;
}
inline ::GLReqGameChoiceCardAns* GLReqGameProtocol::release_reqchoicecardans() {
  clear_has_reqchoicecardans();
  ::GLReqGameChoiceCardAns* temp = reqchoicecardans_;
  reqchoicecardans_ = NULL;
  return temp;
}

// optional .GLReqGameMoveTen reqMoveTen = 12;
inline bool GLReqGameProtocol::has_reqmoveten() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GLReqGameProtocol::set_has_reqmoveten() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GLReqGameProtocol::clear_has_reqmoveten() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GLReqGameProtocol::clear_reqmoveten() {
  if (reqmoveten_ != NULL) reqmoveten_->::GLReqGameMoveTen::Clear();
  clear_has_reqmoveten();
}
inline const ::GLReqGameMoveTen& GLReqGameProtocol::reqmoveten() const {
  return reqmoveten_ != NULL ? *reqmoveten_ : *default_instance_->reqmoveten_;
}
inline ::GLReqGameMoveTen* GLReqGameProtocol::mutable_reqmoveten() {
  set_has_reqmoveten();
  if (reqmoveten_ == NULL) reqmoveten_ = new ::GLReqGameMoveTen;
  return reqmoveten_;
}
inline ::GLReqGameMoveTen* GLReqGameProtocol::release_reqmoveten() {
  clear_has_reqmoveten();
  ::GLReqGameMoveTen* temp = reqmoveten_;
  reqmoveten_ = NULL;
  return temp;
}

// optional .GLReqGameChongTong reqChongTong = 13;
inline bool GLReqGameProtocol::has_reqchongtong() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GLReqGameProtocol::set_has_reqchongtong() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GLReqGameProtocol::clear_has_reqchongtong() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GLReqGameProtocol::clear_reqchongtong() {
  if (reqchongtong_ != NULL) reqchongtong_->::GLReqGameChongTong::Clear();
  clear_has_reqchongtong();
}
inline const ::GLReqGameChongTong& GLReqGameProtocol::reqchongtong() const {
  return reqchongtong_ != NULL ? *reqchongtong_ : *default_instance_->reqchongtong_;
}
inline ::GLReqGameChongTong* GLReqGameProtocol::mutable_reqchongtong() {
  set_has_reqchongtong();
  if (reqchongtong_ == NULL) reqchongtong_ = new ::GLReqGameChongTong;
  return reqchongtong_;
}
inline ::GLReqGameChongTong* GLReqGameProtocol::release_reqchongtong() {
  clear_has_reqchongtong();
  ::GLReqGameChongTong* temp = reqchongtong_;
  reqchongtong_ = NULL;
  return temp;
}

// optional .GLReqGameEnd reqGameEnd = 14;
inline bool GLReqGameProtocol::has_reqgameend() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void GLReqGameProtocol::set_has_reqgameend() {
  _has_bits_[0] |= 0x00002000u;
}
inline void GLReqGameProtocol::clear_has_reqgameend() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void GLReqGameProtocol::clear_reqgameend() {
  if (reqgameend_ != NULL) reqgameend_->::GLReqGameEnd::Clear();
  clear_has_reqgameend();
}
inline const ::GLReqGameEnd& GLReqGameProtocol::reqgameend() const {
  return reqgameend_ != NULL ? *reqgameend_ : *default_instance_->reqgameend_;
}
inline ::GLReqGameEnd* GLReqGameProtocol::mutable_reqgameend() {
  set_has_reqgameend();
  if (reqgameend_ == NULL) reqgameend_ = new ::GLReqGameEnd;
  return reqgameend_;
}
inline ::GLReqGameEnd* GLReqGameProtocol::release_reqgameend() {
  clear_has_reqgameend();
  ::GLReqGameEnd* temp = reqgameend_;
  reqgameend_ = NULL;
  return temp;
}

// optional .GLReqResultOk reqResultOk = 15;
inline bool GLReqGameProtocol::has_reqresultok() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void GLReqGameProtocol::set_has_reqresultok() {
  _has_bits_[0] |= 0x00004000u;
}
inline void GLReqGameProtocol::clear_has_reqresultok() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void GLReqGameProtocol::clear_reqresultok() {
  if (reqresultok_ != NULL) reqresultok_->::GLReqResultOk::Clear();
  clear_has_reqresultok();
}
inline const ::GLReqResultOk& GLReqGameProtocol::reqresultok() const {
  return reqresultok_ != NULL ? *reqresultok_ : *default_instance_->reqresultok_;
}
inline ::GLReqResultOk* GLReqGameProtocol::mutable_reqresultok() {
  set_has_reqresultok();
  if (reqresultok_ == NULL) reqresultok_ = new ::GLReqResultOk;
  return reqresultok_;
}
inline ::GLReqResultOk* GLReqGameProtocol::release_reqresultok() {
  clear_has_reqresultok();
  ::GLReqResultOk* temp = reqresultok_;
  reqresultok_ = NULL;
  return temp;
}

// optional .GLReqGameAutoPlay reqGameAutoPlay = 16;
inline bool GLReqGameProtocol::has_reqgameautoplay() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void GLReqGameProtocol::set_has_reqgameautoplay() {
  _has_bits_[0] |= 0x00008000u;
}
inline void GLReqGameProtocol::clear_has_reqgameautoplay() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void GLReqGameProtocol::clear_reqgameautoplay() {
  if (reqgameautoplay_ != NULL) reqgameautoplay_->::GLReqGameAutoPlay::Clear();
  clear_has_reqgameautoplay();
}
inline const ::GLReqGameAutoPlay& GLReqGameProtocol::reqgameautoplay() const {
  return reqgameautoplay_ != NULL ? *reqgameautoplay_ : *default_instance_->reqgameautoplay_;
}
inline ::GLReqGameAutoPlay* GLReqGameProtocol::mutable_reqgameautoplay() {
  set_has_reqgameautoplay();
  if (reqgameautoplay_ == NULL) reqgameautoplay_ = new ::GLReqGameAutoPlay;
  return reqgameautoplay_;
}
inline ::GLReqGameAutoPlay* GLReqGameProtocol::release_reqgameautoplay() {
  clear_has_reqgameautoplay();
  ::GLReqGameAutoPlay* temp = reqgameautoplay_;
  reqgameautoplay_ = NULL;
  return temp;
}

// optional .GLReqGameEmoti reqGameEmoti = 17;
inline bool GLReqGameProtocol::has_reqgameemoti() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void GLReqGameProtocol::set_has_reqgameemoti() {
  _has_bits_[0] |= 0x00010000u;
}
inline void GLReqGameProtocol::clear_has_reqgameemoti() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void GLReqGameProtocol::clear_reqgameemoti() {
  if (reqgameemoti_ != NULL) reqgameemoti_->::GLReqGameEmoti::Clear();
  clear_has_reqgameemoti();
}
inline const ::GLReqGameEmoti& GLReqGameProtocol::reqgameemoti() const {
  return reqgameemoti_ != NULL ? *reqgameemoti_ : *default_instance_->reqgameemoti_;
}
inline ::GLReqGameEmoti* GLReqGameProtocol::mutable_reqgameemoti() {
  set_has_reqgameemoti();
  if (reqgameemoti_ == NULL) reqgameemoti_ = new ::GLReqGameEmoti;
  return reqgameemoti_;
}
inline ::GLReqGameEmoti* GLReqGameProtocol::release_reqgameemoti() {
  clear_has_reqgameemoti();
  ::GLReqGameEmoti* temp = reqgameemoti_;
  reqgameemoti_ = NULL;
  return temp;
}

// optional .GLReqExitReservation reqExitReservation = 18;
inline bool GLReqGameProtocol::has_reqexitreservation() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void GLReqGameProtocol::set_has_reqexitreservation() {
  _has_bits_[0] |= 0x00020000u;
}
inline void GLReqGameProtocol::clear_has_reqexitreservation() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void GLReqGameProtocol::clear_reqexitreservation() {
  if (reqexitreservation_ != NULL) reqexitreservation_->::GLReqExitReservation::Clear();
  clear_has_reqexitreservation();
}
inline const ::GLReqExitReservation& GLReqGameProtocol::reqexitreservation() const {
  return reqexitreservation_ != NULL ? *reqexitreservation_ : *default_instance_->reqexitreservation_;
}
inline ::GLReqExitReservation* GLReqGameProtocol::mutable_reqexitreservation() {
  set_has_reqexitreservation();
  if (reqexitreservation_ == NULL) reqexitreservation_ = new ::GLReqExitReservation;
  return reqexitreservation_;
}
inline ::GLReqExitReservation* GLReqGameProtocol::release_reqexitreservation() {
  clear_has_reqexitreservation();
  ::GLReqExitReservation* temp = reqexitreservation_;
  reqexitreservation_ = NULL;
  return temp;
}

// optional .GLReqRelayInfo reqRelayInfo = 19;
inline bool GLReqGameProtocol::has_reqrelayinfo() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void GLReqGameProtocol::set_has_reqrelayinfo() {
  _has_bits_[0] |= 0x00040000u;
}
inline void GLReqGameProtocol::clear_has_reqrelayinfo() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void GLReqGameProtocol::clear_reqrelayinfo() {
  if (reqrelayinfo_ != NULL) reqrelayinfo_->::GLReqRelayInfo::Clear();
  clear_has_reqrelayinfo();
}
inline const ::GLReqRelayInfo& GLReqGameProtocol::reqrelayinfo() const {
  return reqrelayinfo_ != NULL ? *reqrelayinfo_ : *default_instance_->reqrelayinfo_;
}
inline ::GLReqRelayInfo* GLReqGameProtocol::mutable_reqrelayinfo() {
  set_has_reqrelayinfo();
  if (reqrelayinfo_ == NULL) reqrelayinfo_ = new ::GLReqRelayInfo;
  return reqrelayinfo_;
}
inline ::GLReqRelayInfo* GLReqGameProtocol::release_reqrelayinfo() {
  clear_has_reqrelayinfo();
  ::GLReqRelayInfo* temp = reqrelayinfo_;
  reqrelayinfo_ = NULL;
  return temp;
}

// optional .GLReqGameInitGameTan reqTanInit = 20;
inline bool GLReqGameProtocol::has_reqtaninit() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void GLReqGameProtocol::set_has_reqtaninit() {
  _has_bits_[0] |= 0x00080000u;
}
inline void GLReqGameProtocol::clear_has_reqtaninit() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void GLReqGameProtocol::clear_reqtaninit() {
  if (reqtaninit_ != NULL) reqtaninit_->::GLReqGameInitGameTan::Clear();
  clear_has_reqtaninit();
}
inline const ::GLReqGameInitGameTan& GLReqGameProtocol::reqtaninit() const {
  return reqtaninit_ != NULL ? *reqtaninit_ : *default_instance_->reqtaninit_;
}
inline ::GLReqGameInitGameTan* GLReqGameProtocol::mutable_reqtaninit() {
  set_has_reqtaninit();
  if (reqtaninit_ == NULL) reqtaninit_ = new ::GLReqGameInitGameTan;
  return reqtaninit_;
}
inline ::GLReqGameInitGameTan* GLReqGameProtocol::release_reqtaninit() {
  clear_has_reqtaninit();
  ::GLReqGameInitGameTan* temp = reqtaninit_;
  reqtaninit_ = NULL;
  return temp;
}

// optional .G_REQ_GAME_TEST_PACKET g_REQ_GAME_TEST_PACKET = 21;
inline bool GLReqGameProtocol::has_g_req_game_test_packet() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void GLReqGameProtocol::set_has_g_req_game_test_packet() {
  _has_bits_[0] |= 0x00100000u;
}
inline void GLReqGameProtocol::clear_has_g_req_game_test_packet() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void GLReqGameProtocol::clear_g_req_game_test_packet() {
  if (g_req_game_test_packet_ != NULL) g_req_game_test_packet_->::G_REQ_GAME_TEST_PACKET::Clear();
  clear_has_g_req_game_test_packet();
}
inline const ::G_REQ_GAME_TEST_PACKET& GLReqGameProtocol::g_req_game_test_packet() const {
  return g_req_game_test_packet_ != NULL ? *g_req_game_test_packet_ : *default_instance_->g_req_game_test_packet_;
}
inline ::G_REQ_GAME_TEST_PACKET* GLReqGameProtocol::mutable_g_req_game_test_packet() {
  set_has_g_req_game_test_packet();
  if (g_req_game_test_packet_ == NULL) g_req_game_test_packet_ = new ::G_REQ_GAME_TEST_PACKET;
  return g_req_game_test_packet_;
}
inline ::G_REQ_GAME_TEST_PACKET* GLReqGameProtocol::release_g_req_game_test_packet() {
  clear_has_g_req_game_test_packet();
  ::G_REQ_GAME_TEST_PACKET* temp = g_req_game_test_packet_;
  g_req_game_test_packet_ = NULL;
  return temp;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_gameLogic_2eproto__INCLUDED
